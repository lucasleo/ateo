SimpleSliderMorph subclass: #OPAdvancedSlider	instanceVariableNames: 'customizableSliderThickness currentSpeed'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPAdvancedSlider methodsFor: 'as yet unclassified' stamp: 'CL 5/27/2009 18:19'!currentSpeed: horst	currentSpeed contents: horst.	! !!OPAdvancedSlider methodsFor: 'as yet unclassified' stamp: 'CL 8/19/2009 16:10'!initialize	customizableSliderThickness := 50.	super initialize.	self maxVal: 0; minVal: 1.0	! !!OPAdvancedSlider methodsFor: 'as yet unclassified' stamp: 'CL 8/9/2009 12:33'!initializeSlider	| mark markContainer mainContainer speedContainer |	slider := (RectangleMorph newBounds: self totalSliderArea color: self thumbColor).	mainContainer := AlignmentMorph new listDirection: #leftToRight;									listCentering: #center;									wrapCentering: #center ;									extent: slider width+45@self sliderThickness + 1 ; 									borderWidth: 1; 									borderColor: Color transparent ; 									layoutInset: 0;									color: Color transparent .		markContainer := AlignmentMorph new listDirection: #leftToRight; "#topToBottom; "									listCentering: #center;									wrapCentering: #center ;									extent: slider width+2@self sliderThickness + 1 ; 									borderWidth: 1; 									borderColor: Color transparent ; 									layoutInset: 0;									color: Color transparent .	mark := RectangleMorph new color: Color black; extent: slider width-1@3; borderWidth:0; borderColor: Color black .	speedContainer := AlignmentMorph new listDirection: #rightToLeft;									wrapCentering: #center ;									listCentering: #right;									extent: 43@self sliderThickness + 1 ; 									borderWidth: 1; 									borderColor: Color transparent ; 									layoutInset: 0;									color: Color transparent;									vResizing: #rigid;									hResizing: #rigid .	currentSpeed := (StringMorph new) contents: ' 100%'; fontName: #BitstreamVeraSans size: 16.	"Transcript show: slider width; cr."	mainContainer 	addMorphBack: (markContainer addMorphBack: mark); 						addMorphBack: (speedContainer addMorphBack: currentSpeed).	"markContainer openInWorld."	slider addMorphBack: mainContainer.	sliderShadow := RectangleMorph newBounds: self totalSliderArea						color: self pagingArea color.	slider on: #mouseMove send: #scrollAbsolute: to: self.	slider on: #mouseDown send: #mouseDownInSlider: to: self.	slider on: #mouseUp send: #mouseUpInSlider: to: self.	slider setBorderWidth: 5 borderColor: #raised.	sliderShadow setBorderWidth: 5 borderColor: #inset.	"(the shadow must have the pagingArea as its owner to highlight properly)"	self pagingArea addMorph: sliderShadow.	sliderShadow hide.	self addMorph: slider.	self computeSlider.! !!OPAdvancedSlider methodsFor: 'as yet unclassified' stamp: 'CL 4/23/2009 11:25'!sliderThickness	^customizableSliderThickness! !!OPAdvancedSlider methodsFor: 'as yet unclassified' stamp: 'CL 4/23/2009 11:25'!sliderThickness: gertFroebe	customizableSliderThickness := gertFroebe.! !RectangleMorph subclass: #OPBackground	instanceVariableNames: 'haloEnabled modelData'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPBackground methodsFor: 'as yet unclassified' stamp: 'CL 6/4/2009 17:07'!blueButtonDown: anEvent	(haloEnabled)	ifTrue:[super blueButtonDown: anEvent.]	ifFalse:[].! !!OPBackground methodsFor: 'as yet unclassified' stamp: 'CL 9/10/2009 19:01'!clicked	(modelData network)	ifTrue:[modelData blindClick: (World cursorPoint asString, ';'). "Transcript show: 'World cursorPoint (Background): ', World cursorPoint asString; cr."]		ifFalse:["Transcript show: 'World cursorPoint (Background): ', World cursorPoint asString; cr."]! !!OPBackground methodsFor: 'as yet unclassified' stamp: 'CL 6/4/2009 17:07'!haloEnabled: bool	haloEnabled := bool.! !!OPBackground methodsFor: 'as yet unclassified' stamp: 'CL 9/10/2009 18:59'!initialize	super initialize.	modelData := OPModelData getInstance .	self 		haloEnabled: true;		color: (Color gray mixed: 0.10 with: Color white); "lighter"		borderWidth: 0; 		extent: 2560@1600;		beSticky ;		openInWorld.	self on: #click send: #clicked to: self.! !RectangleMorph subclass: #OPBar	instanceVariableNames: 'haloEnabled modelData'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPBar methodsFor: 'as yet unclassified' stamp: 'CL 6/4/2009 17:02'!blueButtonDown: anEvent	(haloEnabled)	ifTrue:[super blueButtonDown: anEvent.]	ifFalse:[].! !!OPBar methodsFor: 'as yet unclassified' stamp: 'CL 9/10/2009 19:01'!clicked	(modelData network)	ifTrue:[modelData blindClick: (World cursorPoint asString, ';'). "Transcript show: 'World cursorPoint (Background): ', World cursorPoint asString; cr."]		ifFalse:["Transcript show: 'World cursorPoint (Background): ', World cursorPoint asString; cr."]! !!OPBar methodsFor: 'as yet unclassified' stamp: 'CL 6/4/2009 17:02'!haloEnabled: bool	haloEnabled := bool.! !!OPBar methodsFor: 'as yet unclassified' stamp: 'CL 9/10/2009 18:59'!initialize	super initialize.	modelData := OPModelData getInstance .	self color: Color black; borderWidth: 0.	self on: #click send: #clicked to: self.! !SimpleButtonMorph subclass: #OPButtonForGui	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPButtonForGui methodsFor: 'as yet unclassified' stamp: 'CL 9/24/2009 10:17'!actionSelectorCreateGui		| guiAlreadyCreated |	guiAlreadyCreated := false.		World submorphs do: [:item | 		(item isKindOf: OPGuiMasterControl)		ifTrue:[ guiAlreadyCreated := true. ].	].		(guiAlreadyCreated)	ifFalse:[ OPGuiMasterControl new. ].! !!OPButtonForGui methodsFor: 'as yet unclassified' stamp: 'CL 9/24/2009 09:59'!initialize	super initialize.	self color: (Color gray mixed: 0.14 with: Color white);			borderColor: #raised;			borderWidth: 5;			label: 'Create Gui';			extent: 150 @ 75;			target: self;			actionSelector: #actionSelectorCreateGui;			position: 340 @ 50;			openInWorld.! !Object subclass: #OPModelData	instanceVariableNames: 'directSetDirectionLeft directSetDirectionRight directSetDirectionReset distributionMwiOne directSetSpeed currentCoordinateX currentCoordinateY network simulation scaleFactor stepNr joystickMwiOne joystickMwiTwo speed trackPreviewHint trackName obstacleConfig status dynamicObstacleX blindClick buttonAction tailColor forks trackEdit collision situationalAwarenessConfig waitForItShowStatus'	classVariableNames: 'Current'	poolDictionaries: ''	category: 'ATEO-Operator'!!OPModelData methodsFor: 'accessing' stamp: 'CL 9/10/2009 18:30'!blindClick	^blindClick! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/10/2009 18:30'!blindClick: anObject	blindClick := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/10/2009 20:20'!buttonAction	^buttonAction! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/10/2009 20:20'!buttonAction: anObject	buttonAction := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/16/2009 10:09'!collision	^collision! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/16/2009 10:09'!collision: anObject	collision := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 8/21/2009 13:07'!currentCoordinateX	^currentCoordinateX! !!OPModelData methodsFor: 'accessing' stamp: 'CL 8/21/2009 13:07'!currentCoordinateX: anObject	currentCoordinateX := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 8/21/2009 13:07'!currentCoordinateY	^currentCoordinateY! !!OPModelData methodsFor: 'accessing' stamp: 'CL 8/21/2009 13:07'!currentCoordinateY: anObject	currentCoordinateY := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 8/9/2009 14:57'!directSetDirectionLeft	^directSetDirectionLeft! !!OPModelData methodsFor: 'accessing' stamp: 'CL 8/9/2009 14:57'!directSetDirectionLeft: anObject	directSetDirectionLeft := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 8/9/2009 14:57'!directSetDirectionReset	^directSetDirectionReset! !!OPModelData methodsFor: 'accessing' stamp: 'CL 8/9/2009 14:57'!directSetDirectionReset: anObject	directSetDirectionReset := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 8/9/2009 14:57'!directSetDirectionRight	^directSetDirectionRight! !!OPModelData methodsFor: 'accessing' stamp: 'CL 8/9/2009 14:57'!directSetDirectionRight: anObject	directSetDirectionRight := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'nn 8/11/2009 20:05'!directSetSpeed	^directSetSpeed! !!OPModelData methodsFor: 'accessing' stamp: 'nn 8/11/2009 20:05'!directSetSpeed: anObject	directSetSpeed := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 8/9/2009 15:15'!distributionMwiOne	^distributionMwiOne! !!OPModelData methodsFor: 'accessing' stamp: 'CL 8/9/2009 15:15'!distributionMwiOne: anObject	distributionMwiOne := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/8/2009 18:33'!dynamicObstacleX	^dynamicObstacleX! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/8/2009 18:33'!dynamicObstacleX: anObject	dynamicObstacleX := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/11/2009 10:50'!forks	^forks! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/11/2009 10:50'!forks: anObject	forks := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/3/2009 14:11'!joystickMwiOne	^joystickMwiOne! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/3/2009 14:11'!joystickMwiOne: anObject	joystickMwiOne := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/3/2009 14:11'!joystickMwiTwo	^joystickMwiTwo! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/3/2009 14:11'!joystickMwiTwo: anObject	joystickMwiTwo := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/1/2009 14:46'!network	^network! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/1/2009 14:46'!network: anObject	network := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/4/2009 11:42'!obstacleConfig	^obstacleConfig! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/4/2009 11:42'!obstacleConfig: anObject	obstacleConfig := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/1/2009 15:50'!scaleFactor	^scaleFactor! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/1/2009 15:50'!scaleFactor: anObject	scaleFactor := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/1/2009 14:48'!simulation	^simulation! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/1/2009 14:48'!simulation: anObject	simulation := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/29/2009 16:43'!situationalAwarenessConfig	^situationalAwarenessConfig! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/29/2009 16:43'!situationalAwarenessConfig: anObject	situationalAwarenessConfig := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/3/2009 18:47'!speed	^speed! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/3/2009 18:47'!speed: anObject	speed := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/8/2009 15:13'!status	^status! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/8/2009 15:13'!status: anObject	status := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/3/2009 13:55'!stepNr	^stepNr! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/3/2009 13:55'!stepNr: anObject	stepNr := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/10/2009 21:10'!tailColor	^tailColor! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/10/2009 21:10'!tailColor: anObject	tailColor := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/11/2009 12:48'!trackEdit	^trackEdit! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/11/2009 12:48'!trackEdit: anObject	trackEdit := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/4/2009 11:42'!trackName	^trackName! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/4/2009 11:42'!trackName: anObject	trackName := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/4/2009 09:49'!trackPreviewHint	^trackPreviewHint! !!OPModelData methodsFor: 'accessing' stamp: 'CL 9/4/2009 09:49'!trackPreviewHint: anObject	trackPreviewHint := anObject! !!OPModelData methodsFor: 'accessing' stamp: 'CL 10/1/2009 16:42'!waitForItShowStatus	^waitForItShowStatus! !!OPModelData methodsFor: 'accessing' stamp: 'CL 10/1/2009 16:42'!waitForItShowStatus: anObject	waitForItShowStatus := anObject! !!OPModelData methodsFor: 'reset' stamp: 'CL 10/1/2009 16:42'!resetForNewStep	self directSetDirectionLeft: false;				directSetDirectionReset: false;				directSetDirectionRight: false;				distributionMwiOne: 0.5;				joystickMwiOne: 0 @ 0;				joystickMwiTwo: 0 @ 0;				directSetSpeed: 1.0;				currentCoordinateX: 0;				currentCoordinateY: 0;				trackPreviewHint: false;				blindClick: '';				buttonAction: '';				tailColor: 0;				trackEdit: '';				buttonAction: '';				blindClick: '';				trackEdit: '';				dynamicObstacleX: 0;				waitForItShowStatus: true.	! !!OPModelData methodsFor: 'initialize' stamp: 'CL 10/1/2009 16:43'!initializeValues	self directSetDirectionLeft: false;				directSetDirectionReset: false;				directSetDirectionRight: false;				distributionMwiOne: 0.5;				simulation: false;				network: false;				joystickMwiOne: 0 @ 0;				joystickMwiTwo: 0 @ 0;				directSetSpeed: 1.0;				trackPreviewHint: false;				buttonAction: '';				blindClick: '';				trackEdit: '';				status: '';				stepNr: -1;				blindClick: '';				buttonAction: '';				tailColor: 0;				trackEdit: '';				dynamicObstacleX: 0;				waitForItShowStatus: true.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OPModelData class	instanceVariableNames: ''!!OPModelData class methodsFor: 'as yet unclassified' stamp: 'CL 9/10/2009 19:16'!getInstance	"Transcript cr; show: 'before isNil: ', Current asString."	(Current isNil) 	ifTrue: [ Current := self basicNew initialize. ]. 	"Transcript cr; show: 'after isNil: ', Current asString."	^Current! !!OPModelData class methodsFor: 'as yet unclassified' stamp: 'CL 8/9/2009 14:54'!reset	Current := nil.! !Object subclass: #OPNetwork	instanceVariableNames: 'inspectWindow modelData speed coord dynamicObstacle joystick collision inputDistributionMWI1FromSAM track buttonAction blindClicks trackEdit status obstacleConfig situationAwareness stepNr'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPNetwork methodsFor: 'creating/closing' stamp: 'CL 10/1/2009 16:50'!closeSockets	"schließen der sockets"	(modelData network)	ifTrue:	[		joystick 							closeAndDestroy.		speed 								closeAndDestroy.		coord 								closeAndDestroy.		track									close.		dynamicObstacle 					closeAndDestroy.		buttonAction 						close.		blindClicks 						close.		trackEdit 							close.		inputDistributionMWI1FromSAM 	close.		status 								close.		obstacleConfig 					close.		collision 							closeAndDestroy.		situationAwareness 				close.		stepNr 								close.	].	modelData network: false.	"inspectWindow delete."! !!OPNetwork methodsFor: 'creating/closing' stamp: 'CL 10/1/2009 16:50'!createSockets	modelData network: true.		inputDistributionMWI1FromSAM 	:= SocketStream on: (Socket newTCP listenOn: 60100).	track 								:= SocketStream on: (Socket newTCP listenOn: 60200).	buttonAction 						:= SocketStream on: (Socket newTCP listenOn: 60300).	blindClicks							:= SocketStream on: (Socket newTCP listenOn: 60400).	trackEdit							:= SocketStream on: (Socket newTCP listenOn: 60500).	status 								:= SocketStream on: (Socket newTCP listenOn: 60600).	obstacleConfig						:= SocketStream on: (Socket newTCP listenOn: 60700).	situationAwareness				:= SocketStream on: (Socket newTCP listenOn: 61300).	stepNr								:= SocketStream on: (Socket newTCP listenOn: 61400).	"UDP"	speed 								:= Socket newUDP setPort: 60800.	coord 								:= Socket newUDP setPort: 60900.	dynamicObstacle 					:= Socket newUDP setPort: 61000.	joystick 							:= Socket newUDP setPort: 61100.	collision							:= Socket newUDP setPort: 61200.	self emptyStreams.	"inspectWindow := self inspect."	! !!OPNetwork methodsFor: 'initialize' stamp: 'CL 9/25/2009 15:21'!initialize	modelData := OPModelData getInstance . 	modelData network: false.! !!OPNetwork methodsFor: 'receiving' stamp: 'CL 9/25/2009 15:21'!receiveCollisionData	^collision receiveAvailableData asNumber! !!OPNetwork methodsFor: 'receiving' stamp: 'CL 9/25/2009 15:22'!receiveCoordData	^coord receiveAvailableData asNumber! !!OPNetwork methodsFor: 'receiving' stamp: 'CL 9/25/2009 15:23'!receiveDynamicObstacleData	^dynamicObstacle receiveAvailableData asNumber! !!OPNetwork methodsFor: 'receiving' stamp: 'CL 9/25/2009 09:45'!receiveInputDistributionMWI1	^(self receiveDataAsNumberFromStream: inputDistributionMWI1FromSAM).! !!OPNetwork methodsFor: 'receiving' stamp: 'CL 9/25/2009 15:22'!receiveJoystickData	^joystick receiveAvailableData! !!OPNetwork methodsFor: 'receiving' stamp: 'CL 9/25/2009 09:47'!receiveObstacleConfig	^(self refineObstacleConfig: (self receiveDataAsStringFromStream: obstacleConfig)).! !!OPNetwork methodsFor: 'receiving' stamp: 'CL 9/25/2009 15:51'!receiveSpeedData	^speed receiveAvailableData asNumber! !!OPNetwork methodsFor: 'receiving' stamp: 'CL 9/25/2009 09:46'!receiveStatusData	^(self receiveDataAsStringFromStream: status).! !!OPNetwork methodsFor: 'receiving' stamp: 'CL 9/30/2009 14:32'!receiveStepNr	^(self receiveDataAsNumberFromStream: stepNr).! !!OPNetwork methodsFor: 'receiving' stamp: 'CL 9/25/2009 09:42'!receiveTrackData	^(self receiveDataAsStringFromStream: track).! !!OPNetwork methodsFor: 'receivingWrapper' stamp: 'CL 9/25/2009 14:32'!receiveDataAsNumberFromStream: socketStream	| returnValue |	returnValue := nil.	[socketStream isDataAvailable]	whileTrue:[ returnValue := (socketStream nextLineCrLf) asNumber. "foo := foo, 'found: ', returnValue asString, Character cr asString." ].	"foo := foo, 'returned: ', returnValue asString, Character cr asString.	foo := foo, '-------------------------------------------', Character cr asString."	^returnValue! !!OPNetwork methodsFor: 'receivingWrapper' stamp: 'CL 9/25/2009 10:02'!receiveDataAsStringFromStream: socketStream	| returnValue |	returnValue := nil.	[socketStream isDataAvailable]	whileTrue:[ returnValue := socketStream nextLineCrLf ].	^returnValue! !!OPNetwork methodsFor: 'refinement' stamp: 'CL 9/11/2009 13:50'!refineObstacleConfig: data	| horst obstacleConfig arrayLengthTwo |	obstacleConfig := OrderedCollection new.		(data size > 0)	ifTrue:[				horst := data findTokens: ';'.		horst do: [:token |			arrayLengthTwo := (token findTokens: '-') asArray.			arrayLengthTwo at: 1 put: (arrayLengthTwo at: 1) asInteger; at: 2 put: (arrayLengthTwo at: 2) asInteger.			obstacleConfig add: arrayLengthTwo copy.		].	].	^obstacleConfig.! !!OPNetwork methodsFor: 'reset/emptying' stamp: 'CL 10/1/2009 13:33'!emptyStreams		speed 								receiveAvailableData.	coord 								receiveAvailableData.	dynamicObstacle 					receiveAvailableData.	joystick 							receiveAvailableData.	collision							receiveAvailableData.	inputDistributionMWI1FromSAM 	receiveAvailableData; resetBuffers .	track 								receiveAvailableData; resetBuffers .	buttonAction 						receiveAvailableData; resetBuffers .	blindClicks							receiveAvailableData; resetBuffers .	trackEdit							receiveAvailableData; resetBuffers .	status 								receiveAvailableData; resetBuffers .	obstacleConfig						receiveAvailableData; resetBuffers .! !!OPNetwork methodsFor: 'reset/emptying' stamp: 'CL 9/25/2009 15:24'!resetForNewStep	"UDP"	speed 				receiveAvailableData.	coord 				receiveAvailableData.	dynamicObstacle 	receiveAvailableData.	joystick 			receiveAvailableData.	collision			receiveAvailableData.! !!OPNetwork methodsFor: 'sending' stamp: 'CL 9/25/2009 11:44'!sendBlindClicksData	(modelData blindClick ~= '')	ifTrue:[		((modelData blindClick) findTokens: ';') do: [:token | blindClicks sendCommand: token. ].		modelData blindClick: ''.	].! !!OPNetwork methodsFor: 'sending' stamp: 'CL 10/1/2009 13:33'!sendButtonActionData	(modelData buttonAction ~= '')	ifTrue:[ 		((modelData buttonAction) findTokens: ';') do: [:token | buttonAction sendCommand: token. ].		modelData buttonAction: ''.	].! !!OPNetwork methodsFor: 'sending' stamp: 'CL 9/25/2009 11:44'!sendTrackEditData	(modelData trackEdit ~= '')	ifTrue:[		((modelData trackEdit) findTokens: ';') do: [:token | trackEdit sendCommand: token. ].		modelData trackEdit: ''.	].! !ImageMorph subclass: #OPObstacle	instanceVariableNames: 'kindOfObstacle orderOfObstacle'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPObstacle methodsFor: 'initialization' stamp: 'CL 9/7/2009 16:38'!initialize		| obstacle |	super initialize.	obstacle := (Form fromFileNamed: 'gfx\icons\obstacle.png') replaceColor: Color white withColor: Color transparent .	self image: obstacle.! !!OPObstacle methodsFor: 'initialization' stamp: 'CL 9/7/2009 16:41'!scaleWithFactor: scaleFactor	self image: ((self image) scaledToSize: (((self image) extent) * scaleFactor)) .! !!OPObstacle methodsFor: 'accessing' stamp: 'CL 9/4/2009 11:18'!kindOfObstacle	^kindOfObstacle! !!OPObstacle methodsFor: 'accessing' stamp: 'CL 9/4/2009 11:18'!kindOfObstacle: anObject	kindOfObstacle := anObject! !!OPObstacle methodsFor: 'accessing' stamp: 'CL 9/4/2009 11:18'!orderOfObstacle	^orderOfObstacle! !!OPObstacle methodsFor: 'accessing' stamp: 'CL 9/4/2009 11:18'!orderOfObstacle: anObject	orderOfObstacle := anObject! !RectangleMorph subclass: #OPSituationAwareness	instanceVariableNames: 'haloEnabled modelData grayArea leftButton rightButton colorGray colorGreen situationalAwarenessConfig status timeout1 timeout2 mp3File timeStamp attention'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPSituationAwareness methodsFor: 'as yet unclassified' stamp: 'CL 10/1/2009 09:08'!actionSelectorLeftButton	(mp3File class = StreamingMP3Sound)	ifTrue:[	mp3File play. ].	leftButton color: colorGray;					label: '';					lock;					extent: 100 @ 100.	rightButton unlock;				color: colorGreen; 				label: 'fertig';				extent: 100 @ 100.	status := 2.	self sendDataToSam: status.	timeStamp := Time millisecondClockValue.! !!OPSituationAwareness methodsFor: 'as yet unclassified' stamp: 'CL 9/30/2009 14:40'!actionSelectorRightButton	self grayAreaShowAndSomeMore.	status := 0.	self sendDataToSam: 3.! !!OPSituationAwareness methodsFor: 'as yet unclassified' stamp: 'CL 9/30/2009 14:12'!blueButtonDown: anEvent	(haloEnabled)	ifTrue:[super blueButtonDown: anEvent.]	ifFalse:[].! !!OPSituationAwareness methodsFor: 'as yet unclassified' stamp: 'CL 9/30/2009 14:12'!clicked	(modelData network)	ifTrue:[modelData blindClick: (World cursorPoint asString, ';'). "Transcript show: 'World cursorPoint (Background): ', World cursorPoint asString; cr."]		ifFalse:["Transcript show: 'World cursorPoint (Background): ', World cursorPoint asString; cr."]! !!OPSituationAwareness methodsFor: 'as yet unclassified' stamp: 'CL 9/30/2009 14:12'!createSituationalAwarenessElements	grayArea := (RectangleMorph new) 						extent: 1265 @ 275; 						position: (self position); 						useRoundedCorners ; 						borderWidth: 0; 						color: ((Color veryLightGray) alpha: 0.5).	leftButton := SimpleButtonMorph new						color: colorGray;						borderColor: #raised;						borderWidth: 5;						label: '';						extent: 100 @ 100;						target: self;						openInWorld;						position: self position + (50 @ 88);						lock;						actionSelector: #actionSelectorLeftButton.	rightButton := SimpleButtonMorph new						color: colorGray;						borderColor: #raised;						borderWidth: 5;						label: '';						extent: 100 @ 100;						target: self;						openInWorld;						position: self position + (200 @ 88);						lock;						actionSelector: #actionSelectorRightButton.	! !!OPSituationAwareness methodsFor: 'as yet unclassified' stamp: 'CL 10/1/2009 09:07'!delete	attention closeFile.	(mp3File class = StreamingMP3Sound)	ifTrue:[ mp3File closeFile. ].	super delete.! !!OPSituationAwareness methodsFor: 'as yet unclassified' stamp: 'CL 9/30/2009 14:12'!grayAreaHideAndSomeMore	grayArea hide.	leftButton unlock;				color: colorGreen; 				label: 'bereit';				extent: 100 @ 100.! !!OPSituationAwareness methodsFor: 'as yet unclassified' stamp: 'CL 9/30/2009 14:12'!grayAreaShowAndSomeMore	grayArea show.	leftButton lock;				color: colorGray; 				label: '';				extent: 100 @ 100.	rightButton lock;				color: colorGray; 				label: '';				extent: 100 @ 100.! !!OPSituationAwareness methodsFor: 'as yet unclassified' stamp: 'CL 9/30/2009 14:12'!haloEnabled: bool	haloEnabled := bool.! !!OPSituationAwareness methodsFor: 'as yet unclassified' stamp: 'CL 10/1/2009 09:34'!initialize	| title |	super initialize.	modelData := OPModelData getInstance .	status := 0.	attention := (StreamingMP3Sound onFileNamed: 'sa\audio\achtung.mp3').	situationalAwarenessConfig := OrderedCollection new.	colorGray := (Color gray mixed: 0.14 with: Color white).	colorGreen := (Color green mixed: 0.5 with: Color white).	self loadSituationalAwarenessConfiguration.	self position: 1285 @ 1315; "the positioning is a little tweak, so that we are not jumping from 0 @ 0 to the destination"		createSituationalAwarenessElements.	title := (StringMorph new) 					contents: 'Messung Situationsbewusstsein'; 					fontName: #BitstreamVeraSans size: 32; 					"emphasis: 1; bold"					position: self position + (50 @ 30).	self color: Color transparent; 		borderWidth: 5;		borderColor: Color black;		extent: 1265 @ 275;		useRoundedCorners;		addMorphBack: grayArea;		addMorphBack: leftButton;		addMorphBack: rightButton;		addMorphBack: title;		openInWorld.	self on: #click send: #clicked to: self.! !!OPSituationAwareness methodsFor: 'as yet unclassified' stamp: 'CL 10/1/2009 09:33'!loadSituationalAwarenessConfiguration		| fileStreamSteps line lineTokens saItem|		fileStreamSteps := FileStream readOnlyFileNamed: 'sa\situationAwareness.txt'.		[fileStreamSteps atEnd]	whileFalse:	[		line := fileStreamSteps nextLine.		lineTokens := line findTokens: ';'.		saItem := (OPSituationAwarenessItem new)						stepNr: (lineTokens at: 1) asInteger;						distance: (lineTokens at: 2) asInteger;						timeout1: (lineTokens at: 3) asInteger;						timeout2: (lineTokens at: 4) asInteger.		(lineTokens size = 5)		ifTrue:[ saItem mp3File: (StreamingMP3Sound onFileNamed: 'sa\audio\', ((lineTokens at: 5) withBlanksTrimmed)). ].		situationalAwarenessConfig add: saItem. 	].	fileStreamSteps close.! !!OPSituationAwareness methodsFor: 'as yet unclassified' stamp: 'CL 10/1/2009 15:19'!processSituationalAwareness	"status = 0 - initial situation buttons gray and grayArea overlays them	status = 1 - grayArea hidden and button 1 (the left one) is green and has a label, button 2 is gray and timeout1 is active	status = 2 - grayArea is still hidden and button 2 (yes, the right one) is green and button 1 is gray and timeout2 is active	status can be changed in the respective actionSelectors!!"	"situationalAwarenessConfig 		do: [:item | 			Transcript cr; show: 'situationalAwarenessConfig contains: ', item stepNr asString, '; ',			item timeout1 asString, '; ',			item timeout2 asString, '; ',			item distance asString. 		]."	"Transcript cr; show: 'status: ', status asString, ' modelData currentCoordinateY: ', modelData currentCoordinateY asString."	(status = 0)	ifTrue:[		situationalAwarenessConfig 			do: [:item |				(item stepNr = modelData stepNr)				ifTrue:[					((modelData currentCoordinateY) between: item distance and: item distance + 21)					ifTrue:[						self grayAreaHideAndSomeMore .						status := 1.						self sendDataToSam: status.						"Transcript cr; show: 'modelData currentCoordinateY: ', modelData currentCoordinateY asString, ' modelData buttonAction: ', modelData buttonAction asString."						timeout1 := item timeout1.						timeout2 := item timeout2.						(mp3File class = StreamingMP3Sound)						ifTrue:[ mp3File closeFile. ].						mp3File := item mp3File.						timeStamp := Time millisecondClockValue.						situationalAwarenessConfig remove: item.						"Transcript cr; show: 'situationalAwarenessConfig entry with key: ', (item stepNr + item timeout1 + item timeout2) asString, ' deleted'."						attention play.					].				].			].	].	(status = 1)	ifTrue:[		(((Time millisecondClockValue - timeStamp) / 1000.0) > timeout1)		ifTrue:[			status := 0.			self sendDataToSam: 11. "11 is the code for reached timeout"			self grayAreaShowAndSomeMore.			"Transcript cr; show: '(Time millisecondClockValue - timeStamp) / 1000.0: ', ((Time millisecondClockValue - timeStamp) / 1000.0) asString."		].	].	(status = 2)	ifTrue:[		(((Time millisecondClockValue - timeStamp) / 1000.0) > timeout2)		ifTrue:[			status := 0.			self sendDataToSam: 22. "22 is the code for reached timeout"			self grayAreaShowAndSomeMore.		].].! !!OPSituationAwareness methodsFor: 'as yet unclassified' stamp: 'CL 10/1/2009 11:33'!sendDataToSam: data	(modelData network)	ifTrue:[ modelData buttonAction: modelData buttonAction, ((8000 + data) asString, ';'). ].! !Object subclass: #OPSituationAwarenessItem	instanceVariableNames: 'distance timeout1 timeout2 mp3File stepNr'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPSituationAwarenessItem methodsFor: 'accessing' stamp: 'CL 9/30/2009 14:16'!distance	^distance! !!OPSituationAwarenessItem methodsFor: 'accessing' stamp: 'CL 9/30/2009 14:16'!distance: anObject	distance := anObject! !!OPSituationAwarenessItem methodsFor: 'accessing' stamp: 'CL 9/30/2009 14:16'!mp3File	^mp3File! !!OPSituationAwarenessItem methodsFor: 'accessing' stamp: 'CL 9/30/2009 14:16'!mp3File: anObject	mp3File := anObject! !!OPSituationAwarenessItem methodsFor: 'accessing' stamp: 'CL 10/1/2009 09:20'!stepNr	^stepNr! !!OPSituationAwarenessItem methodsFor: 'accessing' stamp: 'CL 10/1/2009 09:20'!stepNr: anObject	stepNr := anObject! !!OPSituationAwarenessItem methodsFor: 'accessing' stamp: 'CL 9/30/2009 14:16'!timeout1	^timeout1! !!OPSituationAwarenessItem methodsFor: 'accessing' stamp: 'CL 9/30/2009 14:16'!timeout1: anObject	timeout1 := anObject! !!OPSituationAwarenessItem methodsFor: 'accessing' stamp: 'CL 9/30/2009 14:16'!timeout2	^timeout2! !!OPSituationAwarenessItem methodsFor: 'accessing' stamp: 'CL 9/30/2009 14:16'!timeout2: anObject	timeout2 := anObject! !AlignmentMorph subclass: #OPWindow	instanceVariableNames: 'buttonSize label switchButtonSize guiElementName buttonBag seperationBar labelContainer haloEnabled guiElementPositions modelData'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 6/4/2009 14:23'!blueButtonDown: anEvent	(haloEnabled)	ifTrue:[super blueButtonDown: anEvent.]	ifFalse:[].! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 4/24/2009 14:24'!buttonFontSize: size	buttonBag do: [:button| (button findA: StringMorph) fontName: #BitstreamVeraSansMono size: size].	! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 4/22/2009 11:39'!buttonSize	^buttonSize! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 9/10/2009 19:28'!clicked	(modelData network)	ifTrue:[modelData blindClick: modelData blindClick, (World cursorPoint asString, ';'). "Transcript show: 'modelData blindClick: ', modelData blindClick; cr." ]		ifFalse:["Transcript show: 'World cursorPoint (Background): ', World cursorPoint asString; cr."]! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 9/25/2009 18:22'!createAlignmentMorph: thisExtent	^AlignmentMorph new		color: Color transparent ;			listDirection: #topToBottom;		borderColor: Color blue;		borderWidth: 0;		wrapCentering: #center;		extent: thisExtent ;		vResizing: #rigid;		hResizing: #rigid;		layoutInset: 0;		useRoundedCorners .! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 5/27/2009 16:26'!createIconicButton: aFile withActionSelector: aSelector 	^IconicButton new		target: self;		labelGraphic: ((Form fromFileNamed: aFile) replaceColor: Color white withColor: Color transparent );		actionSelector: aSelector;		borderColor: #raised;		borderWidth: 4;		extent: self buttonSize;		"recolor: Color veryVeryLightGray;"		color: (self groupColor );		useRoundedCorners .! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 5/27/2009 18:54'!createSimpleButton: buttonLabel withActionSelector: foo 	"in buttonBag all the created buttons are stored for later manipulation"	^buttonBag add: (SimpleButtonMorph new				color: (self groupColor);				borderColor: #raised;				borderWidth: 5;				label: buttonLabel;				extent: self buttonSize;				target: self;				actionSelector: foo).! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 7/23/2009 17:23'!createStringMorphBigAndBold: buttonLabel ^(StringMorph new) contents: buttonLabel; fontName: #BitstreamVeraSans size: 24; emphasis: 1.! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 5/29/2009 16:37'!createStringMorphBold: buttonLabel ^(StringMorph new) contents: buttonLabel; fontName: #BitstreamVeraSans size: 16; emphasis: 1.! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 7/27/2009 10:18'!createStringMorphSmall: buttonLabel ^(StringMorph new) contents: buttonLabel; fontName: #BitstreamVeraSans size: 16.! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 7/23/2009 16:57'!createStringMorph: buttonLabel ^(StringMorph new) contents: buttonLabel; fontName: #BitstreamVeraSans size: 24.! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 5/28/2009 13:20'!createSwitchButton: buttonLabel withActionSelector: foo 	^SimpleSwitchMorph new				onColor: (Color green mixed: 0.5 with: Color white);				offColor: (Color red mixed: 0.5 with: Color white);				color: (Color green mixed: 0.5 with: Color white);				borderColor: #inset;				borderWidth: 5;				label: buttonLabel;				extent: self switchButtonSize;				target: self;				setSwitchState: false;				actionSelector: foo.! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 7/23/2009 10:06'!createTitle	^(TextMorph new) 				contents: (('Horst') asText 								addAttribute: (TextFontReference toFont: (StrikeFont familyName: 'BitstreamVeraSans' size: 32)));				centered;				lock.! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 5/27/2009 16:27'!groupColor	^(Color gray mixed: 0.14 with: Color white)! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 8/9/2009 16:29'!groupColorDarker	^(Color gray mixed: 0.34 with: Color white)! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 8/9/2009 16:29'!groupColorDarkest	^(Color gray mixed: 0.54 with: Color white)! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 6/4/2009 14:29'!haloEnabled: bool	haloEnabled := bool.! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 9/30/2009 14:12'!initialize	| sepaerationBarContainer |	modelData := OPModelData getInstance .	guiElementName := Dictionary new.	guiElementName at: 'OPVisualHints' put: 'Visuelle Hinweise'.	guiElementName at: 'OPAuditiveHints' put: 'Auditive Hinweise'.	guiElementName at: 'OPDirectionButtons' put: 'Richtungsbeschränkung'.	guiElementName at: 'OPSpeed' put: 'Geschwindigkeitslimit'.	guiElementName at: 'OPInputDistribution' put: 'Steuergewalt'.	guiElementName at: 'OPTrackPreview' put: 'Streckenansicht'.	guiElementName at: 'OPSystemStatus' put: 'Systemstatus'.	guiElementName at: 'OPMentalWorkload' put: 'Anstrengung'.	guiElementName at: 'OPVideo' put: 'Videobild der Personen'.	guiElementPositions := Dictionary new. 	guiElementPositions at: 'OPVisualHints' 			put: 1285 @ 10.	guiElementPositions at: 'OPAuditiveHints' 		put: 1285 @ 520.	guiElementPositions at: 'OPDirectionButtons' 		put: 2150 @ 705.	guiElementPositions at: 'OPSpeed' 					put: 2150 @ 10.	guiElementPositions at: 'OPInputDistribution'		put: 2150 @ 1010.	guiElementPositions at: 'OPTrackPreview' 			put: 495 @ 10.	guiElementPositions at: 'OPSystemStatus' 			put: 10 @ 10.	guiElementPositions at: 'OPMentalWorkload' 		put: 10 @ 820.	guiElementPositions at: 'BarneyOne' 				put: 450 @ 10.	guiElementPositions at: 'BarneyTwo' 				put: 1215 @ 10.	guiElementPositions at: 'BarneyThree' 			put: 2105 @ 10.	guiElementPositions at: 'OPBackground' 			put: 0 @ 0.	guiElementPositions at: 'OPVideo' 					put: 10 @ 1150.	guiElementPositions at: 'OPSituationAwareness'	put: 1285 @ 1315.	buttonBag := Bag new.	buttonSize := 100 @ 100.	switchButtonSize := 250@50.		haloEnabled := true.	super initialize.	self		color: Color veryVeryLightGray;		height:190;		width: 350;		borderWidth: 2;		layoutInset: 0;		listDirection: #topToBottom;		wrapCentering: #center;		cellPositioning: #topCenter;		cornerStyle: #rounded.	labelContainer := (AlignmentMorph new)				listDirection: #topToBottom;				height: 40;				width: self width - (self borderWidth * 2);				borderWidth: 0;				cellPositioning: #center;				listCentering: #center;				wrapCentering: #center;				vResizing: #rigid;				hResizing: #rigid;				borderColor: Color yellow;				color: Color transparent;				layoutInset: 0.	label := self createTitle .	sepaerationBarContainer := (AlignmentMorph new)				listDirection: #topToBottom;				height: 20;				width: self width - (self borderWidth * 2);				borderWidth: 0;				cellPositioning: #top;				listCentering: #center;				wrapCentering: #center;				vResizing: #rigid;				hResizing: #rigid;				borderColor: Color yellow;				color: Color transparent;				layoutInset: 0.		seperationBar := RectangleMorph new color: Color black; extent: self width - (self borderWidth * 2)@2; borderWidth: 0; borderColor: Color blue .	sepaerationBarContainer addMorphBack: seperationBar.	self addMorphBack: (labelContainer addMorphBack: label); addMorphBack: sepaerationBarContainer.	self on: #click send: #clicked to: self.	! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 4/22/2009 11:40'!label: foo 	label contents: foo! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 4/23/2009 10:02'!myName: foo 	^guiElementName at: foo! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 7/24/2009 10:32'!myPosition: foo 	^(guiElementPositions at: foo)! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 5/28/2009 16:24'!setWindwoSize: newSize	self extent: newSize.	seperationBar extent: self width - (self borderWidth * 2)@2.	labelContainer width: self width - (self borderWidth * 2).! !!OPWindow methodsFor: 'as yet unclassified' stamp: 'CL 4/22/2009 13:00'!switchButtonSize	^switchButtonSize! !OPWindow subclass: #OPAuditiveHints	instanceVariableNames: 'mwiOneButton mwiBothButton mwiTwoButton backButton leftButton rightButton forwardButton grayArea leftGfx rightGfx mwi'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPAuditiveHints methodsFor: 'as yet unclassified' stamp: 'CL 9/16/2009 12:07'!actionSelectorBack	self sendDataToSam: 4000 + 21.	self showGrayArea.	self showTrackPreviewHints: 'back'.! !!OPAuditiveHints methodsFor: 'as yet unclassified' stamp: 'CL 9/16/2009 12:07'!actionSelectorForward	self sendDataToSam: 4000 + 22.	self showGrayArea.	self showTrackPreviewHints: 'forward'.! !!OPAuditiveHints methodsFor: 'as yet unclassified' stamp: 'CL 9/16/2009 12:07'!actionSelectorGreenThingyOffTrack	self sendDataToSam: 4000 + 41.	self showGrayArea.	self showTrackPreviewHints: 'greenThingyOffTrack'.! !!OPAuditiveHints methodsFor: 'as yet unclassified' stamp: 'CL 9/16/2009 12:07'!actionSelectorGreenThingyOnTrack	self sendDataToSam: 4000 + 42.	self showGrayArea.	self showTrackPreviewHints: 'greenThingyOnTrack'.! !!OPAuditiveHints methodsFor: 'as yet unclassified' stamp: 'CL 9/16/2009 12:07'!actionSelectorJoystickBig	self sendDataToSam: 4000 + 52.	self showGrayArea. 	self showTrackPreviewHints: 'joystickBig'.! !!OPAuditiveHints methodsFor: 'as yet unclassified' stamp: 'CL 9/16/2009 12:08'!actionSelectorJoystickSmall	self sendDataToSam: 4000 + 51.	self showGrayArea.	self showTrackPreviewHints: 'joystickSmall'.! !!OPAuditiveHints methodsFor: 'as yet unclassified' stamp: 'CL 9/16/2009 12:08'!actionSelectorLeft	self sendDataToSam: 4000 + 31.	self showGrayArea.	self showTrackPreviewHints: 'left'.! !!OPAuditiveHints methodsFor: 'as yet unclassified' stamp: 'CL 9/16/2009 12:11'!actionSelectorMwiBoth	mwiOneButton borderColor: #raised; color: (self groupColor).	mwiBothButton borderColor: #inset; color: Color veryVeryLightGray.	mwiTwoButton borderColor: #raised; color: (self groupColor).	mwi := 3.	self sendDataToSam: 5000 + mwi.	self hideGrayArea.! !!OPAuditiveHints methodsFor: 'as yet unclassified' stamp: 'CL 9/16/2009 12:11'!actionSelectorMwiOne	mwiOneButton borderColor: #inset; color: Color veryVeryLightGray.	mwiBothButton borderColor: #raised; color: (self groupColor).	mwiTwoButton borderColor: #raised; color: (self groupColor).	mwi := 1.	self sendDataToSam: 5000 + mwi.	self hideGrayArea.! !!OPAuditiveHints methodsFor: 'as yet unclassified' stamp: 'CL 9/16/2009 12:12'!actionSelectorMwiTwo	mwiOneButton borderColor: #raised; color: (self groupColor).	mwiBothButton borderColor: #raised; color: (self groupColor).	mwiTwoButton borderColor: #inset; color: Color veryVeryLightGray.	mwi := 2.		self sendDataToSam: 5000 + mwi.	self hideGrayArea.! !!OPAuditiveHints methodsFor: 'as yet unclassified' stamp: 'CL 9/16/2009 12:08'!actionSelectorRight	self sendDataToSam: 4000 + 32.	self showGrayArea.	self showTrackPreviewHints: 'right'.! !!OPAuditiveHints methodsFor: 'as yet unclassified' stamp: 'CL 7/23/2009 16:42'!hideGrayArea	grayArea hide.! !!OPAuditiveHints methodsFor: 'as yet unclassified' stamp: 'CL 9/10/2009 19:23'!initialize	| mainContainer buttonRowContainer topContainer arrowContainer mwiOneButtonContainer mwiBothButtonContainer mwiTwoButtonContainer turnButtonColumn joystickButtonBig joystickButtonSmall greenThingyOnTrackButton greenThingyOffTrackButton topArrowContainer middleArrowContainer bottomArrowContainer joystickButtonColumn grayContainer localGfx |	super initialize.	leftGfx := Dictionary new.	rightGfx := Dictionary new.	mwi := 0.	localGfx := (Dictionary new).	localGfx	at: 'greenThingyOnTrack'	put: 'gfx\icons\Bild_Kurvenverhalten_auf_Strecke_90x90.png';				at: 'greenThingyOffTrack'	put: 'gfx\icons\Bild_Kurvenverhalten_neben_Strecke_90x90.png';				at: 'joystickBig' 				put: 'gfx\icons\Bild_Joystick_90x90.png';				at: 'joystickSmall' 			put: 'gfx\icons\Bild_Joystick_40x40.png';				at: 'forward'					put: 'gfx\icons\Bild_schneller_fahren.png';				at: 'back' 					put: 'gfx\icons\Bild_langsamer_fahren.png';				at: 'left' 						put: 'gfx\icons\Bild_Richtung_links.png';				at: 'right' 					put: 'gfx\icons\Bild_Richtung_rechts.png'.		self loadTrackPreviewHints: localGfx .	"building the row with the MWI buttons"	mwiOneButton := self createIconicButton: 'gfx\icons\Bild_MWB_dunkel_40x40.png' withActionSelector: #actionSelectorMwiOne.	mwiBothButton := self createIconicButton: 'gfx\icons\Bild_MWB_dunkel+hell_80x80.png' withActionSelector: #actionSelectorMwiBoth .	mwiTwoButton := self createIconicButton: 'gfx\icons\Bild_MWB_hell_40x40.png' withActionSelector: #actionSelectorMwiTwo .	"putting the buttons in the respective container"	mwiOneButtonContainer := self createAlignmentMorph: (mwiOneButton extent x + 4)@(mwiOneButton extent y + 30).	mwiOneButtonContainer addMorphBack: mwiOneButton; addMorphBack: (self createStringMorph: 'Person 1').	mwiBothButtonContainer := self createAlignmentMorph: (mwiBothButton extent x + 4)@(mwiBothButton extent y + 30).	mwiBothButtonContainer addMorphBack: mwiBothButton; addMorphBack: (self createStringMorph: 'Person 1+2').	mwiTwoButtonContainer := self createAlignmentMorph: (mwiTwoButton extent x + 4)@(mwiTwoButton extent y + 30).	mwiTwoButtonContainer addMorphBack: mwiTwoButton; addMorphBack: (self createStringMorph: 'Person 2').	"creating the container and putting it all in there"		buttonRowContainer := self createAlignmentMorph: (mwiTwoButtonContainer extent x * 3)@(mwiOneButtonContainer extent y).	buttonRowContainer listDirection: #leftToRight; 						addMorphBack: mwiOneButtonContainer; 						addMorphBack: mwiBothButtonContainer; 						addMorphBack: mwiTwoButtonContainer.	topContainer := self createAlignmentMorph: 360@(buttonRowContainer extent y + 40).	topContainer color: (self groupColor );					addMorphBack: (self createStringMorphBigAndBold: 'Hinweis an:');					addMorphBack: (self createAlignmentMorph: 10@20);					addMorphBack: buttonRowContainer .							"building the arrowbuttons along with the container that will hold the stuff"	arrowContainer := self createAlignmentMorph: 350@420.								forwardButton 	:= self createIconicButton: (localGfx at: 'forward') withActionSelector: #actionSelectorForward.	backButton 		:= self createIconicButton: (localGfx at: 'back') withActionSelector: #actionSelectorBack.	leftButton 		:= self createIconicButton: (localGfx at: 'left') withActionSelector: #actionSelectorLeft.	rightButton 	:= self createIconicButton: (localGfx at: 'right') withActionSelector: #actionSelectorRight.	topArrowContainer 		:= self createAlignmentMorph: 300@120.	middleArrowContainer 	:= self createAlignmentMorph: 300@120 .		bottomArrowContainer 	:= self createAlignmentMorph: 300@120 .			topArrowContainer addMorphBack: forwardButton ; addMorphBack: (self createStringMorph: 'schneller').	middleArrowContainer listDirection: #leftToRight;  							addMorphBack: ((self createAlignmentMorph: leftButton extent x@120) addMorphBack: leftButton; addMorphBack: (self createStringMorph: 'links')) ; 							addMorphBack: (self createAlignmentMorph: 100@10) ; "acts as spacer"							addMorphBack: ((self createAlignmentMorph: rightButton extent x@120) addMorphBack: rightButton; addMorphBack: (self createStringMorph: 'rechts')).	bottomArrowContainer addMorphBack: backButton ; addMorphBack: (self createStringMorph: 'langsamer').	arrowContainer color: (self groupColor);						addMorphBack: (self createStringMorphBigAndBold: 'Fahrtrichtung & Geschwindigkeit');						addMorphBack: (self createAlignmentMorph: 10@20);						addMorphBack: topArrowContainer; 						addMorphBack: middleArrowContainer; 						addMorphBack: bottomArrowContainer.	"turn button column"	turnButtonColumn := self createAlignmentMorph: 160@420.	turnButtonColumn color: (self groupColor ).	greenThingyOnTrackButton := self createIconicButton: (localGfx at: 'greenThingyOnTrack') withActionSelector: #actionSelectorGreenThingyOnTrack.	greenThingyOffTrackButton := self createIconicButton: (localGfx at: 'greenThingyOffTrack') withActionSelector: #actionSelectorGreenThingyOffTrack.	turnButtonColumn 	addMorphBack: (self createStringMorphBigAndBold: 'Kurvenverhalten');							addMorphBack: (self createAlignmentMorph: 10@20);							addMorphBack: greenThingyOnTrackButton;							addMorphBack: (self createStringMorph: 'genauer fahren');							addMorphBack: (self createAlignmentMorph: 10@120);							addMorphBack: greenThingyOffTrackButton;							addMorphBack: (self createStringMorph: 'abkürzen').	"joystick button column"	joystickButtonColumn := self createAlignmentMorph: 160@420.	joystickButtonColumn color: (self groupColor ).	joystickButtonBig	:= self createIconicButton: (localGfx at: 'joystickBig') withActionSelector: #actionSelectorJoystickBig.	joystickButtonSmall := self createIconicButton: (localGfx at: 'joystickSmall') withActionSelector: #actionSelectorJoystickSmall.	joystickButtonColumn addMorphBack: (self createStringMorphBigAndBold: 'Führung');							addMorphBack: (self createAlignmentMorph: 10@20);							addMorphBack: joystickButtonBig;							addMorphBack: (self createStringMorph: 'übernehmen');							addMorphBack: (self createAlignmentMorph: 10@120);							addMorphBack: joystickButtonSmall;							addMorphBack: (self createStringMorph: 'überlassen').	"adding the elements to the oberhoncho-conatainer"	mainContainer := self createAlignmentMorph: 730@420.	mainContainer listDirection: #leftToRight.	"stuff for graying out"	grayContainer := (RectangleMorph new) extent: 730 @ 420; position: 1166 @ 1117; useRoundedCorners ; borderWidth: 0; color: Color transparent .	grayArea := (RectangleMorph new) extent: 730 @ 420; position: 1166 @ 1117; useRoundedCorners ; borderWidth: 0; color: ((Color veryLightGray) alpha: 0.5).	mainContainer 	addMorphBack: turnButtonColumn;						addMorphBack: (self createAlignmentMorph: 30@10);						addMorphBack: joystickButtonColumn;						addMorphBack: (self createAlignmentMorph: 30@10);						addMorphBack: arrowContainer.	grayContainer addMorphBack: (mainContainer position: 1166 @ 1117); 						addMorph: grayArea.	self label: (self myName: 'OPAuditiveHints'); 					addMorphBack: (self createAlignmentMorph: 10@30);					addMorphBack: topContainer ; 					addMorphBack: (self createAlignmentMorph: 10@50);					"addMorphBack: mainContainer; "					addMorphBack: grayContainer;					setWindwoSize: 780@785;					position: (self myPosition: 'OPAuditiveHints');					color: (self groupColorDarker);					openInWorld .! !!OPAuditiveHints methodsFor: 'as yet unclassified' stamp: 'CL 8/9/2009 16:20'!loadTrackPreviewHints: imageNameDictionary		imageNameDictionary keysAndValuesDo: 		[			:aKey :aValue | 			leftGfx at: aKey put: ((self createAlignmentMorph: 100 @ 100) 											listCentering: #center; 											color: (self groupColor );											addMorphBack: ((Form fromFileNamed: aValue) replaceColor: Color white withColor: Color transparent) asMorph;											position: 535 @ 1240;											openInWorld;											hide).			rightGfx at: aKey put: ((self createAlignmentMorph: 100 @ 100)  											listCentering: #center; 											color: (self groupColor );											addMorphBack: ((Form fromFileNamed: aValue) replaceColor: Color white withColor: Color transparent) asMorph;											position: 1015 @ 1240;											openInWorld;											hide).		].! !!OPAuditiveHints methodsFor: 'as yet unclassified' stamp: 'CL 9/25/2009 16:25'!resetForNewStep	self showGrayArea.! !!OPAuditiveHints methodsFor: 'as yet unclassified' stamp: 'CL 9/16/2009 12:11'!sendDataToSam: data	(modelData network)	ifTrue:[ modelData buttonAction: modelData buttonAction, data asString, ';'; changed. ].! !!OPAuditiveHints methodsFor: 'as yet unclassified' stamp: 'CL 7/23/2009 16:45'!showGrayArea	grayArea show.	mwiOneButton borderColor: #raised; color: (self groupColor).	mwiBothButton borderColor: #raised; color: (self groupColor).	mwiTwoButton borderColor: #raised; color: (self groupColor).! !!OPAuditiveHints methodsFor: 'as yet unclassified' stamp: 'CL 9/4/2009 09:51'!showTrackPreviewHints: aHintString	(modelData trackPreviewHint) 	ifFalse:	[		((mwi = 1) | (mwi = 3))		ifTrue:		[			[				modelData trackPreviewHint: true; changed. 				(leftGfx at: aHintString) show; comeToFront. 				(Delay forMilliseconds: 1500) wait. 				(leftGfx at: aHintString) hide.				modelData trackPreviewHint: false; changed. 			] fork.		].				((mwi = 2) | (mwi = 3))		ifTrue:		[			[				modelData trackPreviewHint: true; changed. 				(rightGfx at: aHintString) show; comeToFront. 				(Delay forMilliseconds: 1500) wait. 				(rightGfx at: aHintString) hide.				modelData trackPreviewHint: false; changed. 			] fork.		].	].! !OPWindow subclass: #OPDirectionButtons	instanceVariableNames: 'denyLeftButton denyRightButton'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPDirectionButtons methodsFor: 'as yet unclassified' stamp: 'CL 8/9/2009 15:03'!actionSelectorDenyLeft	denyLeftButton borderColor: #inset; color: Color veryLightGray.	denyRightButton borderColor: #raised; color: (self groupColor ).	self sendDataToSam: '101'.	modelData directSetDirectionLeft: true;					directSetDirectionRight: false;					changed.! !!OPDirectionButtons methodsFor: 'as yet unclassified' stamp: 'CL 8/9/2009 15:03'!actionSelectorDenyRight	denyLeftButton borderColor: #raised; color: (self groupColor ).	denyRightButton borderColor: #inset; color: Color veryLightGray.	self sendDataToSam: '102'.		modelData directSetDirectionLeft: false;					directSetDirectionRight: true					changed.! !!OPDirectionButtons methodsFor: 'as yet unclassified' stamp: 'CL 8/9/2009 15:03'!actionSelectorReset	denyLeftButton borderColor: #raised; color: (self groupColor ).	denyRightButton borderColor: #raised; color: (self groupColor ).	self sendDataToSam: '103'.		modelData directSetDirectionLeft: false;					directSetDirectionRight: false					changed.! !!OPDirectionButtons methodsFor: 'as yet unclassified' stamp: 'CL 5/29/2009 17:01'!createAlignmentMorph: thisExtent	^AlignmentMorph new		color: Color transparent ;			listDirection: #topToBottom;		borderColor: Color transparent;		borderWidth: 1;		"listCentering: #center;"		wrapCentering: #center;		extent: thisExtent ;		vResizing: #rigid;		hResizing: #rigid;		layoutInset: 0;		useRoundedCorners .! !!OPDirectionButtons methodsFor: 'as yet unclassified' stamp: 'nn 8/11/2009 20:09'!delete	super delete.	modelData directSetDirectionLeft: false;					directSetDirectionRight: false;					directSetDirectionReset: false;					changed.! !!OPDirectionButtons methodsFor: 'as yet unclassified' stamp: 'CL 9/10/2009 19:23'!initialize	| buttonContainer leftButtonContainer middleButtonContainer rightButtonContainer resetButton mainContainer |	super initialize.	buttonContainer := self createAlignmentMorph: 303@121 .	buttonContainer listDirection: #leftToRight.	denyLeftButton := self createIconicButton: 'gfx\icons\Bild_Richtungsbeschränkung_links_100x100.png' withActionSelector: #actionSelectorDenyLeft.	resetButton := (self createSimpleButton: 'Reset' withActionSelector: #actionSelectorReset) extent: 100 @ 50.	denyRightButton := self createIconicButton: 'gfx\icons\Bild_Richtungsbeschränkung_rechts_100x100.png' withActionSelector: #actionSelectorDenyRight .	leftButtonContainer := self createAlignmentMorph: 100@120.	middleButtonContainer := self createAlignmentMorph: 100@70.	rightButtonContainer := self createAlignmentMorph: 100@120.	leftButtonContainer addMorphBack: denyLeftButton; 								addMorphBack: (self createAlignmentMorph: 10 @ 15);								addMorphBack: (self createStringMorph: 'links').	middleButtonContainer addMorphBack: resetButton .	rightButtonContainer addMorphBack: denyRightButton;								addMorphBack: (self createAlignmentMorph: 10 @ 15); 								addMorphBack: (self createStringMorph: 'rechts').	buttonContainer	addMorphBack: leftButtonContainer; 							addMorphBack: middleButtonContainer; 							addMorphBack: rightButtonContainer.	mainContainer := (self createAlignmentMorph: 303 @ 250)								addMorphBack: (self createAlignmentMorph: 303 @ 35);								addMorphBack: buttonContainer.	self label: (self myName: 'OPDirectionButtons'); 		setWindwoSize: 400@295; 		addMorphBack: mainContainer; 		position: (self myPosition: 'OPDirectionButtons');		color: (self groupColorDarkest );		openInWorld.! !!OPDirectionButtons methodsFor: 'as yet unclassified' stamp: 'CL 9/4/2009 09:24'!resetForNewStep	denyLeftButton borderColor: #raised; color: (self groupColor ).	denyRightButton borderColor: #raised; color: (self groupColor ).! !!OPDirectionButtons methodsFor: 'as yet unclassified' stamp: 'CL 9/10/2009 20:30'!sendDataToSam: data	(modelData network)	ifTrue:[ modelData buttonAction: modelData buttonAction, (data asString, ';'); changed. ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OPDirectionButtons class	instanceVariableNames: 'denyLeft denyRight'!OPWindow subclass: #OPGuiMasterControl	instanceVariableNames: 'guiElementState switchButtons selfPosition sticky halo joystickOutput joystickMwiOne joystickMwiTwo nonNetworkY nonNetworkDirection nonNetworkX joystickMwiOneX joystickMwiOneY joystickMwiTwoX joystickMwiTwoY nonNetworkSpeed networkButton simulationButton network waitForIt fooBar waitForItContent'	classVariableNames: 'GuiElement'	poolDictionaries: ''	category: 'ATEO-Operator'!!OPGuiMasterControl methodsFor: 'artificialInput' stamp: 'CL 9/21/2009 11:31'!artificialInputInitialize	| obstacleConfig arrayWithTwoEntrys |	obstacleConfig := OrderedCollection new.	arrayWithTwoEntrys := Array new: 2.	obstacleConfig add: ((arrayWithTwoEntrys at: 1 put: 111; at: 2 put: 15945; yourself) copy);						add: ((arrayWithTwoEntrys at: 1 put: 1110; at: 2 put: 24445; yourself) copy);						add: ((arrayWithTwoEntrys at: 1 put: 1111; at: 2 put: 30985; yourself) copy);						add: ((arrayWithTwoEntrys at: 1 put: 1111; at: 2 put: 54815; yourself) copy);						add: ((arrayWithTwoEntrys at: 1 put: 111; at: 2 put: 63315; yourself) copy);						add: ((arrayWithTwoEntrys at: 1 put: 1111; at: 2 put: 69855; yourself) copy);						add: ((arrayWithTwoEntrys at: 1 put: 1110; at: 2 put: 93685; yourself) copy);						add: ((arrayWithTwoEntrys at: 1 put: 1110; at: 2 put: 102185; yourself) copy);						add: ((arrayWithTwoEntrys at: 1 put: 111; at: 2 put: 108725; yourself) copy).		modelData trackName: 'hauptabschnitt_lang';"'hauptabschnitt_lang' 'lernstrecke';"					obstacleConfig: obstacleConfig.! !!OPGuiMasterControl methodsFor: 'artificialInput' stamp: 'CL 9/21/2009 13:32'!artificialInputJoystick	((10 atRandom) = 5)	ifTrue:[joystickMwiOneX := joystickMwiOneX negated.].	((10 atRandom) = 5)	ifTrue:[joystickMwiOneY := joystickMwiOneY negated.].	((10 atRandom) = 5)	ifTrue:[joystickMwiTwoX := joystickMwiTwoX negated.].	((10 atRandom) = 5)	ifTrue:[joystickMwiTwoY := joystickMwiTwoY negated.].	joystickMwiOne := joystickMwiOne x + ((100 atRandom) * joystickMwiOneX) @ joystickMwiOne y + ((100 atRandom) * joystickMwiOneY).	joystickMwiTwo := joystickMwiTwo x + ((100 atRandom) * joystickMwiTwoX) @ joystickMwiTwo y + ((100 atRandom) * joystickMwiTwoY).	(joystickMwiOne x > 1023)	ifTrue:[joystickMwiOne := 1023 @ joystickMwiOne y.].	(joystickMwiOne x < -1024)	ifTrue:[joystickMwiOne := -1024 @ joystickMwiOne y.].	(joystickMwiOne y > 1023)	ifTrue:[joystickMwiOne := joystickMwiOne x @ 1023.].	(joystickMwiOne y < -1024)	ifTrue:[joystickMwiOne := joystickMwiOne x @ -1024.].	(joystickMwiTwo x > 1023)	ifTrue:[joystickMwiTwo := 1023 @ joystickMwiTwo y.].	(joystickMwiTwo x < -1024)	ifTrue:[joystickMwiTwo := -1024 @ joystickMwiTwo y.].	(joystickMwiTwo y > 1023)	ifTrue:[joystickMwiTwo := joystickMwiTwo x @ 1023.].	(joystickMwiTwo y < -1024)	ifTrue:[joystickMwiTwo := joystickMwiTwo x @ -1024.].	modelData joystickMwiOne: joystickMwiOne;					joystickMwiTwo: joystickMwiTwo.	"Transcript cr; show: 'joystickMwiOne: ', joystickMwiOne asString, ' joystickMwiTwo: ', joystickMwiTwo asString."! !!OPGuiMasterControl methodsFor: 'artificialInput' stamp: 'CL 9/21/2009 11:30'!artificialInputTrack	"calculation of the y-axis movement"	((2 atRandom) = 1)	ifTrue:[(nonNetworkSpeed  < 21) ifTrue:[nonNetworkSpeed := nonNetworkSpeed + 1].]	ifFalse:[(nonNetworkSpeed > 0) ifTrue:[nonNetworkSpeed := nonNetworkSpeed - 1].].		nonNetworkY := nonNetworkY + (nonNetworkSpeed * modelData directSetSpeed).		"calculation of the x-axis movement - nonNetworkDirection acts like a pivot element"	((20 atRandom) = 5)	ifTrue:[nonNetworkDirection := nonNetworkDirection * -1].		"this should prevent being stuck in a corner"	((nonNetworkX < 797) & (nonNetworkX > 3))	ifFalse:[ nonNetworkDirection := nonNetworkDirection * -1. ].	((modelData directSetDirectionLeft) & (nonNetworkDirection < 0)) | ((modelData directSetDirectionRight) & (nonNetworkDirection > 0))	ifFalse:[ nonNetworkX := nonNetworkX + nonNetworkDirection. ].	((nonNetworkY - modelData currentCoordinateY) ~= 0)	ifTrue:[ modelData tailColor: (nonNetworkY - modelData currentCoordinateY); changed. ].	modelData currentCoordinateX: nonNetworkX;					currentCoordinateY: nonNetworkY;					speed: nonNetworkSpeed.	"Transcript cr; show: 'nonNetworkX: ', nonNetworkX asString, ' nonNetworkY: ', nonNetworkY asString, ' directSetDirectionLeft: ', modelData directSetDirectionLeft asString, ' directSetDirectionRight: ', modelData directSetDirectionRight asString."! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 8/18/2009 18:13'!actionSelectorAll: thisIsSomeBoolean	switchButtons keysAndValuesDo: 	[		:aKey :aValueWhichIsAnActualSwitchButton | 		aValueWhichIsAnActualSwitchButton setSwitchState: thisIsSomeBoolean.		guiElementState at: aKey put: thisIsSomeBoolean	].	self setJoystickbuttonState: thisIsSomeBoolean.	self applyChanges.! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 6/9/2009 16:25'!actionSelectorAuditiveHints: foo 	guiElementState at: 'OPAuditiveHints' put: foo.	self applyChanges.! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 6/9/2009 16:25'!actionSelectorBackground: foo	guiElementState at: 'OPBackground' put: foo.	self applyChanges.! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 6/9/2009 16:25'!actionSelectorBarOne: foo	guiElementState at: 'BarneyOne' put: foo.	self applyChanges.! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 6/9/2009 16:25'!actionSelectorBarThree: foo	guiElementState at: 'BarneyThree' put: foo.	self applyChanges.! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 6/9/2009 16:24'!actionSelectorBarTwo: foo	guiElementState at: 'BarneyTwo' put: foo.	self applyChanges.! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 6/5/2009 14:59'!actionSelectorClose	(self confirm: '   Sicher?   '                                        )	ifTrue:[self delete].	! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 6/9/2009 16:24'!actionSelectorDirectionButtons: foo 	guiElementState at: 'OPDirectionButtons' put: foo.	self applyChanges.! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 6/9/2009 16:24'!actionSelectorHalo: someBool	halo := someBool .	self applyChanges.! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 6/4/2009 17:51'!actionSelectorHideUnhide	(self visible)	ifTrue:[self visible: false].! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 6/9/2009 16:24'!actionSelectorInputDistribution: foo 	guiElementState at: 'OPInputDistribution' put: foo.	self applyChanges.! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 8/18/2009 17:49'!actionSelectorJoystickOutput: foo 	"guiElementState at: 'OPJoystickOutput' put: foo.	self applyChanges."	(GuiElement includesKey: 'OPTrackPreview')	ifTrue:[(GuiElement at: 'OPTrackPreview') joysticksVisibility: foo.].! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 6/9/2009 16:24'!actionSelectorMentalWorkload: foo 	guiElementState at: 'OPMentalWorkload' put: foo.	self applyChanges.! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 9/18/2009 09:20'!actionSelectorMouseCursor: bool	(bool)	ifTrue:[ ActiveHand showTemporaryCursor: (Form fromFileNamed: 'gfx\icons\pointing_finger_25x29.png') hotSpotOffset: 10 @ 1. ]	ifFalse:[ ActiveHand showTemporaryCursor: nil. ].! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 10/1/2009 15:20'!actionSelectorNetwork: someBool	(someBool)	ifTrue:[		network createSockets. 		simulationButton color: Color gray;								lock.	]	ifFalse:[		network closeSockets. 		simulationButton color: (Color red mixed: 0.5 with: Color white);								unlock.	].! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 9/16/2009 16:36'!actionSelectorSimulation: bool	modelData simulation: bool.	(bool)	ifTrue:[		networkButton color: Color gray;							lock.		self artificialInputInitialize.		modelData status: 'buildTrack'.	]	ifFalse:[		modelData resetForNewStep.		networkButton color: (Color red mixed: 0.5 with: Color white);								unlock.		modelData status: ''.			].	modelData stepNr: 1; changed.! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 9/30/2009 14:13'!actionSelectorSituationAwareness: foo	guiElementState at: 'OPSituationAwareness' put: foo.	self applyChanges.! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 6/9/2009 16:24'!actionSelectorSpeed: foo 	guiElementState at: 'OPSpeed' put: foo.	self applyChanges.! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 6/9/2009 16:23'!actionSelectorSticky: swarley	sticky := swarley .	self applyChanges.	! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 6/9/2009 16:23'!actionSelectorSystemStatus: foo 	guiElementState at: 'OPSystemStatus' put: foo.	self applyChanges.! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 8/18/2009 18:11'!actionSelectorTrackPreview: foo 	self setJoystickbuttonState: foo.	guiElementState at: 'OPTrackPreview' put: foo.	self applyChanges.! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 6/10/2009 13:26'!actionSelectorVideo: foo 	guiElementState at: 'OPVideo' put: foo.	self applyChanges.! !!OPGuiMasterControl methodsFor: 'actionSelector' stamp: 'CL 6/9/2009 16:23'!actionSelectorVisualHints: foo 	guiElementState at: 'OPVisualHints' put: foo.	self applyChanges.! !!OPGuiMasterControl methodsFor: 'as yet unclassified' stamp: 'CL 9/30/2009 14:21'!applyChanges	guiElementState		keysAndValuesDo:[:aKey :aValue | "keys are something like OPSpeed or OPAuditiveHints, the values are booleans which indicate if an element should be shown"		(aValue asString = 'true')		ifTrue: 		[			GuiElement at: aKey "this dictionary contains the visible gui elements, if one is'nt in it - it will be added via absent clause'"				ifAbsent:[ 								(aKey = 'OPBackground')			ifTrue:[GuiElement at: aKey put: (OPBackground new)].								(aKey = 'BarneyOne') 				ifTrue:[GuiElement at: aKey put: (OPBar new extent: 5@1580; openInWorld)].								(aKey = 'BarneyTwo') 				ifTrue:[GuiElement at: aKey put: (OPBar new extent: 10@1580; openInWorld)].								(aKey = 'BarneyThree')				ifTrue:[GuiElement at: aKey put: (OPBar new extent: 5@1295; openInWorld)].								(aKey = 'OPSpeed')					ifTrue:[GuiElement at: aKey put: (OPSpeed new )].								(aKey = 'OPVisualHints')			ifTrue:[GuiElement at: aKey put: (OPVisualHints new )].								(aKey = 'OPInputDistribution')		ifTrue:[GuiElement at: aKey put: (OPInputDistribution new )].								(aKey = 'OPDirectionButtons')		ifTrue:[GuiElement at: aKey put: (OPDirectionButtons new )].								(aKey = 'OPAuditiveHints')			ifTrue:[GuiElement at: aKey put: (OPAuditiveHints new )].								(aKey = 'OPTrackPreview')			ifTrue:[GuiElement at: aKey put: (OPTrackPreview new )].								(aKey = 'OPSystemStatus')			ifTrue:[GuiElement at: aKey put: (OPSystemStatus new )].								(aKey = 'OPMentalWorkload')		ifTrue:[GuiElement at: aKey put: (OPMentalWorkload new )].								(aKey = 'OPVideo'			)		ifTrue:[GuiElement at: aKey put: (OPVideo new )].								(aKey = 'OPSituationAwareness')	ifTrue:[GuiElement at: aKey put: (OPSituationAwareness new )].							].			(GuiElement at: aKey) position: (self myPosition: aKey)."positioning the gui element and getting it to the front"			"sticky"			(sticky)			ifTrue:[(GuiElement at: aKey) beSticky.]			ifFalse:[ (aKey ~= 'OPBackground') ifTrue:[(GuiElement at: aKey) beUnsticky]].			"halo"			(GuiElement at: aKey) haloEnabled: halo.		]		ifFalse: 		[(GuiElement includesKey: aKey) "when the switchbutton is set to red (false), the element is removed"			ifTrue: [(GuiElement removeKey: aKey) delete]]	].	"arranging the elements, so that all is on top of the background"	GuiElement do: 	[		:morph | 		(morph isKindOf: OPWindow) ifTrue:[ morph comeToFront].		(morph isKindOf: OPBar)		ifTrue:[ morph comeToFront].		(morph isKindOf: OPSituationAwareness)	ifTrue:[ morph comeToFront].	].	self position: selfPosition; comeToFront.! !!OPGuiMasterControl methodsFor: 'as yet unclassified' stamp: 'CL 9/25/2009 14:09'!delete		super delete.		(guiElementState at: 'OPTrackPreview') asString = 'true' 	ifTrue: [(GuiElement at: 'OPTrackPreview') stopStepping .].	GuiElement do: [:a | a delete].	(modelData network)	ifTrue:[ network closeSockets. ].	"fooBar do: [:token | Transcript cr; show: token. ]."	OPModelData reset.! !!OPGuiMasterControl methodsFor: 'as yet unclassified' stamp: 'CL 8/18/2009 18:12'!setJoystickbuttonState: foo	(foo)	ifTrue:[joystickOutput lock: false; setSwitchState: false.]	ifFalse:[		joystickOutput lock: true;							setSwitchState: foo;							color: Color gray.		(GuiElement at: 'OPTrackPreview') joysticksVisibility: foo.	].! !!OPGuiMasterControl methodsFor: 'events-processing' stamp: 'CL 9/10/2009 19:18'!clicked! !!OPGuiMasterControl methodsFor: 'events-processing' stamp: 'CL 10/1/2009 16:42'!eventHandlerKeyStroke: event	| foo |	foo := event keyCharacter asString.	(foo = ' ')	ifTrue:[ self visible: true. ].	(foo = 'h') | (foo = 'H')	ifTrue:[		modelData waitForItShowStatus: false.		(waitForIt visible)		ifTrue:[ waitForIt hide. ]		ifFalse:[ waitForIt comeToFront; show. ].	].	! !!OPGuiMasterControl methodsFor: 'initialization' stamp: 'CL 9/30/2009 14:06'!createMaincontainer	| firstButtonColumn secondButtonColumn buttonColumnContainer bottomButtonRow allButton mainContainer thirdButtonColumn closeButton hideButton haloButton mouseCursorButton |	"alignmentmorph creation"	mainContainer 				:= self createAlignmentMorph: 780@400.	firstButtonColumn 		:= self createAlignmentMorph: 260@230.	secondButtonColumn 		:= self createAlignmentMorph: 260@230.	thirdButtonColumn 		:= self createAlignmentMorph: 260@230.	buttonColumnContainer 	:= (self createAlignmentMorph: 780@230) listDirection: #leftToRight.	bottomButtonRow 			:= (self createAlignmentMorph: 780@100) listDirection: #leftToRight; listCentering: #center.		"the 'normal' buttons"	allButton 			:= (self createSwitchButton: 'Alle' withActionSelector: #actionSelectorAll:) extent: 100@100.	"stickyButton 		:= (self createSwitchButton: 'Sticky' withActionSelector: #actionSelectorSticky:) extent: 100@100."	closeButton 		:= self createSimpleButton: 'Schließen' withActionSelector: #actionSelectorClose .	networkButton  	:= (self createSwitchButton: 'Netzwerk' withActionSelector: #actionSelectorNetwork:) extent: 100@100.	haloButton			:= (self createSwitchButton: 'Halo''s' withActionSelector: #actionSelectorHalo:) extent: 100@100; setSwitchState: true.	hideButton 			:= self createSimpleButton: 'Hide' withActionSelector: #actionSelectorHideUnhide.	mouseCursorButton := (self createSwitchButton: 'Mouse Cursor' withActionSelector: #actionSelectorMouseCursor:) extent: 100@100.	simulationButton 	:= (self createSwitchButton: 'Simulation' withActionSelector: #actionSelectorSimulation:) extent: 100@100.	joystickOutput 	:= (self createSwitchButton: ('Joystick') withActionSelector: #actionSelectorJoystickOutput:) 								lock: true; 								color: Color gray.	"throwing it all together"	firstButtonColumn		addMorphBack: (switchButtons at: 'OPSystemStatus'); addMorphBack: (self createAlignmentMorph: 10@5);		addMorphBack: (switchButtons at: 'OPMentalWorkload'); addMorphBack: (self createAlignmentMorph: 10@5);		addMorphBack: (switchButtons at: 'OPVideo'); addMorphBack: (self createAlignmentMorph: 10@5);		addMorphBack: (switchButtons at: 'OPTrackPreview'); addMorphBack: (self createAlignmentMorph: 10@5);		addMorphBack: joystickOutput.	secondButtonColumn		addMorphBack: (switchButtons at: 'OPAuditiveHints'); addMorphBack: (self createAlignmentMorph: 10@5);		addMorphBack: (switchButtons at: 'OPVisualHints'); addMorphBack: (self createAlignmentMorph: 10@5);		addMorphBack: (switchButtons at: 'OPSpeed'); addMorphBack: (self createAlignmentMorph: 10@5);		addMorphBack: (switchButtons at: 'OPDirectionButtons'); addMorphBack: (self createAlignmentMorph: 10@5);		addMorphBack: (switchButtons at: 'OPInputDistribution').					thirdButtonColumn		addMorphBack: (switchButtons at: 'OPBackground'); addMorphBack: (self createAlignmentMorph: 10@5);		addMorphBack: (switchButtons at: 'BarneyOne'); addMorphBack: (self createAlignmentMorph: 10@5);		addMorphBack: (switchButtons at: 'BarneyTwo'); addMorphBack: (self createAlignmentMorph: 10@5);		addMorphBack: (switchButtons at: 'BarneyThree'); addMorphBack: (self createAlignmentMorph: 10@5);		addMorphBack: (switchButtons at: 'OPSituationAwareness').	buttonColumnContainer		addMorphBack: firstButtonColumn;		addMorphBack: secondButtonColumn;		addMorphBack: thirdButtonColumn.	bottomButtonRow 		addMorphBack: allButton;		addMorphBack: (self createAlignmentMorph: 5@10);		"addMorphBack: stickyButton;		addMorphBack: (self createAlignmentMorph: 5@10);"		addMorphBack: haloButton;		addMorphBack: (self createAlignmentMorph: 5@10);		addMorphBack: hideButton;		addMorphBack: (self createAlignmentMorph: 5@10);		addMorphBack: networkButton;		addMorphBack: (self createAlignmentMorph: 5@10);		addMorphBack: simulationButton;		addMorphBack: (self createAlignmentMorph: 5@10);		addMorphBack: mouseCursorButton;		addMorphBack: (self createAlignmentMorph: 5@10);		addMorphBack: closeButton.	mainContainer		addMorphBack: buttonColumnContainer; 		addMorphBack: (self createAlignmentMorph: 10@20);		addMorphBack: bottomButtonRow.	^mainContainer.! !!OPGuiMasterControl methodsFor: 'initialization' stamp: 'CL 10/1/2009 16:40'!initialize	super initialize.	"OPModelData reset."	modelData := OPModelData getInstance .	modelData initializeValues.	fooBar := OrderedCollection new.	waitForItContent := TextMorph new.	network := OPNetwork new.	waitForIt := (AlignmentMorph new) 							extent: 2560 @ 1600; 							color: ((Color gray mixed: 0.14 with: Color white) alpha: 0.5);							listDirection: #topToBottom;							wrapCentering: #center;							listCentering: #center;							borderWidth: 0;							borderColor: Color black;							openInWorld;							hide;							beSticky;							addMorph: waitForItContent.	waitForIt position: ((2560 - (waitForIt width)) / 2.0) @ ((1600 - (waitForIt height)) / 2.0). "this centers the morph on the screen, in dependence of the extent"	sticky := false.	halo := true.	self initializeArtificialInput.	"initializing the network"	OPNetwork initialize.	"storing own position"	selfPosition := 1285 @ 10.		switchButtons := Dictionary new.	guiElementState := Dictionary new.	self initializeDictionarys. "initializing of switchButtons & guiElementState"	GuiElement := Dictionary new. "this on will be filled with entrys based on button events"	self addMorphBack: (self createMaincontainer );			setWindwoSize: 800 @ 470;			label: 'GUI Elemente';			position: selfPosition;			openInWorld.	World on: #keyStroke send: #eventHandlerKeyStroke: to: self.	self startStepping.! !!OPGuiMasterControl methodsFor: 'initialization' stamp: 'CL 9/4/2009 10:29'!initializeArtificialInput	joystickMwiOneX := 1.	joystickMwiOneY := 1.	joystickMwiTwoX := -1.	joystickMwiTwoY := -1.	joystickMwiOne := 0 @ 0.	joystickMwiTwo := 0 @ 0.	nonNetworkY := 0.	nonNetworkDirection := 5.	nonNetworkSpeed := 0.	nonNetworkX := 402.! !!OPGuiMasterControl methodsFor: 'initialization' stamp: 'CL 9/30/2009 14:13'!initializeDictionarys		"dictionary for the visible state of the elements"	guiElementState at: 'OPVisualHints' put: 'false'.	guiElementState at: 'OPAuditiveHints' put: 'false'.	guiElementState at: 'OPDirectionButtons' put: 'false'.	guiElementState at: 'OPSpeed' put: 'false'.	guiElementState at: 'OPInputDistribution' put: 'false'.	guiElementState at: 'OPTrackPreview' put: 'false'.	guiElementState at: 'OPSystemStatus' put: 'false'.	guiElementState at: 'OPMentalWorkload' put: 'false'. 	guiElementState at: 'BarneyOne' put: 'false'.	guiElementState at: 'BarneyTwo' put: 'false'.	guiElementState at: 'BarneyThree' put: 'false'.	guiElementState at: 'OPBackground' put: 'false'.	guiElementState at: 'OPVideo' put: 'false'.	guiElementState at: 'OPSituationAwareness' put: 'false'.	"switchbuttons - note that the SAME keys as for dictionary 'guiElementState' are used"	switchButtons at: 'OPVisualHints' 			put: (self createSwitchButton: (self myName: 'OPVisualHints') withActionSelector: #actionSelectorVisualHints:).	switchButtons at: 'OPAuditiveHints' 		put: (self createSwitchButton: (self myName: 'OPAuditiveHints') withActionSelector: #actionSelectorAuditiveHints:).	switchButtons at: 'OPDirectionButtons' 		put: (self createSwitchButton: (self myName: 'OPDirectionButtons') withActionSelector: #actionSelectorDirectionButtons:).	switchButtons at: 'OPSpeed' 					put: (self createSwitchButton: (self myName: 'OPSpeed') withActionSelector: #actionSelectorSpeed:).	switchButtons at: 'OPInputDistribution' 		put: (self createSwitchButton: (self myName: 'OPInputDistribution') withActionSelector: #actionSelectorInputDistribution:).	switchButtons at: 'OPTrackPreview' 			put: (self createSwitchButton: (self myName: 'OPTrackPreview') withActionSelector: #actionSelectorTrackPreview:).	switchButtons at: 'OPSystemStatus' 			put: (self createSwitchButton: (self myName: 'OPSystemStatus') withActionSelector: #actionSelectorSystemStatus:).	switchButtons at: 'OPMentalWorkload'		put: (self createSwitchButton: (self myName: 'OPMentalWorkload') withActionSelector: #actionSelectorMentalWorkload:).	switchButtons at: 'BarneyOne' 				put: (self createSwitchButton: 'Bar 1' withActionSelector: #actionSelectorBarOne:).	switchButtons at: 'BarneyTwo' 				put: (self createSwitchButton: 'Bar 2' withActionSelector: #actionSelectorBarTwo:).	switchButtons at: 'BarneyThree' 			put: (self createSwitchButton: 'Bar 3' withActionSelector: #actionSelectorBarThree:).	switchButtons at: 'OPBackground' 			put: (self createSwitchButton: 'Hintergrund' withActionSelector: #actionSelectorBackground:).	switchButtons at: 'OPSituationAwareness'	put: (self createSwitchButton: 'Situationsbewusstsein' withActionSelector: #actionSelectorSituationAwareness:).	switchButtons at: 'OPVideo' 					put: (self createSwitchButton: (self myName: 'OPVideo') withActionSelector: #actionSelectorVideo:).! !!OPGuiMasterControl methodsFor: 'stepping' stamp: 'CL 10/1/2009 15:04'!loadInstructionsForStep: startOrEnd forStep: step		| fileStream content font |		fileStream := (FileStream readOnlyFileNamed: 'instruction\', step,'_', startOrEnd, '.txt') converter: Latin1TextConverter new.	font := (TextFontReference toFont: (StrikeFont familyName: 'BitstreamVeraSans' size: 32)).	content := (fileStream contents) 					asText allBold; addAttribute: font.	fileStream close.	waitForItContent contents: content; centered.	! !!OPGuiMasterControl methodsFor: 'stepping' stamp: 'CL 9/18/2009 09:10'!setWaitForItContent: stepNr	| font screenMsgToOperator |	font := (TextFontReference toFont: (StrikeFont familyName: 'BitstreamVeraSans' size: 32)).	(stepNr = 1)	ifTrue:[		screenMsgToOperator := ('Person 1 steuert nun zum ersten Mal das Fahrobjekt. Bitte beobachten Sie Person 1 und das Fahrobjekt lediglich.', (Character cr) asString,										'Beginnen Sie damit, sobald der Start-Countdown beendet ist.', (Character cr) asString,										'Diese und die folgenden Beobachtungen dienen als Vorbereitung für Ihre Aufgabe, Person 1 und 2 beim Steuern des Fahrobjekts zu unterstützen.') asText allBold; addAttribute: font.	].	(stepNr = 2)	ifTrue:[		screenMsgToOperator := ('Person 1 steuert nun zum zweiten Mal das Fahrobjekt. Bitte beobachten Sie Person 1 und das Fahrobjekt lediglich.', (Character cr) asString,										'Beginnen Sie damit, sobald der Start-Countdown beendet ist.') asText allBold; addAttribute: font.	].	(stepNr = 3)	ifTrue:[		screenMsgToOperator := ('Person 2 steuert nun zum ersten Mal das Fahrobjekt. Bitte beobachten Sie Person 2 und das Fahrobjekt lediglich.', (Character cr) asString,										'Beginnen Sie damit, sobald der Start-Countdown beendet ist.') asText allBold; addAttribute: font.	].	(stepNr = 4)	ifTrue:[		screenMsgToOperator := ('Person 2 steuert nun zum zweiten Mal das Fahrobjekt. Bitte beobachten Sie Person 2 und das Fahrobjekt lediglich.', (Character cr) asString,										'Beginnen Sie damit, sobald der Start-Countdown beendet ist.') asText allBold; addAttribute: font.	].	(stepNr = 5)	ifTrue:[		screenMsgToOperator := ('Person 1 und 2 steuern nun zum ersten Mal gemeinsam das Fahrobjekt. Bitte beobachten Sie die Personen und das Fahrobjekt lediglich.', (Character cr) asString,										'Beginnen Sie damit, sobald der Start-Countdown beendet ist.', (Character cr) asString,										'Diese und die folgenden Beobachtungen dienen als Vorbereitung für Ihre Aufgabe, Person 1 und 2 beim Steuern des Fahrobjekts zu unterstützen.') asText allBold; addAttribute: font.	].	(stepNr = 6)	ifTrue:[		screenMsgToOperator := ('Person 1 und 2 steuern nun zum zweiten Mal gemeinsam das Fahrobjekt. Bitte beobachten Sie die Personen und das Fahrobjekt lediglich.', (Character cr) asString,										'Beginnen Sie damit, sobald der Start-Countdown beendet ist.') asText allBold; addAttribute: font.	].	(stepNr = 7)	ifTrue:[		screenMsgToOperator := ('Person 1 und 2 steuern nun zum dritten Mal gemeinsam das Fahrobjekt. Bitte beobachten Sie die Personen und das Fahrobjekt lediglich.', (Character cr) asString,										'Beginnen Sie damit, sobald der Start-Countdown beendet ist.') asText allBold; addAttribute: font.	].	(stepNr = 8)	ifTrue:[		screenMsgToOperator := ('Ab dem folgenden Versuchsdurchlauf müssen Sie die Personen 1 und 2 bei ihrer Aufgabe unterstützen.', (Character cr) asString,										'Bitte erinnern Sie sich an Ihr Training. Der Versuchsdurchlauf startet mit einem Countdown. Bitte warten Sie, bis der Start-Countdown beendet ist.', (Character cr) asString,										'Dann sind Sie gefordert, die Personen bei der Steuerung des Fahrobjekts so zu unterstützen, ', (Character cr) asString,										'dass maximale Genauigkeit bei maximaler Geschwindigkeit des Fahrobjekts realisierbar ist.') asText allBold; addAttribute: font.	].	(stepNr = 9)	ifTrue:[		screenMsgToOperator := ('Bitte beantworten Sie nun die Fragen an Ihrem Laptop und kehren danach an diesen Arbeitsplatz zurück.', (Character cr) asString,										'Achten Sie auf den Start-Countdown: sobald dieser beendet ist, müssen Sie die Personen 1 und 2 wieder dabei unterstützen,', (Character cr) asString,										'maximale Genauigkeit bei maximaler Geschwindigkeit des Fahrobjekts zu erreichen.') asText allBold; addAttribute: font.	].	(stepNr = 10)	ifTrue:[		screenMsgToOperator := ('Bitte beantworten Sie nun die Fragen an Ihrem Laptop und kehren danach an diesen Arbeitsplatz zurück.', (Character cr) asString,										'Achten Sie auf den Start-Countdown: sobald dieser beendet ist, müssen Sie die Personen 1 und 2 wieder dabei unterstützen,', (Character cr) asString,										'maximale Genauigkeit bei maximaler Geschwindigkeit des Fahrobjekts zu erreichen.') asText allBold; addAttribute: font.	].	(stepNr = 11)	ifTrue:[		screenMsgToOperator := ('Bitte beantworten Sie nun die Fragen an Ihrem Laptop und kehren danach an diesen Arbeitsplatz zurück.', (Character cr) asString,										'Achten Sie auf den Start-Countdown: sobald dieser beendet ist, müssen Sie die Personen 1 und 2 wieder dabei unterstützen,', (Character cr) asString,										'maximale Genauigkeit bei maximaler Geschwindigkeit des Fahrobjekts zu erreichen.') asText allBold; addAttribute: font.	].	(stepNr = 12)	ifTrue:[		screenMsgToOperator := ('Bitte beantworten Sie nun die Fragen an Ihrem Laptop und kehren danach an diesen Arbeitsplatz zurück. ') asText allBold; addAttribute: font.	].	waitForItContent contents: screenMsgToOperator; centered.! !!OPGuiMasterControl methodsFor: 'stepping' stamp: 'CL 9/8/2009 20:28'!showCountdown		| countdownGraphic |	0 to: 3 do: 	[			:i | 				countdownGraphic := ((Form fromFileNamed: 'gfx\icons\Countdown' , (3 - i) asString , '.gif') asMorph) 										openInWorld; 										top: 400; 										left: 1180; 										lock.		countdownGraphic refreshWorld .		(Delay forMilliseconds: 800) wait.				countdownGraphic delete.	].! !!OPGuiMasterControl methodsFor: 'stepping' stamp: 'CL 10/1/2009 15:22'!statusBuildTrack	| forks arrayWithTwoEntrys |	forks := OrderedCollection new.	arrayWithTwoEntrys := Array new:2.	"emptying the sockets from leftovers"	(modelData network)	ifTrue:[ network resetForNewStep. ].	"reseting values"	modelData resetForNewStep.	(modelData network)	ifTrue:[ 		modelData trackName: (network receiveTrackData).		[modelData trackName isNil]		whileTrue:[ modelData trackName: (network receiveTrackData). ]. 		modelData distributionMwiOne: (network receiveInputDistributionMWI1).		[modelData distributionMwiOne isNil]		whileTrue:[ modelData distributionMwiOne: (network receiveInputDistributionMWI1) ].		modelData stepNr: (network receiveStepNr).		[modelData stepNr isNil]		whileTrue:[ modelData stepNr: (network receiveStepNr). ].						modelData obstacleConfig: (network receiveObstacleConfig);							status: 'waitingBeforeTracking'.		((modelData trackName = 'hauptabschnitt1') | (modelData trackName = 'hauptabschnitt2'))		ifTrue:[	"1 - ER; 2 - RL"			forks add: ((arrayWithTwoEntrys at: 1 put: 6541; at: 2 put: 1; yourself) copy);					add: ((arrayWithTwoEntrys at: 1 put: 8721; at: 2 put: 2; yourself) copy);					add: ((arrayWithTwoEntrys at: 1 put: 9721; at: 2 put: 2;  yourself) copy).		].		(modelData trackName = 'hauptabschnitt_lang')		ifTrue:[			forks add: ((arrayWithTwoEntrys at: 1 put: 6534; at: 2 put: 2; yourself) copy);					add: ((arrayWithTwoEntrys at: 1 put: 8734; at: 2 put: 1; yourself) copy);					add: ((arrayWithTwoEntrys at: 1 put: 9734; at: 2 put: 1;  yourself) copy);					add: ((arrayWithTwoEntrys at: 1 put: 21114; at: 2 put: 1;  yourself) copy);					add: ((arrayWithTwoEntrys at: 1 put: 23304; at: 2 put: 2;  yourself) copy);					add: ((arrayWithTwoEntrys at: 1 put: 24304; at: 2 put: 2;  yourself) copy);					add: ((arrayWithTwoEntrys at: 1 put: 35694; at: 2 put: 2;  yourself) copy);					add: ((arrayWithTwoEntrys at: 1 put: 37894; at: 2 put: 1;  yourself) copy);					add: ((arrayWithTwoEntrys at: 1 put: 38874; at: 2 put: 1;  yourself) copy).		].		modelData forks: forks.	].	(modelData simulation)	ifTrue:[ self initializeArtificialInput. modelData status: 'driving'. ].	(GuiElement includesKey: 'OPDirectionButtons')	ifTrue:[ (GuiElement at: 'OPDirectionButtons') resetForNewStep. ].	(GuiElement includesKey: 'OPInputDistribution')	ifTrue:[ (GuiElement at: 'OPInputDistribution') resetForNewStep. ].	(GuiElement includesKey: 'OPSpeed')	ifTrue:[ (GuiElement at: 'OPSpeed') resetForNewStep. ].	(GuiElement includesKey: 'OPSystemStatus')	ifTrue:[ (GuiElement at: 'OPSystemStatus') setStepNr: modelData stepNr. ].	(GuiElement includesKey: 'OPAuditiveHints')	ifTrue:[ (GuiElement at: 'OPAuditiveHints') resetForNewStep. ].	(GuiElement includesKey: 'OPTrackPreview')	ifTrue:[ 		(GuiElement at: 'OPTrackPreview') 			resetForNewStep;			prepareTrack: (modelData trackName) and: (modelData obstacleConfig). 	].		! !!OPGuiMasterControl methodsFor: 'stepping' stamp: 'CL 10/1/2009 16:49'!statusCountdown	(Monitor new) critical: [self showCountdown .].	modelData status: 'driving'.	(waitForIt visible) 	ifTrue:[ waitForIt hide. ].	modelData waitForItShowStatus: true.! !!OPGuiMasterControl methodsFor: 'stepping' stamp: 'CL 10/1/2009 11:22'!statusDriving	| currentCoordinateY currentCoordinateX dynamicObstacleX joystickData |	(modelData simulation)	ifTrue:[				self artificialInputJoystick;				artificialInputTrack.	].	(modelData network)	ifTrue:[ "get data from network" 		currentCoordinateY 	:= (network receiveSpeedData).		currentCoordinateX 	:= (network receiveCoordData).		dynamicObstacleX 		:= (network receiveDynamicObstacleData).		modelData collision: (network receiveCollisionData).		(currentCoordinateY ~= 0)		ifTrue:[ modelData tailColor: (currentCoordinateY - modelData currentCoordinateY). ].		"Transcript cr; show: 'modelData tailColor: ', modelData tailColor asString."		(currentCoordinateY ~= 0)		ifTrue:[ modelData currentCoordinateY: currentCoordinateY. ].		(currentCoordinateX ~= 0)		ifTrue:[ modelData currentCoordinateX: currentCoordinateX. ].		(dynamicObstacleX ~= 0)		ifTrue:[ modelData dynamicObstacleX: dynamicObstacleX. ].		joystickData := network receiveJoystickData.		(joystickData size > 0)		ifTrue:[			joystickData := joystickData findTokens: ';'.						modelData joystickMwiOne: (Point x: ((joystickData at: 1) asInteger) y: ((joystickData at: 2) asInteger)).			modelData joystickMwiTwo: (Point x: ((joystickData at: 3) asInteger) y: ((joystickData at: 4) asInteger)).		].		modelData forks do: [:fork |					((fork at: 1) between: (modelData currentCoordinateY * modelData scaleFactor) and: ((modelData currentCoordinateY * modelData scaleFactor) + 1505)) | 			(((fork at: 1) + 300) between: (modelData currentCoordinateY * modelData scaleFactor) and: ((modelData currentCoordinateY * modelData scaleFactor) + 1505))			ifTrue:[ modelData trackEdit: modelData trackEdit, (1000 + (fork at: 2)) asString, ';'. ].		].	].		(GuiElement includesKey: 'OPTrackPreview')	ifTrue:[ 		(GuiElement at: 'OPTrackPreview') 				processLeftJoystick: 	(modelData joystickMwiOne); 				processRightJoystick:	(modelData joystickMwiTwo);				moveTrackingObject: 		(modelData currentCoordinateX);				moveTail: 					(modelData currentCoordinateY) withColor: (modelData tailColor);				moveTrack: 					(modelData currentCoordinateY);				moveObstacles: 			(modelData currentCoordinateY).	].	(GuiElement includesKey: 'OPSituationAwareness')	ifTrue:[ (GuiElement at: 'OPSituationAwareness') processSituationalAwareness . ].	(modelData network)	ifTrue:[ "send data over the network"		network sendBlindClicksData; 					sendButtonActionData;					sendTrackEditData.	].! !!OPGuiMasterControl methodsFor: 'stepping' stamp: 'CL 10/1/2009 16:46'!statusWaitForSam	(waitForIt visible)	ifFalse:[ 		(modelData waitForItShowStatus)		ifTrue:[	waitForIt show; comeToFront. ].	]. 	! !!OPGuiMasterControl methodsFor: 'stepping' stamp: 'CL 10/1/2009 15:12'!step	| statusData |	"timeStamp := Time millisecondClockValue ."	(modelData network)	ifTrue:[		statusData := network receiveStatusData.		(statusData isNil)		ifFalse:[ modelData status: statusData. ].	].	(modelData status = 'countdown')	ifTrue:[ self statusCountdown. ].	(modelData status = 'waitingBeforeTracking')	ifTrue:[ 		modelData status: 'waiting'.		self loadInstructionsForStep: 'start' forStep: (modelData stepNr) asString. 	].	(modelData status = 'waitingAfterTracking')	ifTrue:[		modelData status: 'waiting'.		network emptyStreams .		self loadInstructionsForStep: 'end' forStep: (modelData stepNr) asString.	].	(modelData status = 'waiting')	ifTrue:[ self statusWaitForSam. ].	(modelData status = 'buildTrack')	ifTrue:[ self statusBuildTrack. ].	(modelData status = 'driving')	ifTrue:[ 		self statusDriving. 		(waitForIt visible) 		ifTrue:[ waitForIt hide. ].	].	"(((Time millisecondClockValue) - timeStamp) > 4)	ifTrue:[	fooBar add: ((Time millisecondClockValue) - timeStamp) asString, ' ms - modelData currentCoordinateY: ', (modelData currentCoordinateY) asString. ]."! !!OPGuiMasterControl methodsFor: 'stepping' stamp: 'CL 9/25/2009 14:41'!stepTime	^18! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OPGuiMasterControl class	instanceVariableNames: 'mwi1Share denyRight marshmellow meMyselfAndIrene denyLeft speed mwi2Share trackPreviewHint'!!OPGuiMasterControl class methodsFor: 'as yet unclassified' stamp: 'CL 4/24/2009 14:46'!buttonSize: newSize	GuiElement do: [:guiElement| guiElement buttonFontSize: newSize]! !!OPGuiMasterControl class methodsFor: 'as yet unclassified' stamp: 'CL 4/24/2009 11:55'!windowColor: newWindowColor	GuiElement do: [:guiElement| guiElement color: newWindowColor]! !OPWindow subclass: #OPInputDistribution	instanceVariableNames: 'clickIncrement labelMin labelMax mwiOneButton mwiTwoButton distributionMwiOne leftUserPercentage rightUserPercentage formForButton1 formForButton2'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPInputDistribution methodsFor: 'as yet unclassified' stamp: 'CL 9/16/2009 11:55'!actionSelectorMwiOne	self updateMwiButtons: 1.	self sendDataToSam: 1000 + distributionMwiOne.! !!OPInputDistribution methodsFor: 'as yet unclassified' stamp: 'CL 9/16/2009 11:55'!actionSelectorMwiTwo	self updateMwiButtons: 2.	self sendDataToSam: 1000 + distributionMwiOne.! !!OPInputDistribution methodsFor: 'as yet unclassified' stamp: 'CL 9/16/2009 11:54'!actionSelectorReset	distributionMwiOne := 50.0 - clickIncrement.	self updateMwiButtons: 1.		self sendDataToSam: 999.! !!OPInputDistribution methodsFor: 'as yet unclassified' stamp: 'nn 8/11/2009 20:10'!delete	super delete.	modelData distributionMwiOne: 0.5; changed.! !!OPInputDistribution methodsFor: 'as yet unclassified' stamp: 'CL 9/10/2009 19:22'!initialize	| mainContainer userLabelContainer buttonContainer mwiOneContainer mwiTwoContainer leftUserLabelContainer rightUserLabelContainer leftUserLabel rightUserLabel resetButton resetContainer |	super initialize.	clickIncrement := 5. "SHOULD be a number which satisfys: 100 mod clickIncrement = 0"	labelMax := 90.	labelMin := 3.	distributionMwiOne := 50.	formForButton1 := Form fromFileNamed: 'gfx\icons\Bild_MWB_dunkel_50x50.png'.	formForButton2 := Form fromFileNamed: 'gfx\icons\Bild_MWB_hell_50x50.png'.	buttonContainer := (self createAlignmentMorph: 380 @ 100) listDirection: #leftToRight.	mwiOneContainer := self createAlignmentMorph: 100 @ 100.	resetContainer := self createAlignmentMorph: 100 @ 50.	mwiTwoContainer := self createAlignmentMorph:  100 @ 100.	userLabelContainer := (self createAlignmentMorph:  380 @ 40) listDirection: #leftToRight.	mwiOneButton := self createIconicButton: 'gfx\icons\Bild_MWB_dunkel_50x50.png' withActionSelector: #actionSelectorMwiOne .	resetButton := (self createSimpleButton: 'Reset' withActionSelector: #actionSelectorReset) extent: 100 @ 50.	mwiTwoButton := self createIconicButton: 'gfx\icons\Bild_MWB_hell_50x50.png' withActionSelector: #actionSelectorMwiTwo .	leftUserLabelContainer := (self createAlignmentMorph: 100 @ 40).	rightUserLabelContainer := (self createAlignmentMorph: 100 @ 40).	leftUserLabel := self createStringMorph: 'Person 1'.	leftUserPercentage := self createStringMorph: '50 %'.	rightUserLabel := self createStringMorph: 'Person 2'.	rightUserPercentage := self createStringMorph: '50 %'.	leftUserLabelContainer addMorphBack: leftUserLabel; addMorphBack: leftUserPercentage.	rightUserLabelContainer addMorphBack: rightUserLabel; addMorphBack: rightUserPercentage.	userLabelContainer addMorphBack: (self createAlignmentMorph: 40 @ 10);							addMorphBack: leftUserLabelContainer; 							addMorphBack: (self createAlignmentMorph: 100 @ 10);							addMorphBack: rightUserLabelContainer.	mwiOneContainer addMorphBack: mwiOneButton.	resetContainer addMorphBack: resetButton.	mwiTwoContainer addMorphBack: mwiTwoButton.	buttonContainer addMorphBack: (self createAlignmentMorph: 40 @ 10);						addMorphBack: mwiOneContainer; 						addMorphBack: resetContainer; 						addMorphBack: mwiTwoContainer.	mainContainer := (self createAlignmentMorph: (390 @ 210))								addMorphBack: (self createAlignmentMorph: (390 @ 30));								addMorphBack: buttonContainer;								addMorphBack: (self createAlignmentMorph: (390 @ 15));								addMorphBack: userLabelContainer.	"self actionSelectorReset ."	self resetForNewStep.	self 	setWindwoSize: 400@295; 				addMorphBack: mainContainer;			label: (self myName: 'OPInputDistribution'); 			position: (self myPosition: 'OPDirectionButtons');			color: (self groupColorDarkest );			openInWorld.	! !!OPInputDistribution methodsFor: 'as yet unclassified' stamp: 'CL 9/4/2009 09:26'!resetForNewStep	distributionMwiOne := ((modelData distributionMwiOne) * 100) - clickIncrement . 	self updateMwiButtons: 1.! !!OPInputDistribution methodsFor: 'as yet unclassified' stamp: 'CL 9/10/2009 20:30'!sendDataToSam: data	(modelData network)	ifTrue:[ modelData buttonAction: modelData buttonAction, (data asString, ';'); changed. ].! !!OPInputDistribution methodsFor: 'as yet unclassified' stamp: 'CL 9/21/2009 11:29'!updateMwiButtons: drWho| label1 label2 distributionMwiTwo |(drWho = 1) & ((distributionMwiOne + clickIncrement) <= 100) ifTrue:[ "Button 1 was clicked" distributionMwiOne := distributionMwiOne + clickIncrement.].(drWho = 2) & ((distributionMwiOne - clickIncrement) >= 0)ifTrue:[ "Button 2 was clicked" distributionMwiOne := distributionMwiOne - clickIncrement. ]. distributionMwiTwo := 100 - distributionMwiOne.leftUserPercentage contents: ((distributionMwiOne) asInteger) asString, ' %'.rightUserPercentage contents: ((distributionMwiTwo) asInteger) asString, ' %'."calculating the new x,y values for the extent of the label for both buttons"label1 := labelMin + ((labelMax - labelMin) * distributionMwiOne/100).label2 := labelMin + ((labelMax - labelMin) * distributionMwiTwo/100).mwiOneButton labelGraphic: ((formForButton1 scaledToSize: label1@label1) replaceColor: Color white withColor: Color transparent); extent: 100@100.mwiTwoButton labelGraphic: ((formForButton2 scaledToSize: label2@label2) replaceColor: Color white withColor: Color transparent); extent: 100@100.modelData distributionMwiOne: (distributionMwiOne / 100.0).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OPInputDistribution class	instanceVariableNames: 'mwi1Share mwi2Share'!OPWindow subclass: #OPMentalWorkload	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPMentalWorkload methodsFor: 'as yet unclassified' stamp: 'CL 9/10/2009 19:22'!initialize	| mainContainer leftyContainer rightyContainer leftForm rightForm formContainer stringContainer stringContainerLeft stringContainerRight subTitleContainer redFillContainerLeft redFillLeft redFillContainerRight redFillRight |	super initialize.	"as usual this on will hold everything beneath the titlebar"	mainContainer := (self createAlignmentMorph: 380 @ 250) listDirection: #bottomToTop.	"dealing with the forms"	formContainer := (self createAlignmentMorph: 380 @ 150) listDirection: #leftToRight.	leftForm := (Form fromFileNamed: 'gfx\icons\Bild_MWB_dunkel_v3_100x100.png') 							replaceColor: Color white withColor: Color transparent.	redFillContainerLeft := (RectangleMorph new)									color: Color transparent;									borderWidth: 0;									extent: 99 @ 99.	redFillLeft := (RectangleMorph new)									color: Color transparent;									borderWidth: 0;									extent: 99 @ 42;									left: redFillContainerLeft left;									bottom: redFillContainerLeft bottom;									clipSubmorphs: true;					addMorphBack: ((EllipseMorph new) 						color: ((Color red) alpha: 0.5);						borderWidth: 0;						extent: 99 @ 99;						left: redFillContainerLeft left;						bottom: redFillContainerLeft bottom).	redFillContainerLeft addMorph: redFillLeft;							addMorphBack: (SketchMorph withForm: leftForm).	leftyContainer := (self createAlignmentMorph: 190 @ 150)								listCentering: #center;								addMorphBack: redFillContainerLeft.	rightForm := (Form fromFileNamed: 'gfx\icons\Bild_MWB_hell_v2_100x100.png') 							replaceColor: Color white withColor: Color transparent.	redFillContainerRight := (RectangleMorph new)									color: Color transparent;									borderWidth: 0;									"extent: 139 @ 139."									extent: 99 @ 99.	redFillRight := (RectangleMorph new)									color: Color transparent;									borderWidth: 0;									extent: 99 @ 92;									left: redFillContainerRight left;									bottom: redFillContainerRight bottom;									clipSubmorphs: true;					addMorphBack: ((EllipseMorph new) 						color: ((Color red) alpha: 0.5);						borderWidth: 0;"						extent: 139 @ 139;"						extent: 99 @ 99;						left: redFillContainerRight left;						bottom: redFillContainerRight bottom).	redFillContainerRight addMorph: redFillRight;							addMorphBack: (SketchMorph withForm: rightForm).	rightyContainer := (self createAlignmentMorph: 190 @ 150)								listCentering: #center;								addMorph: redFillContainerRight.	"container for the graphic labeling"	stringContainer := (self createAlignmentMorph: 380 @ 80) listDirection: #leftToRight.	stringContainerLeft := (self createAlignmentMorph: 190 @ 50)								listCentering: #center;								addMorph: (self createStringMorph: '42 %');								addMorph: (self createAlignmentMorph: 190 @ 20);								addMorph: (self createStringMorph: 'Person 1');								addMorph: (self createAlignmentMorph: 190 @ 20).	stringContainerRight := (self createAlignmentMorph: 190 @ 50)								listCentering: #center;								addMorph: (self createStringMorph: '92 %');								addMorph: (self createAlignmentMorph: 190 @ 20);								addMorph: (self createStringMorph: 'Person 2');								addMorph: (self createAlignmentMorph: 190 @ 20).	"subTitleContainer"	subTitleContainer := (self createAlignmentMorph: 380 @ 25) addMorph: (self createStringMorph: 'Werte der letzten Fahrt:').	"assembling the parts"	formContainer addMorph: rightyContainer; addMorph: leftyContainer.	stringContainer addMorph: stringContainerRight; addMorph: stringContainerLeft.	mainContainer addMorph: subTitleContainer; addMorph: formContainer; addMorph: stringContainer.	self label: (self myName: 'OPMentalWorkload'); 		setWindwoSize: 400@320; 		addMorphBack: mainContainer ;		position: (self myPosition: 'OPMentalWorkload');		openInWorld .! !OPWindow subclass: #OPMenu	instanceVariableNames: 'windowColorMenu buttonFontMenu menuElements'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPMenu methodsFor: 'as yet unclassified' stamp: 'CL 4/24/2009 14:47'!actionSelectorButtonFont: foo	OPGuiMasterControl buttonSize: foo.! !!OPMenu methodsFor: 'as yet unclassified' stamp: 'CL 4/24/2009 11:22'!actionSelectorColorButton	windowColorMenu popUpInWorld .! !!OPMenu methodsFor: 'as yet unclassified' stamp: 'CL 4/24/2009 14:43'!actionSelectorFontSizeButton	buttonFontMenu popUpInWorld .! !!OPMenu methodsFor: 'as yet unclassified' stamp: 'CL 4/24/2009 11:43'!actionSelectorWindowColor: foo	OPGuiMasterControl windowColor: foo.! !!OPMenu methodsFor: 'as yet unclassified' stamp: 'CL 5/1/2009 12:01'!initialize	| windowColorDictionary windowColorArray colorButton fontSizeButton fontSizeDictionary buttonContainer |	super initialize.	menuElements := Dictionary new.	colorButton := self createSimpleButton: 'Farben' withActionSelector: #actionSelectorColorButton. 	fontSizeButton := self createSimpleButton: 'Schriftgrösse' withActionSelector: #actionSelectorFontSizeButton. 	windowColorDictionary := Dictionary new.	windowColorDictionary at: 'Farbe 1' put: Color black.	windowColorDictionary at: 'Farbe 2' put: Color veryVeryDarkGray.	windowColorDictionary at: 'Farbe 3' put: Color darkGray.	windowColorDictionary at: 'Farbe 4' put: Color gray.	windowColorDictionary at: 'Farbe 5' put: Color lightGray.	windowColorDictionary at: 'Farbe 6' put: Color veryLightGray.	windowColorDictionary at: 'Farbe 7' put: Color veryVeryLightGray.	windowColorDictionary at: 'Farbe 8' put: Color white.	windowColorDictionary at: 'Farbe 9' put: Color paleRed.	windowColorDictionary at: 'Farbe 10' put: Color lightBrown.	windowColorDictionary at: 'Farbe 11' put: Color lightMagenta.	windowColorArray := #('Farbe 1' 'Farbe 2' 'Farbe 3' 'Farbe 4' 'Farbe 5' 'Farbe 6' 'Farbe 7' 'Farbe 8' 'Farbe 9' 'Farbe 10' 'Farbe 11').	windowColorMenu := MenuMorph new defaultTarget: self;									addTitle: 'Window Color'.	"creating the menu"	1 to: windowColorArray size do: [:i | windowColorMenu add: 													(windowColorArray at: i) 													selector: #actionSelectorWindowColor: argument: (windowColorDictionary at: (windowColorArray at: i))												].	"making menu items colorful;)"	1 to: (windowColorMenu items) size do: [:item| (windowColorMenu items at: item) color: (windowColorDictionary at: (windowColorArray at: item)).].	fontSizeDictionary := Dictionary new.	fontSizeDictionary at: 16 put: 'Größe 16'.		fontSizeDictionary at: 24 put: 'Größe 24'.	fontSizeDictionary at: 8 put: 'Größe 8'.	buttonFontMenu := MenuMorph new defaultTarget: self;									addTitle: 'Buttonfont Size'.	fontSizeDictionary keysDo: [:key| buttonFontMenu add: (fontSizeDictionary at: key) 													selector: #actionSelectorButtonFont: 													argument: key].	buttonContainer := AlignmentMorph new								color: Color transparent ;									listDirection: #leftToRight;								borderColor: Color transparent ;								borderWidth: 1;								listCentering: #center.	buttonContainer addMorphBack: (colorButton extent: 130@50); addMorphBack: (fontSizeButton extent: 130@50).	self label: 'Einstellungen'; setWindwoSize: 450@130; position: 760@385; addMorphBack: buttonContainer; openInWorld . ! !OPWindow subclass: #OPSpeed	instanceVariableNames: 'speedSlider'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPSpeed methodsFor: 'as yet unclassified' stamp: 'CL 9/16/2009 11:56'!actionSelectorReset	self actionSelectorSpeedSlider: 1.	speedSlider adjustToValue: 1.	self sendDataToSam: 2999.! !!OPSpeed methodsFor: 'as yet unclassified' stamp: 'CL 7/1/2009 10:14'!actionSelectorSpeedSlider: newValue	| newSpeed |	newSpeed := (newValue * 100 roundTo: 1).	speedSlider currentSpeed: (' ', newSpeed asString, '%').	self sendDataToSam: 3000 + newSpeed.! !!OPSpeed methodsFor: 'as yet unclassified' stamp: 'CL 9/21/2009 10:29'!createScale	^(AlignmentMorph 	new listDirection: #topToBottom; 							listCentering: #center; 							extent: 80@516 ; "should be sliderThickness + sliderheight, even with varying scales it will balance itself correctly"							borderWidth: 1; 							borderColor: Color transparent"yellow"; 							color: Color transparent;							vResizing: #rigid;							hResizing: #rigid) 	"addMorphBack: (self createScaleItem: '120'); 														addMorphBack: (self createScaleItem: '110');"														addMorphBack: (self createScaleItem: '100'); 														addMorphBack: (self createScaleItem: '90');														addMorphBack: (self createScaleItem: '80');														addMorphBack: (self createScaleItem: '70');														addMorphBack: (self createScaleItem: '60');														addMorphBack: (self createScaleItem: '50');														addMorphBack: (self createScaleItem: '40');														addMorphBack: (self createScaleItem: '30');														addMorphBack: (self createScaleItem: '20');														addMorphBack: (self createScaleItem: '10');														addMorphBack: (self createScaleItem: '0').! !!OPSpeed methodsFor: 'as yet unclassified' stamp: 'CL 9/1/2009 13:49'!createScaleItem: wilhelm	((wilhelm asInteger \\ 20) = 0)	ifTrue:	[		^(AlignmentMorph new 			listDirection: #rightToLeft; 			listCentering: #right;			wrapCentering: #center;			extent: 100@42 ; 			borderWidth: 1; 			borderColor: Color transparent"yellow"; 			color: Color transparent) 				addMorphBack: (RectangleMorph new extent: 20@2; borderWidth: 0; color: Color gray); 				addMorphBack: ((self createStringMorphBold: wilhelm, ' ') color: Color gray)	]	ifFalse:	[		^(AlignmentMorph new 			listDirection: #rightToLeft; 			listCentering: #right;			wrapCentering: #center;			extent: 100@42 ; 			borderWidth: 1; 			borderColor: Color transparent"yellow"; 			color: Color transparent) 				addMorphBack: (RectangleMorph new extent: 20@2; borderWidth: 0; color: Color gray); 				addMorphBack: ((self createStringMorphSmall: wilhelm, ' ') color: Color gray)	].! !!OPSpeed methodsFor: 'as yet unclassified' stamp: 'CL 9/18/2009 10:01'!delete	modelData directSetSpeed: 1.0;					changed.	super delete.! !!OPSpeed methodsFor: 'as yet unclassified' stamp: 'CL 9/28/2009 11:27'!initialize	| mainContainer resetContainer percentContainer scaleContainer |	super initialize.	speedSlider := (OPAdvancedSlider new)		color: (self groupColor );		sliderColor: (self groupColor );		borderColor: Color gray;		borderWidth: 1;		extent: 100@516;		target: self;		actionSelector: #actionSelectorSpeedSlider:;   		adjustToValue: 1.0.	percentContainer := (self createAlignmentMorph: 390 @ 10)								listDirection: #leftToRight;								addMorphBack: (self createAlignmentMorph: 95 @ 15); "acts like a spacer"								addMorphBack: ((self createStringMorphBold: '%') color: Color gray).	scaleContainer := (self createAlignmentMorph: 390 @ 540)								listDirection: #leftToRight;								addMorphBack: (self createAlignmentMorph: 65 @ 15); "acts like a spacer"								addMorphBack: (self createScale); 								addMorphBack: speedSlider.	resetContainer := (self createAlignmentMorph: 390 @ 50)							listDirection: #leftToRight;							listCentering: #center;							addMorphBack: ((self createSimpleButton: 'Reset' withActionSelector: #actionSelectorReset) extent: 100 @ 50). "resetButton"	mainContainer := (self createAlignmentMorph: 390 @ 610)							addMorphBack: percentContainer;							addMorphBack: scaleContainer;							addMorphBack: resetContainer.	self label: (self myName: 'OPSpeed'); 		setWindwoSize: 400@685; 		addMorphBack: mainContainer ; 		position: (self myPosition: 'OPSpeed');		color: (self groupColorDarkest );		openInWorld .! !!OPSpeed methodsFor: 'as yet unclassified' stamp: 'CL 9/21/2009 10:01'!resetForNewStep	self actionSelectorSpeedSlider: 1.	speedSlider adjustToValue: 1.! !!OPSpeed methodsFor: 'as yet unclassified' stamp: 'CL 9/22/2009 11:43'!sendDataToSam: data	(modelData network)	ifTrue:[ modelData buttonAction: modelData buttonAction, (data asString, ';'); changed. ].	(data = 2999)"reset"	ifTrue:[ modelData directSetSpeed: 1.0. ]	ifFalse:[ modelData directSetSpeed: ((data - 3000) / 100.0); changed. ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OPSpeed class	instanceVariableNames: 'speed'!OPWindow subclass: #OPSystemStatus	instanceVariableNames: 'stepNr'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPSystemStatus methodsFor: 'as yet unclassified' stamp: 'CL 7/24/2009 10:21'!createBarChart: step withPercent: percent	^(self createAlignmentMorph: 390 @ 25)						listDirection: #leftToRight;						addMorphBack: (self createStringMorph: 'Fahrt ', step asString,': ');						addMorphBack: ((self createAlignmentMorph: 200 @ 22)												borderWidth: 1;												borderColor: Color black;												listDirection: #leftToRight;												addMorphBack: ((RectangleMorph new) 																		borderWidth: 0; 																		extent: (percent asInteger * 2) @ 20; 																		color: Color black));						addMorphBack: (self createStringMorph: ' ', percent asString).! !!OPSystemStatus methodsFor: 'as yet unclassified' stamp: 'CL 7/24/2009 10:18'!createBarChart: step withTime: time	^(self createAlignmentMorph: 390 @ 25)						listDirection: #leftToRight;						addMorphBack: (self createStringMorph: 'Fahrt ', step asString,': ');						addMorphBack: ((RectangleMorph new) borderWidth: 0; extent: (time asInteger * 10) @ 20; color: Color black);						addMorphBack: (self createStringMorph: ' ', time asString).! !!OPSystemStatus methodsFor: 'as yet unclassified' stamp: 'CL 9/16/2009 11:09'!initialize	| mainContainer barney01 barney02 barney03 barney05 barney04 |	super initialize.	mainContainer := (self createAlignmentMorph: 390 @ 460) wrapCentering: #topleft.	barney01 := (self createAlignmentMorph: 390 @ 150)						addMorphBack: ((self createAlignmentMorph: 390 @ 24)												listDirection: #leftToRight; 												addMorphBack: (self createStringMorphBigAndBold: 'Fahrinstruktionen')).	barney02 := (self createAlignmentMorph: 195 @ 85)						listDirection: #leftToRight;												addMorphBack: ((Form fromFileNamed: 'gfx\icons\Bild_MWB_dunkel_40x40.png') replaceColor: Color white withColor: Color transparent) asMorph;						addMorphBack: (self createAlignmentMorph: 5 @ 85);						addMorphBack: ((self createAlignmentMorph: 150 @ 44) 											addMorphBack: ((self createAlignmentMorph: 150 @ 22) 																	wrapCentering: #left;																	addMorphBack: (self createStringMorph: 'Person 1:'));											addMorphBack: ((self createAlignmentMorph: 150 @ 22) 																	wrapCentering: #left;																	addMorphBack: (self createStringMorph: 'Geschwindigkeit'))).	barney03 := (self createAlignmentMorph: 195 @ 85)						listDirection: #leftToRight;						addMorphBack: ((Form fromFileNamed: 'gfx\icons\Bild_MWB_hell_40x40.png') replaceColor: Color white withColor: Color transparent) asMorph;						addMorphBack: (self createAlignmentMorph: 5 @ 85);						addMorphBack: ((self createAlignmentMorph: 150 @ 44) 											addMorphBack: ((self createAlignmentMorph: 150 @ 22) 																	wrapCentering: #left;																	addMorphBack: (self createStringMorph: 'Person 2:'));											addMorphBack: ((self createAlignmentMorph: 150 @ 22) 																	wrapCentering: #left;																	addMorphBack: (self createStringMorph: 'Genauigkeit'))).	barney05 := (self createAlignmentMorph: 195 @ 85)						listDirection: #leftToRight;						addMorphBack: barney02;						addMorphBack: barney03.	barney01 addMorphBack: barney05.	stepNr := (self createStringMorphBigAndBold: (modelData stepNr) asString).	barney04 := (self createAlignmentMorph: 390 @ 150)						addMorphBack: ((self createAlignmentMorph: 390 @ 24) listDirection: #leftToRight; addMorphBack: (self createStringMorphBigAndBold: 'Aktuelle Fahrt'));						addMorphBack: ((self createAlignmentMorph: 390 @ 20) 												listDirection: #leftToRight; 												addMorphBack: stepNr; 												addMorphBack: (self createStringMorph: ' von 11')).	"barney06 := (self createAlignmentMorph: 390 @ 180)						addMorphBack: ((self createAlignmentMorph: 390 @ 24) listDirection: #leftToRight; addMorphBack: (self createStringMorphBigAndBold: 'Fahrtdauer in Minuten'));						addMorphBack: (self createBarChart: 1 withTime: 7);						addMorphBack: (self createBarChart: 2 withTime: 8);						addMorphBack: (self createBarChart: 3 withTime: 9);						addMorphBack: ((self createAlignmentMorph: 390 @ 24) listDirection: #leftToRight; addMorphBack: (self createStringMorph: 'Fahrt 4: ')).		barney11 := (self createAlignmentMorph: 390 @ 180)						addMorphBack: ((self createAlignmentMorph: 390 @ 24) listDirection: #leftToRight; addMorphBack: (self createStringMorphBigAndBold: 'Fehlerquote in Prozent'));						addMorphBack: (self createBarChart: 1 withPercent: 32);						addMorphBack: (self createBarChart: 2 withPercent: 25);						addMorphBack: (self createBarChart: 3 withPercent: 16);						addMorphBack: ((self createAlignmentMorph: 390 @ 24) listDirection: #leftToRight; addMorphBack: (self createStringMorph: 'Fahrt 4: '))."	mainContainer 		addMorphBack: barney01; 		addMorphBack: barney04";		addMorphBack: barney06;		addMorphBack: barney11".	self 		label: (self myName: 'OPSystemStatus'); 		setWindwoSize: 400@800; 		addMorphBack: mainContainer;		position: (self myPosition: 'OPSystemStatus');		openInWorld .! !!OPSystemStatus methodsFor: 'as yet unclassified' stamp: 'CL 9/10/2009 15:35'!setStepNr: newStepNr	stepNr contents: newStepNr asString.! !OPWindow subclass: #OPTrackPreview	instanceVariableNames: 'mainContainer nonNetworkSpeed nonNetworkCoord direction frameSlashTrackBorderWidth trackGraphics trackEditOAObject leftJoystick rightJoystick leftDirectionX leftDirectionY rightDirectionX rightDirectionY leftJoystickPosition rightJoystickPosition initialTrackPosition jointY track ufo ufoContainer obstacles frame'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/11/2009 15:53'!buildObstacles: obstacleConfig		"obstacleConfig := (OrderedCollection new)								add: (Array with: 111 	with: 15945);								add: (Array with: 1110 	with: 24445);								add: (Array with: 1111 	with: 30985);								add: (Array with: 1111 	with: 54815);								add: (Array with: 111 	with: 63315);								add: (Array with: 1111 	with: 69855);								add: (Array with: 1110 	with: 93685);								add: (Array with: 1110 	with: 102185);								add: (Array with: 111 	with: 108725)."	(obstacles isNil)	ifTrue:[ obstacles := OrderedCollection new. ].	obstacleConfig do: 	[		:arrayWithLengthTwo |		"Transcript cr; show: '(arrayWithLengthTwo at: 1): ', (arrayWithLengthTwo at: 1) asString, ' (arrayWithLengthTwo at: 2): ', (arrayWithLengthTwo at: 2) asString."				((arrayWithLengthTwo at: 1) = 1110)		ifTrue:		[			obstacles add: ((OPObstacle new)									scaleWithFactor: (modelData scaleFactor);									kindOfObstacle: 1;									position: initialTrackPosition + ((418 @ ((arrayWithLengthTwo at: 2) + 131)) * modelData scaleFactor) ;									orderOfObstacle: 2;									openInWorld);							add: ((OPObstacle new)									scaleWithFactor: (modelData scaleFactor);									kindOfObstacle: 1;									position: initialTrackPosition + ((328 @ ((arrayWithLengthTwo at: 2) + 406)) * modelData scaleFactor) ;									orderOfObstacle: 1;									openInWorld).		].			((arrayWithLengthTwo at: 1) = 1111)		ifTrue:		[			obstacles add: ((OPObstacle new)																		scaleWithFactor: (modelData scaleFactor);									kindOfObstacle: 2;									position: initialTrackPosition + ((405 @ ((arrayWithLengthTwo at: 2) + 131)) * modelData scaleFactor) ; 									orderOfObstacle: 2;									openInWorld);							add: ((OPObstacle new) 									scaleWithFactor: (modelData scaleFactor);									kindOfObstacle: 2;									position:  initialTrackPosition + ((342 @ ((arrayWithLengthTwo at: 2) + 406)) * modelData scaleFactor) ;									orderOfObstacle: 1;									openInWorld).		].			((arrayWithLengthTwo at: 1) = 111)		ifTrue:		[			obstacles add: ((OPObstacle new) 									scaleWithFactor: (modelData scaleFactor);									kindOfObstacle: 3;									position: initialTrackPosition + ((0 @ ((arrayWithLengthTwo at: 2) + 930)) * modelData scaleFactor) ; 									orderOfObstacle: 1;									openInWorld)		].	].		obstacles do: [ :obs | track addMorph: obs. ].! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/3/2009 18:45'!buildTailContainer		"ufoContainer later containes all the tail morphs"	^ufoContainer := (RectangleMorph new)				width: (mainContainer width - (mainContainer borderWidth * 2)) asFloat;				height: (track height);				color: Color transparent;				borderWidth: 0;				borderColor: Color transparent.! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/3/2009 15:57'!buildTrackingObject	"creating the green tracker object, here called ufo;)"	^ufo := (EllipseMorph new) 				extent: (30 @ 30) * (modelData scaleFactor); 				color: Color green.	! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/1/2009 15:23'!buildTrackOld: trackData 	"		here three things will be created and added to the maincontainer: 			1. the track itself			2. the tracking object - affectionately called ufo			3. the transparent containermorph (with the exact same extent as the track), which holds (and only this) the morphs that make up the tail	"	| containerWidth currentTrack currentTrackItem lowerLeftPointOfMainContainer track ufo ufoContainer substuff localTrackData obstacleInPreviousLoopStep previousItem slalomObstacleLightGreen slalomObstacleDarkGray currentGraphicMorph dynamicObstacleContainer totalTrackHeight dynamicObstacle |	currentTrack := OrderedCollection new.	containerWidth := (mainContainer width - (mainContainer borderWidth * 2)) asFloat.	"throwing out the old stuff"	trackEditOAObject do: [:element | trackEditOAObject remove: element].	mainContainerTop := mainContainer top.	mainContainerBottom := mainContainer bottom.	"ufoContainer later containes all the tail morphs"	ufoContainer := (RectangleMorph new)				width: containerWidth;				height: 0;				color: Color transparent;				borderWidth: 0;				borderColor: Color transparent.	"dynamicObstacleContainer contains the dynamic obstacles"	dynamicObstacleContainer := (RectangleMorph new)				width: containerWidth;				height: 0;				color: Color transparent;				borderWidth: 0;				borderColor: Color transparent.	"this is the morph that holds all the graphics - in short: the track"	track := (AlignmentMorph new)				width: containerWidth;				height: 0;				borderWidth: frameSlashTrackBorderWidth;				borderColor: Color transparent;				color: Color transparent;				listDirection: #topToBottom;				hResizing: #rigid;				vResizing: #rigid;				layoutInset: 0.	OPNetwork networkActivated 		ifTrue: [currentTrack := trackData findTokens: ';']		ifFalse: 			["for local testing only"			localTrackData := self localTrackData.						currentTrack := localTrackData findTokens: ';'.		].	"indicates if we found an obstacle code in the indices (1110, 1111, 111)"	obstacleInPreviousLoopStep := false.	previousItem := ''.	totalTrackHeight := 0.	'Loading trackgraphics...' 	displayProgressAt: 0 @ 0 from: 0 to: currentTrack size during: 	[		:bar | 		1 to: currentTrack size do: 		[			:x | 			bar value: x.						currentTrackItem := (currentTrack at: x) withBlanksTrimmed.						((currentTrackItem copyFrom: 1 to: 1) ~= '1') 			ifTrue:			[				currentGraphicMorph := OPSketchMorph withForm: (trackGraphics at: currentTrackItem).				totalTrackHeight := totalTrackHeight + currentGraphicMorph height.				ufoContainer height: totalTrackHeight.				track height: totalTrackHeight.				dynamicObstacleContainer height: totalTrackHeight.				dynamicObstacleContainer submorphs do: [:submorph | submorph position: submorph position + (0 @ currentGraphicMorph height)].				(obstacleInPreviousLoopStep) 				ifTrue: 				[					(previousItem = '1110') 					ifTrue: 					["25lr"						slalomObstacleLightGreen := (OPSketchMorph fromFile: 'block1-1.jpg')																		extent: 60 @ 30 * scaleFactor; 																	position: (currentGraphicMorph left + (328 * scaleFactor)) @ (currentGraphicMorph top + (406 * scaleFactor)); 																	trackEditOA: '4_25lr'.						slalomObstacleDarkGray := (OPSketchMorph fromFile: 'block1-4.jpg') 																	extent: 60 @ 30 * scaleFactor; 																	position: (currentGraphicMorph left + (418 * scaleFactor)) @ (currentGraphicMorph top + (131 * scaleFactor)); 																	trackEditOA: '4_25lr'.						track addMorph: (currentGraphicMorph addMorph: slalomObstacleLightGreen; addMorph: slalomObstacleDarkGray).						trackEditOAObject add: slalomObstacleLightGreen; add: slalomObstacleDarkGray.					].					(previousItem = '1111') 					ifTrue: 					["50lr"						slalomObstacleLightGreen := (OPSketchMorph fromFile: 'block1-1.jpg') 																	extent: 60 @ 30 * scaleFactor; 																	position: (currentGraphicMorph left + (342 * scaleFactor)) @ (currentGraphicMorph top + (406 * scaleFactor)); 																	trackEditOA: '4_50lr'.						slalomObstacleDarkGray := (OPSketchMorph fromFile: 'block1-4.jpg') 																	extent: 60 @ 30 * scaleFactor; 																	position: (currentGraphicMorph left + (405 * scaleFactor))  @ (currentGraphicMorph top + (131 * scaleFactor)); 																	trackEditOA: '4_50lr'.						track addMorph: (currentGraphicMorph addMorph: slalomObstacleLightGreen; addMorph: slalomObstacleDarkGray).						trackEditOAObject add: slalomObstacleLightGreen; add: slalomObstacleDarkGray.					].					(previousItem = '111') 					ifTrue: 					["dynamic"						track addMorph: currentGraphicMorph.						dynamicObstacle := ((OPSketchMorph fromFile: 'block1.jpg') 																				extent: 60 @ 30 * scaleFactor; 																				position: dynamicObstacleContainer position + (frameSlashTrackBorderWidth @ (currentGraphicMorph top + (850 * scaleFactor)));																				trackEditOA: '3').						dynamicObstacleContainer addMorph: dynamicObstacle.						trackEditOAObject add: dynamicObstacle.						"self halt."					].										obstacleInPreviousLoopStep := false				]				ifFalse: 				["if obstacleInPreviousLoopStep was false"					track addMorph: currentGraphicMorph				].				"handling for the famous trackEdit variable - it indicates that a fork is visible"				(currentTrackItem = 'RLl.gif') | (currentTrackItem = 'ELr.gif') | (currentTrackItem = 'ELl.gif') | (currentTrackItem = 'RLr.gif') 				ifTrue: 				["these are the indices of the fork tiles"					trackEditOAObject add: (currentGraphicMorph trackEditOA: '1_',(currentTrackItem copyFrom: 1 to: 3)). "reference to the object in question"				].			]			ifFalse: " if graphicIndex was higher than 100"			[				obstacleInPreviousLoopStep := true. previousItem := currentTrackItem			].		].	]."	(trackEditOATop size > 0 )	ifTrue: 	[		1 to: trackEditOATop size do: 			[				:index | 				Transcript show: 'Entry ' , index asString , ': top: ' , (trackEditOATop at: index) asString , ' - bottom: ' , (trackEditOABottom at: index) asString , ' - content: ' , (trackEditOAContent at: index) asString; cr			]	]."	track height: track height + (track borderWidth * 2).	"creating the green tracker object, here called ufo;)"	ufo := (EllipseMorph new)				extent: 30 @ 30 * scaleFactor;				color: Color green.	"deleting the old stuff"	substuff := mainContainer submorphs.	substuff size > 1 		ifTrue: [2 to: substuff size do: [:x | (substuff at: x) delete]].	"adding the morphs"	mainContainer		addMorphBack: ufo;		addMorphBack: ufoContainer;		addMorphBack: dynamicObstacleContainer;		addMorphBack: track.	"initial positioning of the submorphs track and frame"	lowerLeftPointOfMainContainer := mainContainer position + (mainContainer borderWidth @ mainContainer height).	mainContainer submorphs do: [:mySubMorph | mySubMorph position: lowerLeftPointOfMainContainer + (0 @ (mySubMorph height + 50) * -1)].		initialTrackPosition := track "(mainContainer submorphs at: 4)" position y.	"positioning of the trackerobject aka ufo"	ufo position: ufo position + ((402 * scaleFactor - (ufo width / 2) + frameSlashTrackBorderWidth) @ ((ufo height / 2 + (38 * scaleFactor) + frameSlashTrackBorderWidth) * -1)).	"Transcript show: 'mainContainer top: ',mainContainer top asString,'; bottom: ', mainContainer bottom asString; cr.	Transcript show: 'track Position: ', track position asString; cr.	track submorphs do: [:subi | Transcript show: 'Track Submorph[', ((track submorphs) indexOf: subi) asString, '] position:', (subi position) asString, ' extent: ', subi extent asString, ' subi bottom - mainContainer top: ', ((subi bottom) -(mainContainer top)) asString; cr.]."	"resuming business as usual"	self startStepping.	"self halt."! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/11/2009 15:09'!buildTrack: trackName	| trackForm |	trackForm := Form fromFileNamed: 'gfx\tracks\', trackName, '_scaled.bmp'. 	^track := (trackForm asMorph). "asMorph creates an ImageMorph"! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/11/2009 15:38'!calculateScaleFactor	| originalGraphic scaledGraphic containerWidth scale |	containerWidth := (mainContainer width - (mainContainer borderWidth * 2) - (frameSlashTrackBorderWidth * 2)) asFloat. 	originalGraphic := (Form fromFileNamed: 'gfx\tracks\tiles\SbBx260806.gif').	scaledGraphic := originalGraphic scaledToSize: containerWidth@((originalGraphic height * containerWidth ) / originalGraphic width).	scale := (scaledGraphic height / originalGraphic height) asFloat.	originalGraphic := nil.	scaledGraphic := nil.	modelData scaleFactor: 0.375"scale"; changed.	"Transcript cr; show: 'scaleFactor: ', scale asString."	! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/25/2009 18:31'!createJoystick	| joystick greenThingy vLine hLine whiteArea |	joystick := ((Form fromFileNamed: 'gfx\icons\Bild_Steuergewalt_Hintergrund_130x130.png') replaceColor: Color white withColor: Color transparent) asMorph .	greenThingy := EllipseMorph new color: Color green; extent: 15@15.	vLine := (RectangleMorph new)					position: (joystick center x) @ (joystick top);					width: 1;					height: joystick height;					color: Color lightGray;					borderColor: 0;					borderColor: Color lightGray.	   hLine := (RectangleMorph new)					position: (joystick left) @ (joystick center y);					width: joystick width;					height: 1;					color: Color lightGray;					borderColor: 0;					borderColor: Color lightGray.	whiteArea := (RectangleMorph new)						borderWidth: 1;						borderColor: Color gray;						extent: ((joystick width / 2.0) @ (joystick width / 2.0));						color: (self groupColor );						center: joystick center.	greenThingy position: joystick center - (greenThingy extent // 2).		joystick addMorphBack: greenThingy;				addMorphBack: vLine; 				addMorphBack: hLine; 				addMorphBack: whiteArea.	joystick hide.	^joystick ! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/22/2009 10:24'!initialize	| ueberMainContainer leftJoystickColumn rightJoystickColumn leftJoystickContainer rightJoystickContainer |	super initialize.	obstacles := OrderedCollection new.	modelData currentCoordinateY: 0;									currentCoordinateX: 0;					changed. 	"borderwidth of the track and the frame, MUST be the same"	frameSlashTrackBorderWidth := 5.		leftJoystick := self createJoystick .	rightJoystick := self createJoystick .	leftJoystickContainer := (RectangleMorph new)										extent: 150 @ 150;										color: Color transparent;										borderWidth: 0;										openInWorld.	leftJoystickContainer addMorphBack: (leftJoystick position: leftJoystickContainer position + (10 @ 10)).	rightJoystickContainer := (RectangleMorph new)										extent: 150 @ 150;										color: Color transparent;										borderWidth: 0;										openInWorld.	rightJoystickContainer addMorphBack: (rightJoystick position: rightJoystickContainer position + (10 @ 10)).	ueberMainContainer := (self createAlignmentMorph: 650 @ 1500) listDirection: #leftToRight.	leftJoystickColumn := (self createAlignmentMorph: 170 @ 1500)									addMorphBack: (self createAlignmentMorph: 10 @ 1288);									addMorphBack: ((Form fromFileNamed: 'gfx\icons\Bild_MWB_dunkel_40x40.png') replaceColor: Color white withColor: Color transparent) asMorph;									addMorphBack: (self createAlignmentMorph: 170@10);									addMorphBack: (self createStringMorph: 'Person 1');									addMorphBack: (self createAlignmentMorph: 170@10);									addMorphBack: leftJoystickContainer"leftJoystick".	rightJoystickColumn := (self createAlignmentMorph: 170 @ 1500)									addMorphBack: (self createAlignmentMorph: 10 @ 1288);									addMorphBack: ((Form fromFileNamed: 'gfx\icons\Bild_MWB_hell_40x40.png') replaceColor: Color white withColor: Color transparent) asMorph;									addMorphBack: (self createAlignmentMorph: 170@10);									addMorphBack: (self createStringMorph: 'Person 2');									addMorphBack: (self createAlignmentMorph: 170@10);									addMorphBack: rightJoystickContainer"rightJoystick".	mainContainer := (RectangleMorph new)				color: Color transparent;				listDirection: #topToBottom;				borderWidth: 0;				borderColor: Color black;				layoutInset: 0;				vResizing: #rigid;				hResizing: #rigid;				clipSubmorphs: true.	self		label: (self myName: 'OPTrackPreview');		setWindwoSize: 660 @ 1580;		position: (self myPosition: 'OPTrackPreview');		openInWorld.	"828"	self calculateScaleFactor. "scaleFactor will be stored in modelData"	frame := (RectangleMorph new)				width: 800 * (modelData scaleFactor) + (frameSlashTrackBorderWidth * 2);				height: 768 * (modelData scaleFactor) + (frameSlashTrackBorderWidth * 2);				color: Color transparent;				borderWidth: frameSlashTrackBorderWidth;				borderColor: Color black.	"the (frameSlashTrackBorderWidth * 2) accounts for the border of the frame - which is always frameSlashTrackBorderWidth on both sides"	ueberMainContainer addMorphBack: leftJoystickColumn;								addMorphBack: (mainContainer addMorph: frame);								addMorphBack: rightJoystickColumn.	self addMorphBack: ueberMainContainer.	self joysticksVisibility: false.! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 8/18/2009 17:42'!joysticksVisibility: bool	(bool)	ifTrue:[leftJoystick show. rightJoystick show.]	ifFalse:[leftJoystick hide. rightJoystick hide.].! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/25/2009 16:24'!moveObstacles: yCoord	| someBoolean |	someBoolean := true.	(obstacles size > 0)	ifTrue:[		obstacles do: [:obstacle |					"dynamic obstacle - moving in the simulation"			((obstacle kindOfObstacle) = '3') & (modelData simulation)			ifTrue:[ 				(obstacle bottom > frame top)				ifTrue:[ obstacle position: ((obstacle position x) + 2) @ (obstacle position y). ].			].			(modelData network)			ifTrue:[				"visibility"				((obstacle top) between: mainContainer top and: mainContainer bottom) | ((obstacle bottom) between: mainContainer top and: mainContainer bottom)				ifTrue:[						modelData trackEdit: modelData trackEdit, (100 + (obstacle kindOfObstacle)) asString, ';'; changed. 										((obstacle kindOfObstacle) = 3) "dynamic obstacle"					ifTrue:[ "moving" 						obstacle position: track left + ((modelData dynamicObstacleX) * (modelData scaleFactor)) @ obstacle position y. 						someBoolean := false.					].				].			].			"deleting obstacles involved in collisions"			(modelData collision = 1)			ifTrue:[				((((obstacle top) - (ufo top)) abs) < 60) 				ifTrue:[ obstacles remove: (obstacle delete). ].			].			"deleting obstacles which left the visible area"			(obstacle left > mainContainer right) | (obstacle top > mainContainer bottom)			ifTrue:[ obstacles remove: (obstacle delete). ].		].	].	"the following takes care of data we might get for dynamic obstacles - even if we deleted ours"	((modelData network) & (someBoolean))	ifTrue:[ modelData dynamicObstacleX: 0. ]. ! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/10/2009 21:23'!moveTail: yCoord withColor: tailColor	(track = nil) | (yCoord = 0)	ifFalse:[		"new tail morph"		ufoContainer addMorph: ((EllipseMorph new)					extent: 30 @ 30 * (modelData scaleFactor);					color: (Color black mixed: (tailColor / 20.48) with: Color green);					position: ufo position;					borderWidth: 0).	" 20.48 is the max speed"		"trimming the taillength"		(ufoContainer submorphs size >= 10 )		ifTrue:[ ufoContainer submorphsBehind: (ufoContainer submorphs at: 10) do: [:gertFroebe | gertFroebe delete]. ].		ufoContainer top: (initialTrackPosition y + (yCoord * (modelData scaleFactor))). 	].	"Transcript cr; show: '-------------------------------------------------'.	Transcript cr; show: '((yCoord * (modelData scaleFactor)) + (initialTrackPosition y - (track position y))) / ((20.48)  * (modelData scaleFactor)): ', (((yCoord * (modelData scaleFactor)) + (initialTrackPosition y - (track position y))) / ((20.48)  * (modelData scaleFactor))) asString.	Transcript cr; show: '(yCoord * (modelData scaleFactor): ', (yCoord * (modelData scaleFactor)) asString.	Transcript cr; show: 'initialTrackPosition y - (track position y): ', (initialTrackPosition y - (track position y)) asString.	Transcript cr; show: 'initialTrackPosition y: ', (initialTrackPosition y) asString.	Transcript cr; show: 'track position y: ', (track position y) asString.	Transcript cr; show: '((20.48)  * (modelData scaleFactor)): ', ((20.48)  * (modelData scaleFactor)) asString."! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/11/2009 15:28'!moveTrackingObject: drDoom	| drHorrible |	(ufo = nil) | (drDoom = 0)	ifFalse:[ 		"positioning the tracking object"		drHorrible := (track left + (drDoom * (modelData scaleFactor))) @ ufo position y.		(drHorrible x > (mainContainer right - (20 * (modelData scaleFactor)) - ufo width))		ifTrue:[ ufo position: (mainContainer right - (20 * (modelData scaleFactor)) - ufo width) @ ufo position y. ]. 		(drHorrible x < (mainContainer left + (20 * (modelData scaleFactor))))		ifTrue:[ ufo position: (mainContainer left + (20 * (modelData scaleFactor))) @ ufo position y. ].			(drHorrible x < (mainContainer right - (20 * (modelData scaleFactor)) - ufo width)) & (drHorrible x > (mainContainer left + (20 * (modelData scaleFactor))))		ifTrue:[ ufo position: drHorrible. ].	].! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/11/2009 15:09'!moveTrack: drFuManChu	(track = nil)	ifFalse:[ 		track top: (initialTrackPosition y + (drFuManChu * (modelData scaleFactor))). 		mainContainer refreshWorld .		(modelData simulation)		ifTrue:[ 			((track height - (drFuManChu * (modelData scaleFactor))) < 1000)			ifTrue:[ modelData status: 'buildTrack'; changed. ].		].		"Transcript cr; show: 'track position: ', track position asString, ' track left: ', track left asString, ' track top: ', track top asString."		"Transcript cr; show: 'track bottom: ', track bottom asString, ' frame bottom: ', frame bottom asString."	].! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/25/2009 10:04'!prepareTrack: trackName and: obstacleConfig	| lowerLeftPointOfMainContainer |	"adding the morphs"	mainContainer		addMorphBack: (self buildTrack: trackName);		addMorph: (self buildTailContainer);		addMorph: (self buildTrackingObject).	"initial positioning of the submorphs track and frame"	lowerLeftPointOfMainContainer := mainContainer position + (mainContainer borderWidth @ mainContainer height).	mainContainer submorphs do: [:mySubMorph | mySubMorph position: lowerLeftPointOfMainContainer + (0 @ (mySubMorph height + 50) * -1)].	track position: track position + (frameSlashTrackBorderWidth @ (frameSlashTrackBorderWidth * -1)).	"positioning of the trackerobject aka ufo"	ufo position: (track left + (402 * (modelData scaleFactor)) - (ufo width / 2)) @ (track bottom -(53 * (modelData scaleFactor))).	initialTrackPosition := track position.	self processDirectionButtonsOutput: leftJoystick with: (modelData distributionMwiOne);			processDirectionButtonsOutput: rightJoystick with: (1 -modelData distributionMwiOne).	(obstacleConfig isNil)	ifFalse:[ self buildObstacles: obstacleConfig. ].! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/21/2009 14:57'!processDirectionButtonsOutput: joystick with: input	| whiteArea trimmedJoystickWidth |	whiteArea := joystick submorphs at: 4.	trimmedJoystickWidth := (joystick width)" - 20".	((modelData directSetDirectionLeft) | (modelData directSetDirectionRight ))	ifTrue:[		whiteArea width: (((trimmedJoystickWidth * input)" + 20") * 0.5) ceiling;						height: (trimmedJoystickWidth * input)" + 20".		(modelData directSetDirectionLeft)		ifTrue:[whiteArea left: joystick center x.].		(modelData directSetDirectionRight)		ifTrue:[whiteArea right: joystick center x.].	]	ifFalse:[		whiteArea width: (trimmedJoystickWidth * input)" + 20";						height: (trimmedJoystickWidth * input)" + 20";						"center: joystick center"						left: (joystick center x) - ((whiteArea height) / 2.0) ceiling.	].	whiteArea bottom: (joystick center y) + ((whiteArea height) / 2.0) ceiling.	! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/21/2009 15:02'!processJoystickMovement: joystick withCoord: coord andInput: input andSpeed: speed	| greenThingy newCenterX newCenterY factor whiteArea |		"coord should be in the range [-1024, 1023] for each axis"	greenThingy := joystick submorphs at: 1.	whiteArea := joystick submorphs at: 4.	(input > 0)	ifTrue:[		"the first factor is the maximum range, the second one is the tolerance needed so that the green thing overlaps the joystick morph by half (because of the positioning by center)"		((modelData directSetDirectionLeft) | (modelData directSetDirectionRight))		ifTrue:[factor := (whiteArea width) "- (greenThingy width / 2.0)" .]		ifFalse:[factor := (whiteArea width / 2.0) "- (greenThingy width / 2.0)" .].		newCenterX := (((coord x / 1024.0) * factor) + joystick center x).		newCenterY := (((coord y / 1024.0) * factor) + joystick center y).			"Transcript cr; show: 'factor: ', factor asString,									' whiteArea width: ', whiteArea width asString,									' newCenter: ', newCenterX asString, '@', newCenterY asString,									' joystick center: ', (joystick center) asString,									' coord: ', coord asString."	]	ifFalse:[		newCenterX := whiteArea center x.		newCenterY := whiteArea center y	].	"now we have the center of the green thingy - IF we had no manipulations like speedlimit or direction button input - if we have some, it will be calculated in the following lines"	"processing the directionbuttons"	(modelData directSetDirectionLeft) & (newCenterX < ((joystick center x) "+ (greenThingy width / 2.0)"))	ifTrue:[newCenterX := (joystick center x) "+ (greenThingy width / 2.0)".].	(modelData directSetDirectionRight) & (newCenterX > ((joystick center x) "- (greenThingy width / 2.0)"))	ifTrue:[newCenterX := (joystick center x) "- (greenThingy width / 2.0)".].	"speedlimit"	(speed ~= 1.0) & (newCenterY < ((whiteArea top) "+ (greenThingy width / 2.0)"))	ifTrue:[ newCenterY := (whiteArea top)" + (greenThingy width / 2.0)". 		"Transcript cr; show: 'newCenterY: ', newCenterY asString, ' whiteArea height: ', whiteArea height asString, ' joystick center y: ', joystick center y asString, ' greenThingy width / 2.0: ', (greenThingy width / 2.0) asString."	].	greenThingy center: (newCenterX @ newCenterY).! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/21/2009 13:25'!processLeftJoystick: coord	self processDirectionButtonsOutput: leftJoystick with: modelData distributionMwiOne.	self processSpeedOutput: leftJoystick withSpeed: (modelData directSetSpeed).	self processJoystickMovement: leftJoystick withCoord: coord andInput: (modelData distributionMwiOne) andSpeed: (modelData directSetSpeed).! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/21/2009 13:57'!processRightJoystick: coord	self processDirectionButtonsOutput: rightJoystick with: (1 - modelData distributionMwiOne).	self processSpeedOutput: rightJoystick withSpeed: (modelData directSetSpeed).	self processJoystickMovement: rightJoystick withCoord: coord andInput: (1 - (modelData distributionMwiOne)) andSpeed: (modelData directSetSpeed).! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/21/2009 15:11'!processSpeedOutput: joystick withSpeed: speed	| whiteArea oldHeight |	whiteArea := joystick submorphs at: 4.	oldHeight := whiteArea height.	(speed ~= 1.0)	ifTrue:[ whiteArea height: ((whiteArea height" - 20") * speed)" + 20" ].	(speed = 0)	ifTrue:[ whiteArea height: 1. ].	whiteArea bottom: (joystick center y) + (oldHeight / 2.0) ceiling.	! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/25/2009 18:25'!resetForNewStep	(ufo isNil)	ifFalse:[ ufo delete. ].	(track isNil)	ifFalse:[ track delete. ].	(ufoContainer isNil)	ifFalse:[ ufoContainer delete. ].	(obstacles isNil)	ifFalse:[ obstacles := nil. ].	self processJoystickMovement: leftJoystick withCoord: 0 @ 0 andInput: (modelData distributionMwiOne) andSpeed: 1.	self processJoystickMovement: rightJoystick withCoord: 0 @ 0 andInput: 1 - (modelData distributionMwiOne) andSpeed: 1.! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 7/23/2009 11:17'!setWindwoSize: newSize	self extent: newSize.	seperationBar extent: self width - (self borderWidth * 2)@2.	mainContainer width: self width - 350.	mainContainer height: self height - 75.! !!OPTrackPreview methodsFor: 'as yet unclassified' stamp: 'CL 9/1/2009 15:19'!stepOld	| speed coord trackData dynamicObstacleData oberHorst joystickData|	"Transcript show: 'start step'; cr."	"currentTimeStamp := Time millisecondClockValue. "	"processing directionButtons for the joysticks"	self processDirectionButtonsOutput: rightJoystick with: (1 - modelData distributionMwiOne).	self processDirectionButtonsOutput: leftJoystick with: modelData distributionMwiOne.	speed := ';'.	coord := ';'.	dynamicObstacleData := '0'.	joystickData := ''.	(OPNetwork networkActivated) "network on this side is alive and ready for receiving data (and for all we know connected with sam)"	ifTrue:  	"here is the part with network processing"	[		trackData := (OPNetwork receiveTrackData) asString.		"Transcript show: 'trackData:',  trackData ; cr."		(trackData size > 1)		ifTrue:		[			self stopStepping; buildTrack: trackData .			"Transcript show: trackData ; cr."			modelData distributionMwiOne: (OPNetwork receiveStepConfigData) asNumber; 					currentCoordinateY: 0;									currentCoordinateX: 0;					changed.			OPGuiMasterControl resetForNewStep.				self processLeftJoystickMovement: (Point x: 0 y: 0).			self processRightJoystickMovement: (Point x: 0 y: 0).		]		ifFalse:		[			speed := OPNetwork receiveSpeedData.			"Transcript cr; show: 'speed: ', speed."			coord := OPNetwork receiveCoordData.			dynamicObstacleData := OPNetwork receiveDynamicObstacleData.			joystickData := OPNetwork receiveJoystickData.			"Transcript cr; show: 'joystickData: ', joystickData."			(joystickData size > 0)			ifTrue:[				joystickData := joystickData findTokens: ';'.								self processLeftJoystickMovement: (Point x: ((joystickData at: 1) asInteger) y: ((joystickData at: 2) asInteger)).				self processRightJoystickMovement: (Point x: ((joystickData at: 3) asInteger) y: ((joystickData at: 4) asInteger)).				"Transcript cr; show: 'joystick1: ', (Point x: ((joystickData at: 1) asInteger) y: ((joystickData at: 2) asInteger)) asString, ' joystick2: ', (Point x: ((joystickData at: 3) asInteger) y: ((joystickData at: 4) asInteger)) asString."			].		].	]	ifFalse:		"this is just for non-networking performance testing"	[		dynamicObstacleData := '4'. "the speed of the dynmaic obstacle (x-axis)"		oberHorst := self artificialInput.		speed := oberHorst y asString, ';'.		coord := oberHorst x asString, ';'.		self artificialInputJoystick.	].		"Transcript cr.	Transcript cr; show: 'speed (raw): ', speed asString."	speed := speed findTokens: ';'.	coord := coord findTokens: ';'.	((speed size) > 0)	ifTrue:[modelData currentCoordinateY: (speed last) asNumber; changed. ].	((coord size) > 0)	ifTrue:[modelData currentCoordinateX: (coord last) asNumber; changed. ].	"Transcript cr; show: 'speed: ', speed asString, ' modelData currentCoordinateY: ', (modelData currentCoordinateY) asString.	Transcript cr; show: 'coord ', coord asString, ' modelData currentCoordinateX: ', (modelData currentCoordinateX) asString."	dynamicObstacleData size = 0	ifTrue:[dynamicObstacleData := 0]	ifFalse:[dynamicObstacleData := (dynamicObstacleData asString) asNumber].	"Transcript show: 'speed -', speed asString, '- with coord: -', coord asString, '-  '; cr."	"Transcript show: 'end step'; cr."	(((modelData currentCoordinateY) ~= 0) & ((modelData currentCoordinateX) ~= 0))	ifTrue:[self moveTrack: (modelData currentCoordinateY) withXCoord: (modelData currentCoordinateX) withDynamicObstacleYCoord: dynamicObstacleData.].	! !OPWindow subclass: #OPVideo	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPVideo methodsFor: 'as yet unclassified' stamp: 'CL 9/10/2009 19:21'!initialize	| mainContainer iconContainer leftContainer rightContainer |		super initialize.	leftContainer := (self createAlignmentMorph: 190@100)							addMorphBack: (self createAlignmentMorph: 190@20);							addMorphBack: ((Form fromFileNamed: 'gfx\icons\Bild_MWB_dunkel_40x40.png') replaceColor: Color white withColor: Color transparent) asMorph;							addMorphBack: (self createAlignmentMorph: 190@20);							addMorphBack: (self createStringMorph: 'Person 1').	rightContainer := (self createAlignmentMorph: 190@100)							addMorphBack: (self createAlignmentMorph: 190@20);							addMorphBack: ((Form fromFileNamed: 'gfx\icons\Bild_MWB_hell_40x40.png') replaceColor: Color white withColor: Color transparent) asMorph;							addMorphBack: (self createAlignmentMorph: 190@20);							addMorphBack: (self createStringMorph: 'Person 2').	iconContainer := (self createAlignmentMorph: 380@100)								listDirection: #leftToRight; 								addMorphBack: leftContainer;								addMorphBack: rightContainer.	mainContainer := (self createAlignmentMorph: 380@320) 							addMorphBack: (VPVideoMorph new extent: 374 @ 268);							addMorphBack: iconContainer.	self label: (self myName: 'OPVideo'); 		setWindwoSize: 400@440; 		addMorphBack: mainContainer; 		position: (self myPosition: 'OPVideo');		openInWorld .! !OPWindow subclass: #OPVisualHints	instanceVariableNames: 'leftGfx rightGfx'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-Operator'!!OPVisualHints methodsFor: 'as yet unclassified' stamp: 'CL 7/23/2009 18:28'!actionSelectorBack	self sendDataToSam: '81'.	self showTrackPreviewHints: 'back'.! !!OPVisualHints methodsFor: 'as yet unclassified' stamp: 'CL 7/23/2009 18:28'!actionSelectorFork	self sendDataToSam: '79'.	self showTrackPreviewHints: 'fork'.! !!OPVisualHints methodsFor: 'as yet unclassified' stamp: 'CL 7/23/2009 18:29'!actionSelectorForward	self sendDataToSam: '82'.	self showTrackPreviewHints: 'forward'.! !!OPVisualHints methodsFor: 'as yet unclassified' stamp: 'CL 7/23/2009 18:29'!actionSelectorLeft	self sendDataToSam: '91'.	self showTrackPreviewHints: 'left'.! !!OPVisualHints methodsFor: 'as yet unclassified' stamp: 'CL 7/23/2009 18:29'!actionSelectorObstacle	self sendDataToSam: '69'.	self showTrackPreviewHints: 'obstacle'.! !!OPVisualHints methodsFor: 'as yet unclassified' stamp: 'CL 7/23/2009 18:29'!actionSelectorRight	self sendDataToSam: '92'.	self showTrackPreviewHints: 'right'.! !!OPVisualHints methodsFor: 'as yet unclassified' stamp: 'CL 7/23/2009 18:20'!delete	leftGfx do: [:gfx | gfx delete.].	rightGfx do: [:gfx | gfx delete.].	super delete.! !!OPVisualHints methodsFor: 'as yet unclassified' stamp: 'CL 9/25/2009 18:22'!initialize	| mainContainer forwardButton backButton leftButton rightButton arrowContainer topArrowContainer middleArrowContainer bottomArrowContainer warningContainer warningContainerContainer warningButtonContainer obstacleButton forkButton localGfx |	super initialize.		leftGfx := Dictionary new.	rightGfx := Dictionary new.	localGfx := (Dictionary new).	localGfx	at: 'obstacle'	put: 'gfx\icons\Bild_Warnung Hindernis_90x90.png';				at: 'fork' 	put: 'gfx\icons\Bild_Warnung Gabelung_90x90.png';				at: 'forward'	put: 'gfx\icons\Bild_schneller_fahren.png';				at: 'back' 	put: 'gfx\icons\Bild_langsamer_fahren.png';				at: 'left' 		put: 'gfx\icons\Bild_Richtung_links.png';				at: 'right' 	put: 'gfx\icons\Bild_Richtung_rechts.png'.	self loadTrackPreviewHints: localGfx .	mainContainer := (self createAlignmentMorph: 770@420) listDirection: #leftToRight. 	"building the container for the warnings"	warningContainer := self createAlignmentMorph: 350@170.	obstacleButton := self createIconicButton: (localGfx at: 'obstacle') withActionSelector: #actionSelectorObstacle.	forkButton 		:= self createIconicButton: (localGfx at: 'fork') withActionSelector: #actionSelectorFork.	warningButtonContainer 	:= self createAlignmentMorph: 300@120.	warningContainerContainer := (self createAlignmentMorph: 350@180).	warningButtonContainer 	listDirection: #leftToRight;  							addMorphBack: ((self createAlignmentMorph: obstacleButton extent x@120) addMorphBack: obstacleButton; addMorphBack: (self createStringMorph: 'Hindernis')) ; 							addMorphBack: (self createAlignmentMorph: 100@10) ; "acts as spacer"							addMorphBack: ((self createAlignmentMorph: forkButton extent x@120) addMorphBack: forkButton; addMorphBack: (self createStringMorph: 'Gabelung')).	warningContainer color: (self groupColor);						addMorphBack: (self createStringMorphBigAndBold: 'Warnungen');						addMorphBack: (self createAlignmentMorph: 10@20);						addMorphBack: warningButtonContainer.	warningContainerContainer addMorphBack: warningContainer.	"building the arrowbuttons along with the container that will hold the stuff"	arrowContainer := self createAlignmentMorph: 350@420.								forwardButton 	:= self createIconicButton: (localGfx at: 'forward') withActionSelector: #actionSelectorForward.	backButton 		:= self createIconicButton: (localGfx at: 'back') withActionSelector: #actionSelectorBack.	leftButton 		:= self createIconicButton: (localGfx at: 'left') withActionSelector: #actionSelectorLeft.	rightButton 	:= self createIconicButton: (localGfx at: 'right') withActionSelector: #actionSelectorRight.	topArrowContainer 		:= self createAlignmentMorph: 300@120.	middleArrowContainer 	:= self createAlignmentMorph: 300@120 .		bottomArrowContainer 	:= self createAlignmentMorph: 300@120 .			topArrowContainer addMorphBack: forwardButton ; addMorphBack: (self createStringMorph: 'schneller').	middleArrowContainer listDirection: #leftToRight;  							addMorphBack: ((self createAlignmentMorph: leftButton extent x@120) addMorphBack: leftButton; addMorphBack: (self createStringMorph: 'links')) ; 							addMorphBack: (self createAlignmentMorph: 100@10) ; "acts as spacer"							addMorphBack: ((self createAlignmentMorph: rightButton extent x@120) addMorphBack: rightButton; addMorphBack: (self createStringMorph: 'rechts')).	bottomArrowContainer addMorphBack: backButton ; addMorphBack: (self createStringMorph: 'langsamer').	arrowContainer color: (self groupColor);						addMorphBack: (self createStringMorphBigAndBold: 'Fahrtrichtung & Geschwindigkeit');						addMorphBack: (self createAlignmentMorph: 10@20);						addMorphBack: topArrowContainer; 						addMorphBack: middleArrowContainer; 						addMorphBack: bottomArrowContainer.	mainContainer addMorphBack: (self createAlignmentMorph: 20@10);						addMorphBack: warningContainerContainer; 						addMorphBack: (self createAlignmentMorph: 30@10); 						addMorphBack: arrowContainer.		self addMorphBack: mainContainer; 		label: (self myName: 'OPVisualHints'); 		setWindwoSize: 780@500; 		position: (self myPosition: 'OPVisualHints');		color: (self groupColorDarker);		openInWorld .! !!OPVisualHints methodsFor: 'as yet unclassified' stamp: 'CL 8/9/2009 17:19'!loadTrackPreviewHints: imageNameDictionary		imageNameDictionary keysAndValuesDo: 		[			:aKey :aValue | 			leftGfx at: aKey put: ((self createAlignmentMorph: 100 @ 100) 											listCentering: #center; 											color: (self groupColor );											addMorphBack: ((Form fromFileNamed: aValue) replaceColor: Color white withColor: Color transparent) asMorph;											position: 535 @ 1240;											openInWorld;											hide).			rightGfx at: aKey put: ((self createAlignmentMorph: 100 @ 100)  											listCentering: #center; 											color: (self groupColor );											addMorphBack: ((Form fromFileNamed: aValue) replaceColor: Color white withColor: Color transparent) asMorph;											position: 1015 @ 1240;											openInWorld;											hide).		].! !!OPVisualHints methodsFor: 'as yet unclassified' stamp: 'CL 9/25/2009 11:28'!sendDataToSam: data	(modelData network)	ifTrue:[modelData buttonAction: modelData buttonAction, (data asString, ';').].! !!OPVisualHints methodsFor: 'as yet unclassified' stamp: 'CL 9/4/2009 09:52'!showTrackPreviewHints: aHintString	(modelData trackPreviewHint) 	ifFalse:	[		[			modelData trackPreviewHint: true; changed. 			(leftGfx at: aHintString) show; comeToFront. 			(Delay forMilliseconds: 1500) wait. 			(leftGfx at: aHintString) hide.			modelData trackPreviewHint: false; changed. 		] fork.		[			modelData trackPreviewHint: true; changed. 			(rightGfx at: aHintString) show; comeToFront. 			(Delay forMilliseconds: 1500) wait. 			(rightGfx at: aHintString) hide.			modelData trackPreviewHint: false; changed. 		] fork.	].	! !