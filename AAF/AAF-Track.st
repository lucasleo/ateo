Object subclass: #AAFTrackAnalyzer	instanceVariableNames: 'trackPointsBitmap haveToCreateBitmap'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-Track'!!AAFTrackAnalyzer methodsFor: 'as yet unclassified' stamp: 'HM 10/5/2009 13:39'!findTrackPoints: trackFileName	| track xLoop yLoop onTrack xOffset yValues xValues trackExtent resultBlt color lineBitmap |		"I will not compare with doubles if there are exact values!!"	"greenHash := 214537420.	whiteHash := 1073741823."		yValues := OrderedCollection new.		track := Form fromBMPFileNamed: trackFileName.	trackExtent := ((track width) @ (track height)).		(haveToCreateBitmap)		ifTrue: [			trackPointsBitmap := Form new.			trackPointsBitmap setExtent: trackExtent depth: (track depth).						resultBlt := (BitBlt destForm: trackPointsBitmap  			                     sourceForm: nil			                     halftoneForm: nil			                     combinationRule: Form over			                     destOrigin: 0@0			                     sourceOrigin: 0@0			                     extent: trackExtent			                     clipRect: (0@0 extent: trackExtent)).		].	"The first 15 pixels (0-14) are used to encode track information, so we skip them."	xOffset := 15. 		"Storing the loop conditions explicitly speeds up loop iteration in Squeak. Yup, sad."	yLoop :=	(0 to: ((track height) - 1)).	xLoop := (xOffset to: ((track width) - 1)).		(yLoop)		do: [:yIndex || lBorder rBorderMaybe rBorder |								lBorder := -1.			rBorderMaybe := -1.			rBorder := -1.								xValues := OrderedCollection new.			yValues add: xValues.						onTrack := false.			(haveToCreateBitmap)				ifTrue: [					"Using a new lineBitmap for every yIndex is quite inefficient. We could just draw directly on one form, if that wouldn't create runtime errors. Forms and BitBlits are notoriously bad tested in Squeak. Also, it makes some stuff easier (proper cleanup for each yIndex, at least)."					lineBitmap := Form new.					lineBitmap setExtent: ((track width) @ 1) depth: (track depth).					resultBlt sourceForm: lineBitmap.				].			(xLoop)				do: [:xIndex|								color := (track colorAt: (xIndex @ yIndex)).										((onTrack not) and: [self isWhiteish: color])						ifTrue: [							lBorder := xIndex.							onTrack := true.						].										(onTrack and: [self isWhiteish: color])						ifTrue: [							rBorderMaybe := xIndex.						].										(onTrack and: [self isGreenish: color])						ifTrue: [							rBorder := rBorderMaybe.							onTrack := false.														xValues add: (lBorder to: rBorder).														(haveToCreateBitmap)								ifTrue: [									"lineBitmap fillGray."									lineBitmap colorAt: (lBorder @ 0) put: (Color red);									           colorAt: (rBorder @ 0) put: (Color red);									           colorAt: ((lBorder + ((rBorder - lBorder) * 0.50)) @ 0) put: (Color yellow).																		resultBlt destOrigin: (0 @ yIndex).									resultBlt copyBits.								].														lBorder := -1.							rBorder := -1. 						].           				].		].	^yValues! !!AAFTrackAnalyzer methodsFor: 'as yet unclassified' stamp: 'HM 10/5/2009 02:29'!haveToCreateBitmap: aBoolean	haveToCreateBitmap := aBoolean.! !!AAFTrackAnalyzer methodsFor: 'as yet unclassified' stamp: 'HM 10/5/2009 02:29'!initialize	super initialize.	trackPointsBitmap := Form new.	haveToCreateBitmap := false.! !!AAFTrackAnalyzer methodsFor: 'as yet unclassified' stamp: 'HM 10/5/2009 01:26'!isGreenish: aColor	^((aColor red > 0.15) and: [(aColor red < 0.25) and:	  [(aColor green > 0.55) and: [(aColor green < 0.65) and:	  [(aColor blue > 0.15) and: [(aColor blue < 0.35)]]]]])! !!AAFTrackAnalyzer methodsFor: 'as yet unclassified' stamp: 'HM 10/5/2009 01:13'!isWhiteish: aColor	| threshold |		threshold := 0.9.		^((aColor red > threshold) and:	  [aColor green > threshold] and:	  [aColor blue > threshold])! !!AAFTrackAnalyzer methodsFor: 'as yet unclassified' stamp: 'HM 10/5/2009 02:22'!trackPointsBitmap	^trackPointsBitmap! !