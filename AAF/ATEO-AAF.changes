'From Squeak3.9alpha of 4 July 2005 [latest update: #7054] on 7 September 2006 at 11:22:45 pm'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."Smalltalk condenseSources.SystemVersion current version: 'Squeak3.9gamma'; date: '23 July 2006'.self inform: 'The version number for this image hasnow been advanced to Squeak3.9gamma.'!----End fileIn of a stream----!"empty cs to bump cs number to 7056"!----End fileIn of a stream----!----SNAPSHOT----an Array(7 September 2006 11:23:23 pm) Squeak3.9b-7053.image priorSource: 0!----QUIT/NOSAVE----an Array(7 September 2006 11:23:29 pm) Squeak3.9b-7053.image priorSource: 670!----STARTUP----an Array(7 September 2006 11:23:48 pm) as Macintosh:Users:ducasse:Desktop:Squeak3.9b-7053:Squeak3.9b-7053.image!----SNAPSHOT----an Array(7 September 2006 11:28:13 pm) Squeak3.9b-7056.image priorSource: 670!----QUIT/NOSAVE----an Array(7 September 2006 11:28:23 pm) Squeak3.9b-7056.image priorSource: 993!----STARTUP----an Array(7 September 2006 11:28:50 pm) as Macintosh:Users:ducasse:Desktop:Squeak3.9g-7056:Squeak3.9b-7056.image!----SNAPSHOT----an Array(7 September 2006 11:28:55 pm) Squeak3.9g-7056.image priorSource: 993!----QUIT/NOSAVE----an Array(7 September 2006 11:29 pm) Squeak3.9g-7056.image priorSource: 1318!----STARTUP----an Array(7 September 2006 11:29:10 pm) as Macintosh:Users:ducasse:Desktop:Squeak3.9g-7056:Squeak3.9g-7056.image!----QUIT----an Array(7 September 2006 11:30 pm) Squeak3.9g-7056.image priorSource: 1318!----STARTUP----an Array(10 September 2006 8:06:33 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7057/Squeak3.9g-7056.image!!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/8/2006 20:59'!cleaningCS	"self new cleaningCS" 	 	ChangeSorter removeChangeSetsNamedSuchThat: [:each | true].	ChangeSet resetCurrentToNewUnnamedChangeSet ! !!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/8/2006 20:59' prior: 29494449!currentPackages	"ScriptLoader new currentPackages" 			| copies |	copies := MCWorkingCopy allManagers asSortedCollection:		[ :a :b | a package name <= b package name ].	^ copies select: [:each | '*Plus*' match: each package name ].! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/8/2006 21:06'!script84	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.96.mczSystemChangeNotification-Tests-sd.5.mczTests-md.17.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-al.224.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/8/2006 20:55'!script84Log	"adding way to reset current CS"! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/8/2006 20:53'!updateFrom7056	"self new updateFrom7056"			self script84.	"include changeset extension"	self cleaningCS.		self flushCaches.! !"ScriptLoader"!!ChangeSet class methodsFor: 'current changeset' stamp: 'sd 9/8/2006 21:05'!resetCurrentToNewUnnamedChangeSet 	current := self new.  	self newChanges: current ! !"System"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.305.mcz') load.ScriptLoader new updateFrom7056.!----End fileIn of a stream----!----SNAPSHOT----an Array(10 September 2006 8:13:08 pm) Squeak3.9g-7056.image priorSource: 1641!----SNAPSHOT----an Array(10 September 2006 8:13:23 pm) Squeak3.9g-7057.image priorSource: 4851!----QUIT----an Array(10 September 2006 8:13:29 pm) Squeak3.9g-7057.image priorSource: 4948!----STARTUP----an Array(14 September 2006 9:30:35 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7057/Squeak3.9g-7057.image!!ScriptLoader methodsFor: 'private helpers' stamp: 'sd 9/14/2006 20:33' prior: 29495067!generateCS: extensionAndNumber fromUpdate: updateNumber on: st		st nextPutAll:'"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: ''http://source.squeakfoundation.org/39a''                user: ''''                password: ''''.(repository loadVersionFromFileNamed:' .	st nextPut: $' ; nextPutAll: 'ScriptLoader', extensionAndNumber, '.mcz'') load.'; cr.	st nextPutAll: 'ScriptLoader new updateFrom', (updateNumber-1) asString; nextPutAll: '.' ; cr.	st nextPutAll: '!!'.	^ st contents! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/14/2006 20:33'!script85	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.97.mczSystemChangeNotification-Tests-sd.5.mczTests-md.17.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-al.224.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/14/2006 21:10'!updateFrom7057	"self new updateFrom7057"			self script85.	"fix windowColorRegistry"	ServicePreferences wipe.	ServiceRegistry rebuild.	WindowColorRegistry refresh.	self cleaningCS.		self flushCaches.! !"ScriptLoader"!!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:07' prior: 50891697!refresh	"This is a one-time only method for bootstraping the new registry. Here we will scan all classes for #windowColorSpecification methods and register those to the registry"	registry := nil.	((self systemNavigation allClassesImplementing: #windowColorSpecification)		collect: [:aClass | aClass theNonMetaClass windowColorSpecification])		do: [:spec | self registerColorSpecification: spec toClassNamed: spec classSymbol ].! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:11' prior: 50892769!registry	^registry ifNil: [registry := Dictionary new].! !!WindowColorRegistry class methodsFor: 'registry' stamp: 'sd 9/14/2006 20:11'!unregisterColorSpecificationForClassNamed: aClassName		self registry removeKey: aClassName asSymbol ! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:12' prior: 27893618!setWindowColorFor: modelSymbol to: incomingColor	| aColor aPrefSymbol aColorSpec |	aColorSpec := WindowColorRegistry registeredWindowColorSpecFor: modelSymbol.	aColorSpec ifNil: [^self].	aColor := incomingColor asNontranslucentColor.	(aColor = ColorPickerMorph perniciousBorderColor or: [aColor = Color black]) 		ifTrue: [^ self].		aPrefSymbol :=  self windowColorPreferenceForClassNamed: aColorSpec classSymbol.	self 		addPreference: aPrefSymbol  		categories:  { #'window colors' }		default:  aColor 		balloonHelp: aColorSpec helpMessage translated		projectLocal: false		changeInformee: nil		changeSelector: nil		viewRegistry: (PreferenceViewRegistry registryOf: #windowColorPreferences)! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:13' prior: 27894402!windowColorFor: aModelClassName	| classToCheck prefSymbol |	self checkForWindowColors.	classToCheck := Smalltalk at: aModelClassName.	prefSymbol := self windowColorPreferenceForClassNamed: classToCheck name.	[(classToCheck ~~ Object) and: [(self preferenceAt: prefSymbol) isNil]]		whileTrue: 				[classToCheck := classToCheck superclass.				prefSymbol := self windowColorPreferenceForClassNamed: classToCheck name].	^self valueOfPreference: prefSymbol ifAbsent: [Color white].! !!Preferences class methodsFor: 'window colors' stamp: 'sd 9/14/2006 20:14' prior: 27896694!windowSpecificationPanel	"Put up a panel for specifying window colors"	"Preferences windowSpecificationPanel"	| aPanel buttonRow aButton aRow aSwatch aColor aWindow aMiniWorld aStringMorph |	aPanel := AlignmentMorph newColumn hResizing: #shrinkWrap; vResizing: #shrinkWrap;		layoutInset: 0.	aPanel addMorph: (buttonRow := AlignmentMorph newRow color: (aColor := Color tan lighter)).		buttonRow addTransparentSpacerOfSize: 2@0.	buttonRow addMorphBack: (SimpleButtonMorph new label: '?'; target: self; actionSelector: #windowColorHelp; setBalloonText: 'Click for an explanation of this panel'; color: Color veryVeryLightGray; yourself).	buttonRow addTransparentSpacerOfSize: 8@0.	#(	('Bright' 	installBrightWindowColors	yellow					'Use standard bright colors for all windows.')		('Pastel'		installPastelWindowColors	paleMagenta					'Use standard pastel colors for all windows.')		('White'	installUniformWindowColors		white					'Use white backgrounds for all standard windows.')) do:		[:quad |			aButton := (SimpleButtonMorph new target: self)				label: quad first;				actionSelector: quad second;				color: (Color colorFrom: quad third);				setBalloonText: quad fourth;				yourself.			buttonRow addMorphBack: aButton.			buttonRow addTransparentSpacerOfSize: 10@0].	self windowColorTable do:		[:colorSpec | 			aRow _ AlignmentMorph newRow color: aColor.			aSwatch _ ColorSwatch new				target: self;				getSelector: #windowColorFor:;				putSelector: #setWindowColorFor:to:;				argument: colorSpec classSymbol;				extent: (40 @ 20);				setBalloonText: 'Click here to change the standard color to be used for ', colorSpec wording, ' windows.';				yourself.			aRow addMorphFront: aSwatch.			aRow addTransparentSpacerOfSize: (12 @ 1).			aRow addMorphBack: (aStringMorph := StringMorph contents: colorSpec wording font: TextStyle defaultFont).			aStringMorph setBalloonText: colorSpec helpMessage.			aPanel addMorphBack: aRow].	 Smalltalk isMorphic                ifTrue:                        [aWindow := aPanel wrappedInWindowWithTitle: 'Window Colors'.					" don't allow the window to be picked up by clicking inside "					aPanel on: #mouseDown send: #yourself to: aPanel.					self currentWorld addMorphCentered: aWindow.					aWindow activateAndForceLabelToShow ]                ifFalse:                        [(aMiniWorld := MVCWiWPasteUpMorph newWorldForProject: nil)						addMorph: aPanel.                           aMiniWorld startSteppingSubmorphsOf: aPanel.                        MorphWorldView openOn: aMiniWorld                                label: 'Window Colors'                                extent: aMiniWorld fullBounds extent]! !"System"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.309.mcz') load.ScriptLoader new updateFrom7057.!----End fileIn of a stream----!----SNAPSHOT----an Array(14 September 2006 9:32:22 pm) Squeak3.9g-7058.image priorSource: 5045!----QUIT/NOSAVE----an Array(14 September 2006 9:32:27 pm) Squeak3.9g-7058.image priorSource: 13446!----STARTUP----an Array(22 September 2006 2:45:56 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7058 2/Squeak3.9g-7058.image!!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/18/2006 13:29'!updateFrom7058	"self new updateFrom7058"			(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . ! !"ScriptLoader"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.310.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!'From Squeak3.9gamma of ''23 July 2006'' [latest update: #7059] on 18 September 2006 at 1:43:17 pm'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . !----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/22/2006 13:46'!script86	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.99.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/22/2006 13:46' prior: 33568303!updateFrom7058	"self new updateFrom7058"	self script86.	self flushCaches.	! !"ScriptLoader"!!ChangeSetClassChangesTest methodsFor: 'testing' stamp: 'wiz 8/13/2006 17:55'!testInitialChangeSet	"Run this to assure the initial changeset is named. Checks bug found in 3.9 7052."	"self new testInitialChangeSet"	"self run:  #testInitialChangeSet"	self deny: (ChangeSet current printString = 'a ChangeSet named <no name -- garbage?>') .	^true! !!ChangeSet class methodsFor: 'current changeset' stamp: 'wiz 9/19/2006 03:21' prior: 18299908!current	"return the current changeset	assure first that we have a named changeset. To cure mantis #4535. "	current isMoribund		ifTrue: [(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed'))] .	^ current! !!RequiredSelectors methodsFor: 'access to cache' stamp: 'dvf 9/18/2006 22:04' prior: 28614021!calculateForClass: aClass 	| rscc |	self clearOut: aClass.	rscc := RequiredSelectorsChangesCalculator onModificationOf: { aClass }				withTargets: { aClass }.	rscc doWork! !!ATestCase methodsFor: 'as yet unclassified' stamp: 'dvf 9/18/2006 21:28'!testRequirement  "  self debug: #testRequirement  "  | class |  class := Object            subclass: #AClassForTest            instanceVariableNames: ''            classVariableNames: ''            poolDictionaries: ''            category: self class category.  [   class compile: 'call                    ^ self isCalled'.   self assert: (class requiredSelectors includes: #isCalled).   class compile: 'isCalled                    ^ 1'.   "Fail here:"   self deny: (class requiredSelectors includes: #isCalled)]  ensure: [class removeFromSystem] ! !"System"!"Tests"!"Traits"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.311.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!!AClassForTest methodsFor: 'as yet unclassified' stamp: 'sd 9/22/2006 14:49'!call                    ^ self isCalled! !!AClassForTest methodsFor: 'as yet unclassified' stamp: 'sd 9/22/2006 14:49'!isCalled                    ^ 1! !Smalltalk removeClassNamed: #AClassForTest!testRequirement  "  self debug: #testRequirement!!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/18/2006 13:29' prior: 33570915!updateFrom7058	"self new updateFrom7058"			(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . ! !ScriptLoader removeSelector: #script86!"ScriptLoader"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.310.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!'From Squeak3.9gamma of ''23 July 2006'' [latest update: #7059] on 18 September 2006 at 1:43:17 pm'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . !----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/22/2006 13:46'!script86	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.99.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/22/2006 13:46' prior: 33573645!updateFrom7058	"self new updateFrom7058"	self script86.	self flushCaches.	! !"ScriptLoader"!----QUIT/NOSAVE----an Array(22 September 2006 2:53:01 pm) Squeak3.9g-7058.image priorSource: 13446!----STARTUP----an Array(22 September 2006 2:53:09 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7058 2/Squeak3.9g-7058.image!!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/18/2006 13:29'!updateFrom7058	"self new updateFrom7058"			(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . ! !"ScriptLoader"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.310.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!'From Squeak3.9gamma of ''23 July 2006'' [latest update: #7059] on 18 September 2006 at 1:43:17 pm'!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed')) . !----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 9/22/2006 13:46'!script86	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-md.53.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-md.47.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-md.112.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.99.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 9/22/2006 13:46' prior: 33576725!updateFrom7058	"self new updateFrom7058"	self script86.	self flushCaches.	! !"ScriptLoader"!!ChangeSetClassChangesTest methodsFor: 'testing' stamp: 'wiz 8/13/2006 17:55'!testInitialChangeSet	"Run this to assure the initial changeset is named. Checks bug found in 3.9 7052."	"self new testInitialChangeSet"	"self run:  #testInitialChangeSet"	self deny: (ChangeSet current printString = 'a ChangeSet named <no name -- garbage?>') .	^true! !!ChangeSet class methodsFor: 'current changeset' stamp: 'wiz 9/19/2006 03:21' prior: 18299908!current	"return the current changeset	assure first that we have a named changeset. To cure mantis #4535. "	current isMoribund		ifTrue: [(ChangeSet newChanges: (ChangeSet assuredChangeSetNamed: 'Unnamed'))] .	^ current! !!RequiredSelectors methodsFor: 'access to cache' stamp: 'dvf 9/18/2006 22:04' prior: 28614021!calculateForClass: aClass 	| rscc |	self clearOut: aClass.	rscc := RequiredSelectorsChangesCalculator onModificationOf: { aClass }				withTargets: { aClass }.	rscc doWork! !!ATestCase methodsFor: 'as yet unclassified' stamp: 'dvf 9/18/2006 21:28'!testRequirement  "  self debug: #testRequirement  "  | class |  class := Object            subclass: #AClassForTest            instanceVariableNames: ''            classVariableNames: ''            poolDictionaries: ''            category: self class category.  [   class compile: 'call                    ^ self isCalled'.   self assert: (class requiredSelectors includes: #isCalled).   class compile: 'isCalled                    ^ 1'.   "Fail here:"   self deny: (class requiredSelectors includes: #isCalled)]  ensure: [class removeFromSystem] ! !"System"!"Tests"!"Traits"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.311.mcz') load.ScriptLoader new updateFrom7058.!----End fileIn of a stream----!----SNAPSHOT----an Array(22 September 2006 2:56:15 pm) Squeak3.9g-7061.image priorSource: 13446!----SNAPSHOT----an Array(22 September 2006 2:56:23 pm) Squeak3.9g-7061.image priorSource: 27219!----QUIT/NOSAVE----an Array(22 September 2006 2:56:29 pm) Squeak3.9g-7061.image priorSource: 27317!----STARTUP----an Array(14 October 2006 10:29:19 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9g-7061/Squeak3.9g-7061.image!'From Squeak3.8 of ''5 May 2005'' [latest update: #6665] on 13 October 2006 at 1:46:42 pm'!----End fileIn of a stream----!"Installed SUnit auto version 14".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: '26bea8bf-733f-4715-b188-fa6d848984ad' autoVersion: '14' asVersion atSeconds: 3338274597 number: 3]!!SMLoader commentStamp: '<historical>' prior: 28830228!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance), you can open one with:	SMLoader open!!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:14' prior: 28832242!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := model isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(model directory directoryEntryFor: model lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoader methodsFor: 'gui building' stamp: 'gk 9/25/2006 23:13' prior: 28845150!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease.	item ifNil: [^nil].	dir := item isPackage				ifTrue: [model cache directoryForPackage: item]				ifFalse: [model cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:12' prior: 28850838!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	 	| list first |	list := (((model categories select:[:each | each parent == nil]) asArray 		sort:[:c1 :c2 | c1 name <= c2 name])).	first := list detect:[:any | any name = 'Squeak versions'] ifNone:[nil].	first ifNotNil:[		list := list copyWithout: first.		list := {first}, list].	^list collect:[:cat | SMCategoryWrapper with: cat model: self].! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 9/25/2006 23:13' prior: 28841017!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('display only auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('display only new available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('display only new safely available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('display only installed packages' #filterInstalled 'display only packages that are installed.')	#('display only published packages' #filterPublished 'display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'display only packages in ', (model object: catId) name. catId. 'display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:41' prior: 28856889!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: aRelease) install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:25' prior: 28856648!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:12' prior: 28837324!loadUpdates	[Cursor wait showWhile: [		model loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 01:02' prior: 28857752!noteChanged	filters ifNil: [^self reOpen].	model ifNotNil: [		packagesList := nil.		selectedCategoryWrapper := nil.		self changed: #categoryWrapperList.		self changed: #packageWrapperList.		self changed: #packagesListIndex.	"update my selection"		self contentsChanged]! !!SMLoader methodsFor: 'initialization' stamp: 'gk 9/25/2006 23:12' prior: 28850564!on: aSqueakMap 	"Initialize instance."	model := aSqueakMap.	model synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13' prior: 28851422!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				filters allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (model object: currFilter)]]]].	selectedCategoryWrapper ifNil:[self updateLabel: list. ^list].	selectedCategory := selectedCategoryWrapper category.	list := list select: [:each | self package: each filteredByCategory: selectedCategory].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'private' stamp: 'gk 9/25/2006 23:12' prior: 28858069!packages	"We request the packages as sorted by name by default."	^model packagesByName asArray! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13' prior: 28852607!updateLabel: packagesShown	"Update the label of the window."	self setLabel: 'SqueakMap Package Loader (', packagesShown size printString,			'/', model packages size printString, ')'! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/26/2006 00:40' prior: 28838431!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				model upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:40' prior: 28858774!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					model upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [model upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !"SMLoader"!"Installed SqueakMap2 loader auto version 10".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3' autoVersion: '10' asVersion atSeconds: 3338274602 number: 4]!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."SMSqueakMap default loadUpdates; upgradeOldPackages; purge.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/13/2006 19:11'!script87	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-lr.56.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.113.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-md.32.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/13/2006 19:11'!script87Log	"Name: KernelTests-lr.49Author: lrTime: 5 October 2006, 10:16:34 amUUID: 762d5c23-0364-4c26-ba13-129327ea7f39Ancestors: KernelTests-lr.48- merged code to fix unknown pragma selectors and binary selectors in pragmas- don't allow class names in pragmas (to be consistent)- use pragmas to define primitive-pragmas- added some testsName: Compiler-lr.56Author: lrTime: 5 October 2006, 10:14:04 amUUID: f429f722-c39f-4acf-9d8c-c8a38320eaa8Ancestors: Compiler-lr.55- merged code to fix unknown pragma selectors- don't allow class names in pragmas (to be consistent)- use pragmas to define primitive-pragmasMorphic fix duplicateChange Set:		ToggleBreakFix39Date:			26 September 2006Author:			tim@rowledge.orgPutative fix for Mantis http://bugs.impara.de/view.php?id=5123Fix Squeakmap"! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/13/2006 19:19'!updateFrom7061	"self new updateFrom7061"	self script87.	self flushCaches.	! !"ScriptLoader"!!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:48' prior: 26575366!addPragma: aPragma	self properties addPragma: aPragma! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47' prior: 26575484!pragmaLiteral	"Read a pragma literal."	(hereType == #string or: [ hereType == #literal or: [ hereType == #number ] ])		ifTrue: [ ^ self advance ].	(here == $# and: [ tokenType == #word ])		ifTrue: [ ^ self advance ].	(here == #- and: [ tokenType == #number ])		ifTrue: [ ^ (self advance; advance) negated ].	(here = 'true' or: [ here = 'false' or: [ here = 'nil' ] ])		ifTrue: [ ^ Compiler evaluate: self advance ].	^ self expected: 'Literal constant'! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 10:04' prior: 26576048!pragmaPrimitives	| pragmas primitives |	self properties pragmas isEmpty		ifTrue: [ ^ 0 ].	pragmas := Pragma allNamed: #primitive from: self class to: Parser.	primitives := self properties pragmas select: [ :prim |		pragmas anySatisfy: [ :prag | 			prag selector = prim keyword ] ].	primitives isEmpty 		ifTrue: [ ^ 0 ].	primitives size = 1 		ifFalse: [ ^ self notify: 'Ambigous primitives' ].	^ primitives first message sendTo: self! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47' prior: 26576424!pragmaSequence	"Parse a sequence of method pragmas."		[ true ] whileTrue: [		(self matchToken: #<)			ifFalse: [ ^ self ].		self pragmaStatement.		(self matchToken: #>)			ifFalse: [ ^ self expected: '>' ] ]! !!Parser methodsFor: 'pragmas' stamp: 'lr 8/19/2006 20:39' prior: 26576701!pragmaStatement	"Read a single pragma statement. Parse all generic pragmas in the form of: <key1: val1 key2: val2 ...> and remember them, including primitives."		| selector arguments words index keyword |	(hereType = #keyword or: [ hereType = #word or: [ hereType = #binary ] ])		ifFalse: [  ^ self expected: 'pragma declaration' ].	" This is a ugly hack into the compiler of the FFI package. FFI should be changed to use propre pragmas that can be parsed with the code here. "	(here = #apicall: or: [ here = #cdecl: ])		ifTrue: [ ^ self externalFunctionDeclaration ].	selector := String new.	arguments := OrderedCollection new.	words := OrderedCollection new.	[ hereType = #keyword or: [ (hereType = #word or: [ hereType = #binary ]) and: [ selector isEmpty ] ] ] whileTrue: [		index := self startOfNextToken + requestorOffset.		selector := selector , self advance.		words add: (index to: self endOfLastToken + requestorOffset).		(selector last = $: or: [ selector first isLetter not ])			ifTrue: [ arguments add: self pragmaLiteral ] ].	selector numArgs ~= arguments size		ifTrue: [ ^ self expected: 'pragma argument' ].	(Symbol hasInterned: selector 		ifTrue: [ :value | keyword := value]) 		ifFalse: [ 			keyword := self 				correctSelector: selector wordIntervals: words				exprInterval: (words first first to: words last last)				ifAbort: [ ^ self fail ] ].	self addPragma: (Pragma keyword: keyword arguments: arguments asArray).	^ true! !!Parser methodsFor: 'primitives' stamp: 'lr 10/5/2006 09:50' prior: 26580110!primitive: anIntegerOrString	"Create indexed primitive."		<primitive>	^ anIntegerOrString isInteger		ifTrue: [ anIntegerOrString ]		ifFalse: [ 			anIntegerOrString isString				ifTrue: [ self primitive: anIntegerOrString module: nil ]				ifFalse: [ self expected: 'Indexed primitive' ] ]! !!Parser methodsFor: 'primitives' stamp: 'lr 10/5/2006 09:51' prior: 26580460!primitive: aNameString module: aModuleStringOrNil	"Create named primitive."		<primitive>	(aNameString isString and: [ aModuleStringOrNil isNil or: [ aModuleStringOrNil isString ] ])		ifFalse: [ ^ self expected: 'Named primitive' ].	self allocateLiteral: (Array 		with: (aModuleStringOrNil isNil 			ifFalse: [ aModuleStringOrNil asSymbol ])		with: aNameString asSymbol		with: 0 with: 0).	^ 117! !!Parser methodsFor: 'pragmas' stamp: 'lr 10/5/2006 09:47' prior: 26577682!properties	^ properties ifNil: [ properties := MethodProperties new ]! !!BreakpointManager class methodsFor: 'install-uninstall' stamp: 'tpr 9/26/2006 16:14' prior: 17771108!installInClass: aClass selector: aSymbol 	"Install a new method containing a breakpoint.	The receiver will remember this for unstalling it later"	| breakMethod |	breakMethod _ self compilePrototype: aSymbol in: aClass.	breakMethod isNil		ifTrue: [^ nil].	self installed at: breakMethod put: aClass >> aSymbol. "old method"	aClass class basicAddSelector: aSymbol withMethod: breakMethod.! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 8/19/2006 20:44'!testCompileBinary	self assertPragma: ' = 1' givesKeyword: #= arguments: #( 1 ).	self assertPragma: ' , 3' givesKeyword: #, arguments: #( 3 ).	self assertPragma: ' > 4' givesKeyword: #> arguments: #( 4 ).	self assertPragma: ' < 5' givesKeyword: #< arguments: #( 5 ).	self assertPragma: ' == 1' givesKeyword: #== arguments: #( 1 ).	self assertPragma: ' <> 3' givesKeyword: #<> arguments: #( 3 ).	self assertPragma: ' >< 4' givesKeyword: #>< arguments: #( 4 ).	self assertPragma: ' ** 5' givesKeyword: #** arguments: #( 5 )! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 10/5/2006 10:15' prior: 24466852!testCompileInvalid	"Invalid pragmas should properly raise an error."	self should: [ self compile: '<>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<1>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<#123>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo bar>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo 1>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo bar zork>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo bar 1>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo: bar:>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo: #bar: zork:>' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<<1>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<=2>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '< =1 = >' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '< =1 =2 >' selector: #zork ] raise: SyntaxErrorNotification.		self should: [ self compile: '<foo: String>' selector: #zork ] raise: SyntaxErrorNotification.	self should: [ self compile: '<foo: Pragma>' selector: #zork ] raise: SyntaxErrorNotification! !!MethodPragmaTest methodsFor: 'testing-compiler' stamp: 'lr 10/5/2006 09:49' prior: 24469260!testCompileValue	self assertPragma: 'foo: true' givesKeyword: #foo: arguments: #( true ).	self assertPragma: 'foo: false' givesKeyword: #foo: arguments: #( false ).	self assertPragma: 'foo: nil' givesKeyword: #foo: arguments: #( nil )! !!SMLoader commentStamp: '<historical>' prior: 33582520!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance), you can open one with:	SMLoader open!!SMLoader methodsFor: 'actions' stamp: 'gk 5/5/2006 02:05' prior: 33582749!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := squeakMap isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(squeakMap directory directoryEntryFor: squeakMap lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoader methodsFor: 'gui building' stamp: 'gk 5/5/2006 02:05' prior: 33583415!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease.	item ifNil: [^nil].	dir := item isPackage				ifTrue: [squeakMap cache directoryForPackage: item]				ifFalse: [squeakMap cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'lists' stamp: 'gk 7/12/2004 01:16' prior: 33583905!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	 	| list first |	list := (((squeakMap categories select:[:each | each parent == nil]) asArray 		sort:[:c1 :c2 | c1 name <= c2 name])).	first := list detect:[:any | any name = 'Squeak versions'] ifNone:[nil].	first ifNotNil:[		list := list copyWithout: first.		list := {first}, list].	^list collect:[:cat | SMCategoryWrapper with: cat model: self].! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 7/13/2004 15:49' prior: 33584511!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('display only auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('display only new available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('display only new safely available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('display only installed packages' #filterInstalled 'display only packages that are installed.')	#('display only published packages' #filterPublished 'display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'display only packages in ', (squeakMap object: catId) name. catId. 'display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'private' stamp: 'gk 7/11/2004 04:07' prior: 33585646!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: aRelease) install.		myRelease = self installedReleaseOfMe ifFalse: [self reOpen].		self noteChanged]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'private' stamp: 'gk 7/11/2004 03:58' prior: 33586541!installedReleaseOfMe	"Return the release of the installed package loader."	^squeakMap installedReleaseOf: (squeakMap packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/10/2004 18:51' prior: 33586817!loadUpdates	[Cursor wait showWhile: [		squeakMap loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoader methodsFor: 'private' stamp: 'gk 7/13/2004 17:07' prior: 33587103!noteChanged	packagesList := nil.	selectedCategoryWrapper := nil.	filters ifNil: [^self reOpen].	self changed: #categoryWrapperList.	self changed: #packageWrapperList.	self changed: #packagesListIndex.	"update my selection"	self contentsChanged! !!SMLoader methodsFor: 'initialization' stamp: 'gk 5/5/2006 02:05' prior: 33587467!on: aSqueakMap 	"Initialize instance."	squeakMap := aSqueakMap.	squeakMap synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoader methodsFor: 'lists' stamp: 'gk 7/13/2004 17:10' prior: 33587747!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				filters allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (squeakMap object: currFilter)]]]].	selectedCategoryWrapper ifNil:[self updateLabel: list. ^list].	selectedCategory := selectedCategoryWrapper category.	list := list select: [:each | self package: each filteredByCategory: selectedCategory].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'private' stamp: 'gk 11/18/2003 02:24' prior: 33588552!packages	"We request the packages as sorted by name by default."	^squeakMap packagesByName asArray! !!SMLoader methodsFor: 'lists' stamp: 'gk 7/13/2004 17:10' prior: 33588729!updateLabel: packagesShown	"Update the label of the window."	self setLabel: 'SqueakMap Package Loader (', packagesShown size printString,			'/', squeakMap packages size printString, ')'! !!SMLoader methodsFor: 'actions' stamp: 'gk 7/13/2004 15:25' prior: 33588995!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := squeakMap installedPackages.	old := squeakMap oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := squeakMap upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				squeakMap upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe ifFalse: [self reOpen].				self noteChanged]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'private' stamp: 'gk 5/5/2006 02:05' prior: 33590719!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := squeakMap installedPackages.	old := squeakMap oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := squeakMap upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					squeakMap upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [squeakMap upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe ifFalse: [self reOpen].				self noteChanged]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!Morph methodsFor: 'halos and balloon help' stamp: 'zz 9/28/2006 18:53' prior: 24733634!balloonHelpTextForHandle: aHandle 	"Answer a string providing balloon help for the	given halo handle"	| itsSelector |	itsSelector := aHandle eventHandler firstMouseSelector.	itsSelector == #doRecolor:with:		ifTrue: [^ Preferences propertySheetFromHalo				ifTrue: ['Open a property sheet.']				ifFalse: ['Change color']].	itsSelector == #mouseDownInDimissHandle:with:		ifTrue: [^ Preferences preserveTrash				ifTrue: ['Move to trash']				ifFalse: ['Remove from screen']].	#(#(#addFullHandles 'More halo handles') #(#addSimpleHandles 'Fewer halo handles') #(#chooseEmphasisOrAlignment 'Emphasis & alignment') #(#chooseFont 'Change font') #(#chooseNewGraphicFromHalo 'Choose a new graphic') #(#chooseStyle 'Change style') #(#dismiss 'Remove') #(#doDebug:with: 'Debug') #(#doDirection:with: 'Choose forward direction') #(#doDup:with: 'Duplicate') #(#doMakeSibling:with: 'Make a sibling') #(#doMenu:with: 'Menu') #(#doGrab:with: 'Pick up') #(#editButtonsScript 'See the script for this button') #(#editDrawing 'Repaint') #(#doDupOrMakeSibling:with: 'Duplicate (press shift to make a sibling)') #(#doMakeSiblingOrDup:with: 'Make a sibling (press shift to make simple duplicate)') #(#makeNascentScript 'Make a scratch script') #(#makeNewDrawingWithin 'Paint new object') #(#mouseDownInCollapseHandle:with: 'Collapse') #(#mouseDownOnHelpHandle: 'Help') #(#openViewerForArgument 'Open a Viewer for me. Press shift for a snapshot.') #(#openViewerForTarget:with: 'Open a Viewer for me. Press shift for a snapshot.') #(#paintBackground 'Paint background') #(#prepareToTrackCenterOfRotation:with: 'Move object or set center of rotation') #(#presentViewMenu 'Present the Viewing menu') #(#startDrag:with: 'Move') #(#startGrow:with: 'Change size') #(#startRot:with: 'Rotate') #(#startScale:with: 'Change scale') #(#tearOffTile 'Make a tile representing this object') #(#tearOffTileForTarget:with: 'Make a tile representing this object') #(#trackCenterOfRotation:with: 'Set center of rotation') )		do: [:pair | itsSelector == pair first				ifTrue: [^ pair last]].	^ 'unknown halo handle'translated! !"Compiler"!"KernelTests"!"Morphic"!"SMLoader"!"System"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.316.mcz') load.ScriptLoader new updateFrom7061.!----End fileIn of a stream----!'From Squeak3.8 of ''5 May 2005'' [latest update: #6665] on 13 October 2006 at 1:46:42 pm'!----End fileIn of a stream----!----SNAPSHOT----an Array(14 October 2006 10:37 am) Squeak3.9-RC2-7063.image priorSource: 27317!----SNAPSHOT----an Array(14 October 2006 10:38:53 am) Squeak3.9-RC2-7063.image priorSource: 61467!'From Squeak3.9gamma of ''23 July 2006'' [latest update: #7061] on 5 October 2006 at 12:48:11 pm'!----End fileIn of a stream----!----SNAPSHOT----an Array(14 October 2006 10:40:44 am) Squeak3.9-RC2-7063.image priorSource: 61564!----QUIT/NOSAVE----an Array(14 October 2006 10:41:14 am) Squeak3.9-RC2-7063.image priorSource: 61797!----STARTUP----an Array(14 October 2006 10:41:44 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7063/Squeak3.9-RC2-7063.image!----QUIT/NOSAVE----an Array(14 October 2006 10:41:52 am) Squeak3.9-RC2-7063.image priorSource: 61797!----STARTUP----an Array(14 October 2006 10:58:15 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7063/Squeak3.9-RC2-7063.image!----QUIT/NOSAVE----an Array(14 October 2006 11:03:12 am) Squeak3.9-RC2-7063.image priorSource: 61797!----STARTUP----an Array(14 October 2006 11:03:23 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7063/Squeak3.9-RC2-7063.image!installingDefaultRepositoriesToPackages	"self new installingDefaultRepositoriesToPackages!!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:07' prior: 29509092!installRepository: aString for: packageName	(MCWorkingCopy allManagers select: [:each | each package name = packageName])		first repositoryGroup		addRepository: (MCHttpRepository new location: aString ; user: 'squeak' ; password: 'squeak')		! !installingDefaultRepositoriesToPackages	"self new installingDefaultRepositoriesToPackages!!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:08' prior: 29508560!installInBoxAnd39	"self new installInBoxAnd39"		MCWorkingCopy allManagers do: [:each | 		each  repositoryGroup			addRepository: (MCHttpRepository new location: 'http://source.squeakfoundation.org/39a' ; user: ''; password: '');			addRepository: (MCHttpRepository new location: 'http://source.squeakfoundation.org/inbox' ; user: '' ; password: '')].		! !installInBoxAnd39	"self new installInBoxAnd39!installInBoxAnd39	"self new installInBoxAnd39"		MCWorkingCopy allManagers!!ScriptLoader methodsFor: 'cleaning' stamp: 'sd 10/14/2006 11:12' prior: 29503230!cleanOldRepositories	"self new cleanOldRepositories"	"does not work since the interface of the repository group is not made for removing a repository only based on name"		MCWorkingCopy allManagers do: [:each | 		each  repositoryGroup			removeRepository: (MCHttpRepository new location: 'http://kilana.unibe.ch:8888/Monticello');			removeRepository: (MCHttpRepository new location: 'http://modules.squeakfoundation.org/People/gk/')].	! !"ScriptLoader"!----SNAPSHOT----an Array(14 October 2006 11:15:30 am) Squeak3.9-RC2-7063.image priorSource: 61797!----QUIT/NOSAVE----an Array(14 October 2006 11:15:37 am) Squeak3.9-RC2-7063.image priorSource: 64335!----STARTUP----an Array(15 October 2006 11:15:59 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7064/Squeak3.9-RC2-7063.image!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/15/2006 11:11'!script88	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-lr.56.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.113.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/15/2006 11:11'!updateFrom7063	"self new updateFrom7063"		self script88.	SMSqueakMap default noteInstalledPackageNamed: 'SqueakMap2 loader'autoVersion: '10'.	self flushCaches.	! !"ScriptLoader"!!SMLoader commentStamp: '<historical>' prior: 33602792!A simple package loader that is currently the standard UI for SqueakMap (the model is an SMSqueakMap instance), you can open one with:	SMLoader open!!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:14' prior: 33603020!askToLoadUpdates	"Check how old the map is and ask to update it	if it is older than 10 days or if there is no map on disk."	| available |	available := model isCheckpointAvailable.	(available not or: [		(Date today subtractDate: (Date fromSeconds:			(model directory directoryEntryFor: model lastCheckpointFilename)				modificationTime)) > 3])		ifTrue: [			(self confirm: 				(available ifTrue: ['The map on disk is more than 10 days old,update it from the Internet?'] ifFalse: ['There is no map on disk,fetch it from the Internet?']))				ifTrue: [self loadUpdates]]! !!SMLoader methodsFor: 'gui building' stamp: 'gk 9/25/2006 23:13' prior: 33603697!browseCacheDirectory	"Open a FileList2 on the directory for the package or release."	| item dir win |	item := self selectedPackageOrRelease.	item ifNil: [^nil].	dir := item isPackage				ifTrue: [model cache directoryForPackage: item]				ifFalse: [model cache directoryForPackageRelease: item].	win := FileList2 morphicViewOnDirectory: dir. " withLabel: item name, ' cache directory'."	win openInWorld! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:12' prior: 33604195!categoryWrapperList	"Create the wrapper list for the hierarchical list.	We sort the categories by name but ensure that 'Squeak versions'	is first if it exists."	 	| list first |	list := (((model categories select:[:each | each parent == nil]) asArray 		sort:[:c1 :c2 | c1 name <= c2 name])).	first := list detect:[:any | any name = 'Squeak versions'] ifNone:[nil].	first ifNotNil:[		list := list copyWithout: first.		list := {first}, list].	^list collect:[:cat | SMCategoryWrapper with: cat model: self].! !!SMLoader methodsFor: 'filter utilities' stamp: 'gk 9/25/2006 23:13' prior: 33604805!filterSpecs	"Return a specification for the filter menu. Is called each time."	| specs |	specs := #(	#('display only auto-installable packages' #filterAutoInstall 'display only packages that can be installed automatically')	#('display only new available packages' #filterAvailable 'display only packages that are not installed or that have newer releases available.')	#('display only new safely available packages' #filterSafelyAvailable 'display only packages that are not installed or that have newer releases available that are safe to install, meaning that they are published and meant for the current version of Squeak.')	#('display only installed packages' #filterInstalled 'display only packages that are installed.')	#('display only published packages' #filterPublished 'display only packages that have at least one published release.'))		asOrderedCollection.	categoriesToFilterIds do: [:catId |		specs add: {'display only packages in ', (model object: catId) name. catId. 'display only packages that are in the category.'}].	^ specs! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:41' prior: 33605944!installPackageRelease: aRelease	"Install a package release. The cache is used."	| myRelease |	aRelease isCompatibleWithCurrentSystemVersion ifFalse:		[(self confirm:'The package you are about to install is not listed asbeing compatible with your image version (', SystemVersion current majorMinorVersion, '),so the package may not work properly.Do you still want to proceed with the install?')			ifFalse: [^ self]].	myRelease := self installedReleaseOfMe.	[Cursor wait showWhile: [		(SMInstaller forPackageRelease: aRelease) install.		myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]	] on: Error do: [:ex |		| msg |		msg := ex messageText ifNil:[ex asString].		self informException: ex msg: ('Error occurred during install:\', msg, '\') withCRs].! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:25' prior: 33606822!installedReleaseOfMe	"Return the release of the installed package loader."	^SMSqueakMap default installedReleaseOf: (SMSqueakMap default packageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3').! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/25/2006 23:12' prior: 33607078!loadUpdates	[Cursor wait showWhile: [		model loadUpdates.		self noteChanged ]	] on: Error do: [:ex |		self informException: ex msg: ('Error occurred when updating map:\', ex messageText, '\') withCRs]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 01:02' prior: 33607368!noteChanged	filters ifNil: [^self reOpen].	model ifNotNil: [		packagesList := nil.		selectedCategoryWrapper := nil.		self changed: #categoryWrapperList.		self changed: #packageWrapperList.		self changed: #packagesListIndex.	"update my selection"		self contentsChanged]! !!SMLoader methodsFor: 'initialization' stamp: 'gk 9/25/2006 23:12' prior: 33607705!on: aSqueakMap 	"Initialize instance."	model := aSqueakMap.	model synchWithDisk.	filters := DefaultFilters copy.	categoriesToFilterIds := DefaultCategoriesToFilterIds copy.	self askToLoadUpdates! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13' prior: 33607993!packageList	"Return a list of the SMPackages that should be visible	by applying all the filters. Also filter based on the currently	selected category - if any."	| list selectedCategory |	list := packagesList ifNil: [			packagesList := self packages select: [:p | 				filters allSatisfy: [:currFilter |					currFilter isSymbol						ifTrue: [(self perform: currFilter) value: p]						ifFalse: [						self package: p							filteredByCategory: (model object: currFilter)]]]].	selectedCategoryWrapper ifNil:[self updateLabel: list. ^list].	selectedCategory := selectedCategoryWrapper category.	list := list select: [:each | self package: each filteredByCategory: selectedCategory].	self updateLabel: list.	^list! !!SMLoader methodsFor: 'private' stamp: 'gk 9/25/2006 23:12' prior: 33608803!packages	"We request the packages as sorted by name by default."	^model packagesByName asArray! !!SMLoader methodsFor: 'lists' stamp: 'gk 9/25/2006 23:13' prior: 33608984!updateLabel: packagesShown	"Update the label of the window."	self setLabel: 'SqueakMap Package Loader (', packagesShown size printString,			'/', model packages size printString, ')'! !!SMLoader methodsFor: 'actions' stamp: 'gk 9/26/2006 00:40' prior: 33609254!upgradeInstalledPackages	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. So this is a conservative approach."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				model upgradeOldPackages.				self inform: toUpgrade size printString, ' packages successfully upgraded.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !!SMLoader methodsFor: 'private' stamp: 'gk 9/26/2006 00:40' prior: 33610978!upgradeInstalledPackagesConfirm: confirmEach	"Tries to upgrade all installed packages to the latest published release for this	version of Squeak. If confirmEach is true we ask for every upgrade."	| installed old myRelease toUpgrade info |	installed := model installedPackages.	old := model oldPackages.	old isEmpty ifTrue: [			^self inform: 'All ', installed size printString, ' installed packages are up to date.'].	toUpgrade := model upgradeableAndOldPackages.	toUpgrade isEmpty ifTrue: [			^self inform: 'None of the ', old size printString, ' old packages of the ', installed size printString, ' installed can be automatically upgraded. You need to upgrade them manually.'].	old size < toUpgrade size ifTrue: [		info := 'Of the ', old size printString, ' old packages only ', toUpgrade size printString, ' can be upgraded.The following packages will not be upgraded:',  (String streamContents: [:s | (old removeAll: toUpgrade; yourself)	do: [:p | s nextPutAll: p nameWithVersionLabel; cr]])]		ifFalse: [info := 'All old packages upgradeable.'].	(self confirm: info, 'About to upgrade the following packages:', (String streamContents: [:s | toUpgrade do: [:p | s nextPutAll: p nameWithVersionLabel; cr]]), 'Proceed?') ifTrue: [			myRelease := self installedReleaseOfMe.			[Cursor wait showWhile: [				confirmEach ifTrue: [					model upgradeOldPackagesConfirmBlock: [:p |						self confirm: 'Upgrade ', p installedRelease packageNameWithVersion, ' to ',							(p lastPublishedReleaseForCurrentSystemVersionNewerThan: p installedRelease) listName, '?']]						ifFalse: [model upgradeOldPackages].				self inform: toUpgrade size printString, ' packages successfully processed.'.				myRelease = self installedReleaseOfMe					ifFalse: [self reOpen]					ifTrue: [self noteChanged]]			] on: Error do: [:ex |				self informException: ex msg: ('Error occurred when upgrading old packages:\', ex messageText, '\') withCRs]]! !"SMLoader"!"Installed SqueakMap2 loader auto version 10".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: '941c0108-4039-4071-9863-a8d7d2b3d4a3' autoVersion: '10' asVersion atSeconds: 3338363798 number: 5]!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.318.mcz') load.ScriptLoader new updateFrom7063.!----End fileIn of a stream----!----SNAPSHOT----an Array(15 October 2006 11:23:41 am) Squeak3.9-RC2-7063.image priorSource: 64335!----QUIT/NOSAVE----an Array(15 October 2006 11:23:46 am) Squeak3.9-RC2-7063.image priorSource: 77325!----STARTUP----an Array(15 October 2006 11:24 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7064/Squeak3.9-RC2-7063.image!----SNAPSHOT----an Array(15 October 2006 11:24:06 am) Squeak3.9-RC2-7064.image priorSource: 77325!----QUIT/NOSAVE----an Array(15 October 2006 11:24:10 am) Squeak3.9-RC2-7064.image priorSource: 77689!----STARTUP----an Array(20 October 2006 9:37:38 pm) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC2-7064/Squeak3.9-RC2-7064.image!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/18/2006 11:37'!script89	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-md.148.mczKernelTests-lr.49.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.114.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.100.mczSystemChangeNotification-Tests-sd.5.mczTests-sd.18.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/18/2006 11:37'!updateFrom7064	"self new updateFrom7064"		self script89.	self flushCaches.	! !"ScriptLoader"!!SystemWindow methodsFor: 'initialization' stamp: 'dew 10/14/2006 18:57' prior: 31820324!initialize	"Initialize a system window. Add label, stripes, etc., if desired"	super initialize.	allowReframeHandles _ true.	labelString ifNil: [labelString _ 'Untitled Window'].	isCollapsed _ false.	activeOnlyOnTop _ true.	paneMorphs _ Array new.	borderColor _ Color lightGray.	borderWidth _ 1.	self color: Color lightGray lighter lighter lighter.	self layoutPolicy: ProportionalLayout new.		self initializeLabelArea.					self addCornerGrips.	self extent: 300 @ 200.	mustNotClose _ false.	updatablePanes _ Array new.			Preferences menuAppearance3d		ifTrue: [			self				addDropShadow;				shadowColor: (TranslucentColor r: 0.0 g: 0.0 b: 0.0 alpha: 0.333);				shadowOffset: 1@1.		].					! !!SystemWindow methodsFor: 'initialization' stamp: 'dew 10/14/2006 18:57' prior: 31822124!initializeLabelArea	"Initialize the label area (titlebar) for the window."	label _ StringMorph new contents: labelString;						 font: Preferences windowTitleFont emphasis: 0.			"Add collapse box so #labelHeight will work"			collapseBox _ self createCollapseBox.			stripes _ Array						with: (RectangleMorph newBounds: bounds)						with: (RectangleMorph newBounds: bounds).			"see extent:"			self addLabelArea.			self setLabelWidgetAllowance.			self addCloseBox.			self addMenuControl.			labelArea addMorphBack: (Morph new extent: self class borderWidth @ 0).			labelArea addMorphBack: label.			self wantsExpandBox				ifTrue: [self addExpandBox].			labelArea addMorphBack: collapseBox.			self setFramesForLabelArea.			Preferences clickOnLabelToEdit				ifTrue: [label						on: #mouseDown						send: #relabel						to: self].			Preferences noviceMode				ifTrue: [closeBox						ifNotNil: [closeBox setBalloonText: 'close window'].					menuBox						ifNotNil: [menuBox setBalloonText: 'window menu'].					collapseBox						ifNotNil: [collapseBox setBalloonText: 'collapse/expand window']].! !!Compiler methodsFor: 'public access' stamp: 'md 10/16/2006 09:53' prior: 19127422!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	| methodNode method value toLog itsSelectionString itsSelection |	class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	method selector ifNil: [method selector: #DoIt].	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ])		executeMethod: method.	logFlag ifTrue:		[toLog := ((requestor respondsTo: #selection)  and:			[(itsSelection := requestor selection) notNil] and:			[(itsSelectionString := itsSelection asString) isEmptyOrNil not] )			ifTrue: 				[itsSelectionString]			ifFalse:				[sourceStream contents].		SystemChangeNotifier uniqueInstance evaluated: toLog context: aContext ].	^ value.! !"Compiler"!"Morphic"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.319.mcz') load.ScriptLoader new updateFrom7064.!----End fileIn of a stream----!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 10/20/2006 21:30'!script90	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.149.mczKernelTests-sd.50.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.114.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.101.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-dtl.12.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 10/20/2006 21:31'!updateFrom7065	"self new updateFrom7065"		self script90.	self flushCaches.	! !"ScriptLoader"!!ClassRenameFixTest methodsFor: 'Tests' stamp: 'cmm 8/7/2005 18:21' prior: 18689065!renameClassUsing: aBlock	| createdClass foundClasses |	originalName := self newUniqueClassName.	createdClass := Object 		subclass: originalName		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'ClassRenameFix-GeneradClass'.	newClassName := self newUniqueClassName.	aBlock value: createdClass value: newClassName.	self assert: (Smalltalk classNamed: originalName) isNil.	self assert: (Smalltalk classNamed: newClassName) notNil.	foundClasses := Smalltalk organization listAtCategoryNamed: 'ClassRenameFix-GeneradClass'.	self assert: (foundClasses notEmpty).	self assert: (foundClasses includes: newClassName).	self assert: (createdClass name = newClassName).! !!ClassRenameFixTest methodsFor: 'Running' stamp: 'cmm 8/7/2005 18:20' prior: 18688108!setUp	previousChangeSet := ChangeSet current.	testsChangeSet := ChangeSet new.	ChangeSet newChanges: testsChangeSet.	SystemChangeNotifier uniqueInstance		notify: self		ofSystemChangesOfItem: #class		change: #Renamed		using: #verifyRenameEvent:.	super setUp! !!ClassRenameFixTest methodsFor: 'Running' stamp: 'cmm 8/7/2005 18:21' prior: 18688450!tearDown	self removeEverythingInSetFromSystem: testsChangeSet.	ChangeSet newChanges: previousChangeSet.	ChangeSorter removeChangeSet: testsChangeSet.	previousChangeSet := nil.	testsChangeSet := nil.	SystemChangeNotifier uniqueInstance noMoreNotificationsFor: self.	super tearDown.! !!SystemDictionary methodsFor: 'class and trait names' stamp: 'rw 10/7/2006 08:34' prior: 31627640!renameClass: aClass as: newName 	"Rename the class, aClass, to have the title newName."	"Original one I want to keep but needs to be fixed"		| oldref i oldName category |	oldName := aClass name.	category := aClass category.	SystemOrganization classify: newName under: aClass category.	SystemOrganization removeElement: aClass name.	oldref _ self associationAt: aClass name.	self removeKey: aClass name.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	(Array with: StartUpList with: ShutDownList) do:		[:list |  i _ list indexOf: aClass name ifAbsent: [0].		i > 0 ifTrue: [list at: i put: newName]].	self flushClassNameCache.	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: category! !!SystemDictionary methodsFor: 'class names' stamp: 'rw 10/17/2006 23:07'!renameClass: aClass from: oldName 	"Rename the class, aClass, to have the title newName."	| oldref i newName category |	newName := aClass name.	category := SystemOrganization categoryOfElement: oldName.	SystemOrganization classify: newName under: category.	SystemOrganization removeElement: oldName.	oldref := self associationAt: oldName.	self removeKey: oldName.	oldref key: newName.	self add: oldref.  "Old association preserves old refs"	(Array with: StartUpList with: ShutDownList) do:		[:list |  i := list indexOf: oldName ifAbsent: [0].		i > 0 ifTrue: [list at: i put: newName]].	self flushClassNameCache.	SystemChangeNotifier uniqueInstance classRenamed: aClass from: oldName to: newName inCategory: category! !!SystemChangeNotifierTest commentStamp: 'rw 4/3/2006 17:19' prior: 31614888!A SystemChangeNotifierTest is a test class that tests whether the triggering of changes indeed results in the intended changes to be sent to registered object. The basic mechanism for each test is fairly simple:	- register the receiver as the one to get the change notifier.	- manually trigger a change (so the system is not polluted just to see whether we get the needed event).	- the method #event: is invoked and remembers the change event.	- the change event is checked to see whether it was the intended one.Instance Variables	capturedEvent:		Remembers the captured event!!SystemChangeNotifierTest methodsFor: 'Running' stamp: 'rw 10/19/2006 17:21'!setUp	super setUp.	notifier := SystemChangeNotifier createInstance.! !!SystemChangeNotifierTest methodsFor: 'Private' stamp: 'rw 10/19/2006 17:23'!systemChangeNotifier	"The notifier to use. Do not use the one in the system so that the fake events triggered in the tests perturb clients of the system's change notifier (e.g. the changes file then shows fake entries)."	^notifier! !!SystemChangeNotifierTest methodsFor: 'Running' stamp: 'rw 10/19/2006 17:23' prior: 31617204!tearDown	super tearDown.	self capturedEvent: nil.	notifier releaseAll.	notifier := nil! !!SystemChangeNotifierTest methodsFor: 'Testing-system triggers' stamp: 'rw 10/19/2006 17:24' prior: 31619179!testClassRenamedEvent	"self run: #testClassRenamedEvent"	self systemChangeNotifier notify: self ofAllSystemChangesUsing: #event:.	self systemChangeNotifier 		classRenamed: self class		from: #OldFooClass		to: #NewFooClass		inCategory: #FooCat.	self		checkEventForClass: self class		category: #FooCat		change: #Renamed."	self assert: capturedEvent oldName = #OldFooClass.	self assert: capturedEvent newName = #NewFooClass"! !!ChangeSet methodsFor: 'change logging' stamp: 'rw 10/17/2006 22:26' prior: 18241916!event: anEvent	"Hook for SystemChangeNotifier"	anEvent itemKind = SystemChangeNotifier classKind ifTrue: [		anEvent isRemoved 			ifTrue: [self noteRemovalOf: anEvent item].		anEvent isAdded 			ifTrue: [self addClass: anEvent item].		anEvent isModified 			ifTrue: [anEvent anyChanges ifTrue: [self changeClass: anEvent item from: anEvent oldItem]].		anEvent isCommented 			ifTrue: [self commentClass: anEvent item].		anEvent isRenamed 			ifTrue: [self renameClass: anEvent item from: anEvent oldName to: anEvent newName].		anEvent isReorganized			ifTrue: [self reorganizeClass: anEvent item].		anEvent isRecategorized			ifTrue: [self changeClass: anEvent item from: anEvent item].	].	anEvent itemKind = SystemChangeNotifier methodKind ifTrue: [		anEvent isAdded			ifTrue: [self noteNewMethod: anEvent item forClass: anEvent itemClass selector: anEvent itemSelector priorMethod: nil].		anEvent isModified			ifTrue: [self noteNewMethod: anEvent item forClass: anEvent itemClass selector: anEvent itemSelector priorMethod: anEvent oldItem].		anEvent isRemoved			ifTrue: [self removeSelector: anEvent itemSelector class: anEvent itemClass priorMethod: anEvent item lastMethodInfo: {anEvent item sourcePointer. anEvent itemProtocol}].		anEvent isRecategorized			ifTrue: [self reorganizeClass: anEvent itemClass].	].! !!ChangeSet methodsFor: 'change logging' stamp: 'rw 10/19/2006 17:52'!renameClass: class from: oldName to: newName 	"Include indication that a class has been renamed."	| recorder oldMetaClassName newMetaClassName |	isolationSet ifNotNil:		["If there is an isolation layer above me, inform it as well."		isolationSet renameClass: class as: newName].	(recorder _ self changeRecorderFor: oldName)		noteChangeType: #rename;		noteNewName: newName asSymbol.			"store under new name (metaclass too)"	changeRecords at: newName put: recorder.	changeRecords removeKey: oldName.	self noteClassStructure: class.	newMetaClassName := newName, ' class'.	oldMetaClassName := oldName, ' class'.	recorder _ changeRecords at: oldMetaClassName ifAbsent: [^ nil].	changeRecords at: newMetaClassName put: recorder.	changeRecords removeKey: oldMetaClassName.	recorder noteNewName: newMetaClassName! !!Class methodsFor: 'class name' stamp: 'rw 10/7/2006 08:30' prior: 18519182!rename: aString 	"The new name of the receiver is the argument, aString."	| oldName newName |	(newName _ aString asSymbol) = (oldName _ self name)		ifTrue: [^ self].	(self environment includesKey: newName)		ifTrue: [^ self error: newName , ' already exists'].	(Undeclared includesKey: newName)		ifTrue: [self inform: 'There are references to, ' , aString printString , 'from Undeclared. Check them after this change.'].	name _ newName.	self environment renameClass: self from: oldName! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/7/2006 08:57' prior: 18691219!deleteClass	| cl |	cl := Smalltalk at: className ifAbsent: [^self].	cl removeFromChanges; removeFromSystemUnlogged 	! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/7/2006 08:57'!deleteRenamedClass	| cl |	cl := Smalltalk at: renamedName ifAbsent: [^self].	cl removeFromChanges; removeFromSystemUnlogged 	! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/17/2006 22:05' prior: 18691426!setUp	className := #TUTU.	renamedName := #RenamedTUTU.	self deleteClass.	self deleteRenamedClass.	Object subclass: className		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'KernelTests-Classes'! !!ClassTest methodsFor: 'setup' stamp: 'rw 10/17/2006 22:08' prior: 18691687!tearDown	self deleteClass.	self deleteRenamedClass! !!ClassTest methodsFor: 'testing' stamp: 'rw 10/17/2006 22:13' prior: 18692104!testRenaming	"self debug: #testRenaming"	"self run: #testRenaming"		| oldName newMetaclassName class |	oldName := className.	newMetaclassName := (renamedName, #' class') asSymbol.	class := Smalltalk at: oldName.	class class compile: 'dummyMeth'.	class rename: renamedName.	self assert: class name = renamedName.	self assert: (ChangeSet current changedClassNames includes: renamedName). 	self assert: (ChangeSet current changedClassNames includes: newMetaclassName).	! !ChangeSet removeSelector: #renameClass:as:!"Kernel"!"KernelTests"!"System"!"SystemChangeNotification-Tests"!"Tests"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.320.mcz') load.ScriptLoader new updateFrom7065.!----End fileIn of a stream----!----SNAPSHOT----an Array(20 October 2006 9:43:06 pm) Squeak3.9-RC3-7066.image priorSource: 77689!----QUIT/NOSAVE----an Array(20 October 2006 9:43:18 pm) Squeak3.9-RC3-7066.image priorSource: 95470!----STARTUP----an Array(7 November 2006 11:57:51 am) as /Users/ducasse/Workspace/FirstCircle/Working/SqueakReleasing/Squeak3.9-RC3-7066/Squeak3.9-RC3-7066.image!!ScriptLoader methodsFor: 'scripts' stamp: 'sd 11/6/2006 20:38'!script91	| names|names := '39Deprecated-md.11.mczBalloon-ar.13.mczCollections-md.70.mczCollectionsTests-md.33.mczCompiler-sd.57.mczCompression-ar.8.mczEToys-sd.21.mczExceptions-sd.8.mczFiles-md.18.mczFixUnderscores-cmm.10.mczFlash-ar.5.mczFlexibleVocabularies-al.5.mczGraphics-ar.39.mczGraphicsTests-ar.9.mczKernel-sd.150.mczKernelTests-sd.50.mczMonticello-md.308.mczMonticelloConfigurations-stephaneducasse.38.mczMorphic-sd.115.mczMorphicExtras-md.31.mczMorphicTests-md.6.mczMovies-md.7.mczMultilingual-sd.21.mczNebraska-md.13.mczNetwork-md.32.mczNetworkTests-md.9.mczOB-Standard.39-cwp.3.mczOmniBrowser.39-cwp.1.mczPackageInfo-al.6.mczPreferenceBrowser-hpt.32.mczProtocols-md.12.mczReleaseBuilder-md.4.mczSMBase-sd.85.mczSMLoader-gk.37.mczST80-sd.35.mczSUnit-md.33.mczSUnitGUI-sd.7.mczServices-Base-md.33.mczSmaCC-md.9.mczSound-md.6.mczSpeech-md.9.mczStarSqueak-sd.6.mczSystem-sd.101.mczSystemChangeNotification-Tests-sd.6.mczTests-sd.19.mczToolBuilder-Kernel-cwp.17.mczToolBuilder-MVC-sd.13.mczToolBuilder-Morphic-ar.19.mczToolBuilder-SUnit-cwp.12.mczTools-md.74.mczTraits-sd.226.mczTrueType-ar.4.mczVersionNumber-dew.1.mcz'findTokens: ' ', String cr.	self loadTogether: names merge: false.! !!ScriptLoader methodsFor: 'updates' stamp: 'sd 11/7/2006 11:50'!updateFrom7066	"self new updateFrom7066"		self script91.	World setModel: MorphicModel new.	Behavior flushObsoleteSubclasses.	Smalltalk cleanOutUndeclared.	SystemVersion newVersion: 'Squeak3.9'.	self flushCaches.	! !"ScriptLoader"!!Complex methodsFor: 'comparing' stamp: 'hmm 11/1/2006 23:29' prior: 19144324!= anObject	anObject isNumber ifFalse: [^false].	anObject isComplex		ifTrue: [^ (real = anObject real) & (imaginary = anObject imaginary)]		ifFalse: [^ anObject adaptToComplex: self andSend: #=]! !!Complex methodsFor: 'testing' stamp: 'hmm 11/1/2006 23:34'!isNumber	^ true! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:22'!testAddAction	"MVCToolBuilder does not implement #buildPluggableMenu:"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:22'!testAddTargetSelectorArgumentList	"MVCToolBuilder does not implement #buildPluggableMenu:"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:23'!testButtonFiresBlock	"MVC buttons only support action Symbols"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:23'!testButtonFiresMessage	"MVC buttons only support action Symbols, not MessageSends"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testButtonInitiallyDisabled	"MVC does not have button enablement"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testButtonInitiallyDisabledSelector	"MVC does not have button enablement"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testGetButtonColor	"MVC buttons do not have color"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:17'!testGetButtonEnabled	"MVC does not have button enablement"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:18'!testGetButtonSideEffectFree	"MVC button ask for their state on any change notification"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:19'!testGetInputFieldColor	"MVC input fields do not have color"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:20'!testGetPanelChildren	"MVC panels do not allow changing children"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:21'!testGetTextColor	"not supported in MVC"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:21'!testGetWindowChildren	"not supported in MVC"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:21'!testGetWindowLabel	"not supported in MVC"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeExpandPath	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeExpandPathFirst	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeGetSelectionPath	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeRoots	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:24'!testTreeWidgetID	"MVCToollBuilder does not implement trees"! !!MVCToolBuilderTests methodsFor: 'tests-not applicable' stamp: 'hmm 11/1/2006 23:25'!testWindowCloseAction	"This can only work if we're actually run in MVC"	World isNil ifTrue: [super testWindowCloseAction]! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:36' prior: 17737741!addCornerGrips	self		addMorphBack: (TopLeftGripMorph new target: self; position: self position).	self		addMorphBack: (TopRightGripMorph new target: self; position: self position).	self		addMorphBack: (BottomLeftGripMorph new target: self;position: self position).	self		addMorphBack: (BottomRightGripMorph new target: self;position: self position)! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:36' prior: 17738079!addPaneHSplitterBetween: topMorph and: bottomMorphs	| targetY minX maxX splitter |	targetY _ topMorph layoutFrame bottomFraction.	minX _ (bottomMorphs detectMin: [:each | each layoutFrame leftFraction]) layoutFrame leftFraction.	maxX _ (bottomMorphs detectMax: [:each | each layoutFrame rightFraction]) layoutFrame rightFraction.	splitter _ ProportionalSplitterMorph new beSplitsTopAndBottom; yourself.	splitter layoutFrame: (LayoutFrame		fractions: (minX @ targetY corner: maxX @ targetY)		offsets: (((topMorph layoutFrame leftOffset ifNil: [0]) @ 0 corner: (topMorph layoutFrame rightOffset ifNil: [0]) @ 4) translateBy: 0 @ (topMorph layoutFrame bottomOffset ifNil: [0]))).	self addMorphBack: (splitter position: self position).! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:34' prior: 17738876!addPaneSplitters	| splitter remaining target targetX sameX minY maxY targetY sameY minX maxX |	self removePaneSplitters.	self removeCornerGrips.	remaining _ submorphs reject: [:each | each layoutFrame rightFraction = 1].	[remaining notEmpty] whileTrue:		[target _ remaining first.		targetX _ target layoutFrame rightFraction.		sameX _ submorphs select: [:each | each layoutFrame rightFraction = targetX].		minY _ (sameX detectMin: [:each | each layoutFrame topFraction]) layoutFrame topFraction.		maxY _ (sameX detectMax: [:each | each layoutFrame bottomFraction]) layoutFrame bottomFraction.		splitter _ ProportionalSplitterMorph new.		splitter layoutFrame: (LayoutFrame			fractions: (targetX @ minY corner: targetX @ maxY)			offsets: ((0 @ (target layoutFrame topOffset ifNil: [0]) corner: 4 @ (target layoutFrame bottomOffset ifNil: [0])) translateBy: (target layoutFrame rightOffset ifNil: [0]) @ 0)).		self addMorphBack: (splitter position: self position).		remaining _ remaining copyWithoutAll: sameX].	remaining _ submorphs copy reject: [:each | each layoutFrame bottomFraction = 1].	[remaining notEmpty]		whileTrue: [target _ remaining first.			targetY _ target layoutFrame bottomFraction.			sameY _ submorphs select: [:each | each layoutFrame bottomFraction = targetY].			minX _ (sameY detectMin: [:each | each layoutFrame leftFraction]) layoutFrame leftFraction.			maxX _ (sameY detectMax: [:each | each layoutFrame rightFraction]) layoutFrame rightFraction.			splitter _ ProportionalSplitterMorph new beSplitsTopAndBottom; yourself.			splitter layoutFrame: (LayoutFrame				fractions: (minX @ targetY corner: maxX @ targetY)				offsets: (((target layoutFrame leftOffset ifNil: [0]) @ 0 corner: (target layoutFrame rightOffset ifNil: [0]) @ 4) translateBy: 0 @ (target layoutFrame bottomOffset ifNil: [0]))).			self addMorphBack: (splitter position: self position).			remaining _ remaining copyWithoutAll: sameY].	self linkSubmorphsToSplitters.	self splitters do: [:each | each comeToFront].! !!BorderedMorph methodsFor: 'lookenhancements' stamp: 'kfr 11/5/2006 21:37' prior: 17740940!addPaneVSplitterBetween: leftMorph and: rightMorphs 	| targetX minY maxY splitter |	targetX _ leftMorph layoutFrame rightFraction.	minY _ (rightMorphs detectMin: [:each | each layoutFrame topFraction]) layoutFrame topFraction.	maxY _ (rightMorphs detectMax: [:each | each layoutFrame bottomFraction]) layoutFrame bottomFraction.		splitter _ ProportionalSplitterMorph new.	splitter layoutFrame: (LayoutFrame		fractions: (targetX @ minY corner: targetX @ maxY)		offsets: ((0 @ (leftMorph layoutFrame topOffset ifNil: [0]) corner: (4@ (leftMorph layoutFrame bottomOffset ifNil: [0]))) translateBy: (leftMorph layoutFrame rightOffset ifNil: [0]) @ 0)).	self addMorphBack: (splitter position: self position).! !"Kernel"!"Morphic"!"ToolBuilder-MVC"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://source.squeakfoundation.org/39a'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader-sd.324.mcz') load.ScriptLoader new updateFrom7066.!----End fileIn of a stream----!----SNAPSHOT----an Array(7 November 2006 12:05:35 pm) Squeak3.9-final-7067.image priorSource: 95470!----QUIT/NOSAVE----an Array(7 November 2006 12:05:44 pm) Squeak3.9-final-7067.image priorSource: 105817!----STARTUP----an Array(31 January 2007 8:24:31 pm) as /home/lex/squeak/univ39/squeak.image!!DTDEntityDeclaration class methodsFor: 'accessing' stamp: 'mir 11/16/2000 20:14'!behaviorForContext: aContext	^self contextBehavior at: aContext! !!DTDEntityDeclaration class methodsFor: 'accessing' stamp: 'mir 11/16/2000 20:15'!contextBehavior	^contextBehavior! !!DTDEntityDeclaration class methodsFor: 'class initialization' stamp: 'mir 1/15/2002 18:02'!initialize	"DTDEntityDeclaration initialize"	contextBehavior _ Dictionary new.	contextBehavior		at: #content put: #include ;		at: #attributeValueContent put: #includedInLiteral ;		at: #attributeValue put: #forbidden ;		at: #entityValue put: #bypass ;		at: #dtd put: #forbidden ! !!DTDEntityDeclaration class methodsFor: 'accessing' stamp: 'mir 11/16/2000 20:27'!leadIn	^'&'! !!DTDEntityDeclaration class methodsFor: 'instance creation' stamp: 'mir 11/16/2000 20:13'!name: aString value: aValueString	^self new		name: aString;		value: aValueString! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 11:29'!bypass	"Return my reference as is."	^self reference! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 11:29'!forbidden	self error: 'Forbidden reference usage'! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 18:01'!include	"Return my expanded value."	^value ifNil: [SAXWarning signal: 'XML undefined entity ' , name printString]! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 18:06'!includedInLiteral	"Return my expanded value."	^self include! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 1/4/2002 19:40'!name	^name! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 1/17/2002 15:25'!name: aString	name _ aString asSymbol! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:22'!ndata	^ndata! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:22'!ndata: aString	ndata _ aString! !!DTDEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 11:30'!reference	"Return my reference as is."	^self class leadIn , self name , ';'! !!DTDEntityDeclaration methodsFor: 'invocation' stamp: 'mir 11/16/2000 21:23'!registerIn: aParser	aParser entity: self name put: self! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 11/16/2000 10:54'!value	^value! !!DTDEntityDeclaration methodsFor: 'accessing' stamp: 'mir 11/16/2000 10:55'!value: aString	value _ aString! !!DTDEntityDeclaration methodsFor: 'invocation' stamp: 'mir 1/15/2002 15:08'!valueForContext: aContext	^self perform: (self class behaviorForContext: aContext)! !!DTDExternalEntityDeclaration class methodsFor: 'class initialization' stamp: 'mir 1/14/2002 18:15'!initialize	"DTDExternalEntityDeclaration initialize"	contextBehavior _ Dictionary new.	contextBehavior		at: #content put: #include ;		at: #attributeValueContent put: #includedInLiteral ;		at: #attributeValue put: #forbidden ;		at: #entityValue put: #bypass ;		at: #dtd put: #forbidden ! !!DTDParameterEntityDeclaration class methodsFor: 'class initialization' stamp: 'mir 1/14/2002 18:15'!initialize	"DTDParameterEntityDeclaration initialize"	contextBehavior _ Dictionary new.	contextBehavior		at: #content put: #notRecognized: ;		at: #attributeValueContent put: #notRecognized: ;		at: #attributeValue put: #notRecognized: ;		at: #entityValue put: #include: ;		at: #dtd put: #includePE:! !!DTDParameterEntityDeclaration class methodsFor: 'accessing' stamp: 'mir 11/16/2000 20:27'!leadIn	^'%'! !!DTDParameterEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 11:30'!includePE	"Return my expanded value."	^self include! !!DTDParameterEntityDeclaration methodsFor: 'behaviors' stamp: 'mir 1/15/2002 23:21'!notRecognized	SAXMalformedException signal: 'Malformed entity.'! !!DTDParameterEntityDeclaration methodsFor: 'invocation' stamp: 'mir 11/28/2000 17:26'!registerIn: aParser	aParser parameterEntity: self name put: self! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 8/14/2000 18:29'!new	^super new initialize! !!SAXHandler class methodsFor: 'instance creation' stamp: 'sd 5/23/2003 15:19'!on: aStream	| driver parser |	driver _ SAXDriver on: aStream.	driver validating: true.	parser _ self new driver: driver.	^parser! !!SAXHandler class methodsFor: 'instance creation' stamp: 'cwp 5/28/2003 02:08'!parseDTDFrom: aStream	| driver parser |	driver _ SAXDriver on: aStream.	driver validating: true.	driver startParsingMarkup.	parser _ self new driver: driver.	parser startDocument.	parser parseDocument.	^parser! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 6/5/2003 19:13'!parseDocumentFrom: aStream	|  parser |	parser _ self on: aStream.	parser startDocument.	parser parseDocument.	^parser! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 1/8/2002 15:55'!parseDocumentFromFileNamed: fileName	^self parseDocumentFromFileNamed: fileName readIntoMemory: false! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 1/8/2002 15:55'!parseDocumentFromFileNamed: fileName readIntoMemory: readIntoMemory	| stream xmlDoc |	stream _ FileDirectory default readOnlyFileNamed: fileName.	readIntoMemory		ifTrue: [stream _ stream contentsOfEntireFile readStream].	[xmlDoc _ self parseDocumentFrom: stream]		ensure: [stream close].	^xmlDoc! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 6/5/2003 19:15'!parserOnFileNamed: fileName	^self parserOnFileNamed: fileName readIntoMemory: false! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 6/5/2003 19:14'!parserOnFileNamed: fileName readIntoMemory: readIntoMemory	| stream  |	stream _ FileDirectory default readOnlyFileNamed: fileName.	readIntoMemory		ifTrue: [stream _ stream contentsOfEntireFile readStream].	^self on: stream! !!SAXHandler methodsFor: 'content' stamp: 'mir 1/8/2002 18:27'!characters: aString	"This call corresponds to the Java SAX call	characters(char[] ch, int start, int length)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 1/8/2002 18:24'!checkEOD	"Check if the document shouldn't be ended already"	self eod		ifTrue: [self driver errorExpected: 'No more data expected,']! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:52'!comment: commentString	"This call corresponds to the Java SAX ext call	comment(char[] ch, int start, int length)."! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 11/30/2000 18:12'!document	^document! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 11/30/2000 18:12'!document: aDocument	document _ aDocument! !!SAXHandler methodsFor: 'content' stamp: 'mir 1/17/2002 13:12'!documentAttributes: attributeList! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:34'!driver	^driver! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:34'!driver: aDriver	driver _ aDriver.	driver saxHandler: self! !!SAXHandler methodsFor: 'content' stamp: 'mir 1/8/2002 18:26'!endDocument	"This call corresponds to the Java SAX call	endDocument()."	eod _ true! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/14/2000 18:07'!endElement: elementName! !!SAXHandler methodsFor: 'content' stamp: 'mir 6/5/2003 19:05'!endElement: elementName namespace: namespace namespaceURI: namespaceURI qualifiedName: qualifiedName	"This call corresponds to the Java SAX call	endElement(java.lang.String namespaceURI, java.lang.String localName, java.lang.String qName).	By default this call is mapped to the following more convenient call:"	self endElement: elementName! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:53'!endEntity: entityName	"This call corresponds to the Java SAX ext call	endEntity(java.lang.String name)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:25'!endPrefixMapping: prefix	"This call corresonds to the Java SAX call	endPrefixMapping(java.lang.String prefix)."! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 1/8/2002 18:18'!eod	^eod! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:25'!ignorableWhitespace: aString	"This call corresonds to the Java SAX call	ignorableWhitespace(char[] ch, int start, int length)."! !!SAXHandler methodsFor: 'initialize' stamp: 'mir 1/8/2002 18:18'!initialize	eod _ false! !!SAXHandler methodsFor: 'parsing' stamp: 'mir 1/8/2002 18:18'!parseDocument	[self driver nextEntity isNil or: [self eod]] whileFalse! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:26'!processingInstruction: piName data: dataString	"This call corresonds to the Java SAX call	processingInstruction(java.lang.String target, java.lang.String data)."! !!SAXHandler methodsFor: 'entity' stamp: 'mir 8/11/2000 17:33'!resolveEntity: publicID systemID: systemID	"This call corresonds to the Java SAX call	resolveEntity(java.lang.String publicId, java.lang.String systemId)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:45'!skippedEntity: aString	"This call corresonds to the Java SAX call	skippedEntity(java.lang.String name)."! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:53'!startCData	"This call corresponds to the Java SAX ext call	startCData()."! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:54'!startDTD: declName publicID: publicID systemID: systemID	"This call corresponds to the Java SAX ext call	startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:45'!startDocument	"This call corresonds to the Java SAX call	startDocument()."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/14/2000 18:07'!startElement: elementName attributeList: attributeList! !!SAXHandler methodsFor: 'content' stamp: 'mir 6/5/2003 16:50'!startElement: localName namespaceURI: namespaceUri namespace: namespace attributeList: attributeList	"This call corresonds to the Java SAX call	startElement(java.lang.String namespaceURI, java.lang.String localName, java.lang.String qName, Attributes atts).	By default this call is mapped to the following more convenient call:"	self startElement: localName attributeList: attributeList! !!SAXHandler methodsFor: 'lexical' stamp: 'mir 8/11/2000 18:54'!startEntity: entityName	"This call corresponds to the Java SAX ext call	startEntity(java.lang.String name)."! !!SAXHandler methodsFor: 'content' stamp: 'mir 8/11/2000 16:47'!startPrefixMapping: prefix uri: uri	"This call corresonds to the Java SAX call	startPrefixMapping(java.lang.String prefix, java.lang.String uri)."! !!SAXHandler methodsFor: 'accessing' stamp: 'mir 6/5/2003 19:28'!useNamespaces: aBoolean	self driver useNamespaces: aBoolean! !!XMLDOMParser class methodsFor: 'examples' stamp: 'mir 8/14/2000 18:36'!addressBookXMLWithDTD	"XMLDOMParser addressBookXMLWithDTD"	^self parseDocumentFrom: XMLTokenizer addressBookXMLWithDTD readStream! !!XMLDOMParser class methodsFor: 'instance creation' stamp: 'mir 12/7/2000 16:29'!parseDocumentFrom: aStream	^(super parseDocumentFrom: aStream) document! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 10/25/2000 11:30'!characters: aString	| newElement |	newElement _ XMLStringNode string: aString.	self top addContent: newElement.! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 6/16/2003 17:20'!defaultNamespace	^self top		ifNotNil: [self top namespace]! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 1/17/2002 13:13'!documentAttributes: attributeList	self document version: (attributeList at: 'version' ifAbsent: [nil]).	self document encoding: (attributeList at: 'encoding' ifAbsent: [nil]).	self document requiredMarkup: (attributeList at: 'requiredMarkup' ifAbsent: [nil]).! !!XMLDOMParser methodsFor: 'parsing' stamp: 'mir 6/5/2003 19:29'!domDocument	[self startDocument; parseDocument]		ensure: [self driver stream close].	^document! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 1/8/2002 18:19'!endDocument	self pop.	super endDocument! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 1/8/2002 18:11'!endElement: elementName	| currentElement |	currentElement _ self pop.	currentElement name = elementName		ifFalse: [self driver errorExpected: 'End tag "', elementName , '" doesn''t match "' , currentElement name , '".']! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 6/24/2003 14:53'!endElement: localName namespace: namespace namespaceURI: uri qualifiedName: qualifiedName	| currentElement |	currentElement _ self pop.	(currentElement namespace isNil		or: [currentElement namespace = self defaultNamespace])		ifTrue: [			currentElement localName = localName				ifFalse: [self driver errorExpected: 'End tag "', localName , '" doesn''t match "' , currentElement localName  , '".']]		ifFalse: [			currentElement qualifiedName = qualifiedName				ifFalse: [self driver errorExpected: 'End tag "', qualifiedName , '" doesn''t match "' , currentElement qualifiedName  , '".']]! !!XMLDOMParser methodsFor: 'accessing' stamp: 'mir 1/8/2001 12:05'!incremental	^incremental! !!XMLDOMParser methodsFor: 'accessing' stamp: 'mir 1/8/2001 12:05'!incremental: aBoolean	incremental _ aBoolean! !!XMLDOMParser methodsFor: 'initialize' stamp: 'mir 1/8/2001 12:05'!initialize	super initialize.	stack _ OrderedCollection new.	incremental _ false! !!XMLDOMParser methodsFor: 'parsing' stamp: 'mir 6/28/2001 18:45'!nextEntity	| currentTop |	currentTop _ self top.	[self driver nextEntity isNil		or: [self top ~~ currentTop]] whileTrue.	^entity! !!XMLDOMParser methodsFor: 'parsing' stamp: 'mir 12/21/2000 14:02'!nextEntityStart	[self driver nextEntity.	self stack isEmpty] whileTrue.	^entity! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 1/8/2001 12:04'!pop	| oldTop |	oldTop _ self stack removeLast.	entity _ oldTop.	^oldTop! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 3/6/2002 10:49'!processingInstruction: piName data: dataString	| newElement |	newElement _ XMLPI target: piName data: dataString.	self top addElement: newElement! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 1/8/2001 12:02'!push: anObject	self stack add: anObject.	entity _ anObject! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 8/14/2000 18:28'!stack	^stack! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 11/30/2000 18:14'!startDocument	self document: XMLDocument new.	self push: self document ! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 3/6/2002 10:49'!startElement: elementName attributeList: attributeList	| newElement |	newElement _ XMLElement named: elementName attributes: attributeList.	self incremental		ifFalse: [self stack isEmpty			ifFalse: [self top addElement: newElement]].	self push: newElement! !!XMLDOMParser methodsFor: 'content' stamp: 'mir 6/24/2003 18:52'!startElement: localName namespaceURI: namespaceUri namespace: namespace attributeList: attributeList	| newElement |	"newElement _ namespace = self defaultNamespace		ifTrue: [XMLElement named: localName namespace: nil uri: nil attributes: attributeList]		ifFalse: [XMLElement named: localName namespace: namespace uri: namespaceUri attributes: attributeList]."	newElement _ XMLElement named: localName namespace: namespace uri: namespaceUri attributes: attributeList.	self incremental		ifFalse: [self stack isEmpty			ifFalse: [self top addElement: newElement]].	self push: newElement! !!XMLDOMParser methodsFor: 'private' stamp: 'mir 1/8/2001 11:46'!top	^self stack isEmpty		ifTrue: [nil]		ifFalse: [self stack last]! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/4/2003 15:51'!currentScope	^self scope last! !!XMLNamespaceScope methodsFor: 'scope' stamp: 'mir 6/16/2003 16:37'!declareNamespace: ns uri: uri	"Declare the given name space prefix with the given URL"	ns = 'xmlns'		ifTrue: [^self defaultNamespace: uri].	self establishLocalBindings.	currentBindings removeKey: ns ifAbsent: [].	currentBindings at: ns put: uri! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'mir 6/24/2003 14:22'!defaultNamespace	^self currentScope first! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'mir 6/24/2003 14:23'!defaultNamespace: ns	"Declare the default namespace."	self currentScope at: 1 put: ns! !!XMLNamespaceScope methodsFor: 'scope' stamp: 'mir 6/5/2003 19:28'!enterScope	self scope addLast: { self defaultNamespace. nil. currentBindings. }! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/4/2003 16:08'!establishLocalBindings	(self currentScope at: 2)		ifNil: [			currentBindings := currentBindings copy.			self currentScope at: 2 put: currentBindings]! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/24/2003 14:25'!initScope	scope := OrderedCollection new: 20.	currentBindings := Dictionary new.	scope addLast: {'http://www.w3.org/TR/REC-xml-names'. currentBindings. nil. }.! !!XMLNamespaceScope methodsFor: 'scope' stamp: 'mir 6/4/2003 16:05'!leaveScope	| leftScope |	leftScope := self scope removeLast.	currentBindings := (self currentScope at: 2) ifNil: [leftScope at: 3]! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/5/2003 19:32'!namespaceAliases: namespace	"Locate all namespaces that are aliases of the given URI."	| aliases uri |	aliases _ Set new.	uri _ self namespaceURIOf: namespace ifAbsent: [self parseError: 'Attribute refers to undefined namespace ' , namespace asString ].	currentBindings keysAndValuesDo: [:ns :u |		(u = uri			and: [ns ~= namespace])			ifTrue: [aliases add: ns]].	^ aliases! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'sd 5/28/2003 09:33'!namespaceURIOf: ns	"Retrieve the URI of the given namespace prefix, if it is defined. A nil namespace	returns the global namespace"	^ self namespaceURIOf: ns ifAbsent: [ nil ]! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'mir 6/24/2003 13:33'!namespaceURIOf: ns ifAbsent: aBlock	"Retrieve the URI of the given namespace prefix, if it is defined. 	A nil namespace returns the default namespace. 	If no namespace can be found the value of the block is returned"	^ns		ifNil: [self defaultNamespace]		ifNotNil: [currentBindings at: ns ifAbsent: aBlock]! !!XMLNamespaceScope methodsFor: 'accessing' stamp: 'mir 6/5/2003 19:32'!namespaces	^currentBindings! !!XMLNamespaceScope methodsFor: 'private' stamp: 'mir 6/24/2003 14:26'!scope	scope ifNil: [self initScope].	^scope! !!XMLNamespaceScope methodsFor: 'validation' stamp: 'mir 6/5/2003 17:16'!validateAttributes: attributeList	"check all attribute namespaces are defined and not duplicated by aliasing"	| namespace localName |	attributeList keysDo: [:attrName |		self splitName: attrName into: [:ns :ln |			namespace _ ns.			localName _ ln].		namespace ifNotNil: [			(self namespaceAliases: namespace) do: [:alias |				(attributeList includesKey: alias , ':' , localName)					ifTrue: [self parseError: 'Attributes ' , attrName , ' and ' , alias , ':' , localName , ' are aliased to namespace ' , (self namespaceURIOf: namespace) ]]]]! !!XMLNode methodsFor: 'accessing' stamp: 'mir 1/8/2002 18:44'!addContent: contentString	SAXParseException signal: 'Illegal string data.'! !!XMLNode methodsFor: 'enumerating' stamp: 'mir 1/17/2002 14:49'!contentsDo: aBlock! !!XMLNode methodsFor: 'enumerating' stamp: 'mir 3/6/2002 10:56'!elementsDo: aBlock! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:52'!firstTagNamed: aSymbol 	"Return the first encountered node with the specified tag. Pass the message on"	| answer |	self elementsDo: [:node | (answer _ node firstTagNamed: aSymbol) ifNotNil: [^answer]].	^nil! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!firstTagNamed: aSymbol with: aBlock	"Return the first encountered node with the specified tag that	allows the block to evaluate to true. Pass the message on"	| answer |	self elementsDo: [:node |		(answer _ node firstTagNamed: aSymbol with: aBlock) ifNotNil: [^answer]].	^nil! !!XMLNode methodsFor: 'testing' stamp: 'mir 1/17/2002 15:28'!isProcessingInstruction	^false! !!XMLNode methodsFor: 'testing' stamp: 'mir 1/17/2002 15:26'!isTag	^false! !!XMLNode methodsFor: 'testing' stamp: 'mir 1/17/2002 15:26'!isText	^false! !!XMLNode methodsFor: 'printing' stamp: 'mir 1/17/2002 15:45'!printOn: stream	self printXMLOn: (XMLWriter on: stream)! !!XMLNode methodsFor: 'printing' stamp: 'mir 1/17/2002 15:45'!printXMLOn: writer	self subclassResponsibility! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol childrenDo: aOneArgumentBlock	"Evaluate aOneArgumentBlock for all children who match"	self elementsDo: [:each | 		each tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock]! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol childrenDoAndRecurse: aOneArgumentBlock	"Evaluate aOneArgumentBlock for all children who match and recurse"	self elementsDo: [:each | 		each tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock]! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol contentsDo: aBlock	"Evaluate aBlock for all of the contents of the receiver.	The receiver has no tag, so pass the message on"	self elementsDo: [:each | each tagsNamed: aSymbol contentsDo: aBlock]! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol do: aOneArgumentBlock	"Search for nodes with tag aSymbol. When encountered evaluate aOneArgumentBlock"	self elementsDo: [:each | each tagsNamed: aSymbol do: aOneArgumentBlock]! !!XMLNode methodsFor: 'searching' stamp: 'SqR 7/2/2000 15:58'!tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock	"Handled only by XMLTagNode subclass"! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock	"Recurse all children"	self elementsDo: [:each | each tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock]! !!XMLNode methodsFor: 'searching' stamp: 'mir 3/6/2002 10:53'!tagsNamed: aSymbol ifReceiverOrChildDo: aOneArgumentBlock	"Recurse all children"	self elementsDo: [:each | each tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock]! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 11/30/2000 17:48'!dtd	^dtd! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 11/30/2000 17:48'!dtd: aDTD	dtd _ aDTD! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 5/16/2003 14:09'!encoding		^encoding ifNil: ['UTF-8']! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!encoding: aString		encoding _ aString! !!XMLDocument methodsFor: 'printing' stamp: 'mir 1/17/2002 16:44'!printCanonicalOn: aStream	| writer |	writer _ XMLWriter on: aStream.	writer canonical: true.	self printXMLOn: writer! !!XMLDocument methodsFor: 'printing' stamp: 'mir 5/16/2003 14:08'!printXMLOn: writer	version ifNotNil: [writer xmlDeclaration: self version encoding: self encoding].	super printXMLOn: writer! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!requiredMarkup		^requiredMarkup! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!requiredMarkup: aString		requiredMarkup _ aString! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!version		^version! !!XMLDocument methodsFor: 'accessing' stamp: 'mir 1/17/2002 12:57'!version: aString		version _ aString! !!XMLElement class methodsFor: 'instance creation' stamp: 'mir 3/7/2000 16:33'!named: aString	^self new name: aString! !!XMLElement class methodsFor: 'instance creation' stamp: 'mir 8/14/2000 18:01'!named: aString attributes: attributeList	^self new		name: aString;		setAttributes: attributeList! !!XMLElement class methodsFor: 'instance creation' stamp: 'mir 6/5/2003 15:21'!named: aString namespace: ns uri: uri attributes: attributeList	^self new		name: aString;		namespace: ns uri: uri;		setAttributes: attributeList! !!XMLElement methodsFor: 'initialize' stamp: 'mir 8/14/2000 17:58'!addContent: contentString	self contents add: contentString! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/18/2001 16:55'!attributeAt: attributeName	^self attributeAt: attributeName ifAbsent: [nil]! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/18/2001 16:55'!attributeAt: attributeName ifAbsent: aBlock	^self attributes at: attributeName ifAbsent: [^aBlock value]! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/17/2002 15:24'!attributeAt: attributeName put: attributeValue	self attributes at: attributeName asSymbol put: attributeValue! !!XMLElement methodsFor: 'accessing' stamp: 'mas 10/15/2003 09:18'!attributes	^attributes ifNil: [attributes _ Dictionary new]! !!XMLElement methodsFor: 'accessing' stamp: 'mir 3/7/2000 16:24'!characterData	^self contentString! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/18/2001 16:27'!contentString	^(self contents size == 1		and: [self contents first isKindOf: XMLStringNode])		ifTrue: [self contents first string]		ifFalse: ['']! !!XMLElement methodsFor: 'accessing' stamp: 'mir 6/18/2003 13:47'!contentStringAt: entityName	^(self elementAt: entityName ifAbsent: [^'']) contentString! !!XMLElement methodsFor: 'accessing' stamp: 'mir 8/14/2000 17:58'!contents	contents ifNil: [contents _ OrderedCollection new].	^contents! !!XMLElement methodsFor: 'enumerating' stamp: 'mir 10/25/2000 11:15'!contentsDo: aBlock	contents		ifNotNil: [			self contents do: [:each | aBlock value: each]]! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:34'!firstTagNamed: aSymbol 	"Return the first encountered node with the specified tag.	If it is not the receiver, pass the message on"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [^self].	^super firstTagNamed: aSymbol ! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:34'!firstTagNamed: aSymbol with: aBlock	"Return the first encountered node with the specified tag that allows	the block to evaluate to true. Pass the message on"	((self localName == aSymbol		or: [self tag == aSymbol]) 		and: [aBlock value: self])		ifTrue: [^self].	^super firstTagNamed: aSymbol with: aBlock.! !!XMLElement methodsFor: 'testing' stamp: 'mir 3/6/2002 10:48'!isEmpty	^self elements isEmpty		and: [self contents isEmpty]! !!XMLElement methodsFor: 'testing' stamp: 'mir 1/17/2002 15:26'!isTag	^true! !!XMLElement methodsFor: 'name space' stamp: 'sd 5/25/2003 18:24'!localName	^ name! !!XMLElement methodsFor: 'accessing' stamp: 'sd 5/25/2003 18:25'!name	^ self qualifiedName! !!XMLElement methodsFor: 'initialize' stamp: 'mir 1/17/2002 15:24'!name: aString	name _ aString asSymbol! !!XMLElement methodsFor: 'printing' stamp: 'mir 1/17/2002 16:58'!printXMLOn: writer	writer startElement: self name attributeList: self attributes.	(writer canonical not		and: [self isEmpty and: [self attributes isEmpty not]])		ifTrue: [writer endEmptyTag: self name]		ifFalse: [			writer endTag.			self contentsDo: [:content | content printXMLOn: writer].			super printXMLOn: writer.			writer endTag: self name]! !!XMLElement methodsFor: 'name space' stamp: 'mir 6/5/2003 15:20'!qualifiedName	^self namespace		ifNil: [self localName]		ifNotNil: [self namespace , ':' , self localName]! !!XMLElement methodsFor: 'initialize' stamp: 'mir 3/7/2000 16:43'!setAttributes: newAttributes	attributes _ newAttributes! !!XMLElement methodsFor: 'accessing' stamp: 'sd 5/25/2003 18:25'!tag	^ self name asSymbol! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:33'!tagsNamed: aSymbol contentsDo: aBlock	"Evaluate aBlock for all of the contents of the receiver	if the receiver tag equals aSymbol. Pass the message on"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [self contentsDo: aBlock].	super tagsNamed: aSymbol contentsDo: aBlock! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:35'!tagsNamed: aSymbol do: aOneArgumentBlock	"If the receiver tag equals aSymbol, evaluate aOneArgumentBlock	with the receiver. Continue the search"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [aOneArgumentBlock value: self].	super tagsNamed: aSymbol do: aOneArgumentBlock! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:35'!tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock	"If the receiver tag equals aSymbol, evaluate aOneArgumentBlock with the receiver"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [aOneArgumentBlock value: self]! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:35'!tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock	"If the receiver tag equals aSymbol, evaluate aOneArgumentBlock	with the receiver. Then recurse through all the children"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [aOneArgumentBlock value: self].	super tagsNamed: aSymbol ifReceiverDoAndRecurse: aOneArgumentBlock! !!XMLElement methodsFor: 'searching' stamp: 'mir 6/25/2003 13:35'!tagsNamed: aSymbol ifReceiverOrChildDo: aOneArgumentBlock	"If the receiver tag equals aSymbol, evaluate aOneArgumentBlock with the receiver.	For each of the receivers children do the same. Do not go beyond direct children"	(self localName == aSymbol		or: [self tag == aSymbol])		ifTrue: [aOneArgumentBlock value: self].	super tagsNamed: aSymbol ifReceiverDo: aOneArgumentBlock! !!XMLElement methodsFor: 'accessing' stamp: 'mir 6/5/2003 12:02'!valueFor: aSymbol 	^self valueFor: aSymbol ifAbsent: ['']! !!XMLElement methodsFor: 'accessing' stamp: 'mir 1/17/2002 15:28'!valueFor: aSymbol ifAbsent: aBlock 	^self attributes at: aSymbol ifAbsent: aBlock! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 3/6/2002 11:01'!addElement: element	self elements add: element! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 10/25/2000 11:22'!addEntity: entityName value: entityValue	self entities add: entityName->entityValue! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 3/6/2002 10:46'!elementAt: entityName	^self elementAt: entityName ifAbsent: [nil]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 6/25/2003 13:27'!elementAt: entityName ifAbsent: aBlock	elements		ifNil: [^aBlock value].	^self elements detect: [:each | each name = entityName or: [each localName = entityName]] ifNone: [^aBlock value]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 6/16/2003 17:36'!elementUnqualifiedAt: entityName	^self elementUnqualifiedAt: entityName ifAbsent: [nil]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 6/16/2003 17:36'!elementUnqualifiedAt: entityName ifAbsent: aBlock	elements		ifNil: [^aBlock value].	^self elements detect: [:each | each localName = entityName] ifNone: [^aBlock value]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 3/6/2002 10:54'!elements	elements ifNil: [elements _ OrderedCollection new].	^elements! !!XMLNodeWithElements methodsFor: 'enumerating' stamp: 'mir 3/6/2002 10:45'!elementsDo: aBlock	elements		ifNotNil: [			self elements do: [:each | aBlock value: each]]! !!XMLNodeWithElements methodsFor: 'name space' stamp: 'mir 6/5/2003 15:20'!namespace	^ namespace! !!XMLNodeWithElements methodsFor: 'name space' stamp: 'mir 6/16/2003 16:21'!namespace: ns uri: u	namespace _ ns.	uri _ u! !!XMLNodeWithElements methodsFor: 'name space' stamp: 'mir 6/5/2003 15:20'!namespaceURI	^ uri! !!XMLNodeWithElements methodsFor: 'printing' stamp: 'mir 3/6/2002 10:49'!printXMLOn: writer	self elementsDo: [:element | element printXMLOn: writer]! !!XMLNodeWithElements methodsFor: 'accessing' stamp: 'mir 3/6/2002 10:50'!topElement	^self elements first! !!XMLPI class methodsFor: 'instance creation' stamp: 'mir 1/17/2002 13:03'!target: targetName data: aString	^self new		target: targetName;		data: aString! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!data	^data! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!data: aString	data _ aString! !!XMLPI methodsFor: 'testing' stamp: 'mir 1/17/2002 15:28'!isProcessingInstruction	^true! !!XMLPI methodsFor: 'printing' stamp: 'mir 1/17/2002 15:53'!printXMLOn: writer	writer pi: self target data: self data! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!target	^target! !!XMLPI methodsFor: 'accessing' stamp: 'mir 1/17/2002 13:02'!target: aString	target _ aString! !!XMLStringNode class methodsFor: 'instance creation' stamp: 'mir 10/25/2000 11:30'!string: aString	^self new string: aString! !!XMLStringNode methodsFor: 'accessing'!characterData	^self string! !!XMLStringNode methodsFor: 'testing' stamp: 'mir 1/17/2002 15:27'!isText	^true! !!XMLStringNode methodsFor: 'printing' stamp: 'mir 1/17/2002 15:53'!printXMLOn: writer	writer pcData: self string! !!XMLStringNode methodsFor: 'accessing' stamp: 'mir 10/25/2000 11:28'!string	^string ifNil: ['']! !!XMLStringNode methodsFor: 'accessing' stamp: 'mir 10/25/2000 11:28'!string: aString	string _ aString! !!XMLTokenizer commentStamp: '<historical>' prior: 0!XMLTokenizerbolot@cc.gatech.edubreaks the stream of characters into a stream of XMLnodes (aka token stream)token stream is used by XMLparser to generate XMLdocument tree!!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 1/16/2002 00:33'!handleCData: aString	self saxHandler		checkEOD; 		characters: aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'cwp 6/17/2003 18:26'!handleComment: aString	self saxHandler		checkEOD; 		comment: aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 1/8/2002 18:38'!handleEndDocument	self saxHandler endDocument! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 6/24/2003 13:36'!handleEndTag: elementName	| namespace localName namespaceURI qualifiedName |	self usesNamespaces		ifTrue: [			self splitName: elementName into: [:ns :ln |				namespace _ ns.				localName _ ln].			"ensure our namespace is defined"			namespace				ifNil: [					namespace := self scope defaultNamespace.					qualifiedName := namespace , ':' , elementName]				ifNotNil: [					namespaceURI := self scope namespaceURIOf: namespace.					namespaceURI						ifNil: [self parseError: 'Start tag ' , elementName , ' refers to undefined namespace ' , namespace asString].					qualifiedName := elementName].			"call the handler"			self saxHandler				checkEOD; 				endElement: localName namespace: namespace namespaceURI: namespaceURI qualifiedName: qualifiedName.			self scope leaveScope]		ifFalse: [			"call the handler"			self saxHandler				checkEOD; 				endElement: elementName namespace: nil namespaceURI: nil qualifiedName: elementName]! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 1/8/2002 18:24'!handlePCData: aString	self saxHandler		checkEOD; 		characters: aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 1/8/2002 18:24'!handlePI: piTarget data: piData	self saxHandler		checkEOD; 		processingInstruction: piTarget data: piData! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 18:29'!handleStartDocument	self saxHandler startDocument! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 6/24/2003 13:35'!handleStartTag: elementName attributes: attributeList namespaces: namespaces	| localName namespace namespaceURI |	self usesNamespaces		ifTrue: [			self scope enterScope.				"declare any namespaces"					namespaces keysAndValuesDo: [:ns :uri |					self scope declareNamespace: ns uri: uri].			self splitName: elementName into: [:ns :ln |				namespace _ ns.				localName _ ln].			"ensure our namespace is defined"			namespace				ifNil: [namespace := self scope defaultNamespace]				ifNotNil: [					namespaceURI := self scope namespaceURIOf: namespace.					namespaceURI						ifNil: [self parseError: 'Start tag ' , elementName , ' refers to undefined namespace ' , namespace asString]].			self validatesAttributes				ifTrue: [self scope validateAttributes: attributeList].			"call the handler"			self saxHandler				checkEOD; 				startElement: localName namespaceURI: namespaceURI namespace: namespace attributeList: attributeList]		ifFalse: [			"call the handler"			self saxHandler				checkEOD; 				startElement: elementName namespaceURI: nil namespace: nil attributeList: attributeList]! !!SAXDriver methodsFor: 'handling tokens' stamp: 'cwp 6/18/2003 01:00'!handleWhitespace: aString	self saxHandler		checkEOD; 		ignorableWhitespace: aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 6/24/2003 13:39'!handleXMLDecl: attributes namespaces: namespaces	self saxHandler		checkEOD; 		documentAttributes: attributes.	self usesNamespaces		ifTrue: [			namespaces keysAndValuesDo: [:ns :uri |				self scope declareNamespace: ns uri: uri]]! !!SAXDriver methodsFor: 'initialization' stamp: 'mir 6/5/2003 16:29'!initialize	super initialize.	useNamespaces := false.	validateAttributes := false! !!SAXDriver methodsFor: 'accessing' stamp: 'mir 8/11/2000 17:51'!saxHandler	^saxHandler! !!SAXDriver methodsFor: 'accessing' stamp: 'mir 8/11/2000 17:52'!saxHandler: aHandler	saxHandler _ aHandler! !!SAXDriver methodsFor: 'namespaces' stamp: 'mir 6/24/2003 13:40'!scope	scope ifNil: [scope := XMLNamespaceScope new].	^scope! !!SAXDriver methodsFor: 'namespaces' stamp: 'mir 6/16/2003 13:09'!splitName: aName into: twoArgsBlock	"Split the name into namespace and local name (the block arguments).	Handle both qualified and unqualified names using the default name space"	| i ns ln |	i _ aName lastIndexOf: $:.	i = 0		ifTrue: [			ns := nil.			ln := aName]		ifFalse: [			ns := aName copyFrom: 1 to: (i - 1).			ln := aName copyFrom: i+1 to: aName size].	twoArgsBlock value: ns value: ln! !!SAXDriver methodsFor: 'accessing' stamp: 'mir 6/24/2003 14:51'!useNamespaces: aBoolean	useNamespaces := aBoolean! !!SAXDriver methodsFor: 'testing' stamp: 'mir 6/5/2003 16:30'!usesNamespaces	^useNamespaces! !!SAXDriver methodsFor: 'testing' stamp: 'mir 6/5/2003 17:06'!validatesAttributes	^validateAttributes! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:51'!attribute: aSymbol value: aString	"This method is called for each attribute/value pair in a start tag"	^self subclassResponsibility! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:52'!beginStartTag: aSymbol asPI: aBoolean	"This method is called for at the beginning of a start tag.	The asPI parameter defines whether or not the tag is a 'processing	instruction' rather than a 'normal' tag."	^self subclassResponsibility! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:52'!endStartTag: aSymbol	"This method is called at the end of the start tag after all of the	attributes have been processed"	^self subclassResponsibility! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:52'!endTag: aSymbol	"This method is called when the parser encounters either an	end tag or the end of a unary tag"	^self subclassResponsibility! !!XMLParser methodsFor: 'handling tokens' stamp: 'mir 1/17/2002 09:27'!handleCData: aString	self text: aString! !!XMLParser methodsFor: 'handling tokens' stamp: 'mir 1/17/2002 09:26'!handleEndTag: aString	self endTag: aString! !!XMLParser methodsFor: 'handling tokens' stamp: 'mir 1/17/2002 09:27'!handlePCData: aString	self text: aString! !!XMLParser methodsFor: 'handling tokens' stamp: 'mir 1/17/2002 09:26'!handleStartTag: tagName attributes: attributes	self beginStartTag: tagName asPI: false.	attributes keysAndValuesDo: [:key :value |		self attribute: key value: value].	self endStartTag: tagName! !!XMLParser methodsFor: 'callbacks' stamp: 'SqR 7/2/2000 16:52'!text: aString	"This method is called for the blocks of text between tags.	It preserves whitespace, but has all of the enclosed entities expanded"	^self subclassResponsibility! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 8/14/2000 11:41'!addressBookXML	^'<addressbook>  <person employee-number="A0000" family-name="Gates" first-name="Bob">    <contact-info><!!--Confidential--></contact-info>    <address city="Los Angeles" number="1239" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Manager"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7000" family-name="Brown"    first-name="Robert" middle-initial="L.">    <contact-info>      <email address="robb@iro.ibm.com"/>      <home-phone number="03-3987873"/>    </contact-info>    <address city="New York" number="344" state="NY" street="118 St."/>    <job-info employee-type="Full-Time" is-manager="yes" job-description="Group Leader"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7890" family-name="DePaiva"    first-name="Kassie" middle-initial="W.">    <contact-info><!!-- Kassie''s agent phone: 03-987654 --></contact-info>    <address city="Los Angeles" number="1234" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Actor"/>    <manager employee-number="A0000"/>    <misc-info>One of the most talented actresses on Daytime. Kassie      plays the devious and beautiful Blair Cramer on ABC&apos;s      &quot;One Life To Live.&quot;</misc-info>  </person>  <person employee-number="A7987" family-name="Smith" first-name="Joe">    <contact-info>      <email address="joes@iro.ibm.com"/>      <mobile-phone number="888-7657765"/>      <home-phone number="03-8767898"/>      <home-phone number="03-8767871"/>    </contact-info>    <address city="New York" number="12789" state="NY" street="W. 15th Ave."/>    <job-info employee-type="Part-Time" is-manager="no" job-description="Hacker"/>    <manager employee-number="A7000"/>  </person></addressbook>'! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 12/19/2005 16:10'!addressBookXMLWithDTD	^'<?xml version="1.0" encoding="UTF-8"?><!!DOCTYPE addressbook SYSTEM "addressbook.dtd"><addressbook>  <person employee-number="A0000" family-name="Gates" first-name="Bob">    <contact-info><!!--Confidential--></contact-info>    <address city="Los Angeles" number="1239" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Manager"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7000" family-name="Brown"    first-name="Robert" middle-initial="L.">    <contact-info>      <email address="robb@iro.ibm.com"/>      <home-phone number="03-3987873"/>    </contact-info>    <address city="New York" number="344" state="NY" street="118 St."/>    <job-info employee-type="Full-Time" is-manager="yes" job-description="Group Leader"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7890" family-name="DePaiva"    first-name="Kassie" middle-initial="W.">    <contact-info><!!-- Kassie''s agent phone: 03-987654 --></contact-info>    <address city="Los Angeles" number="1234" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Actor"/>    <manager employee-number="A0000"/>    <misc-info>One of the most talented actresses on Daytime. Kassie      plays the devious and beautiful Blair Cramer on ABC&apos;s      &quot;One Life To Live.&quot;</misc-info>  </person>  <person employee-number="A7987" family-name="Smith" first-name="Joe">    <contact-info>      <email address="joes@iro.ibm.com"/>      <mobile-phone number="888-7657765"/>      <home-phone number="03-8767898"/>      <home-phone number="03-8767871"/>    </contact-info>    <address city="New York" number="12789" state="NY" street="W. 15th Ave."/>    <job-info employee-type="Part-Time" is-manager="no" job-description="Hacker"/>    <manager employee-number="A7000"/>  </person></addressbook>'! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 8/14/2000 11:41'!exampleAddressBook	| tokenizer |	"XMLTokenizer exampleAddressBook"	tokenizer _ XMLTokenizer on: self addressBookXML readStream.	[tokenizer next notNil]		whileTrue: []! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 8/14/2000 16:23'!exampleAddressBookWithDTD	| tokenizer |	"XMLTokenizer exampleAddressBookWithDTD"	tokenizer _ XMLTokenizer on: self addressBookXMLWithDTD readStream.	[tokenizer next notNil]		whileTrue: []! !!XMLTokenizer class methodsFor: 'class initialization' stamp: 'mir 3/14/2003 22:54'!initialize	"XMLTokenizer initialize"	| nameDelimiters |	CharEscapes _ #( $& $" $' $> $< ) asSet.	SeparatorTable  _ Array new: 256.	SeparatorTable atAllPut: true.	#(9 10 12 13 32) do: [:each | SeparatorTable at: each+1 put: false].	LiteralChars _ Array new: 256.	LiteralChars atAllPut: false.	':-_.' do: [:each | LiteralChars at: each asciiValue put: true].	1 to: 256 do: [:i | ((i-1) asCharacter isDigit or: [(i-1) asCharacter isLetter])		ifTrue: [LiteralChars at: i put: true]].	nameDelimiters _ #(9 10 12 13 32 61 "$= asInteger 61" 62 "$> asInteger" 47 "$/ asInteger").	NameDelimiters _ Array new: 256.	NameDelimiters atAllPut: false.	nameDelimiters do: [:each | NameDelimiters at: each put: true].	DigitTable _ Array new: 256.	DigitTable atAllPut: -1.	($0 to: $9) do: [:each | DigitTable at: each asciiValue put: each digitValue].	($A to: $F) do: [:each | DigitTable at: each asciiValue put: each digitValue].! !!XMLTokenizer class methodsFor: 'accessing' stamp: 'mir 1/15/2002 21:39'!isCharEscape: aChar	^CharEscapes includes: aChar! !!XMLTokenizer class methodsFor: 'instance creation' stamp: 'mir 8/2/2000 19:25'!new	^super new initialize! !!XMLTokenizer class methodsFor: 'instance creation' stamp: 'mir 11/16/2000 07:58'!on: aStream	^self new parseStream: aStream! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 22:58'!atEnd	nestedStreams == nil		ifTrue: [^peekChar == nil and: [stream atEnd]].	^stream atEnd		ifTrue: [			self popNestingLevel.			self atEnd]		ifFalse: [false]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 18:12'!checkAndExpandReference: parsingContext	| referenceString nextChar |	nextChar _ self peek.	self validating		ifFalse: [^nil].	nextChar == $&		ifTrue: [			self next.			self peek == $#				ifTrue: [^self pushStream: (ReadStream on: self nextCharReference asString)].			referenceString _ self nextLiteral.			self next == $;				ifFalse: [self errorExpected: ';'].			self handleEntity: referenceString in: parsingContext ]		ifFalse: [			((nextChar == $%				and: [self parsingMarkup])				and: [parsingContext == #entityValue])				ifTrue: [					self skipSeparators.					referenceString _ self nextLiteral.					self handleEntity: referenceString in: parsingContext]].	self atEnd ifTrue: [self errorExpected: 'Character expected.'].	^nextChar! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 22:59'!checkNestedStream	nestedStreams == nil		ifFalse: [(peekChar == nil and: [self stream atEnd])			ifTrue: [				self popNestingLevel.				self checkNestedStream]]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/16/2000 21:41'!conditionalInclude: conditionalKeyword	conditionalKeyword = 'INCLUDE'		ifTrue: [^true].	conditionalKeyword = 'IGNORE'		ifTrue: [^false].	^self conditionalInclude: (self parameterEntity: conditionalKeyword) value! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 6/29/2001 00:08'!endDocTypeDecl	"Skip ]>"	self next; next.	^nil! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 11/13/2000 18:19'!endParsingMarkup	parsingMarkup _ false! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/14/2002 15:06'!entities	entities ifNil: [entities _ self initEntities].	^entities! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/17/2002 13:53'!entity: refName	^self validating		ifTrue: [self entities			at: refName			ifAbsentPut: [self parseError: 'XML undefined entity ' , refName printString]]		ifFalse: [DTDEntityDeclaration name: refName value: '']! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/16/2000 21:43'!entity: refName put: aReference	"Only the first declaration of an entity is valid so if there is already one don't register the new value."	self entities at: refName ifAbsentPut: [aReference]! !!XMLTokenizer methodsFor: 'errors' stamp: 'mir 5/14/2003 18:27'!errorExpected: expectedString	| actualString |	actualString := ''.	self atEnd		ifFalse: [			[actualString := self next: 20]				on: Error				do: [:ex | ]].	self parseError: 'XML expected ' , expectedString printString , ': ' , actualString! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/14/2002 17:59'!externalEntities	externalEntities ifNil: [externalEntities _ Dictionary new].	^externalEntities! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/14/2002 17:59'!externalEntity: refName	^self entities		at: refName		ifAbsentPut: ['']! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 3/14/2003 23:09'!fastStreamStringContents: writeStream	| newSize |	newSize _ writeStream position.	^(String new: newSize)		replaceFrom: 1		to: newSize		with: writeStream originalContents		startingAt: 1! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 11/13/2000 16:04'!handleCData: aString	self log: 'CData: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 11:37'!handleComment: aString	self log: 'Comment: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 18:27'!handleEndDocument	self log: 'End Doc '! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 11:38'!handleEndTag: aString	self log: 'End tag: ' , aString! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 1/17/2002 18:12'!handleEntity: referenceString in: parsingContext 	| entity entityValue |	entity _ self entity: referenceString.	entityValue _ entity valueForContext: parsingContext.	(self class isCharEscape: entityValue)		ifTrue: [entityValue _ entity reference].	self pushStream: (ReadStream on: entityValue asString)! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 11:38'!handlePCData: aString	self log: 'PCData: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 12/11/2000 16:10'!handlePI: piTarget data: piData	self log: 'PI: ' , piTarget , ' data ' , piData! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 18:26'!handleStartDocument	self log: 'Start Doc'! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 8/14/2000 11:39'!handleStartTag: tagName attributes: attributes	self log: 'Start tag: ' , tagName.	attributes keysAndValuesDo: [:key :value |		self log: key , '->' , value]! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'cwp 6/17/2003 21:08'!handleWhitespace: aString	self log: 'Whitespace: ' , aString! !!XMLTokenizer methodsFor: 'handling tokens' stamp: 'mir 6/5/2003 14:53'!handleXMLDecl: attributes namespaces: namespaces	attributes keysAndValuesDo: [:key :value |		self log: key , '->' , value]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 6/28/2001 16:45'!hasNestedStreams	^nestedStreams notNil! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 8/17/2004 16:52'!initEntities	| ents |	ents _ Dictionary new.	ents		at: 'amp' put: (DTDEntityDeclaration name: 'amp' value: $&);		at: 'quot' put: (DTDEntityDeclaration name: 'quot' value: $");		at: 'apos' put: (DTDEntityDeclaration name: 'apos' value: $');		at: 'gt' put: (DTDEntityDeclaration name: 'gt' value: $>);		at: 'lt' put: (DTDEntityDeclaration name: 'lt' value: $<).	^ents! !!XMLTokenizer methodsFor: 'initialize' stamp: 'mir 3/14/2003 19:27'!initialize	parsingMarkup _ false.	validating _ false.	attributeBuffer _ WriteStream on: (String new: 128).	nameBuffer _ WriteStream on: (String new: 128)! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 12/7/2000 16:46'!log: aString	"Transcript show: aString; cr"! !!XMLTokenizer methodsFor: 'errors' stamp: 'mir 1/9/2002 15:26'!malformedError: errorString	SAXMalformedException signal: errorString! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 6/28/2001 16:54'!nestedStreams	nestedStreams ifNil: [nestedStreams _ OrderedCollection new].	^nestedStreams! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 23:04'!next	"Return the next character from the current input stream. If the current stream is at end pop to next nesting level if there is one.	Due to the potential nesting of original document, included documents and replacment texts the streams are held in a stack representing the nested streams. The current stream is the top one."	| nextChar |	peekChar		ifNil: [			nestedStreams ifNotNil: [self checkNestedStream].			^nextChar _ stream next]		ifNotNil: [			nextChar _ peekChar.			peekChar _ nil.			^nextChar].	! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/5/2003 16:32'!nextAttributeInto: attributes namespaces: namespaces	| attrName attrValue |	attrName _ self nextName.	self skipSeparators.	self next == $=		ifFalse: [self errorExpected: '='].	self skipSeparators.	attrValue _ self nextAttributeValue.	(self usesNamespaces		and: [(attrName findString: 'xmlns') = 1])		ifTrue: [attrName size > 6			ifTrue: [namespaces at: (attrName copyFrom: 7 to: attrName size) put: attrValue]			ifFalse: [namespaces at: attrName put: attrValue]]		ifFalse: [attributes at: attrName put: attrValue]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 3/14/2003 23:34'!nextAttributeValue	| delimiterChar attributeValueStream nextChar nextPeek referenceString entity entityValue |	delimiterChar _ self next.	(delimiterChar == $"		or: [delimiterChar == $'])		ifFalse: [self errorExpected: 'Attribute value delimiter expected.'].	attributeValueStream _ attributeBuffer reset.	[	nextPeek _ nextChar _ self next.	nextChar ifNil: [self errorExpected: 'Character expected.'].	nextChar == $&		ifTrue: [			self peek == $#				ifTrue: [					nextPeek _ nil.					nextChar _ self nextCharReference]				ifFalse: [					referenceString _ self nextLiteral.					self next == $;						ifFalse: [self errorExpected: ';'].					entity _ self entity: referenceString.					entityValue _ entity valueForContext: #content.					(self class isCharEscape: entityValue)						ifTrue: [							nextPeek _ nil.							nextChar _ entityValue]						ifFalse: [							entityValue _ entityValue asString.							entityValue isEmpty								ifTrue: [nextPeek _ nextChar _ nil]								ifFalse: [									self pushStream: (ReadStream on: entityValue asString).									nextPeek _ nextChar _ self next]]]].	nextPeek == delimiterChar]		whileFalse: [			nextChar ifNotNil: [attributeValueStream nextPut: nextChar]].	^self fastStreamStringContents: attributeValueStream"	^attributeValueStream contents"! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 17:00'!nextCDataContent	| cdata |	"Skip $[ "	self next.	cdata _ self nextUpToAll: ']]>'.	self handleCData: cdata! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 12/6/2000 14:29'!nextCDataOrConditional	| nextChar conditionalKeyword |	"Skip ["	self next.	self skipSeparators.	nextChar _ self peek.	nextChar == $%		ifTrue: [			self checkAndExpandReference: (self parsingMarkup ifTrue: [#dtd] ifFalse: [#content]).			conditionalKeyword _ self nextLiteral.			self skipSeparators.			^self next == $[				ifTrue: [						self skipSeparators.						self nextIncludeSection: (self conditionalInclude: conditionalKeyword)]				ifFalse: [self errorExpected: '[' ]].	nextChar == $C		ifTrue: [			^self nextLiteral = 'CDATA'				ifTrue: [self peek == $[							ifTrue: [self nextCDataContent]							ifFalse: [self errorExpected: '[' ]]				ifFalse: [self errorExpected: 'CData']].	self errorExpected: 'CData or declaration'! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mu 11/14/2005 14:07'!nextCharReference	| base charValue |	self next == $#		ifFalse: [self errorExpected: 'character reference'].	base _ self peek == $x		ifTrue: [			self next.			16]		ifFalse: [10].	charValue _ [self readNumberBase: base] on: Error do: [:ex | self errorExpected: 'Number.'].	(self next) == $;		ifFalse: [self errorExpected: '";"'].	^Unicode value: charValue! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/28/2000 17:54'!nextComment	| string |	"Skip first -"	self next.	self next == $-		ifFalse: [self errorExpected: 'second comment $-'].	string _ self nextUpToAll: '-->'.	self handleComment: string! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/8/2002 13:54'!nextDocType	| declType |	declType _ self nextLiteral.	declType = 'DOCTYPE'		ifTrue: [			self startParsingMarkup.			^self nextDocTypeDecl].	self errorExpected: 'markup declaration, not ' , declType printString! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/17/2002 17:29'!nextDocTypeDecl	| nextChar |	self skipSeparators.	self nextLiteral.	self skipSeparators.	self peek == $[		ifFalse: [[nextChar _ self peek.				nextChar == $> or: [nextChar == $[ ]] whileFalse: [self next]].	self peek == $[		ifTrue: [			self next.			[self skipSeparators.			self peek == $]] whileFalse: [				self checkAndExpandReference: #dtd.				self nextNode].			self next == $] 				ifFalse: [self errorExpected: ']' ]].	self skipSeparators.	self next == $>		ifFalse: [self errorExpected: '>' ].	self endParsingMarkup! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 3/14/2003 23:27'!nextEndTag	| string |	"Skip /"	self next.	self skipSeparators.	string _ self nextTrimmedBlanksUpTo: $>.	"string _ (self nextUpTo: $>) withBlanksTrimmed."	self handleEndTag: string! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'cwp 6/17/2003 21:04'!nextEntity	"return the next XMLnode, or nil if there are no more"	"branch, depending on what the first character is"	self nextWhitespace.	self atEnd ifTrue: [self handleEndDocument. ^ nil].	self checkAndExpandReference: (self parsingMarkup ifTrue: [#dtd] ifFalse: [#content]).	^self peek = $<		ifTrue: [self nextNode]		ifFalse: [self nextPCData]! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/17/2002 14:24'!nextEntityDeclaration	| entityName entityDef referenceClass reference |	self skipSeparators.	referenceClass _ self peek == $%		ifTrue: [			self next.			self skipSeparators.			DTDParameterEntityDeclaration]		ifFalse: [DTDEntityDeclaration].	entityName _ self nextLiteral.	self skipSeparators.	entityDef _ (self peek == $" or: [self peek == $'])		ifTrue: [self nextEntityValue]		ifFalse: [self nextExternalId].	self skipUpTo: $>.	reference _ referenceClass name: entityName value: entityDef.	reference registerIn: self.	^reference! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 18:14'!nextEntityValue	| delimiterChar entityValueStream nextChar nextPeek referenceString entity entityValue |	delimiterChar _ self next.	(delimiterChar == $"		or: [delimiterChar == $'])		ifFalse: [self errorExpected: 'Entity value delimiter expected.'].	entityValueStream _ WriteStream on: (String new).	[	nextPeek _ nextChar _ self peek.	nextChar ifNil: [self errorExpected: 'Character expected.'].	nextChar == $&		ifTrue: [			self next.			self peek == $#				ifTrue: [					nextPeek _ nil.					nextChar _ self nextCharReference]				ifFalse: [					referenceString _ self nextLiteral.					self next == $;						ifFalse: [self errorExpected: ';'].					entity _ self entity: referenceString.					entityValue _ entity valueForContext: #entityValue.					self pushStream: (ReadStream on: entityValue asString).					nextPeek _ nextChar _ self next]]		ifFalse: [			nextChar == $%				ifTrue: [					self skipSeparators.					referenceString _ self nextLiteral.					nextChar _ self handleEntity: referenceString in: #entityValue.					nextPeek _ nextChar _ self next]				ifFalse: [self next]].	nextPeek == delimiterChar]		whileFalse: [			nextChar ifNotNil: [entityValueStream nextPut: nextChar]].	^entityValueStream contents! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'rkris 7/28/2004 12:35'!nextExternalId	| extDefType systemId dir |	extDefType _ self nextLiteral.	extDefType = 'PUBLIC'		ifTrue: [			self skipSeparators.			self nextPubidLiteral.			self skipSeparators.			self peek == $>				ifFalse: [					systemId _ self nextSystemLiteral]].	extDefType = 'SYSTEM'		ifTrue: [			self skipSeparators.			systemId _ self nextSystemLiteral].	systemId		ifNil: [^nil].	"The rest of this method only applies if we're reading aFileStream"	(self topStream isKindOf: FileStream)		ifFalse: [^''].	dir _ self topStream directory.	^(dir fileExists: systemId)		ifTrue: [(dir readOnlyFileNamed: systemId) contentsOfEntireFile]		ifFalse: ['']! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/28/2001 16:38'!nextIncludeSection: parseSection	| section |	"Read the file up to the next include section delimiter and parse it if parseSection is true"		section _ self nextUpToAll: ']]>'.	parseSection		ifTrue: [			self pushStream: (ReadStream on: section)]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 3/14/2003 19:56'!nextLiteral	| resultStream nextChar resultString |	resultStream _ (String new: 10) writeStream.	((nextChar _ self peek) isLetter		or: [nextChar == $_])		ifFalse: [self errorExpected: 'Name literal.'].	[nextChar _ self peek.	(LiteralChars at: nextChar asciiValue+1)		ifTrue: [			nextChar == $&				ifTrue: [					nextChar _ self next.					resultStream nextPut: (self peek == $#						ifTrue: [self nextCharReference]						ifFalse: [^resultStream contents])]				ifFalse: [					resultStream nextPut: self next]]		ifFalse: [resultString _ resultStream contents.			resultString isEmpty				ifTrue: [self errorExpected: 'Name literal']				ifFalse: [^resultString]]] repeat! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/17/2002 13:49'!nextMarkupDeclaration	| declType |	declType _ self nextLiteral.	self validating		ifFalse: [^self skipMarkupDeclaration].	declType = 'ENTITY'		ifTrue: [self nextEntityDeclaration]		ifFalse: [self skipMarkupDeclaration]! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 3/14/2003 23:10'!nextName	| nextChar |	nameBuffer reset.	self peek == $.		ifTrue: [self malformedError: 'Character expected.'].	[(nextChar _ self peek)		ifNil: [self errorExpected: 'Character expected.'].	NameDelimiters at: nextChar asciiValue] whileFalse: [			nameBuffer nextPut: self next].	^self fastStreamStringContents: nameBuffer"	^nameBuffer contents"! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 11/28/2000 17:52'!nextNode	| nextChar |	"Skip < "	self next.	nextChar _ self peek.	nextChar == $!! ifTrue: [		"Skip !!"		self next.		nextChar _ self peek.		nextChar == $- ifTrue: [^self nextComment].		nextChar == $[ ifTrue: [^self nextCDataOrConditional].		^self parsingMarkup			ifTrue: [self nextMarkupDeclaration]			ifFalse: [self nextDocType]].	nextChar == $? ifTrue: [^self nextPI].	^self nextTag! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 18:01'!nextPCData	| resultStream nextChar referenceString entity entityValue nextPeek |	resultStream _ (String new: 10) writeStream.	self validating		ifFalse: [			[self peek == $<]				whileFalse: [resultStream nextPut: self next].			^self handlePCData: resultStream contents].	[	nextPeek _ nextChar _ self peek.	nextChar ifNil: [self errorExpected: 'Character expected.'].	nextChar == $&		ifTrue: [			self next.			self peek == $#				ifTrue: [					nextPeek _ nil.					nextChar _ self nextCharReference]				ifFalse: [					referenceString _ self nextLiteral.					self next == $;						ifFalse: [self errorExpected: ';'].					entity _ self entity: referenceString.					entityValue _ entity valueForContext: #content.					(self class isCharEscape: entityValue)						ifTrue: [							nextPeek _ nil.							nextChar _ entityValue]						ifFalse: [							entityValue _ entityValue asString.							entityValue isEmpty								ifTrue: [nextPeek _ nextChar _ nil]								ifFalse: [									self pushStream: (ReadStream on: entityValue asString).									nextPeek _ nextChar _ self peek]]]]		ifFalse: [nextPeek == $< ifFalse: [self next]].	nextPeek == $<]		whileFalse: [			nextChar ifNotNil: [resultStream nextPut: nextChar]].	self handlePCData: resultStream contents! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 13:00'!nextPI	| piTarget piData |	"Skip ?"	self next.	piTarget _ self nextLiteral.	piTarget asUppercase = 'XML'		ifTrue: [^self nextXMLDecl].	self skipSeparators.	piData _ self nextUpToAll: '?>'.	self handlePI: piTarget data: piData! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 14:25'!nextPubidLiteral	^self nextAttributeValue! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 1/17/2002 14:25'!nextSystemLiteral	^self nextAttributeValue! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/5/2003 22:37'!nextTag	| tagName attributes nextChar namespaces |	(self peek = $/)		ifTrue: [^self nextEndTag].	tagName _ self nextName.	self skipSeparators.	attributes _ Dictionary new: 33.	namespaces _ Dictionary new: 5.	[(nextChar _ self peek) == $> or: [nextChar == $/]] whileFalse: [		self checkAndExpandReference: #content.		self nextAttributeInto: attributes namespaces: namespaces.		self skipSeparators.].	self handleStartTag: tagName attributes: attributes namespaces: namespaces.	self next == $/		ifTrue: [			self handleEndTag: tagName.			self next].	! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 23:27'!nextTrimmedBlanksUpTo: delimiter	| resultStream nextChar |	resultStream _ WriteStream on: (String new: 10).	nextChar _ nil.	[peekChar _ self peek.	peekChar		ifNotNil: [			[peekChar == $ 				and: [nextChar == $ ]]				whileTrue: [peekChar _ self next]].	(nextChar _ self next) == delimiter]		whileFalse: [resultStream nextPut: nextChar].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found'].	^resultStream contents! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 5/14/2003 18:44'!nextUpTo: delimiter	| resultStream nextChar |	resultStream _ WriteStream on: (String new: 10).	[self atEnd or: [(nextChar _ self next) == delimiter]]		whileFalse: [resultStream nextPut: nextChar].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found'].	^resultStream contents! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/9/2002 15:29'!nextUpToAll: delimitingString	| string |	self unpeek.	string _ self stream upToAll: delimitingString.	self stream skip: delimitingString size negated.	(self stream next: delimitingString size) = delimitingString		ifFalse: [self parseError: 'XML no delimiting ' , delimitingString printString , ' found'].	^string! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mu 11/9/2005 09:43'!nextWhitespace	| nextChar resultStream resultString|	resultStream _ (String new: 10) writeStream.	[((nextChar _ self peek) == nil)		or: [SeparatorTable at: nextChar asciiValue+1 ifAbsent:[true]]]		whileFalse: [resultStream nextPut: nextChar. self next].	(nestedStreams == nil or: [self atEnd not])		ifFalse: [self checkNestedStream.				self nextWhitespace].	resultString _ resultStream contents.	resultString isEmpty ifFalse: [self handleWhitespace: resultString].! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'mir 6/5/2003 14:52'!nextXMLDecl	| attributes nextChar namespaces |	self skipSeparators.	attributes _ Dictionary new.	namespaces _ Dictionary new.	[(nextChar _ self peek) == $?] whileFalse: [		self nextAttributeInto: attributes namespaces: namespaces.		self skipSeparators.].	self next.	self next == $>		ifFalse: [self errorExpected: '> expected.'].	self handleXMLDecl: attributes namespaces: namespaces! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/16/2000 21:20'!parameterEntities	parameterEntities ifNil: [parameterEntities _ Dictionary new].	^parameterEntities! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/16/2000 21:40'!parameterEntity: refName	^self parameterEntities		at: refName		ifAbsent: [self parseError: 'XML undefined parameter entity ' , refName printString]! !!XMLTokenizer methodsFor: 'entities' stamp: 'mir 11/16/2000 21:42'!parameterEntity: refName put: aReference	"Only the first declaration of an entity is valid so if there is already one don't register the new value."	self parameterEntities at: refName ifAbsentPut: [aReference]! !!XMLTokenizer methodsFor: 'errors' stamp: 'mir 1/8/2002 15:37'!parseError: errorString	SAXParseException signal: errorString! !!XMLTokenizer methodsFor: 'accessing' stamp: 'mir 6/28/2001 16:51'!parseStream: aStream	self stream: aStream! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 11/13/2000 18:19'!parsingMarkup	^parsingMarkup! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 23:05'!peek	"Return the next character from the current input stream. If the current stream poop to next nesting level if there is one.	Due to the potential nesting of original document, included documents and replacment texts the streams are held in a stack representing the nested streams. The current stream is the top one."	peekChar		ifNil: [			nestedStreams ifNotNil: [self checkNestedStream].			^peekChar _ stream next]		ifNotNil: [^peekChar]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 6/29/2001 00:36'!popNestingLevel	self hasNestedStreams		ifTrue: [			self stream close.			self stream: self nestedStreams removeLast.			self nestedStreams size > 0				ifFalse: [nestedStreams _ nil]]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/16/2002 10:50'!pushBack: aString	| pushBackString |	pushBackString _ peekChar		ifNil: [aString]		ifNotNil: [peekChar asString , aString].	peekChar _ nil.	self pushStream: (ReadStream on: pushBackString)! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/16/2002 10:54'!pushStream: newStream	"Continue parsing from the new nested stream."	self unpeek.	self nestedStreams addLast: self stream.	self stream: newStream! !!XMLTokenizer methodsFor: 'private' stamp: 'mu 11/14/2005 14:12'!readNumberBase: base	"Read a hex number from stream until encountering $; "	| value digit |	base = 10 ifFalse: [	| numberString | 		numberString _ self nextUpTo: $;.		self stream skip: -1.		^Integer readFrom: numberString asUppercase readStream base: base. 	].	value _ 0.	digit _ DigitTable at: self peek asciiValue.	digit < 0		ifTrue: [self error: 'At least one digit expected here'].	self next.	value _ digit.	[digit _ DigitTable at: self peek asciiValue.	digit < 0		ifTrue: [^value]		ifFalse: [			self next.			value _ value * base + digit]		] repeat.	^ value! !!XMLTokenizer methodsFor: 'tokenizing dtd' stamp: 'mir 1/4/2002 11:05'!skipMarkupDeclaration	self skipUpTo: $>! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 3/14/2003 22:54'!skipSeparators	| nextChar |	[((nextChar _ self peek) == nil)		or: [SeparatorTable at: nextChar asciiValue+1]]		whileFalse: [self next].	(nestedStreams == nil or: [self atEnd not])		ifFalse: [			self checkNestedStream.			self skipSeparators]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/16/2002 10:42'!skipUpTo: delimiter	| nextChar |	self unpeek.	[self atEnd or: [(nextChar _ self next) == delimiter]]		whileFalse: [].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found']! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 11/13/2000 18:19'!startParsingMarkup	parsingMarkup _ true! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 6/28/2001 16:50'!stream	^stream! !!XMLTokenizer methodsFor: 'private' stamp: 'mir 6/28/2001 16:50'!stream: newStream	"Continue parsing from the new nested stream."	stream _ newStream! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 1/17/2002 14:31'!topStream	^self hasNestedStreams		ifTrue: [self nestedStreams first]		ifFalse: [self stream]! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 5/14/2003 18:45'!unpeek	peekChar		ifNotNil: [			self stream pushBack: (String with: peekChar).			peekChar _ nil]! !!XMLTokenizer methodsFor: 'testing' stamp: 'mir 6/5/2003 16:33'!usesNamespaces	^false! !!XMLTokenizer methodsFor: 'testing' stamp: 'mir 1/14/2002 17:51'!validating	^validating! !!XMLTokenizer methodsFor: 'accessing' stamp: 'mir 1/14/2002 17:51'!validating: aBoolean	validating _ aBoolean! !!XMLWriter class methodsFor: 'class initialization' stamp: 'ar 12/13/2002 01:04'!initialize	"XMLWriter initialize"	XMLTranslation := Dictionary new.	XMLTranslation		at: Character cr put: '&#13;';		at: Character lf put: '&#10;';		at: Character tab put: '&#9;';		at: $& put: '&amp;';		at: $< put: '&lt;';		at: $> put: '&gt;';"		at: $' put: '&apos;'; "		at: $" put: '&quot;'.	XMLTranslationMap := ByteArray new: 256.	XMLTranslation keysDo:[:ch| XMLTranslationMap at: ch asciiValue+1 put: 1].! !!XMLWriter class methodsFor: 'instance creation' stamp: 'mir 12/8/2000 17:54'!on: aStream	^self basicNew initialize stream: aStream! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 11:04'!attribute: attributeName value: attributeValue	self stream		space;		nextPutAll: attributeName.	self		eq;		putAsXMLString: attributeValue! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:54'!canonical	^canonical! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/7/2000 15:54'!canonical: aBoolean	canonical _ aBoolean! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 12/8/2000 17:55'!cdata: aString	self startCData.	self stream nextPutAll: aString.	self endCData! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 12/8/2000 17:56'!comment: aString	self startComment.	self stream nextPutAll: aString.	self endComment! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 15:09'!declareNamespace: ns uri: uri	self scope declareNamespace: ns uri: uri! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 14:23'!defaultNamespace	^self scope defaultNamespace! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 14:23'!defaultNamespace: ns	"Declare the default namespace."	self scope defaultNamespace: ns! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!endCData	self stream nextPutAll: ']]>'! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!endComment	self stream nextPutAll: ' -->'! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 8/8/2000 18:13'!endDecl: type	self endTag! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 12/8/2000 18:02'!endDeclaration	self stream		cr;		nextPut: $].	self endTag! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 12/8/2000 17:56'!endEmptyTag: tagName	self popTag: tagName.	self stream nextPutAll: '/>'.	self canonical		ifFalse: [self stream space]! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 5/20/2003 12:13'!endPI	self stream nextPutAll: ' ?>'! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 15:25'!endTag	self stream nextPutAll: '>'.	"self canonical		ifFalse: [self stream space]"! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 11:52'!endTag: tagName	self endTag: tagName xmlns: nil! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 6/24/2003 14:46'!endTag: tagName xmlns: xmlns	self popTag: tagName.	self stream		nextPutAll: '</'.	(xmlns notNil		and: [xmlns ~= self defaultNamespace])		ifTrue: [self stream			nextPutAll: xmlns;			nextPut: $:].	stream nextPutAll: tagName.	self endTag.! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 15:02'!enterScope	self scope enterScope! !!XMLWriter methodsFor: 'private' stamp: 'mir 12/8/2000 18:00'!eq	self stream nextPut: $=! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 11:13'!flush	self stream flush! !!XMLWriter methodsFor: 'initialize' stamp: 'mir 6/24/2003 13:41'!initialize	stack _ OrderedCollection new.	canonical _ false.	scope := XMLNamespaceScope new! !!XMLWriter methodsFor: 'namespaces' stamp: 'mir 6/24/2003 14:47'!leaveScope	self scope leaveScope! !!XMLWriter methodsFor: 'writing xml' stamp: 'ar 12/15/2002 15:56'!pcData: aString	| lastIndex nextIndex |	lastIndex := 1.	"Unroll the first search to avoid copying"	nextIndex := String findFirstInString: aString inSet: XMLTranslationMap startingAt: lastIndex.	nextIndex = 0 ifTrue:[^self stream nextPutAll: aString].	[self stream nextPutAll: (aString copyFrom: lastIndex to: nextIndex-1).	self stream nextPutAll: (XMLTranslation at: (aString at: nextIndex)).	lastIndex := nextIndex + 1.	nextIndex := String findFirstInString: aString inSet: XMLTranslationMap startingAt: lastIndex.	nextIndex = 0] whileFalse.	self stream nextPutAll: (aString copyFrom: lastIndex to: aString size).! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 12/11/2000 16:12'!pi: piTarget data: piData	self startPI: piTarget.	self stream nextPutAll: piData.	self endPI! !!XMLWriter methodsFor: 'private' stamp: 'mir 8/7/2000 16:23'!popTag: tagName	| stackTop |	stackTop _ self stack isEmpty		ifTrue: ['<empty>']		ifFalse: [self stack last].	^stackTop = tagName		ifTrue: [self stack removeLast]		ifFalse: [self error: 'Closing tag "' , tagName , '" does not match "' , stackTop]! !!XMLWriter methodsFor: 'private' stamp: 'mir 8/7/2000 16:18'!pushTag: tagName	self stack add: tagName! !!XMLWriter methodsFor: 'private' stamp: 'mir 12/11/2000 16:24'!putAsXMLString: aValue	self stream nextPut: $".	self pcData: aValue.	self stream nextPut: $"! !!XMLWriter methodsFor: 'private' stamp: 'mir 6/24/2003 14:22'!scope	^scope! !!XMLWriter methodsFor: 'private' stamp: 'mir 8/8/2000 17:02'!stack	^stack! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!startCData	self stream nextPutAll: '<!![CDATA['! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!startComment	self stream nextPutAll: '<-- '! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 12/8/2000 18:02'!startDecl: type	self stream		nextPutAll: '<!!';		nextPutAll: type asUppercase;		space! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 12/8/2000 18:02'!startDecl: type named: aString	self stream		nextPutAll: '<!!';		nextPutAll: type asUppercase;		space;		nextPutAll: aString;		space! !!XMLWriter methodsFor: 'writing dtd' stamp: 'mir 12/8/2000 18:02'!startDeclaration: dtdName	self startDecl: 'DOCTYPE' named: dtdName.	self stream		nextPut: $[;		cr! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 1/17/2002 17:07'!startElement: elementName attributeList: attributeList	self canonical		ifFalse: [self stream cr].	self startTag: elementName.	attributeList keys asSortedCollection do: [:key |		self attribute: key value: (attributeList at: key)]! !!XMLWriter methodsFor: 'private tags' stamp: 'mir 12/8/2000 18:01'!startPI: identifier	self stream		nextPutAll: '<?';		nextPutAll: identifier;		space! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 11:51'!startTag: tagName	self startTag: tagName xmlns: nil! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 6/24/2003 14:10'!startTag: tagName xmlns: xmlns	self stream		nextPut: $<.	(xmlns notNil		and: [xmlns ~= self scope defaultNamespace])		ifTrue: [self stream			nextPutAll: xmlns;			nextPut: $:].	self stream		nextPutAll: tagName.	"self canonical		ifFalse: [self stream space]."	self pushTag: tagName! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:54'!stream	^stream! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 12/8/2000 17:54'!stream: aStream	stream _ aStream! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 5/20/2003 12:17'!xmlDeclaration: versionString encoding: encodingString	self canonical		ifFalse: [			self				startPI: 'xml';				attribute: 'version' value: versionString;				attribute: 'encoding' value: encodingString;				endPI.			self stream flush]! !"XML-Parser"!"Installed YAXO auto version 3".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: 'c6e0d836-d1e6-41ac-b1c2-0505bdd46663' autoVersion: '3' asVersion atSeconds: 3347727928 number: 6]!!Integer methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:33'!uversionEqual: anObject	^anObject isInteger and: [ self = anObject ]! !!Integer methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:33'!uversionLessThan: anObject	^anObject isInteger and: [ self < anObject ]! !!UAccountEditor commentStamp: '<historical>' prior: 0!A tool for editing an account!!UAccountEditor class methodsFor: 'class initialization' stamp: 'ls 2/13/2005 16:58'!initialize	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UAccountEditor class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:41'!username: username0  password: password0  email: email0  whenDone: aBlock	^self basicNew		username: username0  password: password0  email: email0  whenDone: aBlock;		yourself! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 17:52'!acceptFields	fields do: [ :f | f accept ]! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:40'!morphicView	| win column nameRow submitButton passwordRow password1Row password2Row emailRow submitButtonHolder |	window ifNotNil: [^window].	win := SystemWindow labelled: 'Account Editor'.	win model: self.	column := AlignmentMorph newColumn.	win addMorph: column frame: (0 @ 0 extent: 1 @ 1).	nameRow := UInterfaceUtilities 				makeFieldRowNamed: 'name:'				getSelector: #username				setSelector: nil				isPassword: false				for: self.	column addMorphBack: nameRow.	passwordRow := UInterfaceUtilities 				makeFieldRowNamed: 'password:'				getSelector: #password				setSelector: #password:				isPassword: true				for: self.	column addMorphBack: passwordRow.	password1Row := UInterfaceUtilities 				makeFieldRowNamed: 'new password'				getSelector: #password1				setSelector: #password1:				isPassword: true				for: self.	column addMorphBack: password1Row.	password2Row := UInterfaceUtilities 				makeFieldRowNamed: 'confirm:'				getSelector: #password2				setSelector: #password2:				isPassword: true				for: self.	column addMorphBack: password2Row.	emailRow := UInterfaceUtilities 				makeFieldRowNamed: 'email:'				getSelector: #newEmail				setSelector: #newEmail:				isPassword: false				for: self.	column addMorphBack: emailRow.	submitButtonHolder := Morph new.	"necessary to keep SystemWindow from screwing up the colors of the button"	submitButtonHolder		layoutPolicy: TableLayout new;		hResizing: #spaceFill;		borderColor: self defaultBackgroundColor.	submitButton := UInterfaceUtilities 				makeButtonWithAction: #submit				andLabel: 'Submit'				for: self.	submitButton		useSquareCorners;		borderWidth: 0.	submitButtonHolder addMorph: submitButton.	column addMorphBack: submitButtonHolder.	^window := win! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:52'!newEmail	^newEmail! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:53'!newEmail: anObject	newEmail _ anObject! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:34'!noteField: field 	"note that the receiver has the specified text field"	fields ifNil: [fields := OrderedCollection new].	fields add: field! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:38'!openInMorphic	^self morphicView openInWorldExtent:  251@263! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:50'!password	^password! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:51'!password1	^newPassword! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:51'!password1: aString	newPassword _ aString asString.	self changed: #password1.	^true! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:51'!password2	^newPassword2! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:51'!password2: aString	newPassword2 _ aString asString.	self changed: #password2.	^true! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 2/13/2005 16:50'!password: aString	password _ aString.	self changed: #password! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:12'!returnTrue	^true! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 16:52'!submit	self acceptFields.	newPassword = newPassword2 ifFalse: [		^self inform: 'new passwords do not match!!' ].	whenDone value: password value: newPassword value: newEmail	! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:50'!username	^username! !!UAccountEditor methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 17:40'!username: username0  password: password0  email: email0  whenDone: aBlock	username _ username0.	password _ password0.	newPassword _ ''.	newPassword2 _ ''.	newEmail _ email0.	whenDone _ aBlock.! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 18:01'!window	^window! !!UPackageEditor commentStamp: '<historical>' prior: 0!A simple GUI for editing a package and then doing something with it.!!UPackageEditor class methodsFor: 'class initialization' stamp: 'ls 2/13/2005 16:58'!initialize	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UPackageEditor class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 16:28'!package: aPackage  whenComplete: aBlock	^self basicNew		package: aPackage  whenComplete: aBlock;		yourself! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 16:41'!acceptFields	fields do: [ :f | f accept ]! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59'!conflictsString	^self stringForPackageNames: package conflicts! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59'!conflictsString: aString 	package conflicts: (self packageNamesFromString: aString).	self changed: #conflictsString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:58'!dependsString	^self stringForPackageNames: package depends! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59'!dependsString: aString 	package depends: (self packageNamesFromString: aString).	self changed: #dependsString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:40'!description	^package description! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:41'!description: aString	package description: aString asString.	self changed: #description.	^true! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 18:00'!homepageString	^package homepage		ifNil: [ '' ]		ifNotNil: [ package homepage toText ]! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 18:01'!homepageString: newHomePage	newHomePage asString = ''		ifTrue: [ package homepage: nil ]		ifFalse: [ package homepage: (Url absoluteFromText: newHomePage asString) ].	self changed: #homepageString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59'!maintainer	^package maintainer! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 18:00'!maintainer: aStringOrText 	package maintainer: aStringOrText asString.	self changed: #maintainer! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 16:34'!makeFieldGet: getSelector  set: setSelector	| field fieldHeight |	fieldHeight _ TextStyle default defaultFont pointSize + 8.					field := PluggableTextMorph on: self text: getSelector accept: setSelector.	field extent: 200@fieldHeight.	field hideScrollBarsIndefinitely.	field setProperty: #alwaysAccept toValue: true.		fields ifNil: [ fields _ OrderedCollection new].	fields add: field.		^field! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 2/15/2005 22:04'!morphicView	| win column nameRow versionRow urlRow descriptionField submitButton dependsRow homepageRow providesRow conflictsRow |	window ifNotNil: [ ^window ].	win _ SystemWindow labelled: 'Package Editor'.	win model: self.	column _ AlignmentMorph newColumn.	win addMorph: column frame: (0@0  extent:  1@0.6).		nameRow _ UInterfaceUtilities makeFieldRowNamed: 'name:' getSelector: #packageName setSelector: #packageName: for: self.	column addMorphBack: nameRow.		versionRow _ UInterfaceUtilities makeFieldRowNamed: 'version:' getSelector: #versionString setSelector: #versionString: for: self.	column addMorphBack: versionRow.		versionRow _ UInterfaceUtilities makeFieldRowNamed: 'maintainer:' getSelector: #maintainer setSelector: #maintainer: for: self.	column addMorphBack: versionRow.		homepageRow _ UInterfaceUtilities makeFieldRowNamed: 'homepage:' getSelector: #homepageString setSelector: #homepageString: for: self.	column addMorphBack: homepageRow.				urlRow _ UInterfaceUtilities makeFieldRowNamed: 'download from:' getSelector: #urlString setSelector: #urlString: for: self.	column addMorphBack: urlRow.	providesRow _ UInterfaceUtilities makeFieldRowNamed: 'provides:' getSelector: #providesString setSelector: #providesString: for: self.	column addMorphBack: providesRow.		dependsRow _ UInterfaceUtilities makeFieldRowNamed: 'depends:' getSelector: #dependsString setSelector: #dependsString: for: self.	column addMorphBack: dependsRow.	conflictsRow _ UInterfaceUtilities makeFieldRowNamed: 'conflicts:' getSelector: #conflictsString setSelector: #conflictsString: for: self.	column addMorphBack: conflictsRow.	column addMorphBack: (StringMorph contents: 'Description:').		descriptionField _ self makeFieldGet: #description set: #description:.	win addMorph: descriptionField frame: (0@0.6 extent: 1@0.3).		submitButton _ UInterfaceUtilities makeButtonWithAction: #submit andLabel: 'Submit' for: self.	win addMorph: submitButton frame: (0@0.9 extent: 1@0.1).			^window _ win! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:34'!noteField: field 	"note that the receiver has the specified text field"	fields ifNil: [fields := OrderedCollection new].	fields add: field! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 18:02'!openInMorphic	^self morphicView openInWorldExtent: 517@488! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:45'!package	^package! !!UPackageEditor methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 16:28'!package: aPackage  whenComplete: aBlock	package _ aPackage.	whenComplete _ aBlock.	! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:38'!packageName	^package name! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:43'!packageName: aString	package name: aString asString.	self changed: #packageName.	^true! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59'!packageNamesFromString: aString 	| depNames |	depNames := aString asString findTokens: ','.	depNames := depNames collect: [:d | d withBlanksTrimmed].	^depNames! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59'!providesString	^self stringForPackageNames: package provides! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59'!providesString: aString 	package provides: (self packageNamesFromString: aString).	self changed: #providesString! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 18:05'!returnTrue	^true! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:58'!stringForPackageNames: depends 	| first |	first := true.	^String streamContents: 			[:str | 			depends do: 					[:depName | 					first ifTrue: [first := false] ifFalse: [str nextPutAll: ', '].					str nextPutAll: depName]]! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 16:43'!submit	self acceptFields.	whenComplete value: package! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:40'!urlString	^package url toText! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:43'!urlString: aString	package url: (Url absoluteFromText: aString asString).	self changed: #urlString.	^true! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:39'!versionString	^package version printString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:39'!versionString: aString	package version: (UVersion readFromString: aString).	self changed: #versionString.	^true! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 17:12'!window	^window! !!UUniverse commentStamp: 'ls 2/13/2005 11:10' prior: 0!Abstract.  One "package universe".  A package universe is an evolving set of packages that multiple people can participate in.  Each Squeak image is a member of exactly one universe.!!UCompoundUniverse commentStamp: 'ls 7/29/2004 18:48' prior: 0!A universe that is the union of other universes.!!UCompoundUniverse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 18:47'!composedOf: universes	^self new		components: universes;		yourself! !!UCompoundUniverse methodsFor: 'accessing' stamp: 'ls 2/13/2005 14:56'!components: anObject	components _ anObject.	components do: [ :c | c addDependent:  self ].! !!UCompoundUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:09'!packages	^Array streamContents: [ :pstr |		components do: [ :univ |			pstr nextPutAll: univ packages ] ]! !!UCompoundUniverse methodsFor: 'accessing' stamp: 'ls 7/29/2004 18:50'!standardUniverses	^Array streamContents: [ :str |		components do: [ :comp |			str nextPutAll: comp standardUniverses  ] ]! !!UCompoundUniverse methodsFor: 'updating' stamp: 'ls 2/13/2005 14:57'!update: aSymbol	aSymbol = #packages ifTrue: [ self changed: #packages ].! !!UCompoundUniverse methodsFor: 'packages' stamp: 'ls 2/13/2005 14:58'!updatePackagesViaWWW	components do: [ :component | component updatePackagesViaWWW ]! !!UStandardUniverse commentStamp: 'ls 7/28/2004 10:36' prior: 0!A universe that looks to one single server for authoritative information.!!UStandardUniverse methodsFor: 'packages' stamp: 'ls 2/13/2005 12:43'!addPackage: aPackage	"make sure that we end up with no two packages with the same name and version"	packages removeAllSuchThat: [ :p | p name = aPackage name and: [ p version = aPackage version ] ].		"now add the new package"	packages add: aPackage.	self changed: #packages! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 1/16/2005 14:07'!initialize	super initialize.	packages _ Set new.! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 1/16/2005 14:07'!packages	^packages! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 15:01'!packages: aCollection	packages _ Set new.	packages addAll: aCollection.	self changed: #packages! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 2/13/2005 11:13'!packagesURL	"a URL from which the list of packages may be downloaded"	^packagesURL! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 11:12'!packagesURL: aURL	packagesURL _ aURL! !!UStandardUniverse methodsFor: 'packages' stamp: 'ls 2/13/2005 12:43'!removePackage: aPackage	packages remove: aPackage.	self changed: #packages! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 7/28/2004 13:21'!serverName	^serverName! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 10:37'!serverName: aString		serverName _ aString! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 7/28/2004 13:21'!serverPort	^serverPort! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 10:37'!serverPort: port	serverPort _ port! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 7/29/2004 18:09'!standardUniverses	^{self}! !!UStandardUniverse methodsFor: 'packages' stamp: 'ls 2/15/2005 22:42'!updatePackagesViaWWW	| rawPackageList newPackages |	packagesURL ifNil: [ ^self ].	rawPackageList _ packagesURL retrieveContents content.	(rawPackageList withBlanksTrimmed beginsWith: '<') ifFalse: [		"it is possible that the universe is completely empty, but more likely there was an error retrieving the document"		^self ].	newPackages _ UPackage decodePackagesFromXMLStream: (ReadStream on: rawPackageList).	self packages: newPackages! !!UUniverse class methodsFor: 'well known' stamp: 'ls 2/15/2005 23:32'!developmentUniverse 	"[UUniverse switchSystemToUniverse: UUniverse developmentUniverse]"	^UStandardUniverse new		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		shortName: 'development';		description: 'Development';		packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/development.packages' asUrl;		yourself! !!UUniverse class methodsFor: 'well known' stamp: 'ls 2/13/2005 12:45'!exampleCompoundUniverse	"[UUniverse switchSystemToUniverse: UUniverse exampleCompoundUniverse]"	^(UCompoundUniverse composedOf: {		self developmentUniverse.		self homeMoviesUniverse	}) description: 'example compound universe'; yourself! !!UUniverse class methodsFor: 'well known' stamp: 'ls 2/15/2005 23:33'!homeMoviesUniverse 	"[UUniverse switchSystemToUniverse: UUniverse homeMoviesUniverse]"	^UStandardUniverse new		shortName: 'homemovies';		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/homemovies.packages' asUrl;		description: 'Home Movies';		yourself! !!UUniverse class methodsFor: 'class initialization' stamp: 'ls 2/15/2005 23:42'!initialize	"fix up old instances, to have a proper packagesURL"	"this method should be deleted, after suitable time has passed to allow for upgrades"	self allSubInstancesDo: [ :universe |		universe class == UStandardUniverse ifTrue: [			universe packagesURL == nil ifTrue: [				"no URL specified.  guess...."				universe serverPort = 4129 ifTrue: [					universe shortName: 'development'.					universe packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/development.packages' asUrl.					universe serverPort: UUniverseMultiServer defaultPort. ].				universe serverPort = 8940 ifTrue: [ 					universe shortName: 'homevideos'.					universe packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/homemovies.packages' asUrl.					universe serverPort: UUniverseMultiServer defaultPort. ].				universe serverPort = 7273 ifTrue: [ 					universe shortName: 'squeak37'.					universe packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/squeak37.packages' asUrl.					universe serverPort: UUniverseMultiServer defaultPort. ]. ] ] ]! !!UUniverse class methodsFor: 'well known' stamp: 'ls 2/15/2005 23:33'!squeak37Universe 	"[UUniverse switchSystemToUniverse: UUniverse squeak37Universe]"	^UStandardUniverse new		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		shortName: 'squeak37';		description: 'Squeak 3.7';		packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/squeak37.packages' asUrl;		yourself! !!UUniverse class methodsFor: 'system' stamp: 'ls 7/29/2004 18:54'!switchSystemToUniverse: aUniverse	SystemUniverse _ aUniverse! !!UUniverse class methodsFor: 'system' stamp: 'ls 2/13/2005 12:44'!systemUniverse	"return the universe this image uses"	^SystemUniverse ifNil: [ SystemUniverse _ self developmentUniverse ]! !!UUniverse methodsFor: 'packages' stamp: 'ls 7/29/2004 19:09'!addPackages: newPackages	newPackages do: [ :p | self addPackage: p ]! !!UUniverse methodsFor: 'accessing' stamp: 'ls 2/13/2005 11:10'!description	"The description is a one-line description of the universe for human consumption."	^description! !!UUniverse methodsFor: 'initialize-release' stamp: 'ls 7/29/2004 16:16'!description: aString	description _ aString! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:06'!hasPackageNamed: name	^self packages anySatisfy: [ :p | p name = name ].	! !!UUniverse methodsFor: 'initialize-release' stamp: 'ls 1/16/2005 14:07'!initialize	description _ 'some universe'.! !!UUniverse methodsFor: 'packages' stamp: 'ls 7/28/2004 17:17'!newestPackageNamed: name	| potentials sorted |	potentials _ self packagesNamed: name.	sorted _ potentials asSortedCollection: [ :p1 :p2 | p1 version < p2 version ].	^sorted last! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:06'!packageNames	| names |	names _ Set new.	self packages do: [ :p | names add: p name ].	^names! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:08'!packages	^self subclassResponsibility! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:07'!packagesNamed: name	^self packages select: [ :p | p name = name ].	! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:06'!removePackageNamed: packageName withVersion: version	| packagesToRemove |	packagesToRemove _ self packages select: [ :p | p name = packageName and: [ p version = version ] ].	packagesToRemove do: [ :p | self removePackage: p ].	! !!UUniverse methodsFor: 'accessing' stamp: 'ls 2/13/2005 14:46'!shortName	"A short, computer-friendly alphanumeric identifier"	^shortName! !!UUniverse methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 11:10'!shortName: aString	shortName _ aString! !!UUniverse methodsFor: 'accessing' stamp: 'ls 2/15/2005 21:49'!standardUniverses	"return a list of standard universes within the receiver.  See class UStandardUniverse"	^self subclassResponsibility! !!UUniverse methodsFor: 'packages' stamp: 'ls 2/13/2005 14:56'!updatePackagesViaWWW	"update the packages in this universe by downloading them from the universe's URL"	^self subclassResponsibility! !!UUniverseBrowser commentStamp: '<historical>' prior: 0!A tool to support one-click installs and upgrades of packages within a universe.!!UUniverseBrowser class methodsFor: 'instance creation' stamp: 'ls 2/13/2005 14:53'!forUniverse: aUniverse	^self new universe: aUniverse; yourself! !!UUniverseBrowser class methodsFor: 'class initialization' stamp: 'ls 9/4/2004 14:29'!initialize	TheWorldMenu registerOpenCommand: {'Universe Browser'. {self. #open}}.	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UUniverseBrowser class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 18:15'!open	^self new open! !!UUniverseBrowser class methodsFor: 'dependencies' stamp: 'ls 7/29/2004 15:16'!orderPackagesByDependency: packages	"return a collection of the specified packages such that, when possible, any dependencies of a package are ordered before that package"	"The present algorithm is simple but slow..."	| remainingPackages orderedPackages packagesToAdd |	remainingPackages _ Set new.	orderedPackages _ OrderedCollection new.	remainingPackages addAll: packages.		"each time through this loop, add to orderedPackages any packages whose dependencies are not in remainaingPackages"	[	packagesToAdd := remainingPackages select: [ :p | p depends noneSatisfy: [ :depName | remainingPackages anySatisfy: [ :p2 | p2 name = depName ] ] ].		packagesToAdd isEmpty not	] whileTrue: [		orderedPackages addAll: packagesToAdd.		remainingPackages := remainingPackages difference: packagesToAdd ].		orderedPackages addAll: remainingPackages.	^orderedPackages! !!UUniverseBrowser class methodsFor: 'class initialization' stamp: 'ls 7/29/2004 18:15'!unload	TheWorldMenu unregisterOpenCommand: 'Universe Browser'! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 7/29/2004 17:31'!allPackagesNeededToInstall: initialPackage  orIfImpossible: errorBlock	"find all packages needed to installed initialPackage; if it is impossible to accomplish, invoke errorBlock with the name of the missing package"	| newPackages packagesToConsider |	newPackages _ Set new.	packagesToConsider _ OrderedCollection with: initialPackage.	[ packagesToConsider isEmpty ] whileFalse: [		| package |		package _ packagesToConsider removeFirst.		(newPackages includes: package) ifFalse: [			newPackages add: package.			package depends do: [ :depName |				((configuration includesPackageNamed: depName) not and: [ packagesToInstall noneSatisfy: [ :p | p name = depName  ] ])				ifTrue: [					"the dependency is needed but is not installed or planned to be installed"					(universe hasPackageNamed: depName) ifTrue: [						"in principle, one could additionally consider trying a different package than the newest..."						packagesToConsider add: (universe newestPackageNamed: depName) ]					ifFalse: [						^errorBlock value: depName ] ] ] ] ].		^newPackages! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 7/27/2004 21:34'!anyPackageSelected	^selectedPackageIndex > 0! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 9/4/2004 14:36'!anyPackagesToInstall	^packagesToInstall isEmpty not! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 9/4/2004 14:16'!canMarkSelectionForInstallation	^self anyPackageSelected and: [ (packagesToInstall includes: self selectedPackage) not ]! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 7/28/2004 10:27'!chooseUpgrades	"select packages that appear to be upgrades of packages that are already installed"	universe packageNames do: [ :name |		(configuration includesPackageNamed: name) ifTrue: [			| cpack mypack |			cpack _ configuration packageNamed: name.			mypack _ universe newestPackageNamed: name.			mypack version > cpack version ifTrue: [				self planToInstallPackageWithoutUIUpdate: mypack ] ] ].		self changed: #packageDescriptions.! !!UUniverseBrowser methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:58'!configuration: aConfiguration	configuration _ aConfiguration! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 9/4/2004 14:19'!doInstall	| orderedPackages |	packagesToInstall isEmpty ifTrue: [		^self inform: 'no packages selected to install' ].			orderedPackages := UUniverseBrowser orderPackagesByDependency: packagesToInstall.	orderedPackages do: [ :p | 		Utilities informUser: 'installing ', p printString during: [			configuration installPackage: p ] ].	packagesToInstall _ Set new.	self changed: #packageDescriptions.! !!UUniverseBrowser methodsFor: 'initialize-release' stamp: 'ls 7/30/2004 15:05'!initialize	configuration _ UConfiguration forSystem.	selectedPackageIndex _ 0.	packagesToInstall _ Set new.	self universe: UUniverse systemUniverse.! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 7/29/2004 17:11'!installSelectedPackage	self anyPackageSelected ifFalse: [ ^self ].	self planToInstallPackage: self selectedPackage.		! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 9/4/2004 14:37'!makeButtonWithAction: selector andGetState: getStateSelector andLabel: aString	^(PluggableButtonMorph on: self getState: getStateSelector action: selector)		label: aString;		useRoundedCorners;		vResizing: #spaceFill;		hResizing: #spaceFill;		onColor: self defaultBackgroundColor offColor: self defaultBackgroundColor muchLighter;		yourself! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 9/4/2004 14:35'!makeButtonWithAction: selector  andLabel: aString	^self makeButtonWithAction: selector andGetState: #returnTrue andLabel: aString! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 2/13/2005 15:14'!morphicView	| win packageList installButton doInstallButton titleArea buttonList upgradeButton updateListButton descriptionArea installButtonHolder |	win _ SystemWindow labelled: 'Universe'.	win model: self.		titleArea _ PluggableTextMorph on: self text: #titleAreaText accept: nil.	titleArea hideScrollBarsIndefinitely.	titleArea name: 'universe title'.	win addMorph: titleArea frame: (0@0 extent: 1@0.1).		packageList _ PluggableListMorph on: self list: #packageDescriptions  selected: #selectedPackageIndex changeSelected: #selectedPackageIndex: menu: nil.	packageList name: 'package list'.	win addMorph: packageList frame: ((0@0.1) extent: (0.5@0.8)).		installButtonHolder _ Morph new.  "necessary to keep SystemWindow from screwing up the colors of the button"	installButtonHolder 		name: 'holder for install button';		layoutPolicy: TableLayout new;		borderColor: self defaultBackgroundColor.	doInstallButton _ self makeButtonWithAction: #doInstall andGetState: #anyPackagesToInstall andLabel: 'Install Selections'.	doInstallButton		useSquareCorners;		borderWidth: 0;		setBalloonText: 'Download and install all the packages that you have selected';		name: 'install selections button'.	installButtonHolder addMorph: doInstallButton.	win addMorph: installButtonHolder frame: ((0@0.9) extent:(1@0.1)).	descriptionArea _ PluggableTextMorph on: self text: #selectedPackageDescription accept: nil.	win addMorph: descriptionArea frame: ((0.5@0.4) extent: (0.5@0.5)).		buttonList _ AlignmentMorph newColumn.	buttonList		cellInset: 0@3;		name: 'button list'.	win addMorph: buttonList frame: ((0.5@0.1) extent: (0.5@0.3)).			installButton _ self makeButtonWithAction: #installSelectedPackage andGetState: #canMarkSelectionForInstallation andLabel: 'select package'.	installButton setBalloonText: 'Select this package for installation'.	buttonList addMorph: installButton.		upgradeButton _ self makeButtonWithAction: #chooseUpgrades andLabel: 'select all upgrades'.	upgradeButton setBalloonText: 'Select every possible upgrade for the currently installed packages'.	buttonList addMorphBack: upgradeButton.		updateListButton _ self makeButtonWithAction: #requestPackageList andLabel: 'update list from network'.	updateListButton setBalloonText: 'Refresh the list of available packages from the network'.	buttonList addMorphBack: updateListButton.		^win! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 7/29/2004 16:19'!open	self morphicView openInWorld! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 7/27/2004 22:02'!packageDescriptions	| commentary |	^self sortedPackages collect: [ :p |		commentary _ ''.		(packagesToInstall includes: p) ifTrue: [ commentary _ ' (install)' ].		(configuration installedPackages includes: p) ifTrue: [ commentary _ ' (installed)' ].				p printString, commentary. ]! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 2/13/2005 15:12'!packagesChanged	packagesToInstall _ Set new.  "the selected packages may not be there any more!!"	self selectedPackageIndex: 0.		self changed: #packageDescriptions.	! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 7/29/2004 17:11'!planToInstallPackage: package	"plan to install a package plus its dependencies; refuses if any dependencies cannot be met"	self planToInstallPackageWithoutUIUpdate: package.	self changed: #packageDescriptions.	! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 7/29/2004 17:31'!planToInstallPackageWithoutUIUpdate: initialPackage	"same as planToInstallPackage:, but does not called #changed:.  Don't call this unless you later call #changed: yourself"	| newPackages |	"find all packages needed to install this one"	newPackages _ self allPackagesNeededToInstall: initialPackage orIfImpossible: [ :missingDep |		^self notify: 'could not find necessary package: ', missingDep ].		packagesToInstall removeAllSuchThat: [ :p | p name = initialPackage name ].	newPackages do: [ :p | packagesToInstall add: p ].	! !!UUniverseBrowser methodsFor: 'server communication' stamp: 'ls 2/15/2005 22:40'!requestPackageListuniverse addDependent: self.  "hack, to aid upgrading from Universes 0.5"	Utilities informUser: 'updating package list...' during:  [		universe updatePackagesViaWWW ]! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 9/4/2004 14:35'!returnTrue	"return true; used for buttons that are always enabled"	^true! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 7/27/2004 21:33'!selectedPackage	^self sortedPackages at: self selectedPackageIndex! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 2/13/2005 18:05'!selectedPackageDescription	self anyPackageSelected ifFalse: [ ^ '' ].	^String streamContents: [ :str |		str nextPutAll: self selectedPackage description; cr; cr.		self selectedPackage provides isEmpty ifFalse: [			str nextPutAll: 'Provides:'; cr.			self selectedPackage provides do: [ :depName |				str tab; nextPutAll: depName; cr ].			str cr].		self selectedPackage depends isEmpty ifFalse: [			str nextPutAll: 'Depends on:'; cr.			self selectedPackage depends do: [ :depName |				str tab; nextPutAll: depName; cr ].			str cr].		self selectedPackage conflicts isEmpty ifFalse: [			str nextPutAll: 'Conflicts with:'; cr.			self selectedPackage conflicts do: [ :depName |				str tab; nextPutAll: depName; cr ].			str cr].		str nextPutAll: ('Maintained by: ', self selectedPackage maintainer); cr.		str nextPutAll: ('Downloads from: ', self selectedPackage url toText); cr.		self selectedPackage homepage ifNotNil: [			str nextPutAll: ('Homepage: ', self selectedPackage homepage toText); cr]. ].	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 7/27/2004 21:26'!selectedPackageIndex	^selectedPackageIndex! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 9/4/2004 14:35'!selectedPackageIndex: anInteger	selectedPackageIndex _ anInteger.	self changed: #selectedPackageIndex.	self changed: #selectedPackageDescription.	self changed: #canMarkSelectionForInstallation.! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 7/27/2004 21:31'!sortedPackages	^universe packages asSortedCollection: [ :p1 :p2 |		p1 name < p2 name or: [			p1 name = p2 name and: [ p1 version < p2 version ] ] ].	! !!UUniverseBrowser methodsFor: 'title pane' stamp: 'ls 7/29/2004 16:18'!titleAreaText	^universe description! !!UUniverseBrowser methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 15:12'!universe: aUniverse	universe _ aUniverse.	universe addDependent: self.! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 2/13/2005 15:12'!update: aSymbol	aSymbol = #packages ifTrue: [ self packagesChanged ]! !!UAccount commentStamp: '<historical>' prior: 0!An account as used in the standard UPolicy's.!!UAccount methodsFor: 'packages' stamp: 'ls 7/28/2004 18:03'!addPackageName: name	packageNames add: name! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:47'!email: aString	email _ aString! !!UAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 18:02'!initialize	username _ 'joeblow'.	password _ ''.	packageNames _ Set new.! !!UAccount methodsFor: 'packages' stamp: 'ls 7/28/2004 18:03'!ownsPackageName: name	^packageNames includes: name! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:50'!password	^password! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:47'!password: anObject	password _ anObject! !!UAccount methodsFor: 'printing' stamp: 'ls 2/15/2005 23:44'!printOn: aStream	aStream nextPutAll: 'Account: ', username! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:50'!username	^username! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:47'!username: anObject	username _ anObject! !!UConfiguration commentStamp: '<historical>' prior: 0!One configuration of packages.!!UConfiguration class methodsFor: 'system' stamp: 'ls 7/27/2004 21:57'!forSystem	"return a configuration describing the currently running system"	^SystemConfiguration ifNil: [ SystemConfiguration _ self new ].	! !!UConfiguration methodsFor: 'packages' stamp: 'ls 7/28/2004 10:19'!includesPackageNamed: name	^self installedPackages anySatisfy: [ :p | p name = name ]! !!UConfiguration methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:55'!initialize	installedPackages _ Set new.! !!UConfiguration methodsFor: 'installing' stamp: 'ls 7/27/2004 21:55'!installPackage: aPackage	| matchingPackages |	matchingPackages _ installedPackages select: [ :p | p name = aPackage name ].	installedPackages removeAll: matchingPackages.	aPackage install.	installedPackages add: aPackage.	! !!UConfiguration methodsFor: 'packages' stamp: 'ls 7/27/2004 22:02'!installedPackages	^installedPackages! !!UConfiguration methodsFor: 'packages' stamp: 'ls 7/28/2004 10:18'!packageNamed: name	^self installedPackages detect: [ :p | p name = name ]! !!UInstaller commentStamp: '<historical>' prior: 0!A simply hierarchy for loading Squeak content in various formats.!!UIFileOut methodsFor: 'testing' stamp: 'ls 9/4/2004 14:02'!handlesFilename: filename	^#('.cs' '.st' '.st.gz' '.cs.gz') anySatisfy: [ :ending | filename endsWith: ending ]! !!UIFileOut methodsFor: 'installing' stamp: 'ls 7/29/2004 20:01'!install: inStream  usingBaseName: basename	"find a changeset name that is not used"	| num changesetName stream |	num _ 0.	[  	changesetName _ basename.	   	num > 0 ifTrue:[ changesetName _ changesetName, '-', num printString. ].		(ChangeSorter changeSetNamed: changesetName) notNil ]	whileTrue: [ num _ num + 1 ].		"decompress if necessary"	inStream peek asInteger = 16r1F		ifTrue: [ stream _ ReadStream on: ((GZipReadStream on: inStream) upToEnd) asString ]		ifFalse: [ stream _ inStream ].			ChangeSorter newChangesFromStream: stream named: changesetName! !!UIMonticello methodsFor: 'testing' stamp: 'ls 7/29/2004 11:04'!handlesFileEnding: ending	^#('mcz') includes: ending! !!UIMonticello methodsFor: 'installing' stamp: 'ls 7/29/2004 19:26'!installFileNamed: filename	Smalltalk at: #MCMczReader ifPresent: [ :reader |		^reader loadVersionFile: filename ].	MczInstaller installFileNamed: filename! !!UIMpeg methodsFor: 'testing' stamp: 'ls 7/29/2004 11:04'!handlesFileEnding: ending	^#('mpg' 'mpeg') includes: ending! !!UIMpeg methodsFor: 'installing' stamp: 'ls 7/29/2004 11:39'!install: stream usingBasename: basename	| movieDir movieFile |	movieDir := FileDirectory default directoryNamed: 'movies'.	movieDir assureExistence.		movieDir removeFileNamed: basename.		movieFile _ movieDir newFileNamed: basename, '.mpeg'.	stream binary.  movieFile binary.	movieFile nextPutAll: stream upToEnd.	movieFile close.		Smalltalk at: #MPEGMoviePlayerMorph ifPresent: [ :player |		player playFile: (movieDir fullNameFor: basename, '.mpeg') ]! !!UIProject methodsFor: 'testing' stamp: 'ls 7/29/2004 11:05'!handlesFileEnding: ending	^#('pr') includes: ending! !!UIProject methodsFor: 'installing' stamp: 'ls 9/18/2004 18:18'!installFileNamed: filename	FileDirectory splitName: filename to: [ :path :base |		[ 				ProjectViewMorph openFromDirectory: (FileDirectory on: path) andFileName: base		] on: ProjectEntryNotification do:		[ :ex |			"don't enter it" ] ]! !!UISar methodsFor: 'testing' stamp: 'ls 7/29/2004 11:04'!handlesFileEnding: ending	^#('sar') includes: ending! !!UISar methodsFor: 'installing' stamp: 'ls 7/29/2004 11:44'!installFileNamed: filename	SARInstaller installSAR: filename! !!UInstaller class methodsFor: 'initialization' stamp: 'ls 7/29/2004 11:09'!initialize	Installers ifNil: [ Installers _ Set new ].		{UIFileOut. UIMonticello. UIMpeg. UIProject. UISar} do: [ :c |		self registerInstaller: c new ]! !!UInstaller class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 11:10'!installFileNamed: filename	(self installerForFilename: filename) installFileNamed: filename! !!UInstaller class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 11:10'!installerForFilename: filename	^self registeredInstallers detect: [ :i | i handlesFilename: filename ] ifNone: [ self error: 'no installer handles file ', filename ].! !!UInstaller class methodsFor: 'registry' stamp: 'ls 7/29/2004 11:02'!registerInstaller: installer	Installers add: installer! !!UInstaller class methodsFor: 'registry' stamp: 'ls 7/29/2004 11:11'!registeredInstallers	^Installers asArray! !!UInstaller methodsFor: 'comparing' stamp: 'ls 7/29/2004 11:02'!= anInstaller	^self class = anInstaller class! !!UInstaller methodsFor: 'testing' stamp: 'ls 7/29/2004 10:59'!handlesFileEnding: anEnding	^false! !!UInstaller methodsFor: 'testing' stamp: 'ls 7/29/2004 11:08'!handlesFilename: filename	^self handlesFileEnding: (FileDirectory extensionFor: filename)	! !!UInstaller methodsFor: 'comparing' stamp: 'ls 7/29/2004 11:03'!hash	^self class hash! !!UInstaller methodsFor: 'installing' stamp: 'ls 7/29/2004 11:06'!install: stream  usingBaseName: baseName	self subclassResponsibility! !!UInstaller methodsFor: 'installing' stamp: 'ls 9/4/2004 15:02'!installFileNamed: filename	| stream baseName |	stream _ (FileStream readOnlyFileNamed: filename).	baseName _ (FileDirectory splitName: filename to: [:path :base|base]) copyUpTo: $. .	self install: stream usingBaseName: baseName.	stream close.	! !!UInterfaceUtilities commentStamp: 'ls 2/13/2005 17:22' prior: 0!This class holds miscellaneous bits of code used to build user interfaces in the various Universes tools.!!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:37'!makeButtonWithAction: selector andGetState: getStateSelector andLabel: aString for: model	^(PluggableButtonMorph on: model getState: getStateSelector action: selector)		label: aString;		useRoundedCorners;		vResizing: #spaceFill;		hResizing: #spaceFill;		onColor: model defaultBackgroundColor offColor: model defaultBackgroundColor muchLighter;		yourself! !!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:41'!makeButtonWithAction: selector  andLabel: aString for: model	^self makeButtonWithAction: selector andGetState: #returnTrue  andLabel: aString	for: model! !!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:34'!makeFieldGet: getSelector  set: setSelector  for: model	| field fieldHeight |	fieldHeight _ TextStyle default defaultFont pointSize + 8.					field := PluggableTextMorph on: model text: getSelector accept: setSelector.	field height: fieldHeight.	field hResizing: #spaceFill.	field hideScrollBarsIndefinitely.	field setProperty: #alwaysAccept toValue: true.	model noteField: field.	^field! !!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:42'!makeFieldRowNamed: fieldName  getSelector: getSelector setSelector: setSelector for: model	^self makeFieldRowNamed: fieldName  getSelector: getSelector setSelector: setSelector isPassword: false for: model! !!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:36'!makeFieldRowNamed: fieldName  getSelector: getSelector setSelector: setSelector isPassword: isPassword for: model	| row field |	row _ AlignmentMorph newRow.	row color: Color transparent.	row cellInset: 3@0.		field _ self makeFieldGet: getSelector set: setSelector for: model.	isPassword ifTrue:[		field font: (StrikeFont passwordFontSize: TextStyle default defaultFont pointSize) ].	row addMorph: (StringMorph contents: fieldName).	row addMorphBack: field.	^row! !!UMessage commentStamp: '<historical>' prior: 0!A message that can be sent to or from a UServer.  All instances may be converted to an array of strings, and that array of strings may be parsed back with fromStringArray:.!!UMAddAccount commentStamp: '<historical>' prior: 0!A request to add a user account.!!UMAddAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:34'!fromStringArray: stringArray	^self username: stringArray second password: stringArray third email: stringArray fourth! !!UMAddAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:34'!username: username  password: password  email: email	^self basicNew username: username  password: password  email: email! !!UMAddAccount methodsFor: '*universes-server' stamp: 'ls 7/28/2004 21:46'!applyToServer: server forConnection: connection	server connection: connection requestedAccountWithUsername: username password: password email: email! !!UMAddAccount methodsFor: 'converting' stamp: 'ls 7/28/2004 14:34'!asStringArray	^{'addaccount' . username . password . email}! !!UMAddAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:33'!username: username0  password: password0  email: email0	username _ username0.	password _ password0.	email _ email0.	! !!UMAddPackage class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:07'!fromStringArray: array	^self username: array second password: array third package: (UPackage decodeFromStringStream: (ReadStream on: (array allButFirst: 3)))! !!UMAddPackage class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:37'!username: username password: password package: package	^self basicNew username: username password: password package: package! !!UMAddPackage methodsFor: '*universes-server' stamp: 'ls 7/28/2004 17:03'!applyToServer: server forConnection: connection	server connection: connection requestedForUsername: username andPassword: password toAddPackage: package! !!UMAddPackage methodsFor: 'converting' stamp: 'ls 7/28/2004 16:56'!asStringArray	^{'addpackage' . username . password },	  package stringArrayEncoding! !!UMAddPackage methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:37'!username: username0 password: password0 package: package0	username _ username0.	password _ password0.	package _ package0.	! !!UMEditAccount commentStamp: '<historical>' prior: 0!A request to change the password or email of an account.!!UMEditAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:38'!fromStringArray: array	^self username: array second password: array third newPassword: array fourth newEmail: array fifth! !!UMEditAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:36'!username: username  password: password  newPassword: newPassword newEmail: newEmail	^self basicNew username: username  password: password  newPassword: newPassword newEmail: newEmail! !!UMEditAccount methodsFor: '*universes-server' stamp: 'ls 7/28/2004 17:55'!applyToServer: server forConnection: connection	server connection: connection requestedAccountChangeForUsername: username password: password newPassword: newPassword newEmail: newEmail! !!UMEditAccount methodsFor: 'converting' stamp: 'ls 7/28/2004 14:36'!asStringArray	^{'editaccount' . username . password . newPassword . newEmail}! !!UMEditAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:36'!username: username0  password: password0  newPassword: newPassword0 newEmail: newEmail0	username _ username0.	password _ password0.	newPassword _ newPassword0.	newEmail _ newEmail0.	! !!UMEditedAccount commentStamp: '<historical>' prior: 0!Notification that an account has been successfully edited.!!UMEditedAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:38'!fromStringArray: array	^self username: array second newPassword: array third newEmail: array fourth! !!UMEditedAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:37'!username: username  newPassword: newPassword  newEmail: newEmail	^self basicNew		username: username  newPassword: newPassword  newEmail: newEmail;		yourself! !!UMEditedAccount methodsFor: '*universes-editor' stamp: 'ls 7/28/2004 17:59'!applyToEditor: editor	editor accountUpdatedWithUsername: username  password:  newPassword  email: newEmail! !!UMEditedAccount methodsFor: 'converting' stamp: 'ls 7/28/2004 17:37'!asStringArray	^{'editedaccount' . username . newPassword . newEmail }! !!UMEditedAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 17:36'!username: username0  newPassword: newPassword0  newEmail: newEmail0	username _ username0.	newPassword _ newPassword0.	newEmail _ newEmail0.	! !!UMError commentStamp: '<historical>' prior: 0!An error message from the server to the client.!!UMConnectionFailed commentStamp: '<historical>' prior: 0!An error in establishing a connection to a server.!!UMError class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 13:33'!description: aString	^self basicNew		description: aString;		yourself! !!UMError class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:02'!fromStringArray: array	^self description: array second! !!UMError methodsFor: '*universes-editor' stamp: 'ls 7/28/2004 21:58'!applyToEditor: editor	"the inform: is deferred, because otherwise the editor can stop stepping!!"	WorldState addDeferredUIMessage: [ editor inform: 'Error: ', description ]! !!UMError methodsFor: '*universes-server' stamp: 'ls 7/28/2004 13:35'!applyToServer: server forConnection: connection	"if the client sends an error back, then the connection is really messed up"	server destroyConnection: connection	! !!UMError methodsFor: 'converting' stamp: 'ls 7/28/2004 13:36'!asStringArray	^{'error' . description }! !!UMError methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 13:26'!description: aString	description := aString! !!UMMalformed commentStamp: '<historical>' prior: 0!a malformed packet!!UMMalformed class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 11:30'!fromStringArray: array	^self basicNew stringArray: array; yourself! !!UMMalformed methodsFor: 'converting' stamp: 'ls 7/28/2004 11:31'!asStringArray	^self error: 'a malformed packet cannot be converted to a string array'! !!UMMalformed methodsFor: 'accessing' stamp: 'ls 7/28/2004 11:45'!stringArray: anObject	stringArray _ anObject! !!UMPackageAdded commentStamp: 'ls 7/28/2004 15:08' prior: 0!A message declaring that a package has been added to the universe.!!UMPackageAdded class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 15:07'!fromStringArray: array	| str |	str _ ReadStream on: array.	str next.	^self package: (UPackage decodeFromStringStream: str)! !!UMPackageAdded class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 15:07'!package: aPackage	^self basicNew		package: aPackage;		yourself! !!UMPackageAdded methodsFor: '*universes-client' stamp: 'ls 7/30/2004 15:01'!applyToClient: aClient	aClient packageAdded: package! !!UMPackageAdded methodsFor: '*universes-editor' stamp: 'ls 7/30/2004 15:38'!applyToEditor: editor	editor closeEditorForPackage: package.! !!UMPackageAdded methodsFor: 'converting' stamp: 'ls 7/28/2004 15:07'!asStringArray	^#('packageadded'), package stringArrayEncoding! !!UMPackageAdded methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:59'!package: aPackage	package _ aPackage! !!UMPackageList commentStamp: '<historical>' prior: 0!A message describing a list of packages that are in the server's universe.!!UMPackageList class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 15:05'!fromStringArray: array	| str packages numPackages |	str _ ReadStream on: array.	str next.  "skip the 'packages' designation".	packages _ OrderedCollection new.	numPackages _ Integer readFromString: str next.	numPackages timesRepeat: [		packages add: (UPackage decodeFromStringStream: str) ].			^self packages: packages! !!UMPackageList class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 12:01'!packages: aCollection	^self basicNew		packages: aCollection;		yourself! !!UMPackageList methodsFor: '*universes-client' stamp: 'ls 7/30/2004 15:01'!applyToClient: aClient	aClient newPackageList: packages! !!UMPackageList methodsFor: 'converting' stamp: 'ls 7/28/2004 15:04'!asStringArray	^Array streamContents: [ :str |		str nextPut: 'packages'.		str nextPut: packages size printString.		packages do: [ :pack |			str nextPutAll: pack stringArrayEncoding ]. ].! !!UMPackageList methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 12:01'!packages: aCollection	packages _ aCollection! !!UMPackageRemoved commentStamp: '<historical>' prior: 0!A message claiming that a package has been removed.!!UMPackageRemoved class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:58'!fromStringArray: array	^self packageName: array second version: (UVersion readFromString: array third)! !!UMPackageRemoved class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:58'!packageName: aString version: aVersion	^self basicNew		packageName: aString version: aVersion;		yourself! !!UMPackageRemoved methodsFor: '*universes-client' stamp: 'ls 7/30/2004 15:02'!applyToClient: aClient	aClient removedPackageNamed: packageName  withVersion: version! !!UMPackageRemoved methodsFor: 'converting' stamp: 'ls 7/28/2004 14:57'!asStringArray	^{'packageremoved' . packageName . version printString }! !!UMPackageRemoved methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:57'!packageName: aString  version: aVersion	packageName _ aString.	version _ aVersion.! !!UMProtocolVersion commentStamp: '<historical>' prior: 0!Tell the receiver what protocol version the sender understands.  The receiver should not send messages back which use a newer protocol version.!!UMProtocolVersion class methodsFor: 'instance creation' stamp: 'ls 2/15/2005 21:40'!fromStringArray: array	^self version: (Integer readFromString: array second)! !!UMProtocolVersion class methodsFor: 'instance creation' stamp: 'ls 2/15/2005 21:40'!version: anInteger	^self new version: anInteger; yourself! !!UMProtocolVersion methodsFor: 'applying' stamp: 'ls 2/15/2005 21:41'!applyToClient: client! !!UMProtocolVersion methodsFor: 'applying' stamp: 'ls 2/15/2005 21:42'!applyToEditor: editor! !!UMProtocolVersion methodsFor: 'applying' stamp: 'ls 2/15/2005 21:42'!applyToMultiServer: server forConnection: connection! !!UMProtocolVersion methodsFor: 'applying' stamp: 'ls 2/15/2005 21:41'!applyToServer: server forConnection: connection! !!UMProtocolVersion methodsFor: 'converting' stamp: 'ls 2/15/2005 21:41'!asStringArray	^{'protocolversion' . version asString}! !!UMProtocolVersion methodsFor: 'attributes' stamp: 'ls 2/15/2005 21:40'!version	^version! !!UMProtocolVersion methodsFor: 'initialize-release' stamp: 'ls 2/15/2005 21:39'!version: anInteger	version _ anInteger! !!UMRemovePackage commentStamp: '<historical>' prior: 0!A request to remove a package from a universe.!!UMRemovePackage class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:26'!fromStringArray: array	^self username: array second password: array third packageName: array fourth packageVersion: (UVersion readFromString: array fifth)! !!UMRemovePackage class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:41'!username: username password: password packageName: packageName packageVersion: packageVersion	^self basicNew username: username password: password packageName: packageName packageVersion: packageVersion! !!UMRemovePackage methodsFor: '*universes-server' stamp: 'ls 7/28/2004 17:20'!applyToServer: server forConnection: connection	server connection: connection requestedForUsername: username andPassword: password toRemovePackageNamed: packageName withVersion: packageVersion! !!UMRemovePackage methodsFor: 'converting' stamp: 'ls 7/29/2004 15:46'!asStringArray	^{'removepackage' . username . password . packageName . packageVersion printString }! !!UMRemovePackage methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:39'!username: username0 password: password0 packageName: packageName0 packageVersion: packageVersion0	username _ username0.	password _ password0.	packageName _ packageName0.	packageVersion _ packageVersion0.	! !!UMRequestPackages commentStamp: '<historical>' prior: 0!A package requesting that a copy of all packages in the server's universe.!!UMRequestPackages class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 11:59'!fromStringArray: array	^self basicNew! !!UMRequestPackages methodsFor: '*universes-server' stamp: 'ls 7/28/2004 13:08'!applyToServer: server forConnection: connection	connection nextPut: (UMPackageList packages: server universe packages) asStringArray! !!UMRequestPackages methodsFor: 'converting' stamp: 'ls 7/28/2004 11:59'!asStringArray	^#('requestpackages')! !!UMSelectServer commentStamp: 'ls 2/13/2005 16:05' prior: 0!A request to a multi-server, to select the server for a specific universe.  Subsequent messages should be directed to the selected universe instead of to the specific universes.!!UMSelectServer class methodsFor: 'instance creation' stamp: 'ls 2/13/2005 16:06'!fromStringArray: stringArray	^self shortName: stringArray second! !!UMSelectServer class methodsFor: 'instance creation' stamp: 'ls 2/13/2005 16:06'!shortName: aString	^self new		shortName: aString;		yourself! !!UMSelectServer methodsFor: '*universes-server' stamp: 'ls 2/13/2005 16:18'!applyToMultiServer: server forConnection: connection	server switchConnection: connection toServerNamed: shortName! !!UMSelectServer methodsFor: 'converting' stamp: 'ls 2/13/2005 16:06'!asStringArray	^{'selectserver' . shortName}! !!UMSelectServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 16:12'!shortName: aString	shortName _ aString! !!UMessage class methodsFor: 'instance creation' stamp: 'ls 2/15/2005 21:41'!fromStringArray: array	| class |	class _ nil.	array first = 'requestpackages' ifTrue: [ class _ UMRequestPackages ].	array first = 'packages' ifTrue: [ class _ UMPackageList ].	array first = 'error' ifTrue: [ class _ UMError ].	array first = 'addaccount' ifTrue: [ class _ UMAddAccount ].	array first = 'addpackage' ifTrue: [ class _ UMAddPackage ].	array first = 'editaccount' ifTrue: [ class _ UMEditAccount ].	array first = 'editedaccount' ifTrue: [ class _ UMEditedAccount ].	array first = 'packageadded' ifTrue: [ class _ UMPackageAdded ].	array first = 'packageremoved' ifTrue: [ class _ UMPackageRemoved ].	array first = 'removepackage' ifTrue: [ class _ UMRemovePackage ].	array first = 'selectserver' ifTrue: [ class _ UMSelectServer ].	array first = 'protocolversion' ifTrue: [ class _ UMProtocolVersion ].	class ifNil: [			^UMMalformed fromStringArray: array ].		^[ class fromStringArray: array ] on: Error do: [ :ex | UMMalformed fromStringArray: array ]! !!UMessage methodsFor: '*universes-client' stamp: 'ls 7/30/2004 15:00'!applyToClient: aClient	"apply this message to a UUniverseClient"	! !!UMessage methodsFor: '*universes-editor' stamp: 'ls 7/28/2004 15:40'!applyToEditor: editor	! !!UMessage methodsFor: '*universes-server' stamp: 'ls 2/13/2005 16:18'!applyToMultiServer: server  forConnection: connection	connection nextPut: (UMError description: 'message inappropriate for multi-server') asStringArray! !!UMessage methodsFor: '*universes-server' stamp: 'ls 7/28/2004 17:25'!applyToServer: server  forConnection: connectionself inspect.	connection nextPut: (UMError description: 'message inappropriate for server') asStringArray! !!UMessage methodsFor: 'converting' stamp: 'ls 7/28/2004 11:30'!asStringArray	^self subclassResponsibility! !!UOneShotConnection commentStamp: '<historical>' prior: 0!A fake StringSocket used to integrate a UUniverseServer with an HTTP server.A OneShotConnection has exactly one input message and only accepts one output message.  It puts the supplied output message onto a SharedQueue and then disconnects itself.!!UOneShotConnection class methodsFor: 'instance creation' stamp: 'ls 8/2/2004 16:31'!withInMessage: inMessage0  andOutQueue: aSharedQueue	^self basicNew		initializeWithInMessage: inMessage0  andOutQueue: aSharedQueue;		yourself! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:33'!destroy	hasBeenWritten _ true! !!UOneShotConnection methodsFor: 'initialize-release' stamp: 'ls 8/2/2004 16:33'!initializeWithInMessage: inMessage0  andOutQueue: aSharedQueue	inputMessage _ inMessage0.	outputQueue _ aSharedQueue.	hasBeenRead _ false.	hasBeenWritten _ false.! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:34'!isConnected	^hasBeenWritten not! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:32'!nextOrNil	hasBeenRead ifTrue:[ ^nil ].	hasBeenRead _ true.	^inputMessage! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:53'!nextPut: anObject	outputQueue nextPut: anObject.	hasBeenWritten _ true! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:32'!processIO! !!UPackage commentStamp: 'ls 7/27/2004 21:20' prior: 0!One release of one package.!!UPackage class methodsFor: '*universes-messages' stamp: 'ls 2/13/2005 12:40'!decodeFromStringStream: str	| package numDepends homePageText numProvides numConflicts |	package _ self new.	package name: str next.	package version: (UVersion readFromString: str next).	package description: str next.	package url: (Url absoluteFromText: str next).	homePageText _ str next.	package homepage: (homePageText isEmpty ifTrue: [ nil ] ifFalse: [ homePageText asUrl ]).	package maintainer: str next.	numProvides _ Integer readFromString: str next. 	package provides: (str next: numProvides).	numDepends _ Integer readFromString: str next. 	package depends: (str next: numDepends).	numConflicts _ Integer readFromString: str next. 	package conflicts: (str next: numConflicts).	^package! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/13/2005 13:29'!decodeFromXMLElement: doc	| package |	package _ self new.	package name: (self getXMLPartNamed: 'name' from: doc).	package version: (UVersion readFromString: (self getXMLPartNamed: 'version' from: doc)).	package description: (self getXMLPartNamed: 'description' from: doc).	package url: (Url absoluteFromText: (self getXMLPartNamed: 'url' from: doc)).	(doc elementAt: 'homepage') ifNotNil: [		package homepage: (Url absoluteFromText: (self getXMLPartNamed: 'homepage' from: doc)) ].	package maintainer: (self getXMLPartNamed: 'maintainer' from: doc).	package provides: (self getXMLPackageList: 'provides' from: doc).	package depends: (self getXMLPackageList: 'depends' from: doc).	package conflicts: (self getXMLPackageList: 'conflicts' from: doc).	^package! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/13/2005 13:24'!decodePackagesFromXMLStream: stream	| doc |	doc _ XMLDOMParser parseDocumentFrom: stream.	^doc elements collect: [ :element | self decodeFromXMLElement: element ].! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/13/2005 13:12'!getXMLPackageList: listname from: element	| listElement |	listElement _ element elementAt: listname.	listElement ifNil: [ ^#() ].	^listElement elements collect: [ :nameXML |		nameXML contents first string ]! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/13/2005 15:05'!getXMLPartNamed: partName  from: xmlDoc	| element |	element _ xmlDoc elementAt: partName.	element contents isEmpty ifTrue:[ ^ '' ].	^element contents first string! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/13/2005 13:41'!readPackageListFromFileNamed: filename	| file packages |	file _ FileStream readOnlyFileNamed: filename.	packages _ self decodePackagesFromXMLStream: file.	file close.	^packages! !!UPackage class methodsFor: 'saving' stamp: 'ls 2/13/2005 14:47'!savePackageList: packageList  onFileNamed: filename	| tmpName file |	tmpName _ filename, 'tmp'.	FileDirectory default deleteFileNamed: tmpName ifAbsent:  [].	file _ FileStream fileNamed: tmpName.	packageList do: [ :package |		file nextPutAll: package xmlForExport ].	file close.	FileDirectory default rename: tmpName toBe: filename.! !!UPackage methodsFor: 'comparing' stamp: 'ls 2/13/2005 12:33'!= anotherPackage	self hash = anotherPackage hash ifFalse: [ ^false ].	self name = anotherPackage name ifFalse: [ ^false ].	self version = anotherPackage version ifFalse: [ ^false ].	self depends = anotherPackage depends ifFalse: [ ^false ].	self provides = anotherPackage provides ifFalse: [ ^false ].	self conflicts = anotherPackage conflicts ifFalse: [ ^false ].	self url toText = anotherPackage url toText ifFalse: [ ^false ].	self maintainer = anotherPackage maintainer ifFalse: [ ^false ].	self homepage isNil = anotherPackage homepage isNil ifFalse: [ ^false ].	(self homepage isNil or: [ 		self homepage toText = anotherPackage homepage toText]) ifFalse: [ ^false ].	self description = anotherPackage description ifFalse:[ ^false ].	^true! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:19'!addDependency: aString	depends add: aString! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 12:28'!conflicts	^conflicts ifNil: [ Set new ]! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 12:27'!conflicts: aCollection	conflicts _ Set withAll: aCollection! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53'!depends	^depends! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/29/2004 15:39'!depends: aCollection	depends _ Set withAll: aCollection! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53'!description	^description! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:17'!description: aString	description _ aString! !!UPackage methodsFor: 'comparing' stamp: 'ls 7/28/2004 09:58'!hash	^self name hash bitXor: self version hash! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 18:05'!homepage	"a homepage describing the package, or nil if there isn't one"	^homepage! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 12:20'!homepage: aURL	homepage _ aURL! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 18:05'!initialize	name _ '(unnamed package)'.	depends _ Set new.	conflicts _ Set new.	provides _ Set new.	description _ ''.	url _ 'file:///dev/null' asUrl.	homepage _ nil.	version _ UVersion readFromString: '0'.	maintainer _ ''.! !!UPackage methodsFor: 'installing' stamp: 'ls 9/4/2004 14:55'!install	| filename doc file downloadDir |	downloadDir _ FileDirectory default directoryNamed: 'universetmp'.	downloadDir assureExistence.		filename _ self url path last.	(downloadDir isAFileNamed: filename)	ifFalse: [		"download the file"		doc _ url retrieveContents.		((doc contentType asString = 'text/plain') and: [			doc content beginsWith: 'error']) ifTrue: [			"HACK to see if the download failed; the real solution is to make retrieveContents report errors"			^self error: 'download failed' ].		file _ downloadDir newFileNamed: filename.		file binary.		file nextPutAll: doc content.		file close. ].		UInstaller installFileNamed: (downloadDir fullNameFor: filename).			! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 12:33'!maintainer	^maintainer ifNil: [ '' ]! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 12:32'!maintainer: aString	maintainer _ aString! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53'!name	^name! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:17'!name: aString	name _ aString! !!UPackage methodsFor: 'printing' stamp: 'ls 7/27/2004 21:19'!printOn: aStream	aStream		nextPutAll: name;		nextPutAll: ' version ';		print: version! !!UPackage methodsFor: 'serializing' stamp: 'ls 2/13/2005 13:29'!printXMLPackageList: names on: stream	names do: [ :n |		stream nextPutAll: ' <packagename>'; nextPutAll: n escapeEntities; nextPutAll: '</packagename>' ].! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 12:29'!provides	^provides ifNil: [ Set new ]! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 12:27'!provides: aCollection	provides _ Set withAll: aCollection! !!UPackage methodsFor: '*universes-messages' stamp: 'ls 2/13/2005 12:37'!stringArrayEncoding	^Array streamContents: [ :str |		str			nextPut: self name;			nextPut: self version printString;			nextPut: self description;			nextPut: self url toText;			nextPut: (self homepage ifNil: [ '' ] ifNotNil: [ self homepage toText ]);			nextPut: self maintainer;			nextPut: self provides size printString;			nextPutAll: self provides;			nextPut: self depends size printString;			nextPutAll: self depends;			nextPut: self conflicts size printString;			nextPutAll: self conflicts ]! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53'!url	^url! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:18'!url: aURL	url _ aURL! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/27/2004 21:32'!version	^version! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:17'!version: aVersion	version _ aVersion.	! !!UPackage methodsFor: 'serializing' stamp: 'ls 2/13/2005 13:28'!xmlForExport	^String streamContents: [ :str |		str			nextPutAll: '<package>'; cr;			nextPutAll: '<name>'; nextPutAll: self name escapeEntities; nextPutAll: '</name>'; cr;			nextPutAll: '<version>'; nextPutAll:  self version printString escapeEntities; nextPutAll: '</version>'; cr;			nextPutAll: '<description>'; nextPutAll: self description escapeEntities; nextPutAll: '</description>'; cr;			nextPutAll: '<url>'; nextPutAll: self url toText escapeEntities; nextPutAll: '</url>'; cr.		self homepage ifNotNil: [			str nextPutAll: '<homepage>'; nextPutAll:  self homepage toText escapeEntities; nextPutAll: '</homepage>'; cr ].		str nextPutAll: '<maintainer>'; nextPutAll: self maintainer escapeEntities; nextPutAll: '</maintainer>'; cr.					str nextPutAll: '<provides>'.		self printXMLPackageList: self provides on: str.		str nextPutAll: '</provides>'.		str nextPutAll: '<depends>'.		self printXMLPackageList: self depends on: str.		str nextPutAll: '</depends>'.		str nextPutAll: '<conflicts>'.		self printXMLPackageList: self conflicts on: str.		str nextPutAll: '</conflicts>'.		str nextPutAll: '</package>'; cr. ]! !!UPackageSerializer commentStamp: 'ls 2/13/2005 12:49' prior: 0!A class for loading and saving lists of packages!!UPolicy commentStamp: '<historical>' prior: 0!A policy for manipulations on a universe.  All of the methods return 'true' on success or on allowing the requested operation, or 'false' on an error or if the operation is not allowed.  By default everything is disallowed.Note that since policy is completely implemented on the server, there is no requirement that a particular UUniverse has a policy describable with this class or a subclass.  A particular server can always modify UUniverseServer to implement an arbitrary policy.!!UPStable commentStamp: '<historical>' prior: 0!A policy somewhat suitable for stable versions.  All updates must come through a single master userid and password.!!UPStable methodsFor: 'policies' stamp: 'ls 7/29/2004 17:59'!addUser: user withPassword: password andEmail: email	^UPolicyResponse denied! !!UPStable methodsFor: 'policies' stamp: 'ls 7/29/2004 17:59'!changeUser: user withPassword: password toHavePassword: newPassword andNewEmail: newEmail	"the changes must be made on the server, not over the standard protocol"	^UPolicy denied! !!UPStable methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 22:08'!masterPassword: password	masterPassword _ password! !!UPStable methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 22:08'!masterUser: userName	masterUser _ userName! !!UPStable methodsFor: 'policies' stamp: 'ls 7/29/2004 18:00'!package: package mayBeAddedBy: user withPassword: password	^(user = masterUser and: [ password = masterPassword ])		ifTrue: [ UPolicyResponse allowed ]		ifFalse: [ UPolicyResponse denied ]! !!UPStable methodsFor: 'policies' stamp: 'ls 7/29/2004 18:00'!packageNamed: packageName  withVersion: version  mayBeRemovedBy: user  withPassword: password	(user = masterUser and: [ password = masterPassword ])		ifTrue: [ ^UPolicyResponse allowed ]		ifFalse: [ ^UPolicyResponse denied ]! !!UPWild commentStamp: '<historical>' prior: 0!This is the wild-n-wooly policy.  Anyone may create a new account, and the first person to try to add or remove a package with a given name comes to exclusively own that package name.  Only the owner of a package name may make changes to packages with that name.!!UPWild class methodsFor: 'reasonable names' stamp: 'ls 7/29/2004 16:51'!isReasonablePackageName: aString	^aString allSatisfy: [ :c | c isAlphaNumeric or: [ ' -.' includes: c ]]! !!UPWild class methodsFor: 'reasonable names' stamp: 'ls 2/15/2005 23:45'!isReasonableUsername: aString	^aString isEmpty not and: [ aString allSatisfy: [ :c | c isAlphaNumeric ] ]! !!UPWild methodsFor: 'policies' stamp: 'ls 7/29/2004 16:49'!addUser: username withPassword: password  andEmail: email	| newAccount |	(accounts anySatisfy: [ :acc | acc username = username]) ifTrue: [		"already an account here"		^UPolicyResponse denied: 'account already exists' ].		(self class isReasonableUsername: username) ifFalse: [		^UPolicyResponse denied: 'invalid account name' ].		newAccount _ UAccount new.	newAccount username: username.	newAccount password: password.	newAccount email: email.		accounts add: newAccount.	^UPolicyResponse allowed! !!UPWild methodsFor: 'policies' stamp: 'ls 2/13/2005 16:38'!changeUser: username withPassword: password toHavePassword: newPassword andNewEmail: newEmail	| account |	account _ self findAccount: username withPassword: password.	account ifNil: [ ^UPolicyResponse denied: 'username not present or password does not match' ].		newPassword isEmpty ifFalse: [account password: newPassword ].	newEmail isEmpty ifFalse: [account email: newEmail ].	^UPolicyResponse allowed! !!UPWild methodsFor: 'policies' stamp: 'ls 7/28/2004 18:14'!findAccount: username withPassword: password	| account |	account _ accounts detect: [ :acc | acc username = username] ifNone: [		"no such account"		^nil ].		account password = password ifFalse:[		"wrong password"		^nil ].		^account! !!UPWild methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 21:35'!initialize	accounts _ OrderedCollection new! !!UPWild methodsFor: 'policies' stamp: 'ls 7/28/2004 21:34'!package: aPackage  mayBeAddedBy: username  withPassword: password	^self tryToGivePackageName: aPackage name toUsername: username withPassword: password! !!UPWild methodsFor: 'policies' stamp: 'ls 7/28/2004 18:15'!packageNamed: packageName withVersion: version mayBeRemovedBy: username withPassword: password	^self tryToGivePackageName: packageName toUsername: username withPassword: password! !!UPWild methodsFor: 'policies' stamp: 'ls 7/29/2004 16:51'!tryToGivePackageName: packageName toUsername: username  withPassword: password	| account |	(self class isReasonablePackageName: packageName) ifFalse: [		^UPolicyResponse denied: 'invalid package name' ].		account _ self findAccount: username withPassword: password.	account ifNil: [ ^UPolicyResponse denied: 'incorrect password or no such user' ].		(account ownsPackageName: packageName) ifTrue: [		^UPolicyResponse allowed ].		(accounts anySatisfy: [ :acc | acc ownsPackageName: packageName ]) ifTrue: [		^UPolicyResponse denied: 'package is owned by another' ].		account addPackageName: packageName.	^UPolicyResponse allowed! !!UPermissivePolicy commentStamp: '<historical>' prior: 0!A policy that allows anything.!!UPermissivePolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:48'!addUser: user  withPassword: password  andEmail: email	^UPolicyResponse allowed! !!UPermissivePolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:48'!changeUser: user withPassword: password toHavePassword: newPassword andNewEmail: newEmail	^UPolicyResponse allowed! !!UPermissivePolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:48'!package: aPackage  mayBeAddedBy: user  withPassword: password	^UPolicyResponse allowed! !!UPermissivePolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:48'!packageNamed: packageName  withVersion: version  mayBeRemovedBy: user  withPassword: password	^UPolicyResponse allowed! !!UPolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:47'!addUser: user  withPassword: password  andEmail: email	^UPolicyResponse denied! !!UPolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:47'!changeUser: user withPassword: password toHavePassword: newPassword andNewEmail: newEmail	^UPolicyResponse denied! !!UPolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:47'!package: aPackage  mayBeAddedBy: user  withPassword: password	^UPolicyResponse denied! !!UPolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:47'!packageNamed: packageName  withVersion: version  mayBeRemovedBy: user  withPassword: password	^UPolicyResponse denied! !!UPolicyResponse commentStamp: '<historical>' prior: 0!A response to a policy query.!!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 16:47'!allowed	^self allowed: nil! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/30/2004 10:34'!allowed: reason	^self allowed: true  reason: reason! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 16:46'!allowed: aBoolean  reason: aReason	^self basicNew		allowed: aBoolean;		reason: (aReason ifNil: ['no reason given']);		yourself! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 16:46'!denied	^self denied: nil! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 17:58'!denied: reason	^self allowed: false  reason: reason! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 16:47'!new	self shouldNotImplement ! !!UPolicyResponse methodsFor: 'accessing' stamp: 'ls 7/29/2004 17:56'!allowed	^allowed! !!UPolicyResponse methodsFor: 'accessing' stamp: 'ls 7/29/2004 17:56'!allowed: anObject	allowed _ anObject! !!UPolicyResponse methodsFor: 'accessing' stamp: 'ls 7/29/2004 17:58'!reason	^reason! !!UPolicyResponse methodsFor: 'accessing' stamp: 'ls 7/29/2004 17:56'!reason: anObject	reason _ anObject! !!UUniverseClient commentStamp: 'ls 7/30/2004 14:58' prior: 0!A client for talking to a universe server.The universe must be a UStandardUniverse.  The client will track update the universe automatically as messages come in.!!UUniverseClient class methodsFor: 'instance creation' stamp: 'ls 7/30/2004 15:06'!forUniverse: aStandardUniverse	^self basicNew		initialize: aStandardUniverse;		yourself! !!UUniverseClient class methodsFor: 'class initialization' stamp: 'ls 2/13/2005 15:45'!initialize	Preferences removePreference: #universesUsesHTTP ! !!UUniverseClient class methodsFor: 'instance creation' stamp: 'ls 7/30/2004 15:06'!new	^self forUniverse: UUniverse systemUniverse! !!UUniverseClient methodsFor: 'public' stamp: 'ls 7/30/2004 15:10'!disconnect	"explicitly close the connection"	socket ifNotNil: [ socket destroy.  socket _ nil ].	stringSocket ifNotNil: [ stringSocket destroy.  stringSocket _ nil ].! !!UUniverseClient methodsFor: 'initialization' stamp: 'ls 8/5/2004 17:16'!initialize: aUniverse	universe _ aUniverse.		inMessages _ OrderedCollection new.	outMessages _ OrderedCollection new.		lastConnectionStart _ DateAndTime epoch.! !!UUniverseClient methodsFor: 'networking' stamp: 'ls 8/4/2004 15:46'!newInMessage: aMessage	aMessage applyToClient: self.	inMessages add: aMessage.	! !!UUniverseClient methodsFor: 'package list' stamp: 'ls 7/30/2004 14:59'!newPackageList: newPackages	universe packages: newPackages.	! !!UUniverseClient methodsFor: 'package list' stamp: 'ls 7/30/2004 15:00'!packageAdded: newPackage	universe addPackage: newPackage! !!UUniverseClient methodsFor: 'networking' stamp: 'ls 2/15/2005 21:44'!processIO	| rawMsg |	(stringSocket notNil and: [ stringSocket isConnected not ]) ifTrue: [		"connection has died"		stringSocket destroy.		stringSocket _ nil ].		(outMessages isEmpty not and: [ socket isNil and: [ stringSocket isNil ] ]) ifTrue: [		"there are outgoing messages queued but there is no stringSocket"		(DateAndTime now - lastConnectionStart) > (Duration minutes: 1) ifTrue: [			self startConnecting ] ].		socket ifNotNil: [		"a connection is in progress"				socket isConnected ifTrue: [			"connection completed"			stringSocket _ StringSocket on: socket.			universe shortName ifNotNil: [				outMessages addFirst: (UMProtocolVersion version: 1).				outMessages addFirst: (UMSelectServer shortName: universe shortName) ].			socket _ nil. ]		ifFalse: [			socket isWaitingForConnection ifFalse: [				"the connection failed"				inMessages add: (UMConnectionFailed description: 'connection failed').				^self disconnect ] ] ].		stringSocket ifNil: [ ^self ].			[ outMessages isEmpty ] whileFalse: [		stringSocket nextPut: outMessages removeFirst asStringArray ].		stringSocket processIO.		[	rawMsg _ stringSocket nextOrNil.		rawMsg isNil not	] whileTrue: [ 		self newInMessage: (UMessage fromStringArray: rawMsg) ]! !!UUniverseClient methodsFor: 'public' stamp: 'ls 7/30/2004 15:33'!receivedMessagesDo: aBlock	"check for new messages, and then evaluate aBlock for each message that is currently available"	self processIO.	[ inMessages isEmpty ] whileFalse: [		aBlock value: inMessages removeFirst ]! !!UUniverseClient methodsFor: 'package list' stamp: 'ls 7/30/2004 15:02'!removedPackageNamed: packageName  withVersion: version	universe removePackageNamed: packageName  withVersion: version! !!UUniverseClient methodsFor: 'public' stamp: 'ls 2/13/2005 15:18'!sendMessage: aMessage	"send the specified message to the server"	outMessages add: aMessage! !!UUniverseClient methodsFor: 'networking' stamp: 'ls 7/30/2004 15:31'!startConnecting	"start a new connection to the server"	self disconnect.		lastConnectionStart _ DateAndTime now.		socket _ Socket newTCP.	socket connectTo: (NetNameResolver addressForName: universe serverName) port: universe serverPort.! !!UUniverseClient methodsFor: 'public' stamp: 'ls 7/30/2004 15:30'!waitForMessage	"block until at least one message is available"	self notYetImplemented.   "proper implementation requires changes to ObjectSocket"		[ inMessages isEmpty ] whileTrue: [		(socket isNil and: [  stringSocket isNil and: [ outMessages isEmpty ] ]) ifTrue: [			self error: 'no more messages will every be available' ].				socket ifNotNil: [ socket waitForConnectionFor: 60 ].		stringSocket ifNotNil: [ stringSocket wait ].		self processIO ].! !!UUniverseEditor commentStamp: '<historical>' prior: 0!A tool for editing a remote universe.!!UUniverseEditor class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 10:23'!forUniverse: aStandardUniverse	^self basicNew		initialize: aStandardUniverse;		yourself! !!UUniverseEditor class methodsFor: 'class initialization' stamp: 'ls 2/13/2005 16:00'!initialize	TheWorldMenu registerOpenCommand: {'Universe Editor'. {self. #open}}.	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UUniverseEditor class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 18:13'!new	| choice choices |	choices := UUniverse systemUniverse standardUniverses asArray.	choices isEmpty ifTrue: [ ^self error: 'no standard universes installed' ].	choices size = 1 ifTrue: [		choice _ choices anyOne ]	ifFalse: [		| menu |		menu _			SelectionMenu				labels: (choices collect: [ :u | u description ])				selections: choices.		choice _ menu startUpWithCaption: 'edit which universe?'.		choice ifNil: [ ^self ] ].		^self forUniverse: choice! !!UUniverseEditor class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 18:13'!open	^self new open! !!UUniverseEditor class methodsFor: 'class initialization' stamp: 'ls 7/29/2004 18:14'!unload	TheWorldMenu unregisterOpenCommand: 'Universe Editor'! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:34'!acceptFields	fields do: [ :f | f accept ]! !!UUniverseEditor methodsFor: 'account' stamp: 'ls 7/28/2004 18:00'!accountUpdatedWithUsername: newUsername  password:  newPassword  email: newEmail	self acceptFields.	username _ newUsername.	password _ newPassword.	email _ newEmail.		self changed: #username.	self changed: #password.	self changed: #email.		self closeAccountEditor! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:25'!anyPackageSelected	^selectedPackageIndex > 0! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 17:58'!closeAccountEditor	accountEditor ifNil: [ ^self ].	accountEditor window delete.	accountEditor _ nil.! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 17:12'!closeEditorForPackage: package	| matchingEditors |	matchingEditors _ packageEditors select: [ :p | p package = package ].	matchingEditors do: [ :editor |		editor window delete.		packageEditors remove: editor ].! !!UUniverseEditor methodsFor: 'account' stamp: 'ls 2/13/2005 16:31'!createAccount	self acceptFields.	email _ FillInTheBlankMorph request: 'your email address?'.	email = '' ifTrue: [ ^self ].	self sendMessage: (UMAddAccount username: username password: password email: email).	! !!UUniverseEditor methodsFor: 'account' stamp: 'ls 2/13/2005 16:52'!editAccount	| editor |	self acceptFields.	self closeAccountEditor.		editor _ UAccountEditor		username: username		password: password		email:  ''		whenDone: [ :oldPassword :newPassword :newEmail |			password _ oldPassword.			self sendMessage: (UMEditAccount username: username password: password newPassword: newPassword newEmail: newEmail) ].			editor openInMorphic.		accountEditor _ editor.! !!UUniverseEditor methodsFor: 'initialization' stamp: 'ls 2/13/2005 17:16'!initialize: universe0	universe _ universe0.	universe addDependent: self.	client _ UUniverseClient forUniverse: universe.	username _ Utilities authorInitialsPerSe.	password _ ''.		packageEditors _ Set new.	selectedPackageIndex _ 0.! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 16:02'!makeButtonWithAction: selector andGetState: getStateSelector andLabel: aString	^(PluggableButtonMorph on: self getState: getStateSelector action: selector)		label: aString;		useRoundedCorners;		vResizing: #spaceFill;		hResizing: #spaceFill;		onColor: self defaultBackgroundColor offColor: self defaultBackgroundColor muchLighter;		yourself! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 16:02'!makeButtonWithAction: selector  andLabel: aString	^self makeButtonWithAction: selector andGetState: #returnTrue andLabel: aString! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/15/2005 22:02'!morphicView	| win universeDescription buttonList usernameRow passwordRow button  usernamePasswordArea packageList |	win _ SystemWindow labelled: 'Universe Editor'.	win model: self.		universeDescription := PluggableTextMorph on: self text: #universeDescription accept: nil.	universeDescription hideScrollBarsIndefinitely.	win addMorph: universeDescription frame: (0@0 extent: 1@0.1).		buttonList _ AlignmentMorph newColumn.	buttonList cellInset: 0@3.	win addMorph: buttonList frame: (0@0.5 extent: 0.5@0.5).			usernamePasswordArea _ AlignmentMorph newColumn.	win addMorph: usernamePasswordArea frame: (0@0.1 extent: 0.5@0.4).	usernameRow _ UInterfaceUtilities makeFieldRowNamed: 'username' getSelector: #username setSelector: #username: for: self.	usernamePasswordArea addMorphBack: usernameRow.		passwordRow _ UInterfaceUtilities makeFieldRowNamed: 'password:' getSelector: #password setSelector: #password: isPassword: true for: self.	usernamePasswordArea addMorphBack: passwordRow.		button _ self makeButtonWithAction: #createAccount andLabel: 'createAccount'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #editAccount andLabel: 'edit account'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #newPackage andLabel: 'new package'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #newPackageVersion andGetState: #anyPackageSelected andLabel: 'new package version'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #removeVersion andGetState: #anyPackageSelected andLabel: 'remove package version'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #requestPackageList andLabel: 'update package list'.	buttonList addMorphBack: button.	packageList _ PluggableListMorph on: self list: #packageDescriptions  selected: #selectedPackageIndex changeSelected: #selectedPackageIndex: menu: nil.	win addMorph: packageList frame: ((0.5@0.1) extent: (0.5@0.9)).		^win! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 22:00'!newPackage	| editor |	self acceptFields.	editor _ UPackageEditor package: UPackage new whenComplete: [ :p |		self acceptFields.		self sendMessage: (UMAddPackage username: username password: password package: p) ].	editor openInMorphic.	packageEditors add: editor.! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 2/15/2005 22:06'!newPackageVersion	| package editor newPackage |	self anyPackageSelected ifFalse: [ ^self ].	self acceptFields.	package _ self selectedPackage.		newPackage _ package deepCopy.	newPackage version: (UVersion readFromString: (newPackage version asString, 'new')).	editor _ UPackageEditor package: newPackage whenComplete: [ :p |		self acceptFields.		self sendMessage: (UMAddPackage username: username password: password package: p) ].	editor openInMorphic.	packageEditors add: editor.! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:34'!noteField: field 	"note that the receiver has the specified text field"	fields ifNil: [fields := OrderedCollection new].	fields add: field! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 7/29/2004 16:27'!open	self morphicView openInWorld.	"self requestPackageList."! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:26'!packageDescriptions	^self sortedPackages collect: [ :p |				p printString. ]! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27'!packagesChanged	self selectedPackageIndex: 0.		self changed: #packageDescriptions.	! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/28/2004 15:54'!password	^password! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/28/2004 16:18'!password: aString	password _ aString asString.	^true! !!UUniverseEditor methodsFor: 'networking' stamp: 'ls 2/13/2005 17:16'!processNetworking	client receivedMessagesDo: [ :message |		message applyToEditor: self ].! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 2/13/2005 17:20'!removeVersion	| package |	self anyPackageSelected ifFalse: [ ^self ].	self acceptFields.	package _ self selectedPackage.	(self confirm: ('Delete ', 	package printString, '?')) ifFalse: [		^self ].	self sendMessage: (UMRemovePackage username: username password: password packageName: package name packageVersion: package version).! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 7/29/2004 16:23'!requestPackageList	self sendMessage: (UMRequestPackages new).	! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 16:02'!returnTrue	^true! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27'!selectedPackage	^self sortedPackages at: self selectedPackageIndex! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27'!selectedPackageIndex	^selectedPackageIndex! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27'!selectedPackageIndex: anInteger	selectedPackageIndex _ anInteger.	self changed: #selectedPackageIndex.! !!UUniverseEditor methodsFor: 'networking' stamp: 'ls 7/30/2004 15:40'!sendMessage: aMessage	client sendMessage: aMessage.	! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27'!sortedPackages	^universe packages asSortedCollection: [ :p1 :p2 |		p1 name < p2 name or: [			p1 name = p2 name and: [ p1 version < p2 version ] ] ].	! !!UUniverseEditor methodsFor: 'stepping' stamp: 'ls 7/28/2004 17:01'!step	self processNetworking! !!UUniverseEditor methodsFor: 'stepping' stamp: 'ls 7/28/2004 17:01'!stepTimeIn: window	^10! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/29/2004 16:21'!universeDescription 	^universe description! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27'!update: aSymbol	aSymbol = #packages ifTrue: [ self packagesChanged ]! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/28/2004 15:53'!username	^username! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/28/2004 16:13'!username: aString	username _ aString asString.	^true! !!UUniverseEditor methodsFor: 'stepping' stamp: 'ls 7/28/2004 17:01'!wantsSteps	^true! !!UUniverseMultiServer commentStamp: 'ls 2/13/2005 14:51' prior: 0!A multi-server server.  This listens on one port, and dispatches to whichever universe was requested.An active server needs someone to call #step periodically on it, in order for it to process networking, save checkpoints, etc.!!UUniverseMultiServer class methodsFor: 'defaults' stamp: 'ls 2/13/2005 14:32'!defaultPort	^3702! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/15/2005 22:00'!acceptConnection: stringSocket	stringSocket nextPut: (UMProtocolVersion version: 1) asStringArray.	connections add: stringSocket! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:29'!acceptConnectionOn: socket	self acceptConnection: (StringSocket on: socket).	! !!UUniverseMultiServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 14:33'!addServer: server	servers add: server! !!UUniverseMultiServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 14:49'!addServers: newServers	newServers do: [ :s | self addServer: s ]! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:29'!checkForNewConnections	connectionQueue ifNil: [ ^self ].	[ connections size < 100 ] whileTrue: [		| newSocket |		newSocket _ connectionQueue getConnectionOrNil.		newSocket ifNil: [ ^self ].		connections add: (StringSocket on: newSocket) ].	! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:30'!destroyConnection: aConnection	aConnection destroy.	connections remove: aConnection ifAbsent: [].	! !!UUniverseMultiServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 14:33'!initialize	servers _ Set new.	port _ UUniverseMultiServer defaultPort.	connections _ Set new.! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:32'!processConnection: aConnection	| message |	aConnection isConnected ifFalse: [ ^self destroyConnection: aConnection ].		"process all incoming messages.  Note that some messages move the connection to one of the subsidiary servers, so be careful not to process messages after that happens"	aConnection processIO.	[ 	(connections includes: aConnection) and: [			message _ aConnection nextOrNil.	 	 	message notNil ]	] whileTrue: [	  	self processRawMessage: message fromConnection: aConnection ].	(connections includes: aConnection) ifFalse: [ ^self ].	aConnection isConnected		ifTrue: [ aConnection processIO.  "start sending out the response" ]		ifFalse: [ self destroyConnection: aConnection ]! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:30'!processConnections	connections copy do: [ :c |		self processConnection: c ]! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:51'!processNetworking	self checkForNewConnections.	self processConnections.! !!UUniverseMultiServer methodsFor: 'messages' stamp: 'ls 2/13/2005 14:34'!processRawMessage: aStringArray  fromConnection: connection	| message |	message _ UMessage fromStringArray: aStringArray.	message applyToMultiServer: self forConnection: connection.! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 16:08'!startListening	self stopListening.	connectionQueue _ ConnectionQueue portNumber: port queueLength: 5.	! !!UUniverseMultiServer methodsFor: 'stepping' stamp: 'ls 2/13/2005 14:50'!step	self processNetworking.	servers do: [ :server | server step ].! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 16:08'!stopListening		connectionQueue ifNotNil: [		connectionQueue destroy.		connectionQueue _ nil ].	! !!UUniverseMultiServer methodsFor: 'messages' stamp: 'ls 2/13/2005 16:18'!switchConnection: aConnection  toServerNamed: serverName	| server |	server _ servers detect: [ :s | s universe shortName = serverName ] ifNone: [		aConnection nextPut: (UMError description: 'no such server here') asStringArray.		^self ].	server acceptConnection: aConnection.	connections remove: aConnection.! !!UUniverseServer commentStamp: 'ls 2/13/2005 13:45' prior: 0!A server holding the authoratative information about a universe.  Clients may make requests to view and update the universe.The server does not manage its own thread; it requires that processNetworking is called periodically.!!UUniverseServer class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 09:29'!forSaveDirectory: aDirectory	| universe |	universe _ self forUniverse: UUniverse new.	universe saveDirectory: aDirectory.	universe loadFromCheckpoint.	^universe! !!UUniverseServer class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 10:31'!forUniverse: universe	^self basicNew initializeForUniverse: universe.	! !!UUniverseServer class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 10:31'!new	^self shouldNotImplement ! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 2/15/2005 22:00'!acceptConnection: stringSocket	stringSocket nextPut: (UMProtocolVersion version: 1) asStringArray.	connections add: stringSocket! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 11:02'!acceptConnectionOn: socket	self acceptConnection: (StringSocket on: socket).	! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 13:15'!checkForNewConnections	connectionQueue ifNil: [ ^self ].	[ connections size < 10 ] whileTrue: [		| newSocket |		newSocket _ connectionQueue getConnectionOrNil.		newSocket ifNil: [ ^self ].		connections add: (StringSocket on: newSocket) ].	! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 8/3/2004 18:10'!comancheServiceName	^'universe server on ', universe serverPort printString! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:53'!connection: connection requestedAccountChangeForUsername: username  password: password  newPassword: newPassword newEmail: newEmail	| response |	response _ policy changeUser: username withPassword: password toHavePassword: newPassword andNewEmail: newEmail.	response allowed ifFalse: [		^self			sendError: 'changing account for ', username, ' failed (', response reason, ')'			onConnection: connection].			self sendMessage: (UMEditedAccount username: username newPassword: newPassword newEmail: newEmail) onConnection: connection! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:53'!connection: connection requestedAccountWithUsername: username  password: password  email: email 	| response |	response _ policy addUser: username withPassword: password andEmail: email.	response allowed ifFalse: [		self			sendError: 'adding account for ', username, ' failed (', response reason, ')'			onConnection: connection].! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:54'!connection: connection requestedForUsername: username  andPassword: password  toAddPackage: package	| response |	response _ policy package: package mayBeAddedBy: username withPassword: password.		response allowed		ifFalse: [			^self 				sendError: 'adding package ', package name, ' failed (', response reason, ')'				onConnection: connection].			universe addPackage: package.	self sendMessage: (UMPackageAdded package: package) onConnection: connection.! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:54'!connection: connection requestedForUsername: username  andPassword: password  toRemovePackageNamed: packageName withVersion: version	| packagesToRemove response |	response _ policy packageNamed: packageName withVersion: version mayBeRemovedBy: username withPassword: password.		response allowed ifFalse: [		^self 			sendError: 'removing package ', packageName, ' failed (', response reason, ')' 			onConnection: connection].			packagesToRemove := universe packages select: [ :p | p name = packageName and: [ p version = version ] ].	packagesToRemove do: [ :p |		universe removePackage: p ].		self sendMessage: (UMPackageRemoved packageName: packageName version: version) onConnection: connection.! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 10:47'!destroyConnection: aConnection	aConnection destroy.	connections remove: aConnection ifAbsent: [].! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 15:20'!initializeForUniverse: aUniverse	universe _ aUniverse.	policy _ UPolicy new.	connectionQueue _ nil.	connections _ Set new.! !!UUniverseServer methodsFor: 'persistence' stamp: 'ls 7/29/2004 09:25'!loadFromCheckpoint	"reload from a checkpoint"	| file savedObject |	(saveDirectory isAFileNamed: 'checkpoint')		ifTrue: [ file _ saveDirectory readOnlyFileNamed: 'checkpoint' ]		ifFalse: [ file _ saveDirectory readOnlyFileNamed: 'checkpoint.die' ].	savedObject := file fileInObjectAndCode.	file close.		universe := savedObject first.	policy := savedObject second.	! !!UUniverseServer methodsFor: 'stepping' stamp: 'ls 8/2/2004 17:15'!openStepperMorph	(UServerStepperMorph new server: self; yourself) openInWorld! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 13:44'!packageListFilename: filename	packageListFilename _ filename! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:32'!policy: aPolicy	policy _ aPolicy! !!UUniverseServer methodsFor: 'persistence' stamp: 'ls 2/13/2005 15:23'!possiblySaveCheckpointAndPackageList	saveDirectory ifNil: [^self].	(lastSaveTime isNil 		or: [DateAndTime now - lastSaveTime > (Duration minutes: 30)]) 			ifTrue: 				[self saveCheckpoint.				self savePackageList.				lastSaveTime := DateAndTime now]! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 21:28'!processConnection: aConnection	| message |	aConnection isConnected ifFalse: [ ^self destroyConnection: aConnection ].		aConnection processIO.	[ 	message _ aConnection nextOrNil.	  	message notNil	] whileTrue: [	  	self processRawMessage: message fromConnection: aConnection ].	aConnection isConnected		ifTrue: [ aConnection processIO.  "start sending out the response" ]		ifFalse: [ self destroyConnection: aConnection ]! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 10:43'!processConnections	connections copy do: [ :c |		self processConnection: c ]! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 2/13/2005 15:19'!processNetworking	self checkForNewConnections.	self processConnections.	! !!UUniverseServer methodsFor: 'messages' stamp: 'ls 7/28/2004 13:12'!processRawMessage: aStringArray  fromConnection: connection	| message |	message _ UMessage fromStringArray: aStringArray.	message applyToServer: self forConnection: connection.! !!UUniverseServer methodsFor: 'persistence' stamp: 'ls 2/13/2005 13:43'!saveCheckpoint	"save a checkpoint"	| tmpFile |	saveDirectory deleteFileNamed: 'checkpoint.tmp'.		tmpFile := saveDirectory newFileNamed: 'checkpoint.tmp'.	(SmartRefStream on: tmpFile) nextPut: {universe.policy}; close.		saveDirectory deleteFileNamed: 'checkpoint.die'.	saveDirectory rename: 'checkpoint.tmp' toBe: 'checkpoint'.		saveDirectory deleteFileNamed: 'checkpoint.die'.	! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 7/29/2004 09:16'!saveDirectory: aDirectory	saveDirectory _ aDirectory! !!UUniverseServer methodsFor: 'persistence' stamp: 'ls 2/13/2005 13:44'!savePackageList	packageListFilename ifNotNil: [		UPackage savePackageList: universe packages onFileNamed: packageListFilename ]! !!UUniverseServer methodsFor: 'messages' stamp: 'ls 7/28/2004 14:49'!sendError: description onConnection: stringSocket	self sendMessage: (UMError description: description) onConnection: stringSocket! !!UUniverseServer methodsFor: 'messages' stamp: 'ls 7/28/2004 11:48'!sendMessage: aMessage  onConnection: connection	connection nextPut: aMessage asStringArray  ! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 13:21'!startListening	self stopListening.	connectionQueue _ ConnectionQueue portNumber: universe serverPort queueLength: 5.	! !!UUniverseServer methodsFor: 'stepping' stamp: 'ls 2/13/2005 15:23'!step	"do any necessary periodic work, including polling the network connections"	self processNetworking.	self possiblySaveCheckpointAndPackageList! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 10:41'!stopListening		connectionQueue ifNotNil: [		connectionQueue destroy.		connectionQueue _ nil ].	! !!UUniverseServer methodsFor: 'accessing' stamp: 'ls 7/28/2004 13:08'!universe	^universe! !!UUtilities commentStamp: 'ls 7/28/2004 10:35' prior: 0!Universe miscellania that belong to no particular object.!!StringSocket class methodsFor: '*universes' stamp: 'ls 8/3/2004 18:04'!decodeStringArray: aString	| idx numStrings |	idx _ 1.	numStrings _ aString getInteger32: idx.	idx _ idx + 4.	numStrings < 0 ifTrue: [ ^self error: 'invalid string socket encoding' ].	numStrings > 10000000 ifTrue: [ self error: 'refusing to decode humongous string socket' ].		^(1 to: numStrings) collect: [ :ignored |		| size str |		size _ aString getInteger32: idx.		idx _ idx + 4.		str _ aString copyFrom: idx to: idx+size-1.		idx _ idx + size.		str ]	! !!StringSocket class methodsFor: '*universes' stamp: 'ls 8/2/2004 16:18'!encodeStringArray: stringArray	| size outBuf outBufIndex |	size _ self spaceToEncode: stringArray.		outBuf _ String new: size.	outBufIndex _ 1.	outBuf putInteger32: stringArray size at: outBufIndex.	outBufIndex _ outBufIndex + 4.	stringArray do: [ :each |		outBuf putInteger32: each size at: outBufIndex.		outBufIndex _ outBufIndex + 4.		outBuf 			replaceFrom: outBufIndex 			to: outBufIndex + each size - 1 			with: each 			startingAt: 1.		outBufIndex _ outBufIndex + each size.	].		^outBuf! !!StringSocket class methodsFor: '*universes' stamp: 'ls 8/2/2004 16:18'!spaceToEncode: stringArray	^stringArray inject: 4 into: [ :sum :array |		sum + (array size + 4) ].! !!UVersion commentStamp: '<historical>' prior: 0!A relatively simple hierarchical version number.!!UVersion class methodsFor: 'instance creation' stamp: 'ls 7/27/2004 17:24'!fromComponents: components	^self basicNew components: components; yourself! !!UVersion class methodsFor: 'instance creation' stamp: 'ls 7/27/2004 17:27'!readFrom: stream	| components |	components _ OrderedCollection new.	[ stream atEnd ] whileFalse: [		stream peek isDigit ifTrue: [			components add: (Integer readFrom: stream) ]		ifFalse: [			components add: (String streamContents: [ :compStr |				[ stream atEnd not and: [ stream peek isDigit not ] ] whileTrue: [					compStr nextPut: stream next ] ]) ] ].			^self fromComponents: components! !!UVersion methodsFor: 'comparing' stamp: 'ls 7/27/2004 21:15'!< aVersion	| numToCompare |	numToCompare := components size min: aVersion components size.	(components first: numToCompare) with: (aVersion components first: numToCompare) do: [ :myComp :itsComp |		(myComp uversionLessThan: itsComp) ifTrue: [			^true ].		(itsComp uversionLessThan: myComp) ifTrue: [			^false ] ].		^components size < aVersion components size! !!UVersion methodsFor: 'comparing' stamp: 'ls 7/27/2004 17:31'!= aVersion	components size = aVersion components size ifFalse:[ ^false ].	components with: aVersion components do: [ :myComp :itsComp |		(myComp uversionEqual: itsComp) ifFalse: [			^false ] ].		^true! !!UVersion methodsFor: 'attributes' stamp: 'ls 7/27/2004 17:33'!components	^components! !!UVersion methodsFor: 'initialization' stamp: 'ls 7/27/2004 17:27'!components: aCollection	components _ aCollection! !!UVersion methodsFor: 'comparing' stamp: 'ls 7/28/2004 10:02'!hash	^components inject: 1 into: [ :tally :new |		(tally bitXor: new hash) hashMultiply ]! !!UVersion methodsFor: 'printing' stamp: 'ls 7/27/2004 17:28'!printOn: aStream	components do: [ :comp | aStream nextPutAll: comp asString ].! !!String methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:32'!uversionEqual: anObject	^anObject isString and: [ self = anObject ]! !!String methodsFor: '*universes-model' stamp: 'ls 7/27/2004 21:13'!uversionLessThan: anObject	^anObject isInteger or: [ self < anObject ]! !!UServerStepperMorph commentStamp: '<historical>' prior: 0!A morph that simply steps a UniverseServer continuously.!!UServerStepperMorph methodsFor: 'closing' stamp: 'ls 2/13/2005 15:20'!delete	super delete.	server stopListening.! !!UServerStepperMorph methodsFor: 'initialization' stamp: 'ls 7/28/2004 13:41'!initialize	super initialize.	timeOfLastFlash _ DateAndTime now.! !!UServerStepperMorph methodsFor: 'initialization' stamp: 'ls 7/28/2004 13:19'!server: aServer	server _ aServer! !!UServerStepperMorph methodsFor: 'stepping' stamp: 'ls 7/28/2004 13:42'!step	server ifNotNil: [ server step ].		(DateAndTime now - timeOfLastFlash ) > (Duration milliSeconds: 3000) ifTrue: [		super step.		timeOfLastFlash _ DateAndTime now. ].! !!UServerStepperMorph methodsFor: 'stepping' stamp: 'ls 7/28/2004 13:19'!stepTime	^10! !!UServerStepperMorph methodsFor: 'stepping' stamp: 'ls 7/28/2004 13:19'!wantsSteps	^true! !!UBrowserTestCase methodsFor: 'Running' stamp: 'ls 1/16/2005 14:11'!setUp	| package |	universe _ UStandardUniverse new.		package _ UPackage new.	package name: 'A'.	package addDependency: 'B'.	universe addPackage: package.		package _ UPackage new.	package name: 'B'.	package addDependency: 'C'.	universe addPackage: package.		package _ UPackage new.	package name: 'C'.	package addDependency: 'D'.	package addDependency: 'E'.	universe addPackage: package.		package _ UPackage new.	package name: 'D'.	universe addPackage: package.		package _ UPackage new.	package name: 'E'.	universe addPackage: package.	package _ UPackage new.	package name: 'Broken'.	package addDependency: 'NonExistent'.	universe addPackage: package.	! !!UBrowserTestCase methodsFor: 'Running' stamp: 'ls 7/29/2004 17:40'!testBasicDependency	| browser neededPackages |	browser _ UUniverseBrowser new universe: universe; yourself.	neededPackages _ browser allPackagesNeededToInstall: (universe newestPackageNamed: 'A')  orIfImpossible: [ :ign | self error: 'dependency not found' ].		self should: [ neededPackages size = 5 ].		browser _ UUniverseBrowser new universe: universe; yourself.	neededPackages _ browser allPackagesNeededToInstall: (universe newestPackageNamed: 'B')  orIfImpossible: [ :ign | self error: 'dependency not found' ].		self should: [ neededPackages size = 4 ].! !!UBrowserTestCase methodsFor: 'Running' stamp: 'ls 7/29/2004 17:39'!testBrokenDependency	| browser neededPackages |	browser _ UUniverseBrowser new universe: universe; yourself.	neededPackages _ browser allPackagesNeededToInstall: (universe newestPackageNamed: 'Broken')  orIfImpossible: [ :ign | nil ].	self should: [ neededPackages isNil ].	! !!UPackageTestCase methodsFor: 'setup' stamp: 'ls 2/13/2005 12:34'!setUp	p1 _ UPackage new.	p1 name: 'Scamper'.	p1 description: 'A web browser'.	p1 url: 'http://www.squeak.org' asUrl.	p1 homepage: p1 url.	p1 version: (UVersion readFromString: '1.0').	p1 maintainer: 'John Doe'.	p2 _ p1 deepCopy.! !!UPackageTestCase methodsFor: 'comparing' stamp: 'ls 2/13/2005 12:34'!testCompare	self should: [ p1 = p2 ].	self should: [ p1 hash = p2 hash ].	p2 homepage: 'http://www.squeakland.org' asUrl.	self shouldnt: [ p1 = p2 ].	p2 homepage: p1 homepage.	p1 conflicts: #('Another Web Browser').	self shouldnt: [ p1 = p2 ].	p1 conflicts: p2 conflicts.	self should: [ p1 = p2 ].	self should: [ p1 hash = p2 hash ].	p1 homepage: nil.	p2 homepage: nil.	self should: [ p1 = p2 ].	self should: [ p1 hash = p2 hash ].	p2 maintainer: 'Jane'.	self shouldnt: [ p1 = p2 ].! !!UPackageTestCase methodsFor: 'comparing' stamp: 'ls 2/13/2005 12:59'!testEncoding	self should: [ p1 = (UPackage decodeFromStringStream: (ReadStream on: p1 stringArrayEncoding)) ].! !!UPackageTestCase methodsFor: 'comparing' stamp: 'ls 2/13/2005 13:29'!testXML	| xmlString stream readp1 readp2 readPackages |	p2 version: (UVersion readFromString: '1.2').	p1 description: 'blah blah <>&"'''.	xmlString _ String streamContents: [ :str |		str 			nextPutAll: p1 xmlForExport;			nextPutAll: p2 xmlForExport ].	stream _ ReadStream on: xmlString.	readPackages _ UPackage decodePackagesFromXMLStream: stream.	self should: [ readPackages size = 2 ].	readp1 _ readPackages first.	readp2 _ readPackages second.	self should: [ readp1 = p1 ].	self should: [ readp2 = p2 ].! !!UVersionTestCase methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:12'!setUp	typicalVersions := #(		'1'		'2'		'1.5.7'		'1.5.8'		'1.6.2'		'1.5'		'1.5a'		'1.5b'		'1.6'		'alpha'		'beta'	) collect: [ :str | UVersion readFromString: str ].	! !!UVersionTestCase methodsFor: 'Running' stamp: 'ls 7/27/2004 17:19'!testCompare	self should: [ (UVersion readFromString: '1') < (UVersion readFromString: '2') ].	self should: [ (UVersion readFromString: '1.5.7') < (UVersion readFromString: '1.5.8') ].	self should: [ (UVersion readFromString: '1.5.7') < (UVersion readFromString: '1.6.2') ].	self should: [ (UVersion readFromString: '1.5') < (UVersion readFromString: '1.5a') ].	self should: [ (UVersion readFromString: '1.5a') < (UVersion readFromString: '1.5b') ].	self should: [ (UVersion readFromString: '1.5b') < (UVersion readFromString: '1.6') ].! !!UVersionTestCase methodsFor: 'Running' stamp: 'ls 7/27/2004 17:24'!testFullOrder	"check that all versions are in some order"	typicalVersions do: [ :v1 |		typicalVersions do: [ :v2 |			self should: [				(v1 < v2)				or: [ (v2 < v1) 				or: [ v1 = v2 ] ] ] ] ]	! !!UVersionTestCase methodsFor: 'Running' stamp: 'ls 7/28/2004 09:59'!testHash	typicalVersions do: [ :v |		self should: [ v hash = v copy hash ] ].		self should: [ (UVersion readFromString: '1.5a') hash = (UVersion readFromString: '1.5a') hash ].! !!UVersionTestCase methodsFor: 'Running' stamp: 'ls 7/27/2004 17:23'!testReversedComparisons	"check that it is never the case that v1<v2 and v2<v1"	typicalVersions do: [ :v1 |		typicalVersions do: [ :v2 |			self should: [ (v1 < v2) not  or:  [  (v2 < v1) not ] ] ] ].	! !"Universes"!"Installed Universes auto version 6".(Smalltalk at: #SMSqueakMap ifAbsent: []) ifNotNil:[	SMSqueakMap noteInstalledPackageWithId: 'c6c6e5fe-a6f5-4ba9-b41d-2aef7c6c3d89' autoVersion: '6' asVersion atSeconds: 3347727954 number: 7]!!UUniverse class methodsFor: 'well known' stamp: 'ls 1/31/2007 20:49'!squeak39Universe 	"[UUniverse switchSystemToUniverse: UUniverse squeak39Universe]"	^UStandardUniverse new		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		shortName: 'squeak3.9';		description: 'Squeak 3.9';		packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/squeak3.9.packages' asUrl;		yourself! !UUniverse switchSystemToUniverse: UUniverse squeak39Universe!!String methodsFor: '*xml-parser' stamp: 'mir 7/14/2006 11:54'!applyLanguageInfomation: languageEnvironment		| leadingChar |	leadingChar := languageEnvironment leadingChar.	self withIndexDo: [:each :idx |		each asciiValue > 255			ifTrue: [self at: idx put: (Character leadingChar: leadingChar code: each asUnicode)]]! !!ByteString methodsFor: '*xml-parser' stamp: 'mir 7/14/2006 11:54'!applyLanguageInfomation: languageEnvironment! !!XMLTokenizer commentStamp: '<historical>' prior: 33693653!XMLTokenizerbolot@cc.gatech.edubreaks the stream of characters into a stream of XMLnodes (aka token stream)token stream is used by XMLparser to generate XMLdocument tree!!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 7/14/2006 11:55' prior: 33695342!handlePCData: aString	self languageEnvironment		ifNotNil: [aString applyLanguageInfomation: self languageEnvironment].	self saxHandler		checkEOD; 		characters: aString! !!SAXDriver methodsFor: 'handling tokens' stamp: 'mir 7/14/2006 11:49' prior: 33695797!handleStartTag: elementName attributes: attributeList namespaces: namespaces	| localName namespace namespaceURI |	(attributeList includesKey: 'xml:lang')		ifTrue: [languageEnvironment := LanguageEnvironment localeID: (LocaleID isoString: (attributeList at: 'xml:lang'))].	self usesNamespaces		ifTrue: [			self scope enterScope.				"declare any namespaces"					namespaces keysAndValuesDo: [:ns :uri |					self scope declareNamespace: ns uri: uri].			self splitName: elementName into: [:ns :ln |				namespace _ ns.				localName _ ln].			"ensure our namespace is defined"			namespace				ifNil: [namespace := self scope defaultNamespace]				ifNotNil: [					namespaceURI := self scope namespaceURIOf: namespace.					namespaceURI						ifNil: [self parseError: 'Start tag ' , elementName , ' refers to undefined namespace ' , namespace asString]].			self validatesAttributes				ifTrue: [self scope validateAttributes: attributeList].			"call the handler"			self saxHandler				checkEOD; 				startElement: localName namespaceURI: namespaceURI namespace: namespace attributeList: attributeList]		ifFalse: [			"call the handler"			self saxHandler				checkEOD; 				startElement: elementName namespaceURI: nil namespace: nil attributeList: attributeList]! !!SAXDriver methodsFor: 'accessing' stamp: 'mir 7/14/2006 11:48'!languageEnvironment	^languageEnvironment! !!XMLTokenizer class methodsFor: 'examples' stamp: 'mir 7/12/2006 16:49' prior: 33702510!addressBookXMLWithDTD	^'<?xml version="1.0" encoding="UTF-8"?><!!DOCTYPE addressbook SYSTEM "addressbook.dtd"><?xml-stylesheet type="text/xsl" href="demo.xsl"?><addressbook>  <person employee-number="A0000" family-name="Gates" first-name="Bob">    <contact-info><!!--Confidential--></contact-info>    <address city="Los Angeles" number="1239" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Manager"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7000" family-name="Brown"    first-name="Robert" middle-initial="L.">    <contact-info>      <email address="robb@iro.ibm.com"/>      <home-phone number="03-3987873"/>    </contact-info>    <address city="New York" number="344" state="NY" street="118 St."/>    <job-info employee-type="Full-Time" is-manager="yes" job-description="Group Leader"/>    <manager employee-number="A0000"/>  </person>  <person employee-number="A7890" family-name="DePaiva"    first-name="Kassie" middle-initial="W.">    <contact-info><!!-- Kassie''s agent phone: 03-987654 --></contact-info>    <address city="Los Angeles" number="1234" state="CA" street="Pine Rd."/>    <job-info employee-type="Full-Time" is-manager="no" job-description="Actor"/>    <manager employee-number="A0000"/>    <misc-info>One of the most talented actresses on Daytime. Kassie      plays the devious and beautiful Blair Cramer on ABC&apos;s      &quot;One Life To Live.&quot;</misc-info>  </person>  <person employee-number="A7987" family-name="Smith" first-name="Joe">    <contact-info>      <email address="joes@iro.ibm.com"/>      <mobile-phone number="888-7657765"/>      <home-phone number="03-8767898"/>      <home-phone number="03-8767871"/>    </contact-info>    <address city="New York" number="12789" state="NY" street="W. 15th Ave."/>    <job-info employee-type="Part-Time" is-manager="no" job-description="Hacker"/>    <manager employee-number="A7000"/>  </person></addressbook>'! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'bf 4/27/2006 17:50' prior: 33718142!nextEndTag	| string |	"Skip /"	self next.	string _ self nextTrimmedBlanksUpTo: $>.	self handleEndTag: string! !!XMLTokenizer methodsFor: 'streaming' stamp: 'bf 4/27/2006 17:55' prior: 33726306!nextTrimmedBlanksUpTo: delimiter	| resultStream nextChar |	resultStream _ WriteStream on: (String new: 10).	nextChar _ nil.	[(nextChar _ self next) == delimiter]		whileFalse: [			nextChar == $  ifFalse: [				resultStream nextPut: nextChar]].	nextChar == delimiter		ifFalse: [self parseError: 'XML no delimiting ' , delimiter printString , ' found'].	^resultStream contents! !!XMLTokenizer methodsFor: 'tokenizing' stamp: 'thf 9/2/2005 15:04' prior: 33728203!nextXMLDecl	| attributes nextChar namespaces |	self skipSeparators.	attributes _ Dictionary new.	namespaces _ Dictionary new.	[(nextChar _ self peek) == $?] whileFalse: [		self nextAttributeInto: attributes namespaces: namespaces.		self skipSeparators.].	self next.	self next == $>		ifFalse: [self errorExpected: '> expected.'].	(attributes includesKey: 'encoding') ifTrue: [self streamEncoding: (attributes at: 'encoding')].	self handleXMLDecl: attributes namespaces: namespaces	! !!XMLTokenizer methodsFor: 'streaming' stamp: 'mir 7/12/2006 17:46'!streamEncoding: encodingString	| converterClass |	Smalltalk at: #TextConverter ifPresent: [:tc | 		(stream respondsTo: #converter:) ifTrue: [			converterClass := tc defaultConverterClassForEncoding: encodingString asLowercase.			converterClass ifNotNil: [stream converter: converterClass new]]]! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 7/12/2006 16:07' prior: 33735870!endTag	self stream nextPutAll: '>'.	self indent.	"self canonical		ifFalse: [self stream space]"! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 7/12/2006 17:02' prior: 33736026!endTag: tagName	self outdent.	self endTag: tagName xmlns: nil! !!XMLWriter methodsFor: 'private' stamp: 'mir 7/12/2006 16:52'!indent	currentIndent		ifNotNil: [currentIndent := currentIndent +1]! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 7/12/2006 16:08'!indentString: aString	currentIndent := 0.	indentString := aString! !!XMLWriter methodsFor: 'accessing' stamp: 'mir 7/12/2006 16:08'!indentTab	self indentString: (String with: Character tab)! !!XMLWriter methodsFor: 'initialize' stamp: 'mir 7/12/2006 15:54' prior: 33736753!initialize	stack := OrderedCollection new.	canonical := false.	scope := XMLNamespaceScope new! !!XMLWriter methodsFor: 'private' stamp: 'mir 7/12/2006 17:05'!outdent	currentIndent		ifNotNil: [			stream cr.			currentIndent := currentIndent-1.			self writeIndent.			currentIndent := currentIndent-1.]! !!XMLWriter methodsFor: 'writing xml' stamp: 'mir 7/12/2006 16:08' prior: 33739868!startTag: tagName	self writeIndent.	self startTag: tagName xmlns: nil! !!XMLWriter methodsFor: 'private' stamp: 'mir 7/12/2006 16:58'!writeIndent	currentIndent ifNotNil: [		currentIndent timesRepeat: [self stream nextPutAll: indentString]]! !!XMLWriter methodsFor: 'writing xml' stamp: 'thf 9/2/2005 14:08' prior: 33740539!xmlDeclaration: versionString encoding: encodingString	self canonical		ifFalse: [			self				startPI: 'xml';				attribute: 'version' value: versionString;				attribute: 'encoding' value: encodingString;				endPI.			self stream flush]! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 7/12/2006 16:24' prior: 33665236!parseDocumentFrom: aStream	^self parseDocumentFrom: aStream useNamespaces: false! !!SAXHandler class methodsFor: 'instance creation' stamp: 'mir 7/12/2006 16:26'!parseDocumentFrom: aStream useNamespaces: aBoolean	|  parser |	parser _ self on: aStream.	parser useNamespaces: aBoolean.	parser startDocument.	parser parseDocument.	^parser! !!XMLDOMParser class methodsFor: 'examples' stamp: 'mir 7/12/2006 16:26' prior: 33671361!addressBookXMLWithDTD	"XMLDOMParser addressBookXMLWithDTD"	^self parseDocumentFrom: XMLTokenizer addressBookXMLWithDTD readStream useNamespaces: true! !!XMLDOMParser class methodsFor: 'instance creation' stamp: 'mir 7/12/2006 16:25' prior: 33671578!parseDocumentFrom: aStream	^self parseDocumentFrom: aStream useNamespaces: false! !!XMLDOMParser class methodsFor: 'instance creation' stamp: 'mir 7/12/2006 16:25'!parseDocumentFrom: aStream useNamespaces: aBoolean	^(super parseDocumentFrom: aStream useNamespaces: aBoolean) document! !!XMLDOMParser methodsFor: 'content' stamp: 'thf 9/2/2005 14:09' prior: 33672036!documentAttributes: attributeList	self document version: (attributeList at: 'version' ifAbsent: [nil]).	self document encoding: (attributeList at: 'encoding' ifAbsent: [nil]).	self document requiredMarkup: (attributeList at: 'requiredMarkup' ifAbsent: [nil]).! !"XML-Parser"!!UPackageTestCase methodsFor: 'setup' stamp: 'ls 11/26/2006 11:10' prior: 33852474!setUp	p1 _ UPackage new.	p1 name: 'Scamper'.	p1 category: (UPackageCategory withComponents: #('Networking')).	p1 description: 'A web browser'.	p1 url: 'http://www.squeak.org' asUrl.	p1 homepage: p1 url.	p1 version: (UVersion readFromString: '1.0').	p1 maintainer: 'John Doe'.	p2 _ p1 deepCopy.! !!UPackageTestCase methodsFor: 'comparing' stamp: 'ls 11/26/2006 10:50' prior: 33853551!testXML	| xmlString stream readp1 readp2 readPackages readp3 |	p2 version: (UVersion readFromString: '1.2').	p1 description: 'blah blah <>&"'''.	xmlString _ String streamContents: [ :str |		str 			nextPutAll: p1 xmlForExport;			nextPutAll: p2 xmlForExport.					str nextPutAll: '<package><name>IRCe</name><version>10.7.6</version><description>This is a significant rewrite of the built-in Squeak IRC client GUI. A new user interface includes having one console window per connection and then having all console messages, channel messages and private messages contained inside the main console window using tabbed swapped panes.                                         Numerous other changes are also included but are not described here. The change-set contains documentation for all features added or modified.Instructions at http://squeak.preeminent.org/irc-help/irc-help.html</description><url>http://kilana.unibe.ch:8888/IRC/Network-IRC-fc.10.7.6.mcz</url><maintainer></maintainer><provides></provides><depends></depends><conflicts></conflicts></package>' ].	stream _ ReadStream on: xmlString.	readPackages _ UPackage decodePackagesFromXMLStream: stream.	self should: [ readPackages size = 3 ].	readp1 _ readPackages first.	readp2 _ readPackages second.	readp3 _ readPackages third.	self should: [ readp1 = p1 ].	self should: [ readp2 = p2 ].	self should: [ readp3 name = 'IRCe'].	self should: [ readp3 version = (UVersion readFromString: '10.7.6')].	! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 11/26/2006 11:22'!categoryString	^package category printString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 11/26/2006 11:23'!categoryString: aText 	package category: (UPackageCategory readFromString: aText asString).	self changed: #categoryString! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 11/26/2006 11:22' prior: 33748730!morphicView	| win column nameRow versionRow urlRow descriptionField submitButton dependsRow homepageRow providesRow conflictsRow maintainerRow categoryRow |	window ifNotNil: [ ^window ].	win _ SystemWindow labelled: 'Package Editor'.	win model: self.	column _ AlignmentMorph newColumn.	win addMorph: column frame: (0@0  extent:  1@0.6).		nameRow _ UInterfaceUtilities makeFieldRowNamed: 'name:' getSelector: #packageName setSelector: #packageName: for: self.	column addMorphBack: nameRow.		versionRow _ UInterfaceUtilities makeFieldRowNamed: 'version:' getSelector: #versionString setSelector: #versionString: for: self.	column addMorphBack: versionRow.		categoryRow _ UInterfaceUtilities makeFieldRowNamed: 'category:' getSelector: #categoryString setSelector: #categoryString: for: self.	column addMorphBack: categoryRow.		maintainerRow _ UInterfaceUtilities makeFieldRowNamed: 'maintainer:' getSelector: #maintainer setSelector: #maintainer: for: self.	column addMorphBack: maintainerRow.		homepageRow _ UInterfaceUtilities makeFieldRowNamed: 'homepage:' getSelector: #homepageString setSelector: #homepageString: for: self.	column addMorphBack: homepageRow.				urlRow _ UInterfaceUtilities makeFieldRowNamed: 'download from:' getSelector: #urlString setSelector: #urlString: for: self.	column addMorphBack: urlRow.	providesRow _ UInterfaceUtilities makeFieldRowNamed: 'provides:' getSelector: #providesString setSelector: #providesString: for: self.	column addMorphBack: providesRow.		dependsRow _ UInterfaceUtilities makeFieldRowNamed: 'depends:' getSelector: #dependsString setSelector: #dependsString: for: self.	column addMorphBack: dependsRow.	conflictsRow _ UInterfaceUtilities makeFieldRowNamed: 'conflicts:' getSelector: #conflictsString setSelector: #conflictsString: for: self.	column addMorphBack: conflictsRow.	column addMorphBack: (StringMorph contents: 'Description:').		descriptionField _ self makeFieldGet: #description set: #description:.	win addMorph: descriptionField frame: (0@0.6 extent: 1@0.3).		submitButton _ UInterfaceUtilities makeButtonWithAction: #submit andLabel: 'Submit' for: self.	win addMorph: submitButton frame: (0@0.9 extent: 1@0.1).			^window _ win! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 10/20/2006 18:36' prior: 33752799!urlString	^package url ifNotNil: [ package url toText ]! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 10/25/2006 15:18' prior: 33752902!urlString: aString	| url trimmedString |	trimmedString := aString asString withBlanksTrimmed.	url := (trimmedString isEmpty or: [ trimmedString beginsWith: '(' ])		ifTrue: [ nil ]		ifFalse: [ Url absoluteFromText: trimmedString ].	package url: url.	self changed: #urlString.	^true! !!Object methodsFor: '*universes' stamp: 'ls 11/26/2006 12:33'!isUPackage	^false! !!Object methodsFor: '*universes' stamp: 'ls 11/26/2006 12:33'!isUPackageCategory	^false! !!UPackage commentStamp: 'ls 7/27/2004 21:20' prior: 33801235!One release of one package.!!UPackage class methodsFor: '*universes-messages' stamp: 'ls 11/26/2006 11:15' prior: 33801343!decodeFromStringStream: str	| package numDepends homePageText numProvides numConflicts urlString |	package _ self new.	package name: str next.	package version: (UVersion readFromString: str next).	package description: str next.	urlString := str next.	(urlString withBlanksTrimmed beginsWith: '(') ifFalse: [		(urlString withBlanksTrimmed beginsWith: 'http://(') ifFalse: [			package url: (Url absoluteFromText: urlString) ] ].	homePageText _ str next.	package homepage: (homePageText isEmpty ifTrue: [ nil ] ifFalse: [ homePageText asUrl ]).	package maintainer: str next.	numProvides _ Integer readFromString: str next. 	package provides: (str next: numProvides).	numDepends _ Integer readFromString: str next. 	package depends: (str next: numDepends).	numConflicts _ Integer readFromString: str next. 	package conflicts: (str next: numConflicts).	str atEnd ifFalse: [		package category: (UPackageCategory readFromString: str next)].		^package! !!UPackage class methodsFor: 'decoding' stamp: 'ls 11/26/2006 11:18' prior: 33802130!decodeFromXMLElement: doc	| package urlString |	package _ self new.	package name: (self getXMLPartNamed: 'name' from: doc).	package version: (UVersion readFromString: (self getXMLPartNamed: 'version' from: doc)).	package description: (self getXMLPartNamed: 'description' from: doc).	urlString _ self getXMLPartNamed: 'url' from: doc.	urlString isEmpty ifFalse: [		(urlString withBlanksTrimmed beginsWith: 'http://(') ifFalse: [	 		package url: (Url absoluteFromText: urlString). ] ].	(doc elementAt: 'homepage') ifNotNil: [		package homepage: (Url absoluteFromText: (self getXMLPartNamed: 'homepage' from: doc)) ].	package maintainer: (self getXMLPartNamed: 'maintainer' from: doc).	package provides: (self getXMLPackageList: 'provides' from: doc).	package depends: (self getXMLPackageList: 'depends' from: doc).	package conflicts: (self getXMLPackageList: 'conflicts' from: doc).	(doc elementAt: 'category') ifNotNil: [		package category: (UPackageCategory readFromString: (self getXMLPartNamed: 'category' from: doc ))].	^package! !!UPackage methodsFor: 'comparing' stamp: 'ls 11/26/2006 11:06' prior: 33804395!= anotherPackage	self hash = anotherPackage hash ifFalse: [ ^false ].	self name = anotherPackage name ifFalse: [ ^false ].	self version = anotherPackage version ifFalse: [ ^false ].	self category = anotherPackage category ifFalse: [ ^false ].	self depends = anotherPackage depends ifFalse: [ ^false ].	self provides = anotherPackage provides ifFalse: [ ^false ].	self conflicts = anotherPackage conflicts ifFalse: [ ^false ].	self url asString = anotherPackage url asString ifFalse: [ ^false ].	self maintainer = anotherPackage maintainer ifFalse: [ ^false ].	self homepage isNil = anotherPackage homepage isNil ifFalse: [ ^false ].	(self homepage isNil or: [ 		self homepage toText = anotherPackage homepage toText]) ifFalse: [ ^false ].	self description = anotherPackage description ifFalse:[ ^false ].	^true! !!UPackage methodsFor: 'accessing' stamp: 'ls 11/26/2006 10:54'!category	^ category ifNil: [self defaultCategory]! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 11/26/2006 11:10'!category: aPackageCategory	category := aPackageCategory! !!UPackage methodsFor: 'miscellania' stamp: 'ls 11/26/2006 11:07'!defaultCategory	^ UPackageCategory withComponents: #('Uncategorized' )! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 11/26/2006 10:54' prior: 33806395!initialize	name := '(unnamed package)'.	version := UVersion readFromString: '0'.	category := self defaultCategory.	depends := Set new.	conflicts := Set new.	provides := Set new.	description := ''.	url := nil.	homepage := nil.	maintainer := ''! !!UPackage methodsFor: 'installing' stamp: 'ls 10/19/2006 10:30' prior: 33806693!install	| filename doc file downloadDir |	self url ifNil: [ ^self ].		downloadDir _ FileDirectory default directoryNamed: 'universetmp'.	downloadDir assureExistence.		filename _ self url path last.	(downloadDir isAFileNamed: filename)	ifFalse: [		"download the file"		doc _ url retrieveContents.		((doc contentType asString = 'text/plain') and: [			doc content beginsWith: 'error']) ifTrue: [			"HACK to see if the download failed; the real solution is to make retrieveContents report errors"			^self error: 'download failed' ].		file _ downloadDir newFileNamed: filename.		file binary.		file nextPutAll: doc content.		file close. ].		UInstaller installFileNamed: (downloadDir fullNameFor: filename).			! !!UPackage methodsFor: 'testing' stamp: 'ls 12/31/2006 16:11'!isPackageCategory	^false! !!UPackage methodsFor: 'comparing' stamp: 'ls 11/26/2006 12:34'!isUPackage	^true! !!UPackage methodsFor: '*universes-messages' stamp: 'ls 11/26/2006 11:16' prior: 33808489!stringArrayEncoding	^Array streamContents: [ :str |		str			nextPut: self name;			nextPut: self version printString;			nextPut: self description;			nextPut: (self url ifNil: [ '(no download url)' ] ifNotNil: [ self url toText ]);			nextPut: (self homepage ifNil: [ '' ] ifNotNil: [ self homepage toText ]);			nextPut: self maintainer;			nextPut: self provides size printString;			nextPutAll: self provides;			nextPut: self depends size printString;			nextPutAll: self depends;			nextPut: self conflicts size printString;			nextPutAll: self conflicts;			nextPut: self category printString ]! !!UPackage methodsFor: 'accessing' stamp: 'ls 10/19/2006 10:30' prior: 33809064!url	"The location of the package to install.  If it is nil, then the package is virtual and only has meaning for its dependencies."	^url! !!UPackage methodsFor: 'serializing' stamp: 'ls 11/26/2006 11:19' prior: 33809439!xmlForExport	^String streamContents: [ :str |		str			nextPutAll: '<package>'; cr;			nextPutAll: '<name>'; nextPutAll: self name escapeEntities; nextPutAll: '</name>'; cr;			nextPutAll: '<version>'; nextPutAll:  self version printString escapeEntities; nextPutAll: '</version>'; cr;			nextPutAll: '<category>'; print: self category; nextPutAll: '</category>'; cr;			nextPutAll: '<description>'; nextPutAll: self description escapeEntities; nextPutAll: '</description>'; cr.		self url ifNotNil: [			str nextPutAll: '<url>'; nextPutAll: self url toText escapeEntities; nextPutAll: '</url>'; cr ].		self homepage ifNotNil: [			str nextPutAll: '<homepage>'; nextPutAll:  self homepage toText escapeEntities; nextPutAll: '</homepage>'; cr ].		str nextPutAll: '<maintainer>'; nextPutAll: self maintainer escapeEntities; nextPutAll: '</maintainer>'; cr.					str nextPutAll: '<provides>'.		self printXMLPackageList: self provides on: str.		str nextPutAll: '</provides>'.		str nextPutAll: '<depends>'.		self printXMLPackageList: self depends on: str.		str nextPutAll: '</depends>'.		str nextPutAll: '<conflicts>'.		self printXMLPackageList: self conflicts on: str.		str nextPutAll: '</conflicts>'.		str nextPutAll: '</package>'; cr. ]! !!UPackageCategory commentStamp: 'ls 11/26/2006 10:59' prior: 0!A category for a package.!!UPackageCategory class methodsFor: 'instance creation' stamp: 'ls 11/26/2006 11:03'!readFrom: aStream	"[UPackageCategory readFromString: 'Core/Umbrella Packages']"	| comps nextComp |	comps := OrderedCollection new.	[aStream atEnd] whileFalse: [		nextComp := (aStream upTo: $/) withBlanksTrimmed.		nextComp isEmpty ifFalse: [			comps add: nextComp ] ].		^self withComponents: comps! !!UPackageCategory class methodsFor: 'instance creation' stamp: 'ls 11/26/2006 12:21'!root	^self withComponents: #()! !!UPackageCategory class methodsFor: 'instance creation' stamp: 'ls 11/26/2006 11:05'!withComponents: anArrayOfStrings	^self basicNew initialize: (Array withAll: anArrayOfStrings)! !!UPackageCategory methodsFor: 'comparing' stamp: 'ls 12/31/2006 16:10'!= aCategory	^aCategory isPackageCategory and: [		components = aCategory components ]! !!UPackageCategory methodsFor: 'attributes' stamp: 'ls 11/26/2006 11:05'!components	^components! !!UPackageCategory methodsFor: 'comparing' stamp: 'ls 11/26/2006 11:06'!hash	^components hash! !!UPackageCategory methodsFor: 'initialize-release' stamp: 'ls 11/26/2006 10:59'!initialize	components := #()! !!UPackageCategory methodsFor: 'initialize-release' stamp: 'ls 11/26/2006 10:59'!initialize: anArrayOfStrings	components := anArrayOfStrings! !!UPackageCategory methodsFor: 'testing' stamp: 'ls 12/31/2006 16:10'!isPackageCategory	^true! !!UPackageCategory methodsFor: 'subcategories' stamp: 'ls 11/26/2006 12:20'!isSubcategoryOf: prefix	components isEmpty ifTrue: [ ^false ].	^components allButLast = prefix components! !!UPackageCategory methodsFor: 'comparing' stamp: 'ls 11/26/2006 12:33'!isUPackageCategory	^true! !!UPackageCategory methodsFor: 'printing' stamp: 'ls 11/26/2006 11:04'!printOn: aStream	components do: [ :comp |		aStream nextPutAll: comp ]	separatedBy: [ aStream nextPut: $/ ]! !!UUniverseBrowser commentStamp: '<historical>' prior: 33762705!A tool to support one-click installs and upgrades of packages within a universe.!!UUniverseBrowser class methodsFor: 'class initialization' stamp: 'ls 11/26/2006 09:25' prior: 33763026!initialize	TheWorldMenu registerOpenCommand: {'Package Universe Browser'. {self. #open}}.	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UUniverseBrowser class methodsFor: 'class initialization' stamp: 'ls 11/26/2006 09:26' prior: 33764345!unload	TheWorldMenu unregisterOpenCommand: 'Package Universe Browser'! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:56' prior: 33765637!anyPackageSelected	^ selectedPackage notNil! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:23'!categories	^((self sortedPackages collect: [ :p | p category])		asSet		asSortedCollection: [ :p1 :p2 | p1 asString < p2 asString])		asArray! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:35'!categoriesAndPackagesIn: categoryPrefix	| categories packages |	categories := self categories select: [ :cat | cat isSubcategoryOf: categoryPrefix ].	packages := self sortedPackages select: [ :p | p category = categoryPrefix ].	^categories, packages! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 12/31/2006 16:12' prior: 33766093!chooseUpgrades	"select packages that appear to be upgrades of packages that are already installed"	universe packageNames do: [ :name |		(configuration includesPackageNamed: name) ifTrue: [			| cpack mypack |			cpack _ configuration packageNamed: name.			mypack _ universe newestPackageNamed: name.			mypack version > cpack version ifTrue: [				self planToInstallPackageWithoutUIUpdate: mypack ] ] ].		self changed: #packageDescriptions.	self changed: #rootCategoriesAndPackages.! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 12/31/2006 16:12' prior: 33766767!doInstall	| orderedPackages |	packagesToInstall isEmpty ifTrue: [		^self inform: 'no packages selected to install' ].			orderedPackages := UUniverseBrowser orderPackagesByDependency: packagesToInstall.	orderedPackages do: [ :p | 		Utilities informUser: 'installing ', p printString during: [			configuration installPackage: p ] ].	packagesToInstall _ Set new.	self changed: #packageDescriptions.	self changed: #rootCategoriesAndPackages.! !!UUniverseBrowser methodsFor: 'initialize-release' stamp: 'ls 11/26/2006 12:56' prior: 33767256!initialize	configuration := UConfiguration forSystem.	packagesToInstall := Set new.	self universe: UUniverse systemUniverse! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:34'!isCategory: anObject	^anObject isUPackageCategory! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 11/26/2006 12:50' prior: 33768328!morphicView	| win packageList installButton doInstallButton buttonList upgradeButton updateListButton descriptionArea installButtonHolder |	win _ SystemWindow labelled: 'Universe'.	win model: self.			packageList _ 		PluggableTreeMorph new			model:  self;			name: 'package list';			getRootsSelector: #rootCategoriesAndPackages; 			hasChildrenSelector: #isCategory:; 			getChildrenSelector: #categoriesAndPackagesIn:;			setSelectedSelector: #selectPackageOrCategory:;			getLabelSelector: #packageOneLineDescription:.	win addMorph: packageList frame: ((0@0) extent: (0.5@0.9)).		installButtonHolder _ Morph new.  "necessary to keep SystemWindow from screwing up the colors of the button"	installButtonHolder 		name: 'holder for install button';		layoutPolicy: TableLayout new;		borderColor: self defaultBackgroundColor.	doInstallButton _ self makeButtonWithAction: #doInstall andGetState: #anyPackagesToInstall andLabel: 'Install Selections'.	doInstallButton		useSquareCorners;		borderWidth: 0;		setBalloonText: 'Download and install all the packages that you have selected';		name: 'install selections button'.	installButtonHolder addMorph: doInstallButton.	win addMorph: installButtonHolder frame: ((0@0.9) extent:(1@0.1)).	descriptionArea _ PluggableTextMorph on: self text: #selectedPackageDescription accept: nil.	win addMorph: descriptionArea frame: ((0.5@0.4) extent: (0.5@0.5)).		buttonList _ AlignmentMorph newColumn.	buttonList		cellInset: 0@3;		name: 'button list'.	win addMorph: buttonList frame: ((0.5@0) extent: (0.5@0.4)).			installButton _ self makeButtonWithAction: #installSelectedPackage andGetState: #canMarkSelectionForInstallation andLabel: 'select package'.	installButton setBalloonText: 'Select this package for installation'.	buttonList addMorph: installButton.		upgradeButton _ self makeButtonWithAction: #chooseUpgrades andLabel: 'select all upgrades'.	upgradeButton setBalloonText: 'Select every possible upgrade for the currently installed packages'.	buttonList addMorphBack: upgradeButton.		updateListButton _ self makeButtonWithAction: #requestPackageList andLabel: 'update list from network'.	updateListButton setBalloonText: 'Refresh the list of available packages from the network'.	buttonList addMorphBack: updateListButton.		^win! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:48' prior: 33770914!packageDescriptions	^ self sortedPackages collect: [:p | self packageOneLineDescription: p]! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:48'!packageOneLineDescription: p 	| commentary |	p isUPackage ifFalse: [ ^p printString ].	commentary := ''.	(packagesToInstall includes: p) ifTrue: [commentary := '(to install) '].	(configuration installedPackages includes: p) 		ifTrue: [commentary := '(installed) '].	^ commentary , p printString! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 12/31/2006 16:23' prior: 33771280!packagesChanged	packagesToInstall _ Set new.  "the selected packages may not be there any more!!"	self selectPackageOrCategory:   nil.		self changed: #packageDescriptions.  self flag: #lex.  "only for compatibility with old, open GUI windows"	self changed: #rootCategoriesAndPackages.	! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 12/31/2006 17:20' prior: 33771534!planToInstallPackage: package	"plan to install a package plus its dependencies; refuses if any dependencies cannot be met"	self planToInstallPackageWithoutUIUpdate: package.	self changed: #packageDescriptions.	self changed: #rootCategoriesAndPackages.! !!UUniverseBrowser methodsFor: 'server communication' stamp: 'ls 11/26/2006 12:53' prior: 33772454!requestPackageList	Utilities informUser: 'updating package list...' during:  [		universe updatePackagesViaWWW ]! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:24'!rootCategoriesAndPackages	^self categoriesAndPackagesIn: (UPackageCategory root)! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 12/31/2006 16:13'!selectPackageOrCategory: packageOrCategory	selectedPackage := 		packageOrCategory isUPackage			ifTrue: [ packageOrCategory ]			ifFalse: [ nil ].	self changed: #selectedPackage.	self changed: #selectedPackageDescription.	self changed: #canMarkSelectionForInstallation.	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:55' prior: 33772873!selectedPackage	^selectedPackage! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 10:58' prior: 33773018!selectedPackageDescription	self anyPackageSelected ifFalse: [ ^ '' ].	^String streamContents: [ :str |		str nextPutAll: self selectedPackage description; cr; cr.		str nextPutAll: 'Category: '; print: self selectedPackage category; cr.		self selectedPackage provides isEmpty ifFalse: [			str nextPutAll: 'Provides:'; cr.			self selectedPackage provides do: [ :depName |				str tab; nextPutAll: depName; cr ].			str cr].		self selectedPackage depends isEmpty ifFalse: [			str nextPutAll: 'Depends on:'; cr.			self selectedPackage depends do: [ :depName |				str tab; nextPutAll: depName; cr ].			str cr].		self selectedPackage conflicts isEmpty ifFalse: [			str nextPutAll: 'Conflicts with:'; cr.			self selectedPackage conflicts do: [ :depName |				str tab; nextPutAll: depName; cr ].			str cr].		str nextPutAll: ('Maintained by: ', self selectedPackage maintainer); cr.		str nextPutAll: 'Downloads from: '.		self selectedPackage url ifNil: [ str nextPutAll: '(no url)' ] ifNotNil: [ str nextPutAll: self selectedPackage url asString ].		str cr.		self selectedPackage homepage ifNotNil: [			str nextPutAll: ('Homepage: ', self selectedPackage homepage toText); cr]. ].	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:58' prior: 33774116!selectedPackageIndex	self flag: #lex.  "only present in case people have existing browser windows open"	^self sortedPackages indexOf: selectedPackage! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 13:02' prior: 33774236!selectedPackageIndex: anIndex	self flag: #lex.  "only present in case people have existing browser windows open"	self selectPackageOrCategory:		(anIndex = 0 ifTrue: [ nil ] ifFalse: [ self sortedPackages at: anIndex ]).	self changed: #selectedPackageIndex	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 12/31/2006 16:25' prior: 33774511!sortedPackages	| packages |	packages := Set new.	packages addAll: universe packages.	packages addAll: configuration installedPackages.		^packages asSortedCollection: [ :p1 :p2 |		p1 name < p2 name or: [			p1 name = p2 name and: [ p1 version < p2 version ] ] ].	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:19'!subcategoriesOf: categoryPrefix	^self categories select: [ :cat | cat isSubcategoryOf: categoryPrefix ]! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 11/26/2006 13:04' prior: 33774740!titleAreaText	self flag: #lex.  "this is only present to support browser windows that are already open"	^universe shortName! !!UUniverseEditor class methodsFor: 'class initialization' stamp: 'ls 11/26/2006 09:26' prior: 33823474!initialize	TheWorldMenu registerOpenCommand: {'Package Universe Editor'. {self. #open}}.	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UUniverseEditor class methodsFor: 'class initialization' stamp: 'ls 11/26/2006 09:25' prior: 33824388!unload	TheWorldMenu unregisterOpenCommand: 'Package Universe Editor'! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 11/16/2006 16:42'!createNewPackage	| package |	package := UPackage new.	Utilities authorInitialsPerSe ifNotNil: [		package maintainer: Utilities authorInitialsPerSe	].	^package! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 11/16/2006 16:42' prior: 33829389!newPackage	| editor |	self acceptFields.	editor _ UPackageEditor package: self createNewPackage whenComplete: [ :p |		self acceptFields.		self sendMessage: (UMAddPackage username: username password: password package: p) ].	editor openInMorphic.	packageEditors add: editor.! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 12/31/2006 16:13' prior: 33830830!packagesChanged	self selectedPackageIndex: 0.		self changed: #packageDescriptions.	self changed: #rootCategoriesAndPackages.! !UUniverse class removeSelector: #squeak39Universe!"Universes"!!XMLTokenizer commentStamp: '<historical>' prior: 33857017!XMLTokenizerbolot@cc.gatech.edubreaks the stream of characters into a stream of XMLnodes (aka token stream)token stream is used by XMLparser to generate XMLdocument tree!"XML-Parser"!!UMAddPackage methodsFor: 'printing' stamp: 'ls 1/13/2007 21:24'!printOn: aStream	aStream 		print: self class;		nextPutAll: ' (';		print: package;		nextPutAll: ')'! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 1/13/2007 14:41' prior: 33868061!categoryString: aText 	package categoryString: aText asString.	self changed: #categoryString! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 1/13/2007 14:41'!categoryString: aString	self category: (UPackageCategory readFromString: aString).! !!UUniverseClient methodsFor: 'networking' stamp: 'ls 1/13/2007 14:47' prior: 33822649!waitForMessage	"return the next message from the server, waiting if necessary.  Many clients will find this method less convenient than polling on the non-blocking receivedMessagesDo:."	[		self receivedMessagesDo: [ :m | ^m ].		(Delay forMilliseconds: 100) wait.	] repeat.! !!UUniverse class methodsFor: 'well known' stamp: 'ls 1/31/2007 20:26'!squeak39Universe 	"[UUniverse switchSystemToUniverse: UUniverse squeak39Universe]"	^UStandardUniverse new		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		shortName: 'squeak3.9';		description: 'Squeak 3.9';		packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/squeak3.9.packages' asUrl;		yourself! !"Universes"!----SNAPSHOT----an Array(31 January 2007 9:34:40 pm) squeak.image priorSource: 105817!----SNAPSHOT----an Array(31 January 2007 9:36:05 pm) squeak.image priorSource: 338952!SystemOrganization addCategory: #'Universes-Interface'!SystemOrganization addCategory: #'Universes-Editor'!SystemOrganization addCategory: #'Universes-Browser'!SystemOrganization addCategory: #'Universes-Policy'!SystemOrganization addCategory: #'Universes-Model'!SystemOrganization addCategory: #'Universes-Tests'!SystemOrganization addCategory: #'Universes-Server'!SystemOrganization addCategory: #'Universes-Client'!SystemOrganization addCategory: #'Universes-Installers'!SystemOrganization addCategory: #'Universes-Messages'!SystemOrganization addCategory: #'Universes-Serialization'!!String methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:32' prior: 33849501!uversionEqual: anObject	^anObject isString and: [ self = anObject ]! !!String methodsFor: '*universes-model' stamp: 'ls 7/27/2004 21:13' prior: 33849641!uversionLessThan: anObject	^anObject isInteger or: [ self < anObject ]! !Model subclass: #UAccountEditor	instanceVariableNames: 'username password newPassword newPassword2 newEmail whenDone window fields'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Editor'!!UAccountEditor commentStamp: '<historical>' prior: 33741368!A tool for editing an account!!UAccountEditor class methodsFor: 'class initialization' stamp: 'ls 2/13/2005 16:58' prior: 33741485!initialize	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UAccountEditor class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:41' prior: 33741662!username: username0  password: password0  email: email0  whenDone: aBlock	^self basicNew		username: username0  password: password0  email: email0  whenDone: aBlock;		yourself! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 17:52' prior: 33741917!acceptFields	fields do: [ :f | f accept ]! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:40' prior: 33742037!morphicView	| win column nameRow submitButton passwordRow password1Row password2Row emailRow submitButtonHolder |	window ifNotNil: [^window].	win := SystemWindow labelled: 'Account Editor'.	win model: self.	column := AlignmentMorph newColumn.	win addMorph: column frame: (0 @ 0 extent: 1 @ 1).	nameRow := UInterfaceUtilities 				makeFieldRowNamed: 'name:'				getSelector: #username				setSelector: nil				isPassword: false				for: self.	column addMorphBack: nameRow.	passwordRow := UInterfaceUtilities 				makeFieldRowNamed: 'password:'				getSelector: #password				setSelector: #password:				isPassword: true				for: self.	column addMorphBack: passwordRow.	password1Row := UInterfaceUtilities 				makeFieldRowNamed: 'new password'				getSelector: #password1				setSelector: #password1:				isPassword: true				for: self.	column addMorphBack: password1Row.	password2Row := UInterfaceUtilities 				makeFieldRowNamed: 'confirm:'				getSelector: #password2				setSelector: #password2:				isPassword: true				for: self.	column addMorphBack: password2Row.	emailRow := UInterfaceUtilities 				makeFieldRowNamed: 'email:'				getSelector: #newEmail				setSelector: #newEmail:				isPassword: false				for: self.	column addMorphBack: emailRow.	submitButtonHolder := Morph new.	"necessary to keep SystemWindow from screwing up the colors of the button"	submitButtonHolder		layoutPolicy: TableLayout new;		hResizing: #spaceFill;		borderColor: self defaultBackgroundColor.	submitButton := UInterfaceUtilities 				makeButtonWithAction: #submit				andLabel: 'Submit'				for: self.	submitButton		useSquareCorners;		borderWidth: 0.	submitButtonHolder addMorph: submitButton.	column addMorphBack: submitButtonHolder.	^window := win! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:52' prior: 33743878!newEmail	^newEmail! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:53' prior: 33743970!newEmail: anObject	newEmail _ anObject! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:34' prior: 33744087!noteField: field 	"note that the receiver has the specified text field"	fields ifNil: [fields := OrderedCollection new].	fields add: field! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:38' prior: 33744306!openInMorphic	^self morphicView openInWorldExtent:  251@263! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:50' prior: 33744439!password	^password! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:51' prior: 33744531!password1	^newPassword! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:51' prior: 33744627!password1: aString	newPassword _ aString asString.	self changed: #password1.	^true! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:51' prior: 33744785!password2	^newPassword2! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:51' prior: 33744882!password2: aString	newPassword2 _ aString asString.	self changed: #password2.	^true! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 2/13/2005 16:50' prior: 33745041!password: aString	password _ aString.	self changed: #password! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:12' prior: 33745182!returnTrue	^true! !!UAccountEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 16:52' prior: 33745277!submit	self acceptFields.	newPassword = newPassword2 ifFalse: [		^self inform: 'new passwords do not match!!' ].	whenDone value: password value: newPassword value: newEmail	! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 17:50' prior: 33745528!username	^username! !!UAccountEditor methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 17:40' prior: 33745629!username: username0  password: password0  email: email0  whenDone: aBlock	username _ username0.	password _ password0.	newPassword _ ''.	newPassword2 _ ''.	newEmail _ email0.	whenDone _ aBlock.! !!UAccountEditor methodsFor: 'accessing' stamp: 'ls 7/28/2004 18:01' prior: 33745902!window	^window! !Model subclass: #UPackageEditor	instanceVariableNames: 'package whenComplete fields window'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Editor'!!UPackageEditor commentStamp: '<historical>' prior: 33745976!A simple GUI for editing a package and then doing something with it.!!UPackageEditor class methodsFor: 'class initialization' stamp: 'ls 2/13/2005 16:58' prior: 33746133!initialize	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UPackageEditor class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 16:28' prior: 33746310!package: aPackage  whenComplete: aBlock	^self basicNew		package: aPackage  whenComplete: aBlock;		yourself! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 16:41' prior: 33746497!acceptFields	fields do: [ :f | f accept ]! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 11/26/2006 11:22' prior: 33867942!categoryString	^package category printString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 1/13/2007 14:41' prior: 33892305!categoryString: aText 	package categoryString: aText asString.	self changed: #categoryString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59' prior: 33746612!conflictsString	^self stringForPackageNames: package conflicts! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59' prior: 33746748!conflictsString: aString 	package conflicts: (self packageNamesFromString: aString).	self changed: #conflictsString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:58' prior: 33746938!dependsString	^self stringForPackageNames: package depends! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59' prior: 33747070!dependsString: aString 	package depends: (self packageNamesFromString: aString).	self changed: #dependsString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:40' prior: 33747254!description	^package description! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:41' prior: 33747360!description: aString	package description: aString asString.	self changed: #description.	^true! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 18:00' prior: 33747529!homepageString	^package homepage		ifNil: [ '' ]		ifNotNil: [ package homepage toText ]! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 18:01' prior: 33747691!homepageString: newHomePage	newHomePage asString = ''		ifTrue: [ package homepage: nil ]		ifFalse: [ package homepage: (Url absoluteFromText: newHomePage asString) ].	self changed: #homepageString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59' prior: 33747965!maintainer	^package maintainer! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 18:00' prior: 33748069!maintainer: aStringOrText 	package maintainer: aStringOrText asString.	self changed: #maintainer! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 16:34' prior: 33748245!makeFieldGet: getSelector  set: setSelector	| field fieldHeight |	fieldHeight _ TextStyle default defaultFont pointSize + 8.					field := PluggableTextMorph on: self text: getSelector accept: setSelector.	field extent: 200@fieldHeight.	field hideScrollBarsIndefinitely.	field setProperty: #alwaysAccept toValue: true.		fields ifNil: [ fields _ OrderedCollection new].	fields add: field.		^field! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 11/26/2006 11:22' prior: 33868279!morphicView	| win column nameRow versionRow urlRow descriptionField submitButton dependsRow homepageRow providesRow conflictsRow maintainerRow categoryRow |	window ifNotNil: [ ^window ].	win _ SystemWindow labelled: 'Package Editor'.	win model: self.	column _ AlignmentMorph newColumn.	win addMorph: column frame: (0@0  extent:  1@0.6).		nameRow _ UInterfaceUtilities makeFieldRowNamed: 'name:' getSelector: #packageName setSelector: #packageName: for: self.	column addMorphBack: nameRow.		versionRow _ UInterfaceUtilities makeFieldRowNamed: 'version:' getSelector: #versionString setSelector: #versionString: for: self.	column addMorphBack: versionRow.		categoryRow _ UInterfaceUtilities makeFieldRowNamed: 'category:' getSelector: #categoryString setSelector: #categoryString: for: self.	column addMorphBack: categoryRow.		maintainerRow _ UInterfaceUtilities makeFieldRowNamed: 'maintainer:' getSelector: #maintainer setSelector: #maintainer: for: self.	column addMorphBack: maintainerRow.		homepageRow _ UInterfaceUtilities makeFieldRowNamed: 'homepage:' getSelector: #homepageString setSelector: #homepageString: for: self.	column addMorphBack: homepageRow.				urlRow _ UInterfaceUtilities makeFieldRowNamed: 'download from:' getSelector: #urlString setSelector: #urlString: for: self.	column addMorphBack: urlRow.	providesRow _ UInterfaceUtilities makeFieldRowNamed: 'provides:' getSelector: #providesString setSelector: #providesString: for: self.	column addMorphBack: providesRow.		dependsRow _ UInterfaceUtilities makeFieldRowNamed: 'depends:' getSelector: #dependsString setSelector: #dependsString: for: self.	column addMorphBack: dependsRow.	conflictsRow _ UInterfaceUtilities makeFieldRowNamed: 'conflicts:' getSelector: #conflictsString setSelector: #conflictsString: for: self.	column addMorphBack: conflictsRow.	column addMorphBack: (StringMorph contents: 'Description:').		descriptionField _ self makeFieldGet: #description set: #description:.	win addMorph: descriptionField frame: (0@0.6 extent: 1@0.3).		submitButton _ UInterfaceUtilities makeButtonWithAction: #submit andLabel: 'Submit' for: self.	win addMorph: submitButton frame: (0@0.9 extent: 1@0.1).			^window _ win! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:34' prior: 33750841!noteField: field 	"note that the receiver has the specified text field"	fields ifNil: [fields := OrderedCollection new].	fields add: field! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 18:02' prior: 33751060!openInMorphic	^self morphicView openInWorldExtent: 517@488! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:45' prior: 33751192!package	^package! !!UPackageEditor methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 16:28' prior: 33751291!package: aPackage  whenComplete: aBlock	package _ aPackage.	whenComplete _ aBlock.	! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:38' prior: 33751450!packageName	^package name! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:43' prior: 33751549!packageName: aString	package name: aString asString.	self changed: #packageName.	^true! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59' prior: 33751711!packageNamesFromString: aString 	| depNames |	depNames := aString asString findTokens: ','.	depNames := depNames collect: [:d | d withBlanksTrimmed].	^depNames! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59' prior: 33751947!providesString	^self stringForPackageNames: package provides! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:59' prior: 33752081!providesString: aString 	package provides: (self packageNamesFromString: aString).	self changed: #providesString! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 18:05' prior: 33752273!returnTrue	^true! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 2/13/2005 17:58' prior: 33752363!stringForPackageNames: depends 	| first |	first := true.	^String streamContents: 			[:str | 			depends do: 					[:depName | 					first ifTrue: [first := false] ifFalse: [str nextPutAll: ', '].					str nextPutAll: depName]]! !!UPackageEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 16:43' prior: 33752671!submit	self acceptFields.	whenComplete value: package! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 10/20/2006 18:36' prior: 33870607!urlString	^package url ifNotNil: [ package url toText ]! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 10/25/2006 15:18' prior: 33870753!urlString: aString	| url trimmedString |	trimmedString := aString asString withBlanksTrimmed.	url := (trimmedString isEmpty or: [ trimmedString beginsWith: '(' ])		ifTrue: [ nil ]		ifFalse: [ Url absoluteFromText: trimmedString ].	package url: url.	self changed: #urlString.	^true! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:39' prior: 33753083!versionString	^package version printString! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 16:39' prior: 33753199!versionString: aString	package version: (UVersion readFromString: aString).	self changed: #versionString.	^true! !!UPackageEditor methodsFor: 'accessors' stamp: 'ls 7/28/2004 17:12' prior: 33753386!window	^window! !Model subclass: #UUniverse	instanceVariableNames: 'shortName description'	classVariableNames: 'SystemUniverse'	poolDictionaries: ''	category: 'Universes-Model'!!UUniverse commentStamp: 'ls 2/13/2005 11:10' prior: 33753461!Abstract.  One "package universe".  A package universe is an evolving set of packages that multiple people can participate in.  Each Squeak image is a member of exactly one universe.!UUniverse subclass: #UCompoundUniverse	instanceVariableNames: 'components'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Model'!!UCompoundUniverse commentStamp: 'ls 7/29/2004 18:48' prior: 33753710!A universe that is the union of other universes.!!UCompoundUniverse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 18:47' prior: 33753846!composedOf: universes	^self new		components: universes;		yourself! !!UCompoundUniverse methodsFor: 'accessing' stamp: 'ls 2/13/2005 14:56' prior: 33753990!components: anObject	components _ anObject.	components do: [ :c | c addDependent:  self ].! !!UCompoundUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:09' prior: 33754157!packages	^Array streamContents: [ :pstr |		components do: [ :univ |			pstr nextPutAll: univ packages ] ]! !!UCompoundUniverse methodsFor: 'accessing' stamp: 'ls 7/29/2004 18:50' prior: 33754340!standardUniverses	^Array streamContents: [ :str |		components do: [ :comp |			str nextPutAll: comp standardUniverses  ] ]! !!UCompoundUniverse methodsFor: 'updating' stamp: 'ls 2/13/2005 14:57' prior: 33754539!update: aSymbol	aSymbol = #packages ifTrue: [ self changed: #packages ].! !!UCompoundUniverse methodsFor: 'packages' stamp: 'ls 2/13/2005 14:58' prior: 33754687!updatePackagesViaWWW	components do: [ :component | component updatePackagesViaWWW ]! !UUniverse subclass: #UStandardUniverse	instanceVariableNames: 'serverName serverPort packagesURL packages'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Model'!!UStandardUniverse commentStamp: 'ls 7/28/2004 10:36' prior: 33754839!A universe that looks to one single server for authoritative information.!!UStandardUniverse methodsFor: 'packages' stamp: 'ls 2/13/2005 12:43' prior: 33754986!addPackage: aPackage	"make sure that we end up with no two packages with the same name and version"	packages removeAllSuchThat: [ :p | p name = aPackage name and: [ p version = aPackage version ] ].		"now add the new package"	packages add: aPackage.	self changed: #packages! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 1/16/2005 14:07' prior: 33755351!initialize	super initialize.	packages _ Set new.! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 1/16/2005 14:07' prior: 33755477!packages	^packages! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 15:01' prior: 33755581!packages: aCollection	packages _ Set new.	packages addAll: aCollection.	self changed: #packages! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 2/13/2005 11:13' prior: 33755755!packagesURL	"a URL from which the list of packages may be downloaded"	^packagesURL! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 11:12' prior: 33755924!packagesURL: aURL	packagesURL _ aURL! !!UStandardUniverse methodsFor: 'packages' stamp: 'ls 2/13/2005 12:43' prior: 33756036!removePackage: aPackage	packages remove: aPackage.	self changed: #packages! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 7/28/2004 13:21' prior: 33756189!serverName	^serverName! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 10:37' prior: 33756297!serverName: aString		serverName _ aString! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 7/28/2004 13:21' prior: 33756415!serverPort	^serverPort! !!UStandardUniverse methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 10:37' prior: 33756523!serverPort: port	serverPort _ port! !!UStandardUniverse methodsFor: 'accessing' stamp: 'ls 7/29/2004 18:09' prior: 33756634!standardUniverses	^{self}! !!UStandardUniverse methodsFor: 'packages' stamp: 'ls 2/15/2005 22:42' prior: 33756735!updatePackagesViaWWW	| rawPackageList newPackages |	packagesURL ifNil: [ ^self ].	rawPackageList _ packagesURL retrieveContents content.	(rawPackageList withBlanksTrimmed beginsWith: '<') ifFalse: [		"it is possible that the universe is completely empty, but more likely there was an error retrieving the document"		^self ].	newPackages _ UPackage decodePackagesFromXMLStream: (ReadStream on: rawPackageList).	self packages: newPackages! !!UUniverse class methodsFor: 'well known' stamp: 'ls 2/15/2005 23:32' prior: 33757255!developmentUniverse 	"[UUniverse switchSystemToUniverse: UUniverse developmentUniverse]"	^UStandardUniverse new		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		shortName: 'development';		description: 'Development';		packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/development.packages' asUrl;		yourself! !!UUniverse class methodsFor: 'well known' stamp: 'ls 2/13/2005 12:45' prior: 33757705!exampleCompoundUniverse	"[UUniverse switchSystemToUniverse: UUniverse exampleCompoundUniverse]"	^(UCompoundUniverse composedOf: {		self developmentUniverse.		self homeMoviesUniverse	}) description: 'example compound universe'; yourself! !!UUniverse class methodsFor: 'well known' stamp: 'ls 2/15/2005 23:33' prior: 33758020!homeMoviesUniverse 	"[UUniverse switchSystemToUniverse: UUniverse homeMoviesUniverse]"	^UStandardUniverse new		shortName: 'homemovies';		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/homemovies.packages' asUrl;		description: 'Home Movies';		yourself! !!UUniverse class methodsFor: 'class initialization' stamp: 'ls 2/15/2005 23:42' prior: 33758475!initialize	"fix up old instances, to have a proper packagesURL"	"this method should be deleted, after suitable time has passed to allow for upgrades"	self allSubInstancesDo: [ :universe |		universe class == UStandardUniverse ifTrue: [			universe packagesURL == nil ifTrue: [				"no URL specified.  guess...."				universe serverPort = 4129 ifTrue: [					universe shortName: 'development'.					universe packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/development.packages' asUrl.					universe serverPort: UUniverseMultiServer defaultPort. ].				universe serverPort = 8940 ifTrue: [ 					universe shortName: 'homevideos'.					universe packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/homemovies.packages' asUrl.					universe serverPort: UUniverseMultiServer defaultPort. ].				universe serverPort = 7273 ifTrue: [ 					universe shortName: 'squeak37'.					universe packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/squeak37.packages' asUrl.					universe serverPort: UUniverseMultiServer defaultPort. ]. ] ] ]! !!UUniverse class methodsFor: 'well known' stamp: 'ls 2/15/2005 23:33' prior: 33759645!squeak37Universe 	"[UUniverse switchSystemToUniverse: UUniverse squeak37Universe]"	^UStandardUniverse new		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		shortName: 'squeak37';		description: 'Squeak 3.7';		packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/squeak37.packages' asUrl;		yourself! !!UUniverse class methodsFor: 'well known' stamp: 'ls 1/31/2007 20:26' prior: 33893004!squeak39Universe 	"[UUniverse switchSystemToUniverse: UUniverse squeak39Universe]"	^UStandardUniverse new		serverName: 'universes.dnsalias.net';		serverPort: UUniverseMultiServer defaultPort;		shortName: 'squeak3.9';		description: 'Squeak 3.9';		packagesURL: 'http://universes.dnsalias.net:8888/~universes/repositories/squeak3.9.packages' asUrl;		yourself! !!UUniverse class methodsFor: 'system' stamp: 'ls 7/29/2004 18:54' prior: 33760077!switchSystemToUniverse: aUniverse	SystemUniverse _ aUniverse! !!UUniverse class methodsFor: 'system' stamp: 'ls 2/13/2005 12:44' prior: 33760209!systemUniverse	"return the universe this image uses"	^SystemUniverse ifNil: [ SystemUniverse _ self developmentUniverse ]! !!UUniverse methodsFor: 'packages' stamp: 'ls 7/29/2004 19:09' prior: 33760399!addPackages: newPackages	newPackages do: [ :p | self addPackage: p ]! !!UUniverse methodsFor: 'accessing' stamp: 'ls 2/13/2005 11:10' prior: 33760536!description	"The description is a one-line description of the universe for human consumption."	^description! !!UUniverse methodsFor: 'initialize-release' stamp: 'ls 7/29/2004 16:16' prior: 33760723!description: aString	description _ aString! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:06' prior: 33760833!hasPackageNamed: name	^self packages anySatisfy: [ :p | p name = name ].	! !!UUniverse methodsFor: 'initialize-release' stamp: 'ls 1/16/2005 14:07' prior: 33760985!initialize	description _ 'some universe'.! !!UUniverse methodsFor: 'packages' stamp: 'ls 7/28/2004 17:17' prior: 33761094!newestPackageNamed: name	| potentials sorted |	potentials _ self packagesNamed: name.	sorted _ potentials asSortedCollection: [ :p1 :p2 | p1 version < p2 version ].	^sorted last! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:06' prior: 33761342!packageNames	| names |	names _ Set new.	self packages do: [ :p | names add: p name ].	^names! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:08' prior: 33761505!packages	^self subclassResponsibility! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:07' prior: 33761610!packagesNamed: name	^self packages select: [ :p | p name = name ].	! !!UUniverse methodsFor: 'packages' stamp: 'ls 1/16/2005 14:06' prior: 33761746!removePackageNamed: packageName withVersion: version	| packagesToRemove |	packagesToRemove _ self packages select: [ :p | p name = packageName and: [ p version = version ] ].	packagesToRemove do: [ :p | self removePackage: p ].	! !!UUniverse methodsFor: 'accessing' stamp: 'ls 2/13/2005 14:46' prior: 33762046!shortName	"A short, computer-friendly alphanumeric identifier"	^shortName! !!UUniverse methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 11:10' prior: 33762199!shortName: aString	shortName _ aString! !!UUniverse methodsFor: 'accessing' stamp: 'ls 2/15/2005 21:49' prior: 33762307!standardUniverses	"return a list of standard universes within the receiver.  See class UStandardUniverse"	^self subclassResponsibility! !!UUniverse methodsFor: 'packages' stamp: 'ls 2/13/2005 14:56' prior: 33762510!updatePackagesViaWWW	"update the packages in this universe by downloading them from the universe's URL"	^self subclassResponsibility! !Model subclass: #UUniverseBrowser	instanceVariableNames: 'universe configuration selectedPackage packagesToInstall'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Browser'!!UUniverseBrowser commentStamp: '<historical>' prior: 33880456!A tool to support one-click installs and upgrades of packages within a universe.!!UUniverseBrowser class methodsFor: 'instance creation' stamp: 'ls 2/13/2005 14:53' prior: 33762872!forUniverse: aUniverse	^self new universe: aUniverse; yourself! !!UUniverseBrowser class methodsFor: 'class initialization' stamp: 'ls 11/26/2006 09:25' prior: 33880643!initialize	TheWorldMenu registerOpenCommand: {'Package Universe Browser'. {self. #open}}.	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UUniverseBrowser class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 18:15' prior: 33763277!open	^self new open! !!UUniverseBrowser class methodsFor: 'dependencies' stamp: 'ls 7/29/2004 15:16' prior: 33763381!orderPackagesByDependency: packages	"return a collection of the specified packages such that, when possible, any dependencies of a package are ordered before that package"	"The present algorithm is simple but slow..."	| remainingPackages orderedPackages packagesToAdd |	remainingPackages _ Set new.	orderedPackages _ OrderedCollection new.	remainingPackages addAll: packages.		"each time through this loop, add to orderedPackages any packages whose dependencies are not in remainaingPackages"	[	packagesToAdd := remainingPackages select: [ :p | p depends noneSatisfy: [ :depName | remainingPackages anySatisfy: [ :p2 | p2 name = depName ] ] ].		packagesToAdd isEmpty not	] whileTrue: [		orderedPackages addAll: packagesToAdd.		remainingPackages := remainingPackages difference: packagesToAdd ].		orderedPackages addAll: remainingPackages.	^orderedPackages! !!UUniverseBrowser class methodsFor: 'class initialization' stamp: 'ls 11/26/2006 09:26' prior: 33880922!unload	TheWorldMenu unregisterOpenCommand: 'Package Universe Browser'! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 7/29/2004 17:31' prior: 33764491!allPackagesNeededToInstall: initialPackage  orIfImpossible: errorBlock	"find all packages needed to installed initialPackage; if it is impossible to accomplish, invoke errorBlock with the name of the missing package"	| newPackages packagesToConsider |	newPackages _ Set new.	packagesToConsider _ OrderedCollection with: initialPackage.	[ packagesToConsider isEmpty ] whileFalse: [		| package |		package _ packagesToConsider removeFirst.		(newPackages includes: package) ifFalse: [			newPackages add: package.			package depends do: [ :depName |				((configuration includesPackageNamed: depName) not and: [ packagesToInstall noneSatisfy: [ :p | p name = depName  ] ])				ifTrue: [					"the dependency is needed but is not installed or planned to be installed"					(universe hasPackageNamed: depName) ifTrue: [						"in principle, one could additionally consider trying a different package than the newest..."						packagesToConsider add: (universe newestPackageNamed: depName) ]					ifFalse: [						^errorBlock value: depName ] ] ] ] ].		^newPackages! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:56' prior: 33881087!anyPackageSelected	^ selectedPackage notNil! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 9/4/2004 14:36' prior: 33765759!anyPackagesToInstall	^packagesToInstall isEmpty not! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 9/4/2004 14:16' prior: 33765888!canMarkSelectionForInstallation	^self anyPackageSelected and: [ (packagesToInstall includes: self selectedPackage) not ]! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:23' prior: 33881210!categories	^((self sortedPackages collect: [ :p | p category])		asSet		asSortedCollection: [ :p1 :p2 | p1 asString < p2 asString])		asArray! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:35' prior: 33881432!categoriesAndPackagesIn: categoryPrefix	| categories packages |	categories := self categories select: [ :cat | cat isSubcategoryOf: categoryPrefix ].	packages := self sortedPackages select: [ :p | p category = categoryPrefix ].	^categories, packages! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 12/31/2006 16:12' prior: 33881786!chooseUpgrades	"select packages that appear to be upgrades of packages that are already installed"	universe packageNames do: [ :name |		(configuration includesPackageNamed: name) ifTrue: [			| cpack mypack |			cpack _ configuration packageNamed: name.			mypack _ universe newestPackageNamed: name.			mypack version > cpack version ifTrue: [				self planToInstallPackageWithoutUIUpdate: mypack ] ] ].		self changed: #packageDescriptions.	self changed: #rootCategoriesAndPackages.! !!UUniverseBrowser methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:58' prior: 33766623!configuration: aConfiguration	configuration _ aConfiguration! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 12/31/2006 16:12' prior: 33882377!doInstall	| orderedPackages |	packagesToInstall isEmpty ifTrue: [		^self inform: 'no packages selected to install' ].			orderedPackages := UUniverseBrowser orderPackagesByDependency: packagesToInstall.	orderedPackages do: [ :p | 		Utilities informUser: 'installing ', p printString during: [			configuration installPackage: p ] ].	packagesToInstall _ Set new.	self changed: #packageDescriptions.	self changed: #rootCategoriesAndPackages.! !!UUniverseBrowser methodsFor: 'initialize-release' stamp: 'ls 11/26/2006 12:56' prior: 33882927!initialize	configuration := UConfiguration forSystem.	packagesToInstall := Set new.	self universe: UUniverse systemUniverse! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 7/29/2004 17:11' prior: 33767493!installSelectedPackage	self anyPackageSelected ifFalse: [ ^self ].	self planToInstallPackage: self selectedPackage.		! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:34' prior: 33883132!isCategory: anObject	^anObject isUPackageCategory! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 9/4/2004 14:37' prior: 33767693!makeButtonWithAction: selector andGetState: getStateSelector andLabel: aString	^(PluggableButtonMorph on: self getState: getStateSelector action: selector)		label: aString;		useRoundedCorners;		vResizing: #spaceFill;		hResizing: #spaceFill;		onColor: self defaultBackgroundColor offColor: self defaultBackgroundColor muchLighter;		yourself! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 9/4/2004 14:35' prior: 33768118!makeButtonWithAction: selector  andLabel: aString	^self makeButtonWithAction: selector andGetState: #returnTrue andLabel: aString! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 11/26/2006 12:50' prior: 33883279!morphicView	| win packageList installButton doInstallButton buttonList upgradeButton updateListButton descriptionArea installButtonHolder |	win _ SystemWindow labelled: 'Universe'.	win model: self.			packageList _ 		PluggableTreeMorph new			model:  self;			name: 'package list';			getRootsSelector: #rootCategoriesAndPackages; 			hasChildrenSelector: #isCategory:; 			getChildrenSelector: #categoriesAndPackagesIn:;			setSelectedSelector: #selectPackageOrCategory:;			getLabelSelector: #packageOneLineDescription:.	win addMorph: packageList frame: ((0@0) extent: (0.5@0.9)).		installButtonHolder _ Morph new.  "necessary to keep SystemWindow from screwing up the colors of the button"	installButtonHolder 		name: 'holder for install button';		layoutPolicy: TableLayout new;		borderColor: self defaultBackgroundColor.	doInstallButton _ self makeButtonWithAction: #doInstall andGetState: #anyPackagesToInstall andLabel: 'Install Selections'.	doInstallButton		useSquareCorners;		borderWidth: 0;		setBalloonText: 'Download and install all the packages that you have selected';		name: 'install selections button'.	installButtonHolder addMorph: doInstallButton.	win addMorph: installButtonHolder frame: ((0@0.9) extent:(1@0.1)).	descriptionArea _ PluggableTextMorph on: self text: #selectedPackageDescription accept: nil.	win addMorph: descriptionArea frame: ((0.5@0.4) extent: (0.5@0.5)).		buttonList _ AlignmentMorph newColumn.	buttonList		cellInset: 0@3;		name: 'button list'.	win addMorph: buttonList frame: ((0.5@0) extent: (0.5@0.4)).			installButton _ self makeButtonWithAction: #installSelectedPackage andGetState: #canMarkSelectionForInstallation andLabel: 'select package'.	installButton setBalloonText: 'Select this package for installation'.	buttonList addMorph: installButton.		upgradeButton _ self makeButtonWithAction: #chooseUpgrades andLabel: 'select all upgrades'.	upgradeButton setBalloonText: 'Select every possible upgrade for the currently installed packages'.	buttonList addMorphBack: upgradeButton.		updateListButton _ self makeButtonWithAction: #requestPackageList andLabel: 'update list from network'.	updateListButton setBalloonText: 'Refresh the list of available packages from the network'.	buttonList addMorphBack: updateListButton.		^win! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 7/29/2004 16:19' prior: 33770802!open	self morphicView openInWorld! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:48' prior: 33885687!packageDescriptions	^ self sortedPackages collect: [:p | self packageOneLineDescription: p]! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:48' prior: 33885858!packageOneLineDescription: p 	| commentary |	p isUPackage ifFalse: [ ^p printString ].	commentary := ''.	(packagesToInstall includes: p) ifTrue: [commentary := '(to install) '].	(configuration installedPackages includes: p) 		ifTrue: [commentary := '(installed) '].	^ commentary , p printString! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 12/31/2006 16:23' prior: 33886254!packagesChanged	packagesToInstall _ Set new.  "the selected packages may not be there any more!!"	self selectPackageOrCategory:   nil.		self changed: #packageDescriptions.  self flag: #lex.  "only for compatibility with old, open GUI windows"	self changed: #rootCategoriesAndPackages.	! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 12/31/2006 17:20' prior: 33886646!planToInstallPackage: package	"plan to install a package plus its dependencies; refuses if any dependencies cannot be met"	self planToInstallPackageWithoutUIUpdate: package.	self changed: #packageDescriptions.	self changed: #rootCategoriesAndPackages.! !!UUniverseBrowser methodsFor: 'install selections' stamp: 'ls 7/29/2004 17:31' prior: 33771833!planToInstallPackageWithoutUIUpdate: initialPackage	"same as planToInstallPackage:, but does not called #changed:.  Don't call this unless you later call #changed: yourself"	| newPackages |	"find all packages needed to install this one"	newPackages _ self allPackagesNeededToInstall: initialPackage orIfImpossible: [ :missingDep |		^self notify: 'could not find necessary package: ', missingDep ].		packagesToInstall removeAllSuchThat: [ :p | p name = initialPackage name ].	newPackages do: [ :p | packagesToInstall add: p ].	! !!UUniverseBrowser methodsFor: 'server communication' stamp: 'ls 11/26/2006 12:53' prior: 33887006!requestPackageList	Utilities informUser: 'updating package list...' during:  [		universe updatePackagesViaWWW ]! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 9/4/2004 14:35' prior: 33772721!returnTrue	"return true; used for buttons that are always enabled"	^true! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:24' prior: 33887199!rootCategoriesAndPackages	^self categoriesAndPackagesIn: (UPackageCategory root)! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 12/31/2006 16:13' prior: 33887359!selectPackageOrCategory: packageOrCategory	selectedPackage := 		packageOrCategory isUPackage			ifTrue: [ packageOrCategory ]			ifFalse: [ nil ].	self changed: #selectedPackage.	self changed: #selectedPackageDescription.	self changed: #canMarkSelectionForInstallation.	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:55' prior: 33887731!selectedPackage	^selectedPackage! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 10:58' prior: 33887859!selectedPackageDescription	self anyPackageSelected ifFalse: [ ^ '' ].	^String streamContents: [ :str |		str nextPutAll: self selectedPackage description; cr; cr.		str nextPutAll: 'Category: '; print: self selectedPackage category; cr.		self selectedPackage provides isEmpty ifFalse: [			str nextPutAll: 'Provides:'; cr.			self selectedPackage provides do: [ :depName |				str tab; nextPutAll: depName; cr ].			str cr].		self selectedPackage depends isEmpty ifFalse: [			str nextPutAll: 'Depends on:'; cr.			self selectedPackage depends do: [ :depName |				str tab; nextPutAll: depName; cr ].			str cr].		self selectedPackage conflicts isEmpty ifFalse: [			str nextPutAll: 'Conflicts with:'; cr.			self selectedPackage conflicts do: [ :depName |				str tab; nextPutAll: depName; cr ].			str cr].		str nextPutAll: ('Maintained by: ', self selectedPackage maintainer); cr.		str nextPutAll: 'Downloads from: '.		self selectedPackage url ifNil: [ str nextPutAll: '(no url)' ] ifNotNil: [ str nextPutAll: self selectedPackage url asString ].		str cr.		self selectedPackage homepage ifNotNil: [			str nextPutAll: ('Homepage: ', self selectedPackage homepage toText); cr]. ].	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:58' prior: 33889149!selectedPackageIndex	self flag: #lex.  "only present in case people have existing browser windows open"	^self sortedPackages indexOf: selectedPackage! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 13:02' prior: 33889395!selectedPackageIndex: anIndex	self flag: #lex.  "only present in case people have existing browser windows open"	self selectPackageOrCategory:		(anIndex = 0 ifTrue: [ nil ] ifFalse: [ self sortedPackages at: anIndex ]).	self changed: #selectedPackageIndex	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 12/31/2006 16:25' prior: 33889751!sortedPackages	| packages |	packages := Set new.	packages addAll: universe packages.	packages addAll: configuration installedPackages.		^packages asSortedCollection: [ :p1 :p2 |		p1 name < p2 name or: [			p1 name = p2 name and: [ p1 version < p2 version ] ] ].	! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 11/26/2006 12:19' prior: 33890100!subcategoriesOf: categoryPrefix	^self categories select: [ :cat | cat isSubcategoryOf: categoryPrefix ]! !!UUniverseBrowser methodsFor: 'user interface' stamp: 'ls 11/26/2006 13:04' prior: 33890301!titleAreaText	self flag: #lex.  "this is only present to support browser windows that are already open"	^universe shortName! !!UUniverseBrowser methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 15:12' prior: 33774860!universe: aUniverse	universe _ aUniverse.	universe addDependent: self.! !!UUniverseBrowser methodsFor: 'package list' stamp: 'ls 2/13/2005 15:12' prior: 33775010!update: aSymbol	aSymbol = #packages ifTrue: [ self packagesChanged ]! !!Object methodsFor: '*universes' stamp: 'ls 11/26/2006 12:33' prior: 33871108!isUPackage	^false! !!Object methodsFor: '*universes' stamp: 'ls 11/26/2006 12:33' prior: 33871193!isUPackageCategory	^false! !Object subclass: #UAccount	instanceVariableNames: 'username password email packageNames'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Policy'!!UAccount commentStamp: '<historical>' prior: 33775132!An account as used in the standard UPolicy's.!!UAccount methodsFor: 'packages' stamp: 'ls 7/28/2004 18:03' prior: 33775241!addPackageName: name	packageNames add: name! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:47' prior: 33775352!email: aString	email _ aString! !!UAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 18:02' prior: 33775459!initialize	username _ 'joeblow'.	password _ ''.	packageNames _ Set new.! !!UAccount methodsFor: 'packages' stamp: 'ls 7/28/2004 18:03' prior: 33775599!ownsPackageName: name	^packageNames includes: name! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:50' prior: 33775717!password	^password! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:47' prior: 33775803!password: anObject	password _ anObject! !!UAccount methodsFor: 'printing' stamp: 'ls 2/15/2005 23:44' prior: 33775908!printOn: aStream	aStream nextPutAll: 'Account: ', username! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:50' prior: 33776034!username	^username! !!UAccount methodsFor: 'accessing' stamp: 'ls 7/28/2004 21:47' prior: 33776120!username: anObject	username _ anObject! !Object subclass: #UConfiguration	instanceVariableNames: 'installedPackages'	classVariableNames: 'SystemConfiguration'	poolDictionaries: ''	category: 'Universes-Model'!!UConfiguration commentStamp: '<historical>' prior: 33776218!One configuration of packages.!!UConfiguration class methodsFor: 'system' stamp: 'ls 7/27/2004 21:57' prior: 33776322!forSystem	"return a configuration describing the currently running system"	^SystemConfiguration ifNil: [ SystemConfiguration _ self new ].	! !!UConfiguration methodsFor: 'packages' stamp: 'ls 7/28/2004 10:19' prior: 33776536!includesPackageNamed: name	^self installedPackages anySatisfy: [ :p | p name = name ]! !!UConfiguration methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:55' prior: 33776704!initialize	installedPackages _ Set new.! !!UConfiguration methodsFor: 'installing' stamp: 'ls 7/27/2004 21:55' prior: 33776818!installPackage: aPackage	| matchingPackages |	matchingPackages _ installedPackages select: [ :p | p name = aPackage name ].	installedPackages removeAll: matchingPackages.	aPackage install.	installedPackages add: aPackage.	! !!UConfiguration methodsFor: 'packages' stamp: 'ls 7/27/2004 22:02' prior: 33777118!installedPackages	^installedPackages! !!UConfiguration methodsFor: 'packages' stamp: 'ls 7/28/2004 10:18' prior: 33777227!packageNamed: name	^self installedPackages detect: [ :p | p name = name ]! !Object subclass: #UInstaller	instanceVariableNames: ''	classVariableNames: 'Installers'	poolDictionaries: ''	category: 'Universes-Installers'!!UInstaller commentStamp: '<historical>' prior: 33777356!A simply hierarchy for loading Squeak content in various formats.!UInstaller subclass: #UIFileOut	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Installers'!!UIFileOut methodsFor: 'testing' stamp: 'ls 9/4/2004 14:02' prior: 33777484!handlesFilename: filename	^#('.cs' '.st' '.st.gz' '.cs.gz') anySatisfy: [ :ending | filename endsWith: ending ]! !!UIFileOut methodsFor: 'installing' stamp: 'ls 7/29/2004 20:01' prior: 33777665!install: inStream  usingBaseName: basename	"find a changeset name that is not used"	| num changesetName stream |	num _ 0.	[  	changesetName _ basename.	   	num > 0 ifTrue:[ changesetName _ changesetName, '-', num printString. ].		(ChangeSorter changeSetNamed: changesetName) notNil ]	whileTrue: [ num _ num + 1 ].		"decompress if necessary"	inStream peek asInteger = 16r1F		ifTrue: [ stream _ ReadStream on: ((GZipReadStream on: inStream) upToEnd) asString ]		ifFalse: [ stream _ inStream ].			ChangeSorter newChangesFromStream: stream named: changesetName! !UInstaller subclass: #UIMonticello	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Installers'!!UIMonticello methodsFor: 'testing' stamp: 'ls 7/29/2004 11:04' prior: 33778304!handlesFileEnding: ending	^#('mcz') includes: ending! !!UIMonticello methodsFor: 'installing' stamp: 'ls 7/29/2004 19:26' prior: 33778429!installFileNamed: filename	Smalltalk at: #MCMczReader ifPresent: [ :reader |		^reader loadVersionFile: filename ].	MczInstaller installFileNamed: filename! !UInstaller subclass: #UIMpeg	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Installers'!!UIMpeg methodsFor: 'testing' stamp: 'ls 7/29/2004 11:04' prior: 33778649!handlesFileEnding: ending	^#('mpg' 'mpeg') includes: ending! !!UIMpeg methodsFor: 'installing' stamp: 'ls 7/29/2004 11:39' prior: 33778775!install: stream usingBasename: basename	| movieDir movieFile |	movieDir := FileDirectory default directoryNamed: 'movies'.	movieDir assureExistence.		movieDir removeFileNamed: basename.		movieFile _ movieDir newFileNamed: basename, '.mpeg'.	stream binary.  movieFile binary.	movieFile nextPutAll: stream upToEnd.	movieFile close.		Smalltalk at: #MPEGMoviePlayerMorph ifPresent: [ :player |		player playFile: (movieDir fullNameFor: basename, '.mpeg') ]! !UInstaller subclass: #UIProject	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Installers'!!UIProject methodsFor: 'testing' stamp: 'ls 7/29/2004 11:05' prior: 33779305!handlesFileEnding: ending	^#('pr') includes: ending! !!UIProject methodsFor: 'installing' stamp: 'ls 9/18/2004 18:18' prior: 33779426!installFileNamed: filename	FileDirectory splitName: filename to: [ :path :base |		[ 				ProjectViewMorph openFromDirectory: (FileDirectory on: path) andFileName: base		] on: ProjectEntryNotification do:		[ :ex |			"don't enter it" ] ]! !UInstaller subclass: #UISar	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Installers'!!UISar methodsFor: 'testing' stamp: 'ls 7/29/2004 11:04' prior: 33779728!handlesFileEnding: ending	^#('sar') includes: ending! !!UISar methodsFor: 'installing' stamp: 'ls 7/29/2004 11:44' prior: 33779846!installFileNamed: filename	SARInstaller installSAR: filename! !!UInstaller class methodsFor: 'initialization' stamp: 'ls 7/29/2004 11:09' prior: 33779987!initialize	Installers ifNil: [ Installers _ Set new ].		{UIFileOut. UIMonticello. UIMpeg. UIProject. UISar} do: [ :c |		self registerInstaller: c new ]! !!UInstaller class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 11:10' prior: 33780225!installFileNamed: filename	(self installerForFilename: filename) installFileNamed: filename! !!UInstaller class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 11:10' prior: 33780400!installerForFilename: filename	^self registeredInstallers detect: [ :i | i handlesFilename: filename ] ifNone: [ self error: 'no installer handles file ', filename ].! !!UInstaller class methodsFor: 'registry' stamp: 'ls 7/29/2004 11:02' prior: 33780641!registerInstaller: installer	Installers add: installer! !!UInstaller class methodsFor: 'registry' stamp: 'ls 7/29/2004 11:11' prior: 33780770!registeredInstallers	^Installers asArray! !!UInstaller methodsFor: 'comparing' stamp: 'ls 7/29/2004 11:02' prior: 33780880!= anInstaller	^self class = anInstaller class! !!UInstaller methodsFor: 'testing' stamp: 'ls 7/29/2004 10:59' prior: 33780993!handlesFileEnding: anEnding	^false! !!UInstaller methodsFor: 'testing' stamp: 'ls 7/29/2004 11:08' prior: 33781095!handlesFilename: filename	^self handlesFileEnding: (FileDirectory extensionFor: filename)	! !!UInstaller methodsFor: 'comparing' stamp: 'ls 7/29/2004 11:03' prior: 33781256!hash	^self class hash! !!UInstaller methodsFor: 'installing' stamp: 'ls 7/29/2004 11:06' prior: 33781348!install: stream  usingBaseName: baseName	self subclassResponsibility! !!UInstaller methodsFor: 'installing' stamp: 'ls 9/4/2004 15:02' prior: 33781486!installFileNamed: filename	| stream baseName |	stream _ (FileStream readOnlyFileNamed: filename).	baseName _ (FileDirectory splitName: filename to: [:path :base|base]) copyUpTo: $. .	self install: stream usingBaseName: baseName.	stream close.	! !Object subclass: #UInterfaceUtilities	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Interface'!!UInterfaceUtilities commentStamp: 'ls 2/13/2005 17:22' prior: 33781806!This class holds miscellaneous bits of code used to build user interfaces in the various Universes tools.!!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:37' prior: 33782004!makeButtonWithAction: selector andGetState: getStateSelector andLabel: aString for: model	^(PluggableButtonMorph on: model getState: getStateSelector action: selector)		label: aString;		useRoundedCorners;		vResizing: #spaceFill;		hResizing: #spaceFill;		onColor: model defaultBackgroundColor offColor: model defaultBackgroundColor muchLighter;		yourself! !!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:41' prior: 33782458!makeButtonWithAction: selector  andLabel: aString for: model	^self makeButtonWithAction: selector andGetState: #returnTrue  andLabel: aString	for: model! !!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:34' prior: 33782705!makeFieldGet: getSelector  set: setSelector  for: model	| field fieldHeight |	fieldHeight _ TextStyle default defaultFont pointSize + 8.					field := PluggableTextMorph on: model text: getSelector accept: setSelector.	field height: fieldHeight.	field hResizing: #spaceFill.	field hideScrollBarsIndefinitely.	field setProperty: #alwaysAccept toValue: true.	model noteField: field.	^field! !!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:42' prior: 33783198!makeFieldRowNamed: fieldName  getSelector: getSelector setSelector: setSelector for: model	^self makeFieldRowNamed: fieldName  getSelector: getSelector setSelector: setSelector isPassword: false for: model! !!UInterfaceUtilities class methodsFor: 'as yet unclassified' stamp: 'ls 2/13/2005 17:36' prior: 33783498!makeFieldRowNamed: fieldName  getSelector: getSelector setSelector: setSelector isPassword: isPassword for: model	| row field |	row _ AlignmentMorph newRow.	row color: Color transparent.	row cellInset: 3@0.		field _ self makeFieldGet: getSelector set: setSelector for: model.	isPassword ifTrue:[		field font: (StrikeFont passwordFontSize: TextStyle default defaultFont pointSize) ].	row addMorph: (StringMorph contents: fieldName).	row addMorphBack: field.	^row! !Object subclass: #UMessage	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Messages'!!UMessage commentStamp: '<historical>' prior: 33784027!A message that can be sent to or from a UServer.  All instances may be converted to an array of strings, and that array of strings may be parsed back with fromStringArray:.!UMessage subclass: #UMAddAccount	instanceVariableNames: 'username password email'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Messages'!!UMAddAccount commentStamp: '<historical>' prior: 33784254!A request to add a user account.!!UMAddAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:34' prior: 33784370!fromStringArray: stringArray	^self username: stringArray second password: stringArray third email: stringArray fourth! !!UMAddAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:34' prior: 33784573!username: username  password: password  email: email	^self basicNew username: username  password: password  email: email! !!UMAddAccount methodsFor: '*universes-server' stamp: 'ls 7/28/2004 21:46' prior: 33784773!applyToServer: server forConnection: connection	server connection: connection requestedAccountWithUsername: username password: password email: email! !!UMAddAccount methodsFor: 'converting' stamp: 'ls 7/28/2004 14:34' prior: 33784994!asStringArray	^{'addaccount' . username . password . email}! !!UMAddAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:33' prior: 33785134!username: username0  password: password0  email: email0	username _ username0.	password _ password0.	email _ email0.	! !UMessage subclass: #UMAddPackage	instanceVariableNames: 'username password package'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Messages'!!UMAddPackage class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:07' prior: 33785339!fromStringArray: array	^self username: array second password: array third package: (UPackage decodeFromStringStream: (ReadStream on: (array allButFirst: 3)))! !!UMAddPackage class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:37' prior: 33785582!username: username password: password package: package	^self basicNew username: username password: password package: package! !!UMAddPackage methodsFor: '*universes-server' stamp: 'ls 7/28/2004 17:03' prior: 33785786!applyToServer: server forConnection: connection	server connection: connection requestedForUsername: username andPassword: password toAddPackage: package! !!UMAddPackage methodsFor: 'converting' stamp: 'ls 7/28/2004 16:56' prior: 33786011!asStringArray	^{'addpackage' . username . password },	  package stringArrayEncoding! !!UMAddPackage methodsFor: 'printing' stamp: 'ls 1/13/2007 21:24' prior: 33892113!printOn: aStream	aStream 		print: self class;		nextPutAll: ' (';		print: package;		nextPutAll: ')'! !!UMAddPackage methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:37' prior: 33786176!username: username0 password: password0 package: package0	username _ username0.	password _ password0.	package _ package0.	! !UMessage subclass: #UMEditAccount	instanceVariableNames: 'username password newPassword newEmail'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Messages'!!UMEditAccount commentStamp: '<historical>' prior: 33786360!A request to change the password or email of an account.!!UMEditAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:38' prior: 33786501!fromStringArray: array	^self username: array second password: array third newPassword: array fourth newEmail: array fifth! !!UMEditAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:36' prior: 33786709!username: username  password: password  newPassword: newPassword newEmail: newEmail	^self basicNew username: username  password: password  newPassword: newPassword newEmail: newEmail! !!UMEditAccount methodsFor: '*universes-server' stamp: 'ls 7/28/2004 17:55' prior: 33786972!applyToServer: server forConnection: connection	server connection: connection requestedAccountChangeForUsername: username password: password newPassword: newPassword newEmail: newEmail! !!UMEditAccount methodsFor: 'converting' stamp: 'ls 7/28/2004 14:36' prior: 33787230!asStringArray	^{'editaccount' . username . password . newPassword . newEmail}! !!UMEditAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:36' prior: 33787389!username: username0  password: password0  newPassword: newPassword0 newEmail: newEmail0	username _ username0.	password _ password0.	newPassword _ newPassword0.	newEmail _ newEmail0.	! !UMessage subclass: #UMEditedAccount	instanceVariableNames: 'username newPassword newEmail'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Messages'!!UMEditedAccount commentStamp: '<historical>' prior: 33787636!Notification that an account has been successfully edited.!!UMEditedAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:38' prior: 33787780!fromStringArray: array	^self username: array second newPassword: array third newEmail: array fourth! !!UMEditedAccount class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:37' prior: 33787968!username: username  newPassword: newPassword  newEmail: newEmail	^self basicNew		username: username  newPassword: newPassword  newEmail: newEmail;		yourself! !!UMEditedAccount methodsFor: '*universes-editor' stamp: 'ls 7/28/2004 17:59' prior: 33788209!applyToEditor: editor	editor accountUpdatedWithUsername: username  password:  newPassword  email: newEmail! !!UMEditedAccount methodsFor: 'converting' stamp: 'ls 7/28/2004 17:37' prior: 33788391!asStringArray	^{'editedaccount' . username . newPassword . newEmail }! !!UMEditedAccount methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 17:36' prior: 33788544!username: username0  newPassword: newPassword0  newEmail: newEmail0	username _ username0.	newPassword _ newPassword0.	newEmail _ newEmail0.	! !UMessage subclass: #UMError	instanceVariableNames: 'description'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Messages'!!UMError commentStamp: '<historical>' prior: 33788740!An error message from the server to the client.!UMError subclass: #UMConnectionFailed	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Messages'!!UMConnectionFailed commentStamp: '<historical>' prior: 33788848!An error in establishing a connection to a server.!!UMError class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 13:33' prior: 33788976!description: aString	^self basicNew		description: aString;		yourself! !!UMError class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:02' prior: 33789127!fromStringArray: array	^self description: array second! !!UMError methodsFor: '*universes-editor' stamp: 'ls 7/28/2004 21:58' prior: 33789256!applyToEditor: editor	"the inform: is deferred, because otherwise the editor can stop stepping!!"	WorldState addDeferredUIMessage: [ editor inform: 'Error: ', description ]! !!UMError methodsFor: '*universes-server' stamp: 'ls 7/28/2004 13:35' prior: 33789505!applyToServer: server forConnection: connection	"if the client sends an error back, then the connection is really messed up"	server destroyConnection: connection	! !!UMError methodsFor: 'converting' stamp: 'ls 7/28/2004 13:36' prior: 33789737!asStringArray	^{'error' . description }! !!UMError methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 13:26' prior: 33789852!description: aString	description := aString! !UMessage subclass: #UMMalformed	instanceVariableNames: 'stringArray'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Messages'!!UMMalformed commentStamp: '<historical>' prior: 33789952!a malformed packet!!UMMalformed class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 11:30' prior: 33790052!fromStringArray: array	^self basicNew stringArray: array; yourself! !!UMMalformed methodsFor: 'converting' stamp: 'ls 7/28/2004 11:31' prior: 33790190!asStringArray	^self error: 'a malformed packet cannot be converted to a string array'! !!UMMalformed methodsFor: 'accessing' stamp: 'ls 7/28/2004 11:45' prior: 33790346!stringArray: anObject	stringArray _ anObject! !UMessage subclass: #UMPackageAdded	instanceVariableNames: 'package'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Messages'!!UMPackageAdded commentStamp: 'ls 7/28/2004 15:08' prior: 33790456!A message declaring that a package has been added to the universe.!!UMPackageAdded class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 15:07' prior: 33790608!fromStringArray: array	| str |	str _ ReadStream on: array.	str next.	^self package: (UPackage decodeFromStringStream: str)! !!UMPackageAdded class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 15:07' prior: 33790821!package: aPackage	^self basicNew		package: aPackage;		yourself! !!UMPackageAdded methodsFor: '*universes-client' stamp: 'ls 7/30/2004 15:01' prior: 33790967!applyToClient: aClient	aClient packageAdded: package! !!UMPackageAdded methodsFor: '*universes-editor' stamp: 'ls 7/30/2004 15:38' prior: 33791101!applyToEditor: editor	editor closeEditorForPackage: package.! !!UMPackageAdded methodsFor: 'converting' stamp: 'ls 7/28/2004 15:07' prior: 33791237!asStringArray	^#('packageadded'), package stringArrayEncoding! !!UMPackageAdded methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:59' prior: 33791381!package: aPackage	package _ aPackage! !UMessage subclass: #UMPackageList	instanceVariableNames: 'packages'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Messages'!!UMPackageList commentStamp: '<historical>' prior: 33791476!A message describing a list of packages that are in the server's universe.!!UMPackageList class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 15:05' prior: 33791634!fromStringArray: array	| str packages numPackages |	str _ ReadStream on: array.	str next.  "skip the 'packages' designation".	packages _ OrderedCollection new.	numPackages _ Integer readFromString: str next.	numPackages timesRepeat: [		packages add: (UPackage decodeFromStringStream: str) ].			^self packages: packages! !!UMPackageList class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 12:01' prior: 33792049!packages: aCollection	^self basicNew		packages: aCollection;		yourself! !!UMPackageList methodsFor: '*universes-client' stamp: 'ls 7/30/2004 15:01' prior: 33792202!applyToClient: aClient	aClient newPackageList: packages! !!UMPackageList methodsFor: 'converting' stamp: 'ls 7/28/2004 15:04' prior: 33792331!asStringArray	^Array streamContents: [ :str |		str nextPut: 'packages'.		str nextPut: packages size printString.		packages do: [ :pack |			str nextPutAll: pack stringArrayEncoding ]. ].! !!UMPackageList methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 12:01' prior: 33792602!packages: aCollection	packages _ aCollection! !UMessage subclass: #UMPackageRemoved	instanceVariableNames: 'packageName version'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Messages'!!UMPackageRemoved commentStamp: '<historical>' prior: 33792708!A message claiming that a package has been removed.!!UMPackageRemoved class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:58' prior: 33792846!fromStringArray: array	^self packageName: array second version: (UVersion readFromString: array third)! !!UMPackageRemoved class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:58' prior: 33793038!packageName: aString version: aVersion	^self basicNew		packageName: aString version: aVersion;		yourself! !!UMPackageRemoved methodsFor: '*universes-client' stamp: 'ls 7/30/2004 15:02' prior: 33793228!applyToClient: aClient	aClient removedPackageNamed: packageName  withVersion: version! !!UMPackageRemoved methodsFor: 'converting' stamp: 'ls 7/28/2004 14:57' prior: 33793390!asStringArray	^{'packageremoved' . packageName . version printString }! !!UMPackageRemoved methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:57' prior: 33793545!packageName: aString  version: aVersion	packageName _ aString.	version _ aVersion.! !UMessage subclass: #UMProtocolVersion	instanceVariableNames: 'version'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Messages'!!UMProtocolVersion commentStamp: '<historical>' prior: 33793691!Tell the receiver what protocol version the sender understands.  The receiver should not send messages back which use a newer protocol version.!!UMProtocolVersion class methodsFor: 'instance creation' stamp: 'ls 2/15/2005 21:40' prior: 33793923!fromStringArray: array	^self version: (Integer readFromString: array second)! !!UMProtocolVersion class methodsFor: 'instance creation' stamp: 'ls 2/15/2005 21:40' prior: 33794090!version: anInteger	^self new version: anInteger; yourself! !!UMProtocolVersion methodsFor: 'applying' stamp: 'ls 2/15/2005 21:41' prior: 33794223!applyToClient: client! !!UMProtocolVersion methodsFor: 'applying' stamp: 'ls 2/15/2005 21:42' prior: 33794319!applyToEditor: editor! !!UMProtocolVersion methodsFor: 'applying' stamp: 'ls 2/15/2005 21:42' prior: 33794415!applyToMultiServer: server forConnection: connection! !!UMProtocolVersion methodsFor: 'applying' stamp: 'ls 2/15/2005 21:41' prior: 33794542!applyToServer: server forConnection: connection! !!UMProtocolVersion methodsFor: 'converting' stamp: 'ls 2/15/2005 21:41' prior: 33794666!asStringArray	^{'protocolversion' . version asString}! !!UMProtocolVersion methodsFor: 'attributes' stamp: 'ls 2/15/2005 21:40' prior: 33794797!version	^version! !!UMProtocolVersion methodsFor: 'initialize-release' stamp: 'ls 2/15/2005 21:39' prior: 33794899!version: anInteger	version _ anInteger! !UMessage subclass: #UMRemovePackage	instanceVariableNames: 'username password packageName packageVersion'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Messages'!!UMRemovePackage commentStamp: '<historical>' prior: 33794998!A request to remove a package from a universe.!!UMRemovePackage class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 17:26' prior: 33795131!fromStringArray: array	^self username: array second password: array third packageName: array fourth packageVersion: (UVersion readFromString: array fifth)! !!UMRemovePackage class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 14:41' prior: 33795374!username: username password: password packageName: packageName packageVersion: packageVersion	^self basicNew username: username password: password packageName: packageName packageVersion: packageVersion! !!UMRemovePackage methodsFor: '*universes-server' stamp: 'ls 7/28/2004 17:20' prior: 33795659!applyToServer: server forConnection: connection	server connection: connection requestedForUsername: username andPassword: password toRemovePackageNamed: packageName withVersion: packageVersion! !!UMRemovePackage methodsFor: 'converting' stamp: 'ls 7/29/2004 15:46' prior: 33795927!asStringArray	^{'removepackage' . username . password . packageName . packageVersion printString }! !!UMRemovePackage methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:39' prior: 33796110!username: username0 password: password0 packageName: packageName0 packageVersion: packageVersion0	username _ username0.	password _ password0.	packageName _ packageName0.	packageVersion _ packageVersion0.	! !UMessage subclass: #UMRequestPackages	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Messages'!!UMRequestPackages commentStamp: '<historical>' prior: 33796381!A package requesting that a copy of all packages in the server's universe.!!UMRequestPackages class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 11:59' prior: 33796543!fromStringArray: array	^self basicNew! !!UMRequestPackages methodsFor: '*universes-server' stamp: 'ls 7/28/2004 13:08' prior: 33796665!applyToServer: server forConnection: connection	connection nextPut: (UMPackageList packages: server universe packages) asStringArray! !!UMRequestPackages methodsFor: 'converting' stamp: 'ls 7/28/2004 11:59' prior: 33796876!asStringArray	^#('requestpackages')! !UMessage subclass: #UMSelectServer	instanceVariableNames: 'shortName'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Messages'!!UMSelectServer commentStamp: 'ls 2/13/2005 16:05' prior: 33796977!A request to a multi-server, to select the server for a specific universe.  Subsequent messages should be directed to the selected universe instead of to the specific universes.!!UMSelectServer class methodsFor: 'instance creation' stamp: 'ls 2/13/2005 16:06' prior: 33797239!fromStringArray: stringArray	^self shortName: stringArray second! !!UMSelectServer class methodsFor: 'instance creation' stamp: 'ls 2/13/2005 16:06' prior: 33797391!shortName: aString	^self new		shortName: aString;		yourself! !!UMSelectServer methodsFor: '*universes-server' stamp: 'ls 2/13/2005 16:18' prior: 33797534!applyToMultiServer: server forConnection: connection	server switchConnection: connection toServerNamed: shortName! !!UMSelectServer methodsFor: 'converting' stamp: 'ls 2/13/2005 16:06' prior: 33797722!asStringArray	^{'selectserver' . shortName}! !!UMSelectServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 16:12' prior: 33797848!shortName: aString	shortName _ aString! !!UMessage class methodsFor: 'instance creation' stamp: 'ls 2/15/2005 21:41' prior: 33797968!fromStringArray: array	| class |	class _ nil.	array first = 'requestpackages' ifTrue: [ class _ UMRequestPackages ].	array first = 'packages' ifTrue: [ class _ UMPackageList ].	array first = 'error' ifTrue: [ class _ UMError ].	array first = 'addaccount' ifTrue: [ class _ UMAddAccount ].	array first = 'addpackage' ifTrue: [ class _ UMAddPackage ].	array first = 'editaccount' ifTrue: [ class _ UMEditAccount ].	array first = 'editedaccount' ifTrue: [ class _ UMEditedAccount ].	array first = 'packageadded' ifTrue: [ class _ UMPackageAdded ].	array first = 'packageremoved' ifTrue: [ class _ UMPackageRemoved ].	array first = 'removepackage' ifTrue: [ class _ UMRemovePackage ].	array first = 'selectserver' ifTrue: [ class _ UMSelectServer ].	array first = 'protocolversion' ifTrue: [ class _ UMProtocolVersion ].	class ifNil: [			^UMMalformed fromStringArray: array ].		^[ class fromStringArray: array ] on: Error do: [ :ex | UMMalformed fromStringArray: array ]! !!UMessage methodsFor: '*universes-client' stamp: 'ls 7/30/2004 15:00' prior: 33799028!applyToClient: aClient	"apply this message to a UUniverseClient"	! !!UMessage methodsFor: '*universes-editor' stamp: 'ls 7/28/2004 15:40' prior: 33799170!applyToEditor: editor	! !!UMessage methodsFor: '*universes-server' stamp: 'ls 2/13/2005 16:18' prior: 33799268!applyToMultiServer: server  forConnection: connection	connection nextPut: (UMError description: 'message inappropriate for multi-server') asStringArray! !!UMessage methodsFor: '*universes-server' stamp: 'ls 7/28/2004 17:25' prior: 33799495!applyToServer: server  forConnection: connectionself inspect.	connection nextPut: (UMError description: 'message inappropriate for server') asStringArray! !!UMessage methodsFor: 'converting' stamp: 'ls 7/28/2004 11:30' prior: 33799718!asStringArray	^self subclassResponsibility! !Object subclass: #UOneShotConnection	instanceVariableNames: 'inputMessage outputQueue hasBeenRead hasBeenWritten'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Server'!!UOneShotConnection commentStamp: '<historical>' prior: 33799824!A fake StringSocket used to integrate a UUniverseServer with an HTTP server.A OneShotConnection has exactly one input message and only accepts one output message.  It puts the supplied output message onto a SharedQueue and then disconnects itself.!!UOneShotConnection class methodsFor: 'instance creation' stamp: 'ls 8/2/2004 16:31' prior: 33800162!withInMessage: inMessage0  andOutQueue: aSharedQueue	^self basicNew		initializeWithInMessage: inMessage0  andOutQueue: aSharedQueue;		yourself! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:33' prior: 33800387!destroy	hasBeenWritten _ true! !!UOneShotConnection methodsFor: 'initialize-release' stamp: 'ls 8/2/2004 16:33' prior: 33800502!initializeWithInMessage: inMessage0  andOutQueue: aSharedQueue	inputMessage _ inMessage0.	outputQueue _ aSharedQueue.	hasBeenRead _ false.	hasBeenWritten _ false.! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:34' prior: 33800748!isConnected	^hasBeenWritten not! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:32' prior: 33800860!nextOrNil	hasBeenRead ifTrue:[ ^nil ].	hasBeenRead _ true.	^inputMessage! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:53' prior: 33801015!nextPut: anObject	outputQueue nextPut: anObject.	hasBeenWritten _ true! !!UOneShotConnection methodsFor: 'string socket' stamp: 'ls 8/2/2004 16:32' prior: 33801167!processIO! !Object subclass: #UPackage	instanceVariableNames: 'name version category description provides depends conflicts url homepage maintainer'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Model'!!UPackage commentStamp: 'ls 7/27/2004 21:20' prior: 33871285!One release of one package.!!UPackage class methodsFor: '*universes-messages' stamp: 'ls 11/26/2006 11:15' prior: 33871410!decodeFromStringStream: str	| package numDepends homePageText numProvides numConflicts urlString |	package _ self new.	package name: str next.	package version: (UVersion readFromString: str next).	package description: str next.	urlString := str next.	(urlString withBlanksTrimmed beginsWith: '(') ifFalse: [		(urlString withBlanksTrimmed beginsWith: 'http://(') ifFalse: [			package url: (Url absoluteFromText: urlString) ] ].	homePageText _ str next.	package homepage: (homePageText isEmpty ifTrue: [ nil ] ifFalse: [ homePageText asUrl ]).	package maintainer: str next.	numProvides _ Integer readFromString: str next. 	package provides: (str next: numProvides).	numDepends _ Integer readFromString: str next. 	package depends: (str next: numDepends).	numConflicts _ Integer readFromString: str next. 	package conflicts: (str next: numConflicts).	str atEnd ifFalse: [		package category: (UPackageCategory readFromString: str next)].		^package! !!UPackage class methodsFor: 'decoding' stamp: 'ls 11/26/2006 11:18' prior: 33872469!decodeFromXMLElement: doc	| package urlString |	package _ self new.	package name: (self getXMLPartNamed: 'name' from: doc).	package version: (UVersion readFromString: (self getXMLPartNamed: 'version' from: doc)).	package description: (self getXMLPartNamed: 'description' from: doc).	urlString _ self getXMLPartNamed: 'url' from: doc.	urlString isEmpty ifFalse: [		(urlString withBlanksTrimmed beginsWith: 'http://(') ifFalse: [	 		package url: (Url absoluteFromText: urlString). ] ].	(doc elementAt: 'homepage') ifNotNil: [		package homepage: (Url absoluteFromText: (self getXMLPartNamed: 'homepage' from: doc)) ].	package maintainer: (self getXMLPartNamed: 'maintainer' from: doc).	package provides: (self getXMLPackageList: 'provides' from: doc).	package depends: (self getXMLPackageList: 'depends' from: doc).	package conflicts: (self getXMLPackageList: 'conflicts' from: doc).	(doc elementAt: 'category') ifNotNil: [		package category: (UPackageCategory readFromString: (self getXMLPartNamed: 'category' from: doc ))].	^package! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/13/2005 13:24' prior: 33802973!decodePackagesFromXMLStream: stream	| doc |	doc _ XMLDOMParser parseDocumentFrom: stream.	^doc elements collect: [ :element | self decodeFromXMLElement: element ].! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/13/2005 13:12' prior: 33803212!getXMLPackageList: listname from: element	| listElement |	listElement _ element elementAt: listname.	listElement ifNil: [ ^#() ].	^listElement elements collect: [ :nameXML |		nameXML contents first string ]! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/2/2007 15:00' prior: 33803496!getXMLPartNamed: partName  from: xmlDoc	| element |	element _ xmlDoc elementAt: partName.	(element isNil or: [ element contents isEmpty ]) ifTrue:[ ^ '' ].	^element contents first string! !!UPackage class methodsFor: 'decoding' stamp: 'ls 2/13/2005 13:41' prior: 33803734!readPackageListFromFileNamed: filename	| file packages |	file _ FileStream readOnlyFileNamed: filename.	packages _ self decodePackagesFromXMLStream: file.	file close.	^packages! !!UPackage class methodsFor: 'saving' stamp: 'ls 2/13/2005 14:47' prior: 33803985!savePackageList: packageList  onFileNamed: filename	| tmpName file |	tmpName _ filename, 'tmp'.	FileDirectory default deleteFileNamed: tmpName ifAbsent:  [].	file _ FileStream fileNamed: tmpName.	packageList do: [ :package |		file nextPutAll: package xmlForExport ].	file close.	FileDirectory default rename: tmpName toBe: filename.! !!UPackage methodsFor: 'comparing' stamp: 'ls 11/26/2006 11:06' prior: 33873603!= anotherPackage	self hash = anotherPackage hash ifFalse: [ ^false ].	self name = anotherPackage name ifFalse: [ ^false ].	self version = anotherPackage version ifFalse: [ ^false ].	self category = anotherPackage category ifFalse: [ ^false ].	self depends = anotherPackage depends ifFalse: [ ^false ].	self provides = anotherPackage provides ifFalse: [ ^false ].	self conflicts = anotherPackage conflicts ifFalse: [ ^false ].	self url asString = anotherPackage url asString ifFalse: [ ^false ].	self maintainer = anotherPackage maintainer ifFalse: [ ^false ].	self homepage isNil = anotherPackage homepage isNil ifFalse: [ ^false ].	(self homepage isNil or: [ 		self homepage toText = anotherPackage homepage toText]) ifFalse: [ ^false ].	self description = anotherPackage description ifFalse:[ ^false ].	^true! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:19' prior: 33805233!addDependency: aString	depends add: aString! !!UPackage methodsFor: 'accessing' stamp: 'ls 11/26/2006 10:54' prior: 33874499!category	^ category ifNil: [self defaultCategory]! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 11/26/2006 11:10' prior: 33874626!category: aPackageCategory	category := aPackageCategory! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 1/13/2007 14:41' prior: 33892475!categoryString: aString	self category: (UPackageCategory readFromString: aString).! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 12:28' prior: 33805344!conflicts	^conflicts ifNil: [ Set new ]! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 12:27' prior: 33805461!conflicts: aCollection	conflicts _ Set withAll: aCollection! !!UPackage methodsFor: 'miscellania' stamp: 'ls 11/26/2006 11:07' prior: 33874752!defaultCategory	^ UPackageCategory withComponents: #('Uncategorized' )! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53' prior: 33805588!depends	^depends! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/29/2004 15:39' prior: 33805681!depends: aCollection	depends _ Set withAll: aCollection! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53' prior: 33805804!description	^description! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:17' prior: 33805905!description: aString	description _ aString! !!UPackage methodsFor: 'comparing' stamp: 'ls 7/28/2004 09:58' prior: 33806015!hash	^self name hash bitXor: self version hash! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 18:05' prior: 33806129!homepage	"a homepage describing the package, or nil if there isn't one"	^homepage! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 12:20' prior: 33806288!homepage: aURL	homepage _ aURL! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 11/26/2006 10:54' prior: 33874916!initialize	name := '(unnamed package)'.	version := UVersion readFromString: '0'.	category := self defaultCategory.	depends := Set new.	conflicts := Set new.	provides := Set new.	description := ''.	url := nil.	homepage := nil.	maintainer := ''! !!UPackage methodsFor: 'installing' stamp: 'ls 10/19/2006 10:30' prior: 33875253!install	| filename doc file downloadDir |	self url ifNil: [ ^self ].		downloadDir _ FileDirectory default directoryNamed: 'universetmp'.	downloadDir assureExistence.		filename _ self url path last.	(downloadDir isAFileNamed: filename)	ifFalse: [		"download the file"		doc _ url retrieveContents.		((doc contentType asString = 'text/plain') and: [			doc content beginsWith: 'error']) ifTrue: [			"HACK to see if the download failed; the real solution is to make retrieveContents report errors"			^self error: 'download failed' ].		file _ downloadDir newFileNamed: filename.		file binary.		file nextPutAll: doc content.		file close. ].		UInstaller installFileNamed: (downloadDir fullNameFor: filename).			! !!UPackage methodsFor: 'testing' stamp: 'ls 12/31/2006 16:11' prior: 33876045!isPackageCategory	^false! !!UPackage methodsFor: 'comparing' stamp: 'ls 11/26/2006 12:34' prior: 33876138!isUPackage	^true! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 12:33' prior: 33807456!maintainer	^maintainer ifNil: [ '' ]! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 12:32' prior: 33807569!maintainer: aString	maintainer _ aString! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/28/2004 09:53' prior: 33807677!name	^name! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:17' prior: 33807764!name: aString	name _ aString! !!UPackage methodsFor: 'printing' stamp: 'ls 7/27/2004 21:19' prior: 33807859!printOn: aStream	aStream		nextPutAll: name;		nextPutAll: ' version ';		print: version! !!UPackage methodsFor: 'serializing' stamp: 'ls 2/13/2005 13:29' prior: 33808017!printXMLPackageList: names on: stream	names do: [ :n |		stream nextPutAll: ' <packagename>'; nextPutAll: n escapeEntities; nextPutAll: '</packagename>' ].! !!UPackage methodsFor: 'accessing' stamp: 'ls 2/13/2005 12:29' prior: 33808240!provides	^provides ifNil: [ Set new ]! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 12:27' prior: 33808354!provides: aCollection	provides _ Set withAll: aCollection! !!UPackage methodsFor: '*universes-messages' stamp: 'ls 11/26/2006 11:16' prior: 33876249!stringArrayEncoding	^Array streamContents: [ :str |		str			nextPut: self name;			nextPut: self version printString;			nextPut: self description;			nextPut: (self url ifNil: [ '(no download url)' ] ifNotNil: [ self url toText ]);			nextPut: (self homepage ifNil: [ '' ] ifNotNil: [ self homepage toText ]);			nextPut: self maintainer;			nextPut: self provides size printString;			nextPutAll: self provides;			nextPut: self depends size printString;			nextPutAll: self depends;			nextPut: self conflicts size printString;			nextPutAll: self conflicts;			nextPut: self category printString ]! !!UPackage methodsFor: 'accessing' stamp: 'ls 10/19/2006 10:30' prior: 33876936!url	"The location of the package to install.  If it is nil, then the package is virtual and only has meaning for its dependencies."	^url! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:18' prior: 33809149!url: aURL	url _ aURL! !!UPackage methodsFor: 'accessing' stamp: 'ls 7/27/2004 21:32' prior: 33809237!version	^version! !!UPackage methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:17' prior: 33809330!version: aVersion	version _ aVersion.	! !!UPackage methodsFor: 'serializing' stamp: 'ls 11/26/2006 11:19' prior: 33877160!xmlForExport	^String streamContents: [ :str |		str			nextPutAll: '<package>'; cr;			nextPutAll: '<name>'; nextPutAll: self name escapeEntities; nextPutAll: '</name>'; cr;			nextPutAll: '<version>'; nextPutAll:  self version printString escapeEntities; nextPutAll: '</version>'; cr;			nextPutAll: '<category>'; print: self category; nextPutAll: '</category>'; cr;			nextPutAll: '<description>'; nextPutAll: self description escapeEntities; nextPutAll: '</description>'; cr.		self url ifNotNil: [			str nextPutAll: '<url>'; nextPutAll: self url toText escapeEntities; nextPutAll: '</url>'; cr ].		self homepage ifNotNil: [			str nextPutAll: '<homepage>'; nextPutAll:  self homepage toText escapeEntities; nextPutAll: '</homepage>'; cr ].		str nextPutAll: '<maintainer>'; nextPutAll: self maintainer escapeEntities; nextPutAll: '</maintainer>'; cr.					str nextPutAll: '<provides>'.		self printXMLPackageList: self provides on: str.		str nextPutAll: '</provides>'.		str nextPutAll: '<depends>'.		self printXMLPackageList: self depends on: str.		str nextPutAll: '</depends>'.		str nextPutAll: '<conflicts>'.		self printXMLPackageList: self conflicts on: str.		str nextPutAll: '</conflicts>'.		str nextPutAll: '</package>'; cr. ]! !Object subclass: #UPackageCategory	instanceVariableNames: 'components'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Model'!!UPackageCategory commentStamp: 'ls 11/26/2006 10:59' prior: 33878476!A category for a package.!!UPackageCategory class methodsFor: 'instance creation' stamp: 'ls 11/26/2006 11:03' prior: 33878589!readFrom: aStream	"[UPackageCategory readFromString: 'Core/Umbrella Packages']"	| comps nextComp |	comps := OrderedCollection new.	[aStream atEnd] whileFalse: [		nextComp := (aStream upTo: $/) withBlanksTrimmed.		nextComp isEmpty ifFalse: [			comps add: nextComp ] ].		^self withComponents: comps! !!UPackageCategory class methodsFor: 'instance creation' stamp: 'ls 11/26/2006 12:21' prior: 33878984!root	^self withComponents: #()! !!UPackageCategory class methodsFor: 'instance creation' stamp: 'ls 11/26/2006 11:05' prior: 33879105!withComponents: anArrayOfStrings	^self basicNew initialize: (Array withAll: anArrayOfStrings)! !!UPackageCategory methodsFor: 'comparing' stamp: 'ls 12/31/2006 16:10' prior: 33879275!= aCategory	^aCategory isPackageCategory and: [		components = aCategory components ]! !!UPackageCategory methodsFor: 'attributes' stamp: 'ls 11/26/2006 11:05' prior: 33879438!components	^components! !!UPackageCategory methodsFor: 'comparing' stamp: 'ls 11/26/2006 11:06' prior: 33879537!hash	^components hash! !!UPackageCategory methodsFor: 'initialize-release' stamp: 'ls 11/26/2006 10:59' prior: 33879644!initialize	components := #()! !!UPackageCategory methodsFor: 'initialize-release' stamp: 'ls 11/26/2006 10:59' prior: 33879758!initialize: anArrayOfStrings	components := anArrayOfStrings! !!UPackageCategory methodsFor: 'testing' stamp: 'ls 12/31/2006 16:10' prior: 33879892!isPackageCategory	^true! !!UPackageCategory methodsFor: 'subcategories' stamp: 'ls 11/26/2006 12:20' prior: 33879996!isSubcategoryOf: prefix	components isEmpty ifTrue: [ ^false ].	^components allButLast = prefix components! !!UPackageCategory methodsFor: 'comparing' stamp: 'ls 11/26/2006 12:33' prior: 33880179!isUPackageCategory	^true! !!UPackageCategory methodsFor: 'printing' stamp: 'ls 11/26/2006 11:04' prior: 33880279!printOn: aStream	components do: [ :comp |		aStream nextPutAll: comp ]	separatedBy: [ aStream nextPut: $/ ]! !Object subclass: #UPackageSerializer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Serialization'!!UPackageSerializer commentStamp: 'ls 2/13/2005 12:49' prior: 33810645!A class for loading and saving lists of packages!Object subclass: #UPolicy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Policy'!!UPolicy commentStamp: '<historical>' prior: 33810743!A policy for manipulations on a universe.  All of the methods return 'true' on success or on allowing the requested operation, or 'false' on an error or if the operation is not allowed.  By default everything is disallowed.Note that since policy is completely implemented on the server, there is no requirement that a particular UUniverse has a policy describable with this class or a subclass.  A particular server can always modify UUniverseServer to implement an arbitrary policy.!UPolicy subclass: #UPStable	instanceVariableNames: 'masterUser masterPassword'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Policy'!!UPStable commentStamp: '<historical>' prior: 33811279!A policy somewhat suitable for stable versions.  All updates must come through a single master userid and password.!!UPStable methodsFor: 'policies' stamp: 'ls 7/29/2004 17:59' prior: 33811458!addUser: user withPassword: password andEmail: email	^UPolicyResponse denied! !!UPStable methodsFor: 'policies' stamp: 'ls 7/29/2004 17:59' prior: 33811601!changeUser: user withPassword: password toHavePassword: newPassword andNewEmail: newEmail	"the changes must be made on the server, not over the standard protocol"	^UPolicy denied! !!UPStable methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 22:08' prior: 33811857!masterPassword: password	masterPassword _ password! !!UPStable methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 22:08' prior: 33811984!masterUser: userName	masterUser _ userName! !!UPStable methodsFor: 'policies' stamp: 'ls 7/29/2004 18:00' prior: 33812093!package: package mayBeAddedBy: user withPassword: password	^(user = masterUser and: [ password = masterPassword ])		ifTrue: [ UPolicyResponse allowed ]		ifFalse: [ UPolicyResponse denied ]! !!UPStable methodsFor: 'policies' stamp: 'ls 7/29/2004 18:00' prior: 33812350!packageNamed: packageName  withVersion: version  mayBeRemovedBy: user  withPassword: password	(user = masterUser and: [ password = masterPassword ])		ifTrue: [ ^UPolicyResponse allowed ]		ifFalse: [ ^UPolicyResponse denied ]! !UPolicy subclass: #UPWild	instanceVariableNames: 'accounts'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Policy'!!UPWild commentStamp: '<historical>' prior: 33812628!This is the wild-n-wooly policy.  Anyone may create a new account, and the first person to try to add or remove a package with a given name comes to exclusively own that package name.  Only the owner of a package name may make changes to packages with that name.!!UPWild class methodsFor: 'reasonable names' stamp: 'ls 7/29/2004 16:51' prior: 33812966!isReasonablePackageName: aString	^aString allSatisfy: [ :c | c isAlphaNumeric or: [ ' -.' includes: c ]]! !!UPWild class methodsFor: 'reasonable names' stamp: 'ls 2/15/2005 23:45' prior: 33813149!isReasonableUsername: aString	^aString isEmpty not and: [ aString allSatisfy: [ :c | c isAlphaNumeric ] ]! !!UPWild methodsFor: 'policies' stamp: 'ls 7/29/2004 16:49' prior: 33813319!addUser: username withPassword: password  andEmail: email	| newAccount |	(accounts anySatisfy: [ :acc | acc username = username]) ifTrue: [		"already an account here"		^UPolicyResponse denied: 'account already exists' ].		(self class isReasonableUsername: username) ifFalse: [		^UPolicyResponse denied: 'invalid account name' ].		newAccount _ UAccount new.	newAccount username: username.	newAccount password: password.	newAccount email: email.		accounts add: newAccount.	^UPolicyResponse allowed! !!UPWild methodsFor: 'policies' stamp: 'ls 2/13/2005 16:38' prior: 33813893!changeUser: username withPassword: password toHavePassword: newPassword andNewEmail: newEmail	| account |	account _ self findAccount: username withPassword: password.	account ifNil: [ ^UPolicyResponse denied: 'username not present or password does not match' ].		newPassword isEmpty ifFalse: [account password: newPassword ].	newEmail isEmpty ifFalse: [account email: newEmail ].	^UPolicyResponse allowed! !!UPWild methodsFor: 'policies' stamp: 'ls 7/28/2004 18:14' prior: 33814368!findAccount: username withPassword: password	| account |	account _ accounts detect: [ :acc | acc username = username] ifNone: [		"no such account"		^nil ].		account password = password ifFalse:[		"wrong password"		^nil ].		^account! !!UPWild methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 21:35' prior: 33814683!initialize	accounts _ OrderedCollection new! !!UPWild methodsFor: 'policies' stamp: 'ls 7/28/2004 21:34' prior: 33814791!package: aPackage  mayBeAddedBy: username  withPassword: password	^self tryToGivePackageName: aPackage name toUsername: username withPassword: password! !!UPWild methodsFor: 'policies' stamp: 'ls 7/28/2004 18:15' prior: 33815007!packageNamed: packageName withVersion: version mayBeRemovedBy: username withPassword: password	^self tryToGivePackageName: packageName toUsername: username withPassword: password! !!UPWild methodsFor: 'policies' stamp: 'ls 7/29/2004 16:51' prior: 33815250!tryToGivePackageName: packageName toUsername: username  withPassword: password	| account |	(self class isReasonablePackageName: packageName) ifFalse: [		^UPolicyResponse denied: 'invalid package name' ].		account _ self findAccount: username withPassword: password.	account ifNil: [ ^UPolicyResponse denied: 'incorrect password or no such user' ].		(account ownsPackageName: packageName) ifTrue: [		^UPolicyResponse allowed ].		(accounts anySatisfy: [ :acc | acc ownsPackageName: packageName ]) ifTrue: [		^UPolicyResponse denied: 'package is owned by another' ].		account addPackageName: packageName.	^UPolicyResponse allowed! !UPolicy subclass: #UPermissivePolicy	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Policy'!!UPermissivePolicy commentStamp: '<historical>' prior: 33815953!A policy that allows anything.!!UPermissivePolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:48' prior: 33816057!addUser: user  withPassword: password  andEmail: email	^UPolicyResponse allowed! !!UPermissivePolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:48' prior: 33816212!changeUser: user withPassword: password toHavePassword: newPassword andNewEmail: newEmail	^UPolicyResponse allowed! !!UPermissivePolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:48' prior: 33816402!package: aPackage  mayBeAddedBy: user  withPassword: password	^UPolicyResponse allowed! !!UPermissivePolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:48' prior: 33816564!packageNamed: packageName  withVersion: version  mayBeRemovedBy: user  withPassword: password	^UPolicyResponse allowed! !!UPolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:47' prior: 33816748!addUser: user  withPassword: password  andEmail: email	^UPolicyResponse denied! !!UPolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:47' prior: 33816892!changeUser: user withPassword: password toHavePassword: newPassword andNewEmail: newEmail	^UPolicyResponse denied! !!UPolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:47' prior: 33817071!package: aPackage  mayBeAddedBy: user  withPassword: password	^UPolicyResponse denied! !!UPolicy methodsFor: 'policies' stamp: 'ls 7/29/2004 16:47' prior: 33817222!packageNamed: packageName  withVersion: version  mayBeRemovedBy: user  withPassword: password	^UPolicyResponse denied! !Object subclass: #UPolicyResponse	instanceVariableNames: 'allowed reason'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Policy'!!UPolicyResponse commentStamp: '<historical>' prior: 33817400!A response to a policy query.!!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 16:47' prior: 33817515!allowed	^self allowed: nil! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/30/2004 10:34' prior: 33817630!allowed: reason	^self allowed: true  reason: reason! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 16:46' prior: 33817770!allowed: aBoolean  reason: aReason	^self basicNew		allowed: aBoolean;		reason: (aReason ifNil: ['no reason given']);		yourself! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 16:46' prior: 33817988!denied	^self denied: nil! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 17:58' prior: 33818101!denied: reason	^self allowed: false  reason: reason! !!UPolicyResponse class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 16:47' prior: 33818241!new	self shouldNotImplement ! !!UPolicyResponse methodsFor: 'accessing' stamp: 'ls 7/29/2004 17:56' prior: 33818344!allowed	^allowed! !!UPolicyResponse methodsFor: 'accessing' stamp: 'ls 7/29/2004 17:56' prior: 33818435!allowed: anObject	allowed _ anObject! !!UPolicyResponse methodsFor: 'accessing' stamp: 'ls 7/29/2004 17:58' prior: 33818546!reason	^reason! !!UPolicyResponse methodsFor: 'accessing' stamp: 'ls 7/29/2004 17:56' prior: 33818635!reason: anObject	reason _ anObject! !Object subclass: #UUniverseClient	instanceVariableNames: 'universe inMessages outMessages socket stringSocket lastConnectionStart'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Client'!!UUniverseClient commentStamp: 'ls 7/30/2004 14:58' prior: 33818736!A client for talking to a universe server.The universe must be a UStandardUniverse.  The client will track update the universe automatically as messages come in.!!UUniverseClient class methodsFor: 'instance creation' stamp: 'ls 7/30/2004 15:06' prior: 33818986!forUniverse: aStandardUniverse	^self basicNew		initialize: aStandardUniverse;		yourself! !!UUniverseClient class methodsFor: 'class initialization' stamp: 'ls 2/13/2005 15:45' prior: 33819167!initialize	Preferences removePreference: #universesUsesHTTP ! !!UUniverseClient class methodsFor: 'instance creation' stamp: 'ls 7/30/2004 15:06' prior: 33819317!new	^self forUniverse: UUniverse systemUniverse! !!UUniverseClient methodsFor: 'public' stamp: 'ls 7/30/2004 15:10' prior: 33819436!disconnect	"explicitly close the connection"	socket ifNotNil: [ socket destroy.  socket _ nil ].	stringSocket ifNotNil: [ stringSocket destroy.  stringSocket _ nil ].! !!UUniverseClient methodsFor: 'initialization' stamp: 'ls 8/5/2004 17:16' prior: 33819683!initialize: aUniverse	universe _ aUniverse.		inMessages _ OrderedCollection new.	outMessages _ OrderedCollection new.		lastConnectionStart _ DateAndTime epoch.! !!UUniverseClient methodsFor: 'networking' stamp: 'ls 8/4/2004 15:46' prior: 33819922!newInMessage: aMessage	aMessage applyToClient: self.	inMessages add: aMessage.	! !!UUniverseClient methodsFor: 'package list' stamp: 'ls 7/30/2004 14:59' prior: 33820081!newPackageList: newPackages	universe packages: newPackages.	! !!UUniverseClient methodsFor: 'package list' stamp: 'ls 7/30/2004 15:00' prior: 33820220!packageAdded: newPackage	universe addPackage: newPackage! !!UUniverseClient methodsFor: 'networking' stamp: 'ls 2/15/2005 21:44' prior: 33820352!processIO	| rawMsg |	(stringSocket notNil and: [ stringSocket isConnected not ]) ifTrue: [		"connection has died"		stringSocket destroy.		stringSocket _ nil ].		(outMessages isEmpty not and: [ socket isNil and: [ stringSocket isNil ] ]) ifTrue: [		"there are outgoing messages queued but there is no stringSocket"		(DateAndTime now - lastConnectionStart) > (Duration minutes: 1) ifTrue: [			self startConnecting ] ].		socket ifNotNil: [		"a connection is in progress"				socket isConnected ifTrue: [			"connection completed"			stringSocket _ StringSocket on: socket.			universe shortName ifNotNil: [				outMessages addFirst: (UMProtocolVersion version: 1).				outMessages addFirst: (UMSelectServer shortName: universe shortName) ].			socket _ nil. ]		ifFalse: [			socket isWaitingForConnection ifFalse: [				"the connection failed"				inMessages add: (UMConnectionFailed description: 'connection failed').				^self disconnect ] ] ].		stringSocket ifNil: [ ^self ].			[ outMessages isEmpty ] whileFalse: [		stringSocket nextPut: outMessages removeFirst asStringArray ].		stringSocket processIO.		[	rawMsg _ stringSocket nextOrNil.		rawMsg isNil not	] whileTrue: [ 		self newInMessage: (UMessage fromStringArray: rawMsg) ]! !!UUniverseClient methodsFor: 'public' stamp: 'ls 7/30/2004 15:33' prior: 33821683!receivedMessagesDo: aBlock	"check for new messages, and then evaluate aBlock for each message that is currently available"	self processIO.	[ inMessages isEmpty ] whileFalse: [		aBlock value: inMessages removeFirst ]! !!UUniverseClient methodsFor: 'package list' stamp: 'ls 7/30/2004 15:02' prior: 33821979!removedPackageNamed: packageName  withVersion: version	universe removePackageNamed: packageName  withVersion: version! !!UUniverseClient methodsFor: 'public' stamp: 'ls 2/13/2005 15:18' prior: 33822168!sendMessage: aMessage	"send the specified message to the server"	outMessages add: aMessage! !!UUniverseClient methodsFor: 'networking' stamp: 'ls 7/30/2004 15:31' prior: 33822335!startConnecting	"start a new connection to the server"	self disconnect.		lastConnectionStart _ DateAndTime now.		socket _ Socket newTCP.	socket connectTo: (NetNameResolver addressForName: universe serverName) port: universe serverPort.! !!UUniverseClient methodsFor: 'networking' stamp: 'ls 1/13/2007 14:47' prior: 33892650!waitForMessage	"return the next message from the server, waiting if necessary.  Many clients will find this method less convenient than polling on the non-blocking receivedMessagesDo:."	[		self receivedMessagesDo: [ :m | ^m ].		(Delay forMilliseconds: 100) wait.	] repeat.! !Object subclass: #UUniverseEditor	instanceVariableNames: 'universe client username password email usernameField passwordField fields packageEditors accountEditor selectedPackageIndex'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Editor'!!UUniverseEditor commentStamp: '<historical>' prior: 33823169!A tool for editing a remote universe.!!UUniverseEditor class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 10:23' prior: 33823293!forUniverse: aStandardUniverse	^self basicNew		initialize: aStandardUniverse;		yourself! !!UUniverseEditor class methodsFor: 'class initialization' stamp: 'ls 11/26/2006 09:26' prior: 33890534!initialize	TheWorldMenu registerOpenCommand: {'Package Universe Editor'. {self. #open}}.	Preferences setWindowColorFor: self name to: (Color r: 0.194 g: 0.645 b: 1.0).! !!UUniverseEditor class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 18:13' prior: 33823723!new	| choice choices |	choices := UUniverse systemUniverse standardUniverses asArray.	choices isEmpty ifTrue: [ ^self error: 'no standard universes installed' ].	choices size = 1 ifTrue: [		choice _ choices anyOne ]	ifFalse: [		| menu |		menu _			SelectionMenu				labels: (choices collect: [ :u | u description ])				selections: choices.		choice _ menu startUpWithCaption: 'edit which universe?'.		choice ifNil: [ ^self ] ].		^self forUniverse: choice! !!UUniverseEditor class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 18:13' prior: 33824277!open	^self new open! !!UUniverseEditor class methodsFor: 'class initialization' stamp: 'ls 11/26/2006 09:25' prior: 33890811!unload	TheWorldMenu unregisterOpenCommand: 'Package Universe Editor'! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:34' prior: 33824528!acceptFields	fields do: [ :f | f accept ]! !!UUniverseEditor methodsFor: 'account' stamp: 'ls 7/28/2004 18:00' prior: 33824642!accountUpdatedWithUsername: newUsername  password:  newPassword  email: newEmail	self acceptFields.	username _ newUsername.	password _ newPassword.	email _ newEmail.		self changed: #username.	self changed: #password.	self changed: #email.		self closeAccountEditor! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:25' prior: 33824992!anyPackageSelected	^selectedPackageIndex > 0! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 17:58' prior: 33825116!closeAccountEditor	accountEditor ifNil: [ ^self ].	accountEditor window delete.	accountEditor _ nil.! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 7/28/2004 17:12' prior: 33825298!closeEditorForPackage: package	| matchingEditors |	matchingEditors _ packageEditors select: [ :p | p package = package ].	matchingEditors do: [ :editor |		editor window delete.		packageEditors remove: editor ].! !!UUniverseEditor methodsFor: 'account' stamp: 'ls 2/13/2005 16:31' prior: 33825585!createAccount	self acceptFields.	email _ FillInTheBlankMorph request: 'your email address?'.	email = '' ifTrue: [ ^self ].	self sendMessage: (UMAddAccount username: username password: password email: email).	! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 11/16/2006 16:42' prior: 33890961!createNewPackage	| package |	package := UPackage new.	Utilities authorInitialsPerSe ifNotNil: [		package maintainer: Utilities authorInitialsPerSe	].	^package! !!UUniverseEditor methodsFor: 'account' stamp: 'ls 2/13/2005 16:52' prior: 33825872!editAccount	| editor |	self acceptFields.	self closeAccountEditor.		editor _ UAccountEditor		username: username		password: password		email:  ''		whenDone: [ :oldPassword :newPassword :newEmail |			password _ oldPassword.			self sendMessage: (UMEditAccount username: username password: password newPassword: newPassword newEmail: newEmail) ].			editor openInMorphic.		accountEditor _ editor.! !!UUniverseEditor methodsFor: 'initialization' stamp: 'ls 2/13/2005 17:16' prior: 33826356!initialize: universe0	universe _ universe0.	universe addDependent: self.	client _ UUniverseClient forUniverse: universe.	username _ Utilities authorInitialsPerSe.	password _ ''.		packageEditors _ Set new.	selectedPackageIndex _ 0.! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 16:02' prior: 33826676!makeButtonWithAction: selector andGetState: getStateSelector andLabel: aString	^(PluggableButtonMorph on: self getState: getStateSelector action: selector)		label: aString;		useRoundedCorners;		vResizing: #spaceFill;		hResizing: #spaceFill;		onColor: self defaultBackgroundColor offColor: self defaultBackgroundColor muchLighter;		yourself! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 16:02' prior: 33827101!makeButtonWithAction: selector  andLabel: aString	^self makeButtonWithAction: selector andGetState: #returnTrue andLabel: aString! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/15/2005 22:02' prior: 33827310!morphicView	| win universeDescription buttonList usernameRow passwordRow button  usernamePasswordArea packageList |	win _ SystemWindow labelled: 'Universe Editor'.	win model: self.		universeDescription := PluggableTextMorph on: self text: #universeDescription accept: nil.	universeDescription hideScrollBarsIndefinitely.	win addMorph: universeDescription frame: (0@0 extent: 1@0.1).		buttonList _ AlignmentMorph newColumn.	buttonList cellInset: 0@3.	win addMorph: buttonList frame: (0@0.5 extent: 0.5@0.5).			usernamePasswordArea _ AlignmentMorph newColumn.	win addMorph: usernamePasswordArea frame: (0@0.1 extent: 0.5@0.4).	usernameRow _ UInterfaceUtilities makeFieldRowNamed: 'username' getSelector: #username setSelector: #username: for: self.	usernamePasswordArea addMorphBack: usernameRow.		passwordRow _ UInterfaceUtilities makeFieldRowNamed: 'password:' getSelector: #password setSelector: #password: isPassword: true for: self.	usernamePasswordArea addMorphBack: passwordRow.		button _ self makeButtonWithAction: #createAccount andLabel: 'createAccount'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #editAccount andLabel: 'edit account'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #newPackage andLabel: 'new package'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #newPackageVersion andGetState: #anyPackageSelected andLabel: 'new package version'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #removeVersion andGetState: #anyPackageSelected andLabel: 'remove package version'.	buttonList addMorphBack: button.	button _ self makeButtonWithAction: #requestPackageList andLabel: 'update package list'.	buttonList addMorphBack: button.	packageList _ PluggableListMorph on: self list: #packageDescriptions  selected: #selectedPackageIndex changeSelected: #selectedPackageIndex: menu: nil.	win addMorph: packageList frame: ((0.5@0.1) extent: (0.5@0.9)).		^win! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 11/16/2006 16:42' prior: 33891222!newPackage	| editor |	self acceptFields.	editor _ UPackageEditor package: self createNewPackage whenComplete: [ :p |		self acceptFields.		self sendMessage: (UMAddPackage username: username password: password package: p) ].	editor openInMorphic.	packageEditors add: editor.! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 2/15/2005 22:06' prior: 33829741!newPackageVersion	| package editor newPackage |	self anyPackageSelected ifFalse: [ ^self ].	self acceptFields.	package _ self selectedPackage.		newPackage _ package deepCopy.	newPackage version: (UVersion readFromString: (newPackage version asString, 'new')).	editor _ UPackageEditor package: newPackage whenComplete: [ :p |		self acceptFields.		self sendMessage: (UMAddPackage username: username password: password package: p) ].	editor openInMorphic.	packageEditors add: editor.! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 17:34' prior: 33830315!noteField: field 	"note that the receiver has the specified text field"	fields ifNil: [fields := OrderedCollection new].	fields add: field! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 7/29/2004 16:27' prior: 33830535!open	self morphicView openInWorld.	"self requestPackageList."! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:26' prior: 33830675!packageDescriptions	^self sortedPackages collect: [ :p |				p printString. ]! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 12/31/2006 16:13' prior: 33891597!packagesChanged	self selectedPackageIndex: 0.		self changed: #packageDescriptions.	self changed: #rootCategoriesAndPackages.! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/28/2004 15:54' prior: 33830992!password	^password! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/28/2004 16:18' prior: 33831086!password: aString	password _ aString asString.	^true! !!UUniverseEditor methodsFor: 'networking' stamp: 'ls 2/13/2005 17:16' prior: 33831215!processNetworking	client receivedMessagesDo: [ :message |		message applyToEditor: self ].! !!UUniverseEditor methodsFor: 'package editing' stamp: 'ls 2/13/2005 17:20' prior: 33831387!removeVersion	| package |	self anyPackageSelected ifFalse: [ ^self ].	self acceptFields.	package _ self selectedPackage.	(self confirm: ('Delete ', 	package printString, '?')) ifFalse: [		^self ].	self sendMessage: (UMRemovePackage username: username password: password packageName: package name packageVersion: package version).! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 7/29/2004 16:23' prior: 33831804!requestPackageList	self sendMessage: (UMRequestPackages new).	! !!UUniverseEditor methodsFor: 'user interface' stamp: 'ls 2/13/2005 16:02' prior: 33831947!returnTrue	^true! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27' prior: 33832041!selectedPackage	^self sortedPackages at: self selectedPackageIndex! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27' prior: 33832185!selectedPackageIndex	^selectedPackageIndex! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27' prior: 33832305!selectedPackageIndex: anInteger	selectedPackageIndex _ anInteger.	self changed: #selectedPackageIndex.! !!UUniverseEditor methodsFor: 'networking' stamp: 'ls 7/30/2004 15:40' prior: 33832485!sendMessage: aMessage	client sendMessage: aMessage.	! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27' prior: 33832616!sortedPackages	^universe packages asSortedCollection: [ :p1 :p2 |		p1 name < p2 name or: [			p1 name = p2 name and: [ p1 version < p2 version ] ] ].	! !!UUniverseEditor methodsFor: 'stepping' stamp: 'ls 7/28/2004 17:01' prior: 33832842!step	self processNetworking! !!UUniverseEditor methodsFor: 'stepping' stamp: 'ls 7/28/2004 17:01' prior: 33832943!stepTimeIn: window	^10! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/29/2004 16:21' prior: 33833041!universeDescription 	^universe description! !!UUniverseEditor methodsFor: 'package list' stamp: 'ls 2/13/2005 16:27' prior: 33833161!update: aSymbol	aSymbol = #packages ifTrue: [ self packagesChanged ]! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/28/2004 15:53' prior: 33833305!username	^username! !!UUniverseEditor methodsFor: 'attributes' stamp: 'ls 7/28/2004 16:13' prior: 33833399!username: aString	username _ aString asString.	^true! !!UUniverseEditor methodsFor: 'stepping' stamp: 'ls 7/28/2004 17:01' prior: 33833526!wantsSteps	^true! !Object subclass: #UUniverseMultiServer	instanceVariableNames: 'servers port connectionQueue connections connectionVersions'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Server'!!UUniverseMultiServer commentStamp: 'ls 2/13/2005 14:51' prior: 33833614!A multi-server server.  This listens on one port, and dispatches to whichever universe was requested.An active server needs someone to call #step periodically on it, in order for it to process networking, save checkpoints, etc.!!UUniverseMultiServer class methodsFor: 'defaults' stamp: 'ls 2/13/2005 14:32' prior: 33833925!defaultPort	^3702! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/15/2005 22:00' prior: 33834023!acceptConnection: stringSocket	stringSocket nextPut: (UMProtocolVersion version: 1) asStringArray.	connections add: stringSocket! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:29' prior: 33834233!acceptConnectionOn: socket	self acceptConnection: (StringSocket on: socket).	! !!UUniverseMultiServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 14:33' prior: 33834400!addServer: server	servers add: server! !!UUniverseMultiServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 14:49' prior: 33834526!addServers: newServers	newServers do: [ :s | self addServer: s ]! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:29' prior: 33834671!checkForNewConnections	connectionQueue ifNil: [ ^self ].	[ connections size < 100 ] whileTrue: [		| newSocket |		newSocket _ connectionQueue getConnectionOrNil.		newSocket ifNil: [ ^self ].		connections add: (StringSocket on: newSocket) ].	! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:30' prior: 33834998!destroyConnection: aConnection	aConnection destroy.	connections remove: aConnection ifAbsent: [].	! !!UUniverseMultiServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 14:33' prior: 33835187!initialize	servers _ Set new.	port _ UUniverseMultiServer defaultPort.	connections _ Set new.! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:32' prior: 33835364!processConnection: aConnection	| message |	aConnection isConnected ifFalse: [ ^self destroyConnection: aConnection ].		"process all incoming messages.  Note that some messages move the connection to one of the subsidiary servers, so be careful not to process messages after that happens"	aConnection processIO.	[ 	(connections includes: aConnection) and: [			message _ aConnection nextOrNil.	 	 	message notNil ]	] whileTrue: [	  	self processRawMessage: message fromConnection: aConnection ].	(connections includes: aConnection) ifFalse: [ ^self ].	aConnection isConnected		ifTrue: [ aConnection processIO.  "start sending out the response" ]		ifFalse: [ self destroyConnection: aConnection ]! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:30' prior: 33836154!processConnections	connections copy do: [ :c |		self processConnection: c ]! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 14:51' prior: 33836311!processNetworking	self checkForNewConnections.	self processConnections.! !!UUniverseMultiServer methodsFor: 'messages' stamp: 'ls 2/13/2005 14:34' prior: 33836463!processRawMessage: aStringArray  fromConnection: connection	| message |	message _ UMessage fromStringArray: aStringArray.	message applyToMultiServer: self forConnection: connection.! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 16:08' prior: 33836728!startListening	self stopListening.	connectionQueue _ ConnectionQueue portNumber: port queueLength: 5.	! !!UUniverseMultiServer methodsFor: 'stepping' stamp: 'ls 2/13/2005 14:50' prior: 33836911!step	self processNetworking.	servers do: [ :server | server step ].! !!UUniverseMultiServer methodsFor: 'networking' stamp: 'ls 2/13/2005 16:08' prior: 33837061!stopListening		connectionQueue ifNotNil: [		connectionQueue destroy.		connectionQueue _ nil ].	! !!UUniverseMultiServer methodsFor: 'messages' stamp: 'ls 2/13/2005 16:18' prior: 33837238!switchConnection: aConnection  toServerNamed: serverName	| server |	server _ servers detect: [ :s | s universe shortName = serverName ] ifNone: [		aConnection nextPut: (UMError description: 'no such server here') asStringArray.		^self ].	server acceptConnection: aConnection.	connections remove: aConnection.! !Object subclass: #UUniverseServer	instanceVariableNames: 'universe policy saveDirectory packageListFilename lastSaveTime connectionQueue connections'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Server'!!UUniverseServer commentStamp: 'ls 2/13/2005 13:45' prior: 33837620!A server holding the authoratative information about a universe.  Clients may make requests to view and update the universe.The server does not manage its own thread; it requires that processNetworking is called periodically.!!UUniverseServer class methodsFor: 'instance creation' stamp: 'ls 7/29/2004 09:29' prior: 33837934!forSaveDirectory: aDirectory	| universe |	universe _ self forUniverse: UUniverse new.	universe saveDirectory: aDirectory.	universe loadFromCheckpoint.	^universe! !!UUniverseServer class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 10:31' prior: 33838187!forUniverse: universe	^self basicNew initializeForUniverse: universe.	! !!UUniverseServer class methodsFor: 'instance creation' stamp: 'ls 7/28/2004 10:31' prior: 33838347!new	^self shouldNotImplement ! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 2/15/2005 22:00' prior: 33838452!acceptConnection: stringSocket	stringSocket nextPut: (UMProtocolVersion version: 1) asStringArray.	connections add: stringSocket! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 11:02' prior: 33838657!acceptConnectionOn: socket	self acceptConnection: (StringSocket on: socket).	! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 13:15' prior: 33838811!checkForNewConnections	connectionQueue ifNil: [ ^self ].	[ connections size < 10 ] whileTrue: [		| newSocket |		newSocket _ connectionQueue getConnectionOrNil.		newSocket ifNil: [ ^self ].		connections add: (StringSocket on: newSocket) ].	! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 8/3/2004 18:10' prior: 33839131!comancheServiceName	^'universe server on ', universe serverPort printString! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:53' prior: 33839279!connection: connection requestedAccountChangeForUsername: username  password: password  newPassword: newPassword newEmail: newEmail	| response |	response _ policy changeUser: username withPassword: password toHavePassword: newPassword andNewEmail: newEmail.	response allowed ifFalse: [		^self			sendError: 'changing account for ', username, ' failed (', response reason, ')'			onConnection: connection].			self sendMessage: (UMEditedAccount username: username newPassword: newPassword newEmail: newEmail) onConnection: connection! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:53' prior: 33839888!connection: connection requestedAccountWithUsername: username  password: password  email: email 	| response |	response _ policy addUser: username withPassword: password andEmail: email.	response allowed ifFalse: [		self			sendError: 'adding account for ', username, ' failed (', response reason, ')'			onConnection: connection].! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:54' prior: 33840294!connection: connection requestedForUsername: username  andPassword: password  toAddPackage: package	| response |	response _ policy package: package mayBeAddedBy: username withPassword: password.		response allowed		ifFalse: [			^self 				sendError: 'adding package ', package name, ' failed (', response reason, ')'				onConnection: connection].			universe addPackage: package.	self sendMessage: (UMPackageAdded package: package) onConnection: connection.! !!UUniverseServer methodsFor: 'editing' stamp: 'ls 7/29/2004 16:54' prior: 33840833!connection: connection requestedForUsername: username  andPassword: password  toRemovePackageNamed: packageName withVersion: version	| packagesToRemove response |	response _ policy packageNamed: packageName withVersion: version mayBeRemovedBy: username withPassword: password.		response allowed ifFalse: [		^self 			sendError: 'removing package ', packageName, ' failed (', response reason, ')' 			onConnection: connection].			packagesToRemove := universe packages select: [ :p | p name = packageName and: [ p version = version ] ].	packagesToRemove do: [ :p |		universe removePackage: p ].		self sendMessage: (UMPackageRemoved packageName: packageName version: version) onConnection: connection.! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 10:47' prior: 33841617!destroyConnection: aConnection	aConnection destroy.	connections remove: aConnection ifAbsent: [].! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 15:20' prior: 33841799!initializeForUniverse: aUniverse	universe _ aUniverse.	policy _ UPolicy new.	connectionQueue _ nil.	connections _ Set new.! !!UUniverseServer methodsFor: 'persistence' stamp: 'ls 7/29/2004 09:25' prior: 33842002!loadFromCheckpoint	"reload from a checkpoint"	| file savedObject |	(saveDirectory isAFileNamed: 'checkpoint')		ifTrue: [ file _ saveDirectory readOnlyFileNamed: 'checkpoint' ]		ifFalse: [ file _ saveDirectory readOnlyFileNamed: 'checkpoint.die' ].	savedObject := file fileInObjectAndCode.	file close.		universe := savedObject first.	policy := savedObject second.	! !!UUniverseServer methodsFor: 'stepping' stamp: 'ls 8/2/2004 17:15' prior: 33842448!openStepperMorph	(UServerStepperMorph new server: self; yourself) openInWorld! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 2/13/2005 13:44' prior: 33842609!packageListFilename: filename	packageListFilename _ filename! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 7/28/2004 14:32' prior: 33842753!policy: aPolicy	policy _ aPolicy! !!UUniverseServer methodsFor: 'persistence' stamp: 'ls 2/13/2005 15:23' prior: 33842862!possiblySaveCheckpointAndPackageList	saveDirectory ifNil: [^self].	(lastSaveTime isNil 		or: [DateAndTime now - lastSaveTime > (Duration minutes: 30)]) 			ifTrue: 				[self saveCheckpoint.				self savePackageList.				lastSaveTime := DateAndTime now]! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 21:28' prior: 33843193!processConnection: aConnection	| message |	aConnection isConnected ifFalse: [ ^self destroyConnection: aConnection ].		aConnection processIO.	[ 	message _ aConnection nextOrNil.	  	message notNil	] whileTrue: [	  	self processRawMessage: message fromConnection: aConnection ].	aConnection isConnected		ifTrue: [ aConnection processIO.  "start sending out the response" ]		ifFalse: [ self destroyConnection: aConnection ]! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 10:43' prior: 33843700!processConnections	connections copy do: [ :c |		self processConnection: c ]! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 2/13/2005 15:19' prior: 33843852!processNetworking	self checkForNewConnections.	self processConnections.	! !!UUniverseServer methodsFor: 'messages' stamp: 'ls 7/28/2004 13:12' prior: 33844000!processRawMessage: aStringArray  fromConnection: connection	| message |	message _ UMessage fromStringArray: aStringArray.	message applyToServer: self forConnection: connection.! !!UUniverseServer methodsFor: 'persistence' stamp: 'ls 2/13/2005 13:43' prior: 33844256!saveCheckpoint	"save a checkpoint"	| tmpFile |	saveDirectory deleteFileNamed: 'checkpoint.tmp'.		tmpFile := saveDirectory newFileNamed: 'checkpoint.tmp'.	(SmartRefStream on: tmpFile) nextPut: {universe.policy}; close.		saveDirectory deleteFileNamed: 'checkpoint.die'.	saveDirectory rename: 'checkpoint.tmp' toBe: 'checkpoint'.		saveDirectory deleteFileNamed: 'checkpoint.die'.	! !!UUniverseServer methodsFor: 'initialize-release' stamp: 'ls 7/29/2004 09:16' prior: 33844727!saveDirectory: aDirectory	saveDirectory _ aDirectory! !!UUniverseServer methodsFor: 'persistence' stamp: 'ls 2/13/2005 13:44' prior: 33844856!savePackageList	packageListFilename ifNotNil: [		UPackage savePackageList: universe packages onFileNamed: packageListFilename ]! !!UUniverseServer methodsFor: 'messages' stamp: 'ls 7/28/2004 14:49' prior: 33845058!sendError: description onConnection: stringSocket	self sendMessage: (UMError description: description) onConnection: stringSocket! !!UUniverseServer methodsFor: 'messages' stamp: 'ls 7/28/2004 11:48' prior: 33845261!sendMessage: aMessage  onConnection: connection	connection nextPut: aMessage asStringArray  ! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 13:21' prior: 33845429!startListening	self stopListening.	connectionQueue _ ConnectionQueue portNumber: universe serverPort queueLength: 5.	! !!UUniverseServer methodsFor: 'stepping' stamp: 'ls 2/13/2005 15:23' prior: 33845622!step	"do any necessary periodic work, including polling the network connections"	self processNetworking.	self possiblySaveCheckpointAndPackageList! !!UUniverseServer methodsFor: 'networking' stamp: 'ls 7/28/2004 10:41' prior: 33845847!stopListening		connectionQueue ifNotNil: [		connectionQueue destroy.		connectionQueue _ nil ].	! !!UUniverseServer methodsFor: 'accessing' stamp: 'ls 7/28/2004 13:08' prior: 33846020!universe	^universe! !Object subclass: #UUtilities	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Model'!!UUtilities commentStamp: 'ls 7/28/2004 10:35' prior: 33846100!Universe miscellania that belong to no particular object.!Magnitude subclass: #UVersion	instanceVariableNames: 'components'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Model'!!UVersion commentStamp: '<historical>' prior: 33847521!A relatively simple hierarchical version number.!!UVersion class methodsFor: 'instance creation' stamp: 'ls 7/27/2004 17:24' prior: 33847648!fromComponents: components	^self basicNew components: components; yourself! !!UVersion class methodsFor: 'instance creation' stamp: 'ls 7/27/2004 17:27' prior: 33847804!readFrom: stream	| components |	components _ OrderedCollection new.	[ stream atEnd ] whileFalse: [		stream peek isDigit ifTrue: [			components add: (Integer readFrom: stream) ]		ifFalse: [			components add: (String streamContents: [ :compStr |				[ stream atEnd not and: [ stream peek isDigit not ] ] whileTrue: [					compStr nextPut: stream next ] ]) ] ].			^self fromComponents: components! !!UVersion methodsFor: 'comparing' stamp: 'ls 7/27/2004 21:15' prior: 33848273!< aVersion	| numToCompare |	numToCompare := components size min: aVersion components size.	(components first: numToCompare) with: (aVersion components first: numToCompare) do: [ :myComp :itsComp |		(myComp uversionLessThan: itsComp) ifTrue: [			^true ].		(itsComp uversionLessThan: myComp) ifTrue: [			^false ] ].		^components size < aVersion components size! !!UVersion methodsFor: 'comparing' stamp: 'ls 7/27/2004 17:31' prior: 33848707!= aVersion	components size = aVersion components size ifFalse:[ ^false ].	components with: aVersion components do: [ :myComp :itsComp |		(myComp uversionEqual: itsComp) ifFalse: [			^false ] ].		^true! !!UVersion methodsFor: 'attributes' stamp: 'ls 7/27/2004 17:33' prior: 33848982!components	^components! !!UVersion methodsFor: 'initialization' stamp: 'ls 7/27/2004 17:27' prior: 33849077!components: aCollection	components _ aCollection! !!UVersion methodsFor: 'comparing' stamp: 'ls 7/28/2004 10:02' prior: 33849193!hash	^components inject: 1 into: [ :tally :new |		(tally bitXor: new hash) hashMultiply ]! !!UVersion methodsFor: 'printing' stamp: 'ls 7/27/2004 17:28' prior: 33849350!printOn: aStream	components do: [ :comp | aStream nextPutAll: comp asString ].! !!StringSocket class methodsFor: '*universes' stamp: 'ls 8/3/2004 18:04' prior: 33846233!decodeStringArray: aString	| idx numStrings |	idx _ 1.	numStrings _ aString getInteger32: idx.	idx _ idx + 4.	numStrings < 0 ifTrue: [ ^self error: 'invalid string socket encoding' ].	numStrings > 10000000 ifTrue: [ self error: 'refusing to decode humongous string socket' ].		^(1 to: numStrings) collect: [ :ignored |		| size str |		size _ aString getInteger32: idx.		idx _ idx + 4.		str _ aString copyFrom: idx to: idx+size-1.		idx _ idx + size.		str ]	! !!StringSocket class methodsFor: '*universes' stamp: 'ls 8/2/2004 16:18' prior: 33846780!encodeStringArray: stringArray	| size outBuf outBufIndex |	size _ self spaceToEncode: stringArray.		outBuf _ String new: size.	outBufIndex _ 1.	outBuf putInteger32: stringArray size at: outBufIndex.	outBufIndex _ outBufIndex + 4.	stringArray do: [ :each |		outBuf putInteger32: each size at: outBufIndex.		outBufIndex _ outBufIndex + 4.		outBuf 			replaceFrom: outBufIndex 			to: outBufIndex + each size - 1 			with: each 			startingAt: 1.		outBufIndex _ outBufIndex + each size.	].		^outBuf! !!StringSocket class methodsFor: '*universes' stamp: 'ls 8/2/2004 16:18' prior: 33847368!spaceToEncode: stringArray	^stringArray inject: 4 into: [ :sum :array |		sum + (array size + 4) ].! !!Integer methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:33' prior: 33741095!uversionEqual: anObject	^anObject isInteger and: [ self = anObject ]! !!Integer methodsFor: '*universes-model' stamp: 'ls 7/27/2004 17:33' prior: 33741237!uversionLessThan: anObject	^anObject isInteger and: [ self < anObject ]! !Flasher subclass: #UServerStepperMorph	instanceVariableNames: 'server timeOfLastFlash'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Server'!!UServerStepperMorph commentStamp: '<historical>' prior: 33849776!A morph that simply steps a UniverseServer continuously.!!UServerStepperMorph methodsFor: 'closing' stamp: 'ls 2/13/2005 15:20' prior: 33849907!delete	super delete.	server stopListening.! !!UServerStepperMorph methodsFor: 'initialization' stamp: 'ls 7/28/2004 13:41' prior: 33850035!initialize	super initialize.	timeOfLastFlash _ DateAndTime now.! !!UServerStepperMorph methodsFor: 'initialization' stamp: 'ls 7/28/2004 13:19' prior: 33850183!server: aServer	server _ aServer! !!UServerStepperMorph methodsFor: 'stepping' stamp: 'ls 7/28/2004 13:42' prior: 33850293!step	server ifNotNil: [ server step ].		(DateAndTime now - timeOfLastFlash ) > (Duration milliSeconds: 3000) ifTrue: [		super step.		timeOfLastFlash _ DateAndTime now. ].! !!UServerStepperMorph methodsFor: 'stepping' stamp: 'ls 7/28/2004 13:19' prior: 33850545!stepTime	^10! !!UServerStepperMorph methodsFor: 'stepping' stamp: 'ls 7/28/2004 13:19' prior: 33850635!wantsSteps	^true! !TestCase subclass: #UBrowserTestCase	instanceVariableNames: 'universe'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Tests'!!UBrowserTestCase methodsFor: 'Running' stamp: 'ls 1/16/2005 14:11' prior: 33850725!setUp	| package |	universe _ UStandardUniverse new.		package _ UPackage new.	package name: 'A'.	package addDependency: 'B'.	universe addPackage: package.		package _ UPackage new.	package name: 'B'.	package addDependency: 'C'.	universe addPackage: package.		package _ UPackage new.	package name: 'C'.	package addDependency: 'D'.	package addDependency: 'E'.	universe addPackage: package.		package _ UPackage new.	package name: 'D'.	universe addPackage: package.		package _ UPackage new.	package name: 'E'.	universe addPackage: package.	package _ UPackage new.	package name: 'Broken'.	package addDependency: 'NonExistent'.	universe addPackage: package.	! !!UBrowserTestCase methodsFor: 'Running' stamp: 'ls 7/29/2004 17:40' prior: 33851481!testBasicDependency	| browser neededPackages |	browser _ UUniverseBrowser new universe: universe; yourself.	neededPackages _ browser allPackagesNeededToInstall: (universe newestPackageNamed: 'A')  orIfImpossible: [ :ign | self error: 'dependency not found' ].		self should: [ neededPackages size = 5 ].		browser _ UUniverseBrowser new universe: universe; yourself.	neededPackages _ browser allPackagesNeededToInstall: (universe newestPackageNamed: 'B')  orIfImpossible: [ :ign | self error: 'dependency not found' ].		self should: [ neededPackages size = 4 ].! !!UBrowserTestCase methodsFor: 'Running' stamp: 'ls 7/29/2004 17:39' prior: 33852123!testBrokenDependency	| browser neededPackages |	browser _ UUniverseBrowser new universe: universe; yourself.	neededPackages _ browser allPackagesNeededToInstall: (universe newestPackageNamed: 'Broken')  orIfImpossible: [ :ign | nil ].	self should: [ neededPackages isNil ].	! !TestCase subclass: #UPackageTestCase	instanceVariableNames: 'p1 p2'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Tests'!!UPackageTestCase methodsFor: 'setup' stamp: 'ls 11/26/2006 11:10' prior: 33865985!setUp	p1 _ UPackage new.	p1 name: 'Scamper'.	p1 category: (UPackageCategory withComponents: #('Networking')).	p1 description: 'A web browser'.	p1 url: 'http://www.squeak.org' asUrl.	p1 homepage: p1 url.	p1 version: (UVersion readFromString: '1.0').	p1 maintainer: 'John Doe'.	p2 _ p1 deepCopy.! !!UPackageTestCase methodsFor: 'comparing' stamp: 'ls 2/13/2005 12:34' prior: 33852787!testCompare	self should: [ p1 = p2 ].	self should: [ p1 hash = p2 hash ].	p2 homepage: 'http://www.squeakland.org' asUrl.	self shouldnt: [ p1 = p2 ].	p2 homepage: p1 homepage.	p1 conflicts: #('Another Web Browser').	self shouldnt: [ p1 = p2 ].	p1 conflicts: p2 conflicts.	self should: [ p1 = p2 ].	self should: [ p1 hash = p2 hash ].	p1 homepage: nil.	p2 homepage: nil.	self should: [ p1 = p2 ].	self should: [ p1 hash = p2 hash ].	p2 maintainer: 'Jane'.	self shouldnt: [ p1 = p2 ].! !!UPackageTestCase methodsFor: 'comparing' stamp: 'ls 2/13/2005 12:59' prior: 33853365!testEncoding	self should: [ p1 = (UPackage decodeFromStringStream: (ReadStream on: p1 stringArrayEncoding)) ].! !!UPackageTestCase methodsFor: 'comparing' stamp: 'ls 11/26/2006 10:50' prior: 33866381!testXML	| xmlString stream readp1 readp2 readPackages readp3 |	p2 version: (UVersion readFromString: '1.2').	p1 description: 'blah blah <>&"'''.	xmlString _ String streamContents: [ :str |		str 			nextPutAll: p1 xmlForExport;			nextPutAll: p2 xmlForExport.					str nextPutAll: '<package><name>IRCe</name><version>10.7.6</version><description>This is a significant rewrite of the built-in Squeak IRC client GUI. A new user interface includes having one console window per connection and then having all console messages, channel messages and private messages contained inside the main console window using tabbed swapped panes.                                         Numerous other changes are also included but are not described here. The change-set contains documentation for all features added or modified.Instructions at http://squeak.preeminent.org/irc-help/irc-help.html</description><url>http://kilana.unibe.ch:8888/IRC/Network-IRC-fc.10.7.6.mcz</url><maintainer></maintainer><provides></provides><depends></depends><conflicts></conflicts></package>' ].	stream _ ReadStream on: xmlString.	readPackages _ UPackage decodePackagesFromXMLStream: stream.	self should: [ readPackages size = 3 ].	readp1 _ readPackages first.	readp2 _ readPackages second.	readp3 _ readPackages third.	self should: [ readp1 = p1 ].	self should: [ readp2 = p2 ].	self should: [ readp3 name = 'IRCe'].	self should: [ readp3 version = (UVersion readFromString: '10.7.6')].	! !TestCase subclass: #UUniverseServerTestCase	instanceVariableNames: 'server'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Tests'!TestCase subclass: #UVersionTestCase	instanceVariableNames: 'typicalVersions'	classVariableNames: ''	poolDictionaries: ''	category: 'Universes-Tests'!!UVersionTestCase methodsFor: 'initialize-release' stamp: 'ls 7/27/2004 21:12' prior: 33854160!setUp	typicalVersions := #(		'1'		'2'		'1.5.7'		'1.5.8'		'1.6.2'		'1.5'		'1.5a'		'1.5b'		'1.6'		'alpha'		'beta'	) collect: [ :str | UVersion readFromString: str ].	! !!UVersionTestCase methodsFor: 'Running' stamp: 'ls 7/27/2004 17:19' prior: 33854411!testCompare	self should: [ (UVersion readFromString: '1') < (UVersion readFromString: '2') ].	self should: [ (UVersion readFromString: '1.5.7') < (UVersion readFromString: '1.5.8') ].	self should: [ (UVersion readFromString: '1.5.7') < (UVersion readFromString: '1.6.2') ].	self should: [ (UVersion readFromString: '1.5') < (UVersion readFromString: '1.5a') ].	self should: [ (UVersion readFromString: '1.5a') < (UVersion readFromString: '1.5b') ].	self should: [ (UVersion readFromString: '1.5b') < (UVersion readFromString: '1.6') ].! !!UVersionTestCase methodsFor: 'Running' stamp: 'ls 7/27/2004 17:24' prior: 33855025!testFullOrder	"check that all versions are in some order"	typicalVersions do: [ :v1 |		typicalVersions do: [ :v2 |			self should: [				(v1 < v2)				or: [ (v2 < v1) 				or: [ v1 = v2 ] ] ] ] ]	! !!UVersionTestCase methodsFor: 'Running' stamp: 'ls 7/28/2004 09:59' prior: 33855302!testHash	typicalVersions do: [ :v |		self should: [ v hash = v copy hash ] ].		self should: [ (UVersion readFromString: '1.5a') hash = (UVersion readFromString: '1.5a') hash ].! !!UVersionTestCase methodsFor: 'Running' stamp: 'ls 7/27/2004 17:23' prior: 33855555!testReversedComparisons	"check that it is never the case that v1<v2 and v2<v1"	typicalVersions do: [ :v1 |		typicalVersions do: [ :v2 |			self should: [ (v1 < v2) not  or:  [  (v2 < v1) not ] ] ] ].	! !UAccountEditor initialize!UPackageEditor initialize!UUniverse initialize!UUniverseBrowser initialize!UInstaller initialize!UUniverseClient initialize!UUniverseEditor initialize!----End fileIn of a stream----!"Universes"!----SNAPSHOT----an Array(2 February 2007 4:23:54 pm) squeak.image priorSource: 339040!----SNAPSHOT----an Array(2 February 2007 9:29:35 pm) squeak.image priorSource: 479354!----SNAPSHOT----an Array(5 February 2007 6:30:55 am) squeak.image priorSource: 479442!----STARTUP----an Array(10 February 2007 3:50:19 pm) as /home/lex/squeak/univ39/squeak.image!----SNAPSHOT----an Array(10 February 2007 5:17:31 pm) squeak.image priorSource: 479530!----QUIT----an Array(11 February 2007 9:56:38 am) squeak.image priorSource: 479714!----STARTUP----an Array(7 July 2009 3:50:39 pm) as D:\Users\Christian\Documents\Studienarbeit\Quellen\ATEO 1.5_SAM 2.0 (final)\Squeak3.9u1.image!'From Squeak3.7alpha of ''11 September 2003'' [latest update: #5423] on 4 March 2004 at 10:07:15 pm'!MorphicModel subclass: #PCArcMorph	instanceVariableNames: 'fromRadians toRadians '	classVariableNames: ''	poolDictionaries: ''	category: 'PieChart'!TestCase subclass: #PCArcMorphTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PieChart-Tests'!!PCArcMorphTest commentStamp: '<historical>' prior: 0!This is the unit test for the class PCArcMorph. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!RectangleMorph subclass: #PCPieChartMorph	instanceVariableNames: 'portions piePortionInfos title '	classVariableNames: ''	poolDictionaries: ''	category: 'PieChart'!TestCase subclass: #PCPieChartMorphTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PieChart-Tests'!!PCPieChartMorphTest commentStamp: '<historical>' prior: 0!This is the unit test for the class PCPieChartMorph. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!Object subclass: #PCPiePortionInfo	instanceVariableNames: 'value reference color '	classVariableNames: ''	poolDictionaries: ''	category: 'PieChart'!TestCase subclass: #PCPiePortionInfoTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PieChart-Tests'!!PCPiePortionInfoTest commentStamp: '<historical>' prior: 0!This is the unit test for the class PCPiePortionInfo. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!PCArcMorph subclass: #PCPiePortionMorph	instanceVariableNames: 'piePortionInfo pie label '	classVariableNames: ''	poolDictionaries: ''	category: 'PieChart'!TestCase subclass: #PCPiePortionMorphTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PieChart-Tests'!!PCPiePortionMorphTest commentStamp: '<historical>' prior: 0!This is the unit test for the class PCPiePortionMorph. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!Object subclass: #PCSemiArc	instanceVariableNames: 'radiansFrom radiansTo center radius vertices '	classVariableNames: ''	poolDictionaries: ''	category: 'PieChart'!TestCase subclass: #PCSemiArcTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'PieChart-Tests'!!PCSemiArcTest commentStamp: '<historical>' prior: 0!This is the unit test for the class PCSemiArc. Unit tests are a good way to exercise the functionality of your system in a repeatable and automatic manner. They are therefore recommended if you plan to release anything. For more information, see: 	- http://www.c2.com/cgi/wiki?UnitTest	- http://minnow.cc.gatech.edu/squeak/1547	- the sunit class category!!PCArcMorph methodsFor: 'accessing' stamp: 'gm 3/2/2004 23:44'!color: aColor 	"sets the receiver's color"	super color: aColor.	self balloonColor: aColor! !!PCArcMorph methodsFor: 'accessing' stamp: 'gm 3/2/2004 23:47'!fromDegrees	"answers the origin of the arc, in degrees"	^self fromRadians radiansToDegrees! !!PCArcMorph methodsFor: 'accessing' stamp: 'gm 3/2/2004 23:46'!fromDegrees: aNumber 	"sets the origin of the arc, in degrees"	self fromRadians: aNumber degreesToRadians! !!PCArcMorph methodsFor: 'accessing' stamp: 'gm 3/2/2004 23:47'!fromRadians	"answers the origin of the arc, in radians"	^fromRadians! !!PCArcMorph methodsFor: 'accessing' stamp: 'gm 3/2/2004 23:46'!fromRadians: aNumber 	"sets the origin of the arc, in radians"	fromRadians := aNumber! !!PCArcMorph methodsFor: 'accessing' stamp: 'gm 3/2/2004 23:49'!radius	"answers the radius"	^(self width min: self height) // 2 - self borderWidth! !!PCArcMorph methodsFor: 'accessing' stamp: 'gm 3/2/2004 23:47'!toDegrees	"answers the end of the arc, in degrees"	^self toRadians radiansToDegrees! !!PCArcMorph methodsFor: 'accessing' stamp: 'gm 3/2/2004 23:46'!toDegrees: aNumber 	"sets the end of the arc, in degrees"	self toRadians: aNumber degreesToRadians! !!PCArcMorph methodsFor: 'accessing' stamp: 'gm 3/2/2004 23:47'!toRadians	"answers the end of the arc, in radians"	^toRadians! !!PCArcMorph methodsFor: 'accessing' stamp: 'gm 3/2/2004 23:47'!toRadians: aNumber 	"sets the end of the arc, in radians"	toRadians := aNumber! !!PCArcMorph methodsFor: 'drawing' stamp: 'gm 3/2/2004 23:45'!drawOn: aCanvas 	"draws the arc"	aCanvas 		drawPolygon: self calculateVertices		color: self color		borderWidth: self borderWidth		borderColor: self borderColor! !!PCArcMorph methodsFor: 'geometry testing' stamp: 'gm 3/2/2004 23:42'!arcContainsPoint: aPoint 	"answers whether the arc covered by the received contains aPoint"	^(PolygonMorph 		vertices: self calculateVertices		color: Color red		borderWidth: 1		borderColor: Color blue) containsPoint: aPoint! !!PCArcMorph methodsFor: 'initialization' stamp: 'gm 3/2/2004 23:45'!defaultDiameter	"answers the default diameter"	^self defaultRadius * 2! !!PCArcMorph methodsFor: 'initialization' stamp: 'gm 3/2/2004 23:45'!defaultRadius	"answers the default radius"	^50! !!PCArcMorph methodsFor: 'initialization' stamp: 'gm 3/2/2004 23:47'!initialize	"initializes this instance"	super initialize.	fromRadians := 0.	toRadians := 2 * Float pi.	self height: self defaultDiameter.	self width: self defaultDiameter.	self color: Color red.	self borderWidth: 0! !!PCArcMorph methodsFor: 'initialization' stamp: 'gm 3/2/2004 23:48'!initializeFromDegrees: fromNumber toDegrees: toNumber 	"initializes this instances using fromNumber as origin and toNumber as end"	self initialize.	self fromDegrees: fromNumber.	self toDegrees: toNumber! !!PCArcMorph methodsFor: 'printing' stamp: 'gm 3/2/2004 23:48'!printOn: aStream 	"Append to the argument, aStream, a sequence of characters that	identifies the receiver."	aStream		nextPutAll: 'from:';		print: fromRadians;		nextPutAll: ' to:';		print: toRadians! !!PCArcMorph methodsFor: 'private' stamp: 'gm 3/2/2004 23:44'!calculateVertices	"calculates the vertices for the arc, using PCSemiArcs for the arc itselfs and then adding the center of the circle to close the shape"	| vertices |	vertices := OrderedCollection new.	fromRadians < Float pi & (toRadians > Float pi) 		ifTrue: 			[vertices := OrderedCollection new.			vertices 				addAll: (PCSemiArc 						radiansFrom: fromRadians						radiansTo: Float pi						center: self center						radius: self radius) vertices.			vertices 				addAll: (PCSemiArc 						radiansFrom: Float pi						radiansTo: toRadians						center: self center						radius: self radius) vertices]		ifFalse: 			[vertices := (PCSemiArc 						radiansFrom: fromRadians						radiansTo: toRadians						center: self center						radius: self radius) vertices].	vertices add: self center x @ self center y.	^vertices! !!PCArcMorph class methodsFor: 'instance creation' stamp: 'gm 7/9/2002 15:39'!fromDegrees: fromNumber toDegrees: toNumber 	^ self new initializeFromDegrees: fromNumber toDegrees: toNumber! !!PCArcMorphTest methodsFor: 'Testing' stamp: 'gm 3/17/2003 23:56'!testArcContainsPoint	| arcMorph |	arcMorph := PCArcMorph fromDegrees: 0 toDegrees: 90.	arcMorph center: 0 @ 0;	width: 100;	height: 100;	borderWidth: 0.	self assert: (arcMorph arcContainsPoint: 0 @ 0).	self assert: (arcMorph arcContainsPoint: 50 @ 0).	self assert: (arcMorph arcContainsPoint: 0 @ -50).	self deny: (arcMorph arcContainsPoint: 50 @ -50).	self assert: (arcMorph arcContainsPoint: 25 @ -25)! !!PCArcMorphTest methodsFor: 'Testing' stamp: 'gm 3/26/2003 21:45'!testCalculateVertices	| arcMorph |	arcMorph _ PCArcMorph fromDegrees: 0 toDegrees: 90.	arcMorph center: 0 @ 0;		 width: 100;		 height: 100;		 borderWidth: 0.	self assert: arcMorph calculateVertices = {50.0 @ 0. 50 @ 0. 49 @ -10. 48 @ -14. 47 @ -17. 46 @ -20. 45 @ -22. 44 @ -24. 43 @ -26. 42 @ -27. 41 @ -29. 40 @ -30. 39 @ -31. 38 @ -32. 37 @ -34. 36 @ -35. 35 @ -36. 34 @ -37. 33 @ -38. 32 @ -38. 31 @ -39. 30 @ -40. 29 @ -41. 28 @ -41. 27 @ -42. 26 @ -43. 25 @ -43. 24 @ -44. 23 @ -44. 22 @ -45. 21 @ -45. 20 @ -46. 19 @ -46. 18 @ -47. 17 @ -47. 16 @ -47. 15 @ -48. 14 @ -48. 13 @ -48. 12 @ -49. 11 @ -49. 10 @ -49. 9 @ -49. 8 @ -49. 7 @ -50. 6 @ -50. 5 @ -50. 4 @ -50. 3 @ -50. 2 @ -50. 1 @ -50. 0 @ -50. 0 @ 0} asOrderedCollection!]style[(21 3 9 4 8 3 10 14 1 12 2 3 8 9 1 3 1 12 3 13 3 18 1 3 4 9 8 22 4 3 1 2 2 3 1 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 2 3 3 2 1 3 3 2 1 3 3 2 1 3 3 2 1 3 3 2 1 3 3 2 1 3 3 2 1 3 3 2 1 3 3 2 1 3 3 6 3 2 1 3 1 21)f1b,f1,f1cblue;i,f1,f1cblue;i,f1,f1cmagenta;,f1,f1c201201125,f1,f1c201201125,f1,f1cblue;i,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1cmagenta;,f1,f1cblue;i,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1,f1c201201125,f1! !!PCArcMorphTest methodsFor: 'Testing' stamp: 'gm 3/26/2003 22:08'!testCalculateVertices2	| arcMorph |	arcMorph _ PCArcMorph fromDegrees: 1 toDegrees: 359.	arcMorph center: 0 @ 0;		 width: 100;		 height: 100;		 borderWidth: 0.	self assert: arcMorph calculateVertices =  {50@-1. 50@0. 49@-10. 48@-14. 47@-17. 46@-20. 45@-22. 44@-24. 43@-26. 42@-27. 41@-29. 40@-30. 39@-31. 38@-32. 37@-34. 36@-35. 35@-36. 34@-37. 33@-38. 32@-38. 31@-39. 30@-40. 29@-41. 28@-41. 27@-42. 26@-43. 25@-43. 24@-44. 23@-44. 22@-45. 21@-45. 20@-46. 19@-46. 18@-47. 17@-47. 16@-47. 15@-48. 14@-48. 13@-48. 12@-49. 11@-49. 10@-49. 9@-49. 8@-49. 7@-50. 6@-50. 5@-50. 4@-50. 3@-50. 2@-50. 1@-50. -1@-50. -2@-50. -3@-50. -4@-50. -5@-50. -6@-50. -7@-50. -8@-49. -9@-49. -10@-49. -11@-49. -12@-49. -13@-48. -14@-48. -15@-48. -16@-47. -17@-47. -18@-47. -19@-46. -20@-46. -21@-45. -22@-45. -23@-44. -24@-44. -25@-43. -26@-43. -27@-42. -28@-41. -29@-41. -30@-40. -31@-39. -32@-38. -33@-38. -34@-37. -35@-36. -36@-35. -37@-34. -38@-32. -39@-31. -40@-30. -41@-29. -42@-27. -43@-26. -44@-24. -45@-22. -46@-20. -47@-17. -48@-14. -49@-10. -50@0. -50@0. -50@0. -50@0. -49@10. -48@14. -47@17. -46@20. -45@22. -44@24. -43@26. -42@27. -41@29. -40@30. -39@31. -38@32. -37@34. -36@35. -35@36. -34@37. -33@38. -32@38. -31@39. -30@40. -29@41. -28@41. -27@42. -26@43. -25@43. -24@44. -23@44. -22@45. -21@45. -20@46. -19@46. -18@47. -17@47. -16@47. -15@48. -14@48. -13@48. -12@49. -11@49. -10@49. -9@49. -8@49. -7@50. -6@50. -5@50. -4@50. -3@50. -2@50. -1@50. 1@50. 2@50. 3@50. 4@50. 5@50. 6@50. 7@50. 8@49. 9@49. 10@49. 11@49. 12@49. 13@48. 14@48. 15@48. 16@47. 17@47. 18@47. 19@46. 20@46. 21@45. 22@45. 23@44. 24@44. 25@43. 26@43. 27@42. 28@41. 29@41. 30@40. 31@39. 32@38. 33@38. 34@37. 35@36. 36@35. 37@34. 38@32. 39@31. 40@30. 41@29. 42@27. 43@26. 44@24. 45@22. 46@20. 47@17. 48@14. 49@10. 50@0. 50@1. 0@0} asOrderedCollection! !!PCArcMorphTest methodsFor: 'Testing' stamp: 'gm 2/21/2003 23:52'!testColor	| arcMorph |	arcMorph _ PCArcMorph fromDegrees: 10 toDegrees: 80.	arcMorph color: Color red.	self assert: arcMorph color = Color red.	self assert: arcMorph balloonColor = Color red.	arcMorph color: Color blue.	self assert: arcMorph color = Color blue.	self assert: arcMorph balloonColor = Color blue.! !!PCArcMorphTest methodsFor: 'Testing' stamp: 'gm 2/21/2003 23:48'!testCreation	| arcMorph |	arcMorph _ PCArcMorph fromDegrees: 10 toDegrees: 20.	self assert: arcMorph fromDegrees = 10.	self assert: arcMorph toDegrees = 20.	self assert: arcMorph fromRadians = 10 degreesToRadians.	self assert: arcMorph toRadians = 20 degreesToRadians! !!PCArcMorphTest methodsFor: 'Testing' stamp: 'gm 2/23/2003 21:19'!testDefaults	| arcMorph |	arcMorph _ PCArcMorph fromDegrees: 0 toDegrees: 90.	self assert: arcMorph defaultDiameter > 0.	self assert: arcMorph defaultRadius > 0.	self assert: arcMorph defaultDiameter = (arcMorph defaultRadius * 2).! !!PCArcMorphTest methodsFor: 'Testing' stamp: 'gm 2/21/2003 23:49'!testFromDegress	| arcMorph |	arcMorph _ PCArcMorph fromDegrees: 10 toDegrees: 80.	arcMorph fromDegrees: 20.	self assert: arcMorph fromDegrees = 20.	self assert: arcMorph fromRadians = 20 degreesToRadians.! !!PCArcMorphTest methodsFor: 'Testing' stamp: 'gm 2/21/2003 23:50'!testFromRadians	| arcMorph |	arcMorph _ PCArcMorph fromDegrees: 10 toDegrees: 80.	arcMorph fromRadians: 20 degreesToRadians.	self assert: arcMorph fromDegrees = 20.	self assert: arcMorph fromRadians = 20 degreesToRadians! !!PCArcMorphTest methodsFor: 'Testing' stamp: 'gm 3/17/2003 23:56'!testRadius	| arcMorph |	arcMorph := PCArcMorph fromDegrees: 0 toDegrees: 90.	arcMorph width: 100;	height: 100;	borderWidth: 0.	self assert: arcMorph radius = 50.	arcMorph width: 50.	self assert: arcMorph radius = 25.	arcMorph width: 100.	self assert: arcMorph radius = 50.	arcMorph height: 50.	self assert: arcMorph radius = 25.	arcMorph height: 100.	self assert: arcMorph radius = 50.	arcMorph borderWidth: 1.	self assert: arcMorph radius = 49.	arcMorph borderWidth: 10.	self assert: arcMorph radius = 40! !!PCArcMorphTest methodsFor: 'Testing' stamp: 'gm 2/21/2003 23:49'!testToDegress	| arcMorph |	arcMorph _ PCArcMorph fromDegrees: 10 toDegrees: 80.	arcMorph toDegrees: 70.	self assert: arcMorph toDegrees = 70.	self assert: arcMorph toRadians = 70 degreesToRadians! !!PCArcMorphTest methodsFor: 'Testing' stamp: 'gm 2/21/2003 23:50'!testToRadians	| arcMorph |	arcMorph _ PCArcMorph fromDegrees: 10 toDegrees: 80.	arcMorph toRadians: 70 degreesToRadians.	self assert: arcMorph toDegrees = 70.	self assert: arcMorph toRadians = 70 degreesToRadians! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 00:23'!addValue: aNumber 	"adds a new pie with the value aNumber"	piePortionInfos add: (PCPiePortionInfo value: aNumber).	self updateColors: self defaultColors.	self recalculate! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 00:24'!addValue: aNumber reference: aString color: aColor 	"adds a new pie with the specified value, reference and color"	piePortionInfos add: (PCPiePortionInfo 				value: aNumber				reference: aString				color: aColor).	self recalculate! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 00:26'!alpha: aNumber 	"sets the alpha for all the pie portions"	piePortionInfos do: [:each | each color: (each color alpha: aNumber)].	self updatePortionsPortionInfo! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 00:27'!balloonColorFor: aPCPiePortionMorph 	"answers the balloon color for the specified portion, or the default if it is nil."	^aPCPiePortionMorph isNil 		ifTrue: [self defaultBalloonColor]		ifFalse: [aPCPiePortionMorph piePortionInfo color]! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/4/2004 14:06'!balloonTextFor: aPCPiePortionMorph ifNil: aString	"answers the balloon text for the specified portion, or the pie balloon 	text if it is nil."	^ aPCPiePortionMorph isNil		ifTrue: [aString]		ifFalse: [aPCPiePortionMorph portionBalloonText]! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 00:31'!colors	"answers the colors of the pie portions"	^piePortionInfos collect: [:each | each color]! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 00:32'!colors: aCollection 	"sets the colors of the pie portions"	self updateColors: aCollection.	self updatePortionsPortionInfo! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 08:51'!hideLabels	"hides all labels"	portions do: [:each | each hideLabel]! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 00:33'!piePortionInfos	"answers a collection with information about the pie portions"	^piePortionInfos! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 08:52'!portions	"answers the portions of the pie"	^portions! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 00:35'!references	"answers the references"	^piePortionInfos collect: [:each | each reference]! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 08:53'!references: aCollection 	"sets the references"	self updateReferences: aCollection.	self updatePortionsPortionInfo! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 08:51'!showLabels	"shows all labels"	portions do: [:each | each showLabel]! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 00:35'!size	"answers the amount of portions in the pie"	^piePortionInfos size! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 00:37'!sum	"answers the accumulated absolute value of all the pie portions"	^piePortionInfos sum value! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 00:37'!title	"answers the content of the title"	^title contents! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 00:37'!title: aString 	"sets the content of the title"	title contents: aString.	self changed! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 00:38'!titleHeight	"calculates the heigth of the title"	^title contents isEmpty ifTrue: [0] ifFalse: [title height]! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 23:57'!updateColors: aCollection 	"updates the pie portions's colors, ensuring there is enough pie portions"	self ensurePiePortionInfosSize: aCollection size.	piePortionInfos with: aCollection asOrderedCollection		do: [:eachPiePortionInfo :eachColor | eachPiePortionInfo color: eachColor]! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 23:57'!updateReferences: aCollection 	"updates the pie portions's references, ensuring there is enough pie portions"	self ensurePiePortionInfosSize: aCollection size.	piePortionInfos with: aCollection asOrderedCollection		do: [:eachPiePortionInfo :eachReference | eachPiePortionInfo reference: eachReference]! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 23:57'!updateValues: aCollection 	"updates the pie portions's values, ensuring there is enough pie portions"	self ensurePiePortionInfosSize: aCollection size.	piePortionInfos with: aCollection asOrderedCollection		do: [:eachPiePortionInfo :eachValue | eachPiePortionInfo value: eachValue]! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 07:58'!values	"answers the values of the pie portions"	^ piePortionInfos		collect: [:each | each value]! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 07:58'!values: aCollection 	"sets the values of the pie portions"	self updateValues: aCollection.	self recalculate! !!PCPieChartMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 07:59'!wheelColor: aColor 	"resets the color of the pie portions using the wheel color from aColor"	self colors: (aColor wheel: self size)! !!PCPieChartMorph methodsFor: 'change reporting' stamp: 'gm 3/3/2004 00:31'!changed	"the receiver has changed, update the size of the components so they look right"	portions do: 			[:each | 			each width: self portionWidth.			each height: self portionHeight.			each left: self portionLeft.			each top: self portionTop].	title top: self titleTop.	title left: self titleLeft.	^super changed! !!PCPieChartMorph methodsFor: 'initialization' stamp: 'gm 3/3/2004 08:49'!defaultBorderForPie	"answers the default border size for the pie"	^5! !!PCPieChartMorph methodsFor: 'initialization' stamp: 'gm 3/3/2004 08:49'!defaultColors	"answers the default colors"	^(self defaultWheelColor wheel: self size) asOrderedCollection! !!PCPieChartMorph methodsFor: 'initialization' stamp: 'gm 3/3/2004 08:49'!defaultDiameter	"answers the default diameter"	^self defaultRadius * 2! !!PCPieChartMorph methodsFor: 'initialization' stamp: 'gm 3/3/2004 08:49'!defaultRadius	"answers the default radius"	^50! !!PCPieChartMorph methodsFor: 'initialization' stamp: 'gm 3/3/2004 08:49'!defaultTitleHeight	"answers the default title height"	^20! !!PCPieChartMorph methodsFor: 'initialization' stamp: 'gm 3/3/2004 08:50'!defaultWheelColor	"answers the default wheel color"	^Color cyan! !!PCPieChartMorph methodsFor: 'initialization' stamp: 'gm 3/3/2004 00:32'!initialize	"initializes this instance"	super initialize.	piePortionInfos := OrderedCollection new.	portions := OrderedCollection new.	title := StringMorph contents: ''.	self		addMorph: title;		borderWidth: 0;		height: self defaultDiameter + self defaultTitleHeight;		width: self defaultDiameter;		color: Color transparent;		balloonTextSelector: #title! !!PCPieChartMorph methodsFor: 'initialization' stamp: 'gm 3/3/2004 00:32'!initializeValues: aCollection 	"initializes this instance with the specified values"	self initialize.	self updateValues: aCollection.	self updateColors: self defaultColors.	self recalculate! !!PCPieChartMorph methodsFor: 'initialization' stamp: 'gm 3/3/2004 00:32'!initializeValues: valuesCollection references: referencesCollection colors: colorsCollection 	"initializes this instance with the specified values, references and colors"	self initialize.	self updateValues: valuesCollection.	self updateReferences: referencesCollection.	self updateColors: colorsCollection.	self recalculate! !!PCPieChartMorph methodsFor: 'private' stamp: 'gm 3/3/2004 08:37'!addPortions	"removes all submorphs and then adds the title and the pie portions"	self removeAllMorphs.	self addMorph: title.	portions do: [:each | self addMorph: each]! !!PCPieChartMorph methodsFor: 'private' stamp: 'gm 3/3/2004 00:25'!adjustValues: valuesCollection 	"adjust the absolute values to relative values in the circle"	| total |	total := valuesCollection sum.	^valuesCollection collect: [:each | each / total * 360]! !!PCPieChartMorph methodsFor: 'private' stamp: 'gm 3/4/2004 14:07'!balloonText	"answers the balloon text."	"tries to guess the pointed portion based on the cursor position."	| pointed |	pointed _ portions				detect: [:each | each arcContainsPoint: self cursorPoint]				ifNone: [].	self		balloonColor: (self balloonColorFor: pointed).	^ self balloonTextFor: pointed ifNil: super balloonText! !!PCPieChartMorph methodsFor: 'private' stamp: 'gm 3/3/2004 00:30'!calculatePortions	"generates the pie portions based on the specified values"	| portion |	portions := OrderedCollection new.	(self adjustValues: self values) inject: 0		into: 			[:sum :each | 			portion := PCPiePortionMorph new.			portion				borderWidth: 0;				width: self portionWidth;				height: self portionHeight;				fromDegrees: sum;				toDegrees: sum + each;				pie: self.			portions add: portion.			sum + each]! !!PCPieChartMorph methodsFor: 'private' stamp: 'gm 3/3/2004 08:50'!ensurePiePortionInfosSize: aNumber 	"ensures that there are enough pie portion info elements"	[piePortionInfos size < aNumber] 		whileTrue: [piePortionInfos add: PCPiePortionInfo new]! !!PCPieChartMorph methodsFor: 'private' stamp: 'gm 3/3/2004 00:34'!portionHeight	"calculates the height of the circle containing each portion"	^self height - (self defaultBorderForPie * 2) - self defaultTitleHeight! !!PCPieChartMorph methodsFor: 'private' stamp: 'gm 3/3/2004 00:34'!portionLeft	"calculates the left of the circle containing each portion"	^self left + ((self width - self portionWidth) / 2) asInteger! !!PCPieChartMorph methodsFor: 'private' stamp: 'gm 3/3/2004 00:34'!portionTop	"calculates the top of the circle containing each portion"	^self top + self titleHeight 		+ ((self height - self portionHeight) / 2) asInteger! !!PCPieChartMorph methodsFor: 'private' stamp: 'gm 3/3/2004 00:34'!portionWidth	"calculates the width of the circle containing each portion"	^self width - (self defaultBorderForPie * 2)! !!PCPieChartMorph methodsFor: 'private' stamp: 'gm 3/3/2004 08:52'!recalculate	"recalculates all the pie portions from scratch and then adds them to the pie"	self calculatePortions.	self updatePortionsPortionInfo.	self addPortions! !!PCPieChartMorph methodsFor: 'private' stamp: 'gm 3/3/2004 00:37'!titleLeft	"calculates the left of the title"	^self left + ((self width - title width) / 2) asInteger! !!PCPieChartMorph methodsFor: 'private' stamp: 'gm 3/3/2004 00:38'!titleTop	"calculates the top of the title"	^self top + 5! !!PCPieChartMorph methodsFor: 'private' stamp: 'gm 3/3/2004 23:57'!updatePortionsPortionInfo	"updates the pie portion info for each pie portion"	portions with: piePortionInfos		do: [:portion :piePortionInfo | portion piePortionInfo: piePortionInfo]! !!PCPieChartMorph class methodsFor: 'instance creation' stamp: 'gm 7/9/2002 15:39'!values: aCollection 	^ self new initializeValues: aCollection! !!PCPieChartMorph class methodsFor: 'instance creation' stamp: 'gm 8/10/2002 16:11'!values: aCollection references: referencesCollection colors: colorsCollection 	^ self new initializeValues: aCollection references: referencesCollection colors: colorsCollection ! !!PCPieChartMorph class methodsFor: 'testing' stamp: 'gm 2/21/2003 23:14'!test1	| pie |	pie := PCPieChartMorph values: { 						5.						3.						2.						1.						5.						6.						7.						2.						5.						3.						3}.	pie title: 'a Pie!!'.	pie openInWorld.	^pie! !!PCPieChartMorph class methodsFor: 'testing' stamp: 'gm 3/17/2003 21:32'!test2	| pie |	pie _ PCPieChartMorph values: {55. 26. 15. 36}.	pie references: {'A'. 'B'. 'C'. 'D'}.	pie colors: {Color red. Color green. Color blue. Color yellow}.	pie alpha: 0.5.	pie showLabels.	pie openInWorld.	^ pie! !!PCPieChartMorph class methodsFor: 'testing' stamp: 'gm 3/17/2003 23:30'!test3	| pie |	pie _ PCPieChartMorph values: {45. 26. 20. 36}.	pie		color: (Color blue twiceDarker twiceDarker twiceDarker alpha: 0.3);		 references: {'Banana'. 'Apple'. 'Orange'. 'Kiwi'};		 colors: {Color yellow. Color red. Color orange. Color green};		title: 'Fruits';		 alpha: 0.5;		 extent: 200 @ 220;		 useRoundedCorners;		 borderWidth: 2;		 showLabels;		 openInWorld.	^ pie! !!PCPieChartMorph class methodsFor: 'testing' stamp: 'gm 2/21/2003 23:14'!test4	| pie |	pie := PCPieChartMorph 				values: { 						50.						50.						50.						50}				references: { 						'A'.						'B'.						'C'.						'D'}				colors: { 						Color red.						Color green.						Color blue.						Color yellow}.	pie 		addValue: 50		reference: 'E'		color: Color cyan.	pie 		addValue: 50		reference: 'F'		color: Color orange.	pie openInWorld.	^pie! !!PCPieChartMorphTest methodsFor: 'Testing' stamp: 'gm 3/11/2003 22:18'!testAddValue	| pie values |	values _ {50. 60. 70. 30} asOrderedCollection.	pie _ PCPieChartMorph values: values.	self assert: pie values = values.	self assert: pie portions size = 4.	pie addValue: 40.	self assert: pie values			= (values copyWith: 40).	self assert: pie portions size = 5.	self assert: pie portions last piePortionInfo value = 40! !!PCPieChartMorphTest methodsFor: 'Testing' stamp: 'gm 3/11/2003 22:14'!testAddValueReferenceColor	| pie values references colors |	values _ {50. 60. 70. 30} asOrderedCollection.	references _ {'A'. 'B'. 'C'. 'D'} asOrderedCollection.	colors _ {Color red. Color green. Color blue. Color yellow} asOrderedCollection.	pie _ PCPieChartMorph				values: values				references: references				colors: colors.	self assert: pie values = values.	self assert: pie references = references.	self assert: pie colors = colors.	self assert: pie portions size = 4.	pie		addValue: 40		reference: 'E'		color: Color brown.	self assert: pie values			= (values copyWith: 40).	self assert: pie references			= (references copyWith: 'E').	self assert: pie colors			= (colors copyWith: Color brown).	self assert: pie portions size = 5.	self assert: pie portions last piePortionInfo value = 40.	self assert: pie portions last piePortionInfo reference = 'E'.	self assert: pie portions last piePortionInfo color = Color brown! !!PCPieChartMorphTest methodsFor: 'Testing' stamp: 'gm 3/17/2003 21:18'!testAlpha	| pie |	pie _ PCPieChartMorph values: {5. 3. 2} asOrderedCollection.	pie alpha: 0.5.	self assert: (pie portions first piePortionInfo color alpha - 0.5) abs < 0.01.	self assert: (pie portions second piePortionInfo color alpha - 0.5) abs < 0.01.	self assert: (pie portions third piePortionInfo color alpha - 0.5) abs < 0.01.	pie alpha: 0.8.	self assert: (pie portions first piePortionInfo color alpha - 0.8) abs < 0.01.	self assert: (pie portions second piePortionInfo color alpha - 0.8) abs < 0.01.	self assert: (pie portions third piePortionInfo color alpha - 0.8) abs < 0.01! !!PCPieChartMorphTest methodsFor: 'Testing' stamp: 'gm 3/10/2003 06:32'!testBalloonColorFor	| pie |	pie _ PCPieChartMorph values: {5. 3. 2} asOrderedCollection.	pie colors: {Color red. Color green. Color blue}.	self assert: (pie balloonColorFor: pie portions first)			= Color red.	self assert: (pie balloonColorFor: pie portions second)			= Color green.	self assert: (pie balloonColorFor: pie portions third)			= Color blue.	self assert: (pie balloonColorFor: nil)			= pie defaultBalloonColor! !!PCPieChartMorphTest methodsFor: 'Testing' stamp: 'gm 3/4/2004 14:07'!testBalloonTextFor	| pie |	pie _ PCPieChartMorph values: {3. 2} asOrderedCollection.	self assert: (pie balloonTextFor: pie portions first ifNil: '')			= '3 - 60%'.	self assert: (pie balloonTextFor: pie portions second ifNil: '')			= '2 - 40%'.	self assert: (pie balloonTextFor: nil ifNil: 'title')			= 'title'! !!PCPieChartMorphTest methodsFor: 'Testing' stamp: 'gm 3/15/2003 02:31'!testColors	| pie colors |	pie _ PCPieChartMorph values: {5. 3. 2}.	colors _ {Color red. Color green. Color blue} asOrderedCollection.	pie colors: colors.	self assert: pie colors = colors.	self assert: pie portions first piePortionInfo color = Color red.	self assert: pie portions second piePortionInfo color = Color green.	self assert: pie portions third piePortionInfo color = Color blue! !!PCPieChartMorphTest methodsFor: 'Testing' stamp: 'gm 2/25/2003 17:30'!testCreationValues	| values pie |	values _ {5. 3. 2. 1. 6. 7} asOrderedCollection.	pie _ PCPieChartMorph values: values.	self assert: pie values = values.	self assert: pie portions size = 6.! !!PCPieChartMorphTest methodsFor: 'Testing' stamp: 'gm 2/25/2003 17:32'!testCreationValuesReferencesColors	| values pie references colors |	values _ {50. 60. 70. 30} asOrderedCollection.	references _ {'A'. 'B'. 'C'. 'D'} asOrderedCollection.	colors _ {Color red. Color green. Color blue. Color yellow} asOrderedCollection.	pie _ PCPieChartMorph				values: values				references: references				colors: colors.	self assert: pie values = values.	self assert: pie references = references.	self assert: pie colors = colors.	self assert: pie portions size = 4! !!PCPieChartMorphTest methodsFor: 'Testing' stamp: 'gm 3/17/2003 21:20'!testEnsurePiePortionInfosSize	| pie |	pie _ PCPieChartMorph values: {5. 3. 2} asOrderedCollection.	self assert: pie piePortionInfos size = 3.	pie 	ensurePiePortionInfosSize: 5.	self assert: pie piePortionInfos size = 5.! !!PCPieChartMorphTest methodsFor: 'Testing' stamp: 'gm 3/4/2004 19:55'!testHideLabels	| pie references |	pie _ PCPieChartMorph values: {5. 3. 2}.	references _ {'A'. 'B'. 'C'} asOrderedCollection.	pie references: references.	pie showLabels.	pie portions		do: [:each | self assert: each submorphs notEmpty].	pie hideLabels.	pie portions		do: [:each | self assert: each submorphs isEmpty]! !!PCPieChartMorphTest methodsFor: 'Testing' stamp: 'gm 3/15/2003 02:32'!testReferences	| pie references |	pie _ PCPieChartMorph values: {5. 3. 2} .	references _ {'A'. 'B'. 'C'} asOrderedCollection.	pie references: references.	self assert: pie references = references.	self assert: pie portions first piePortionInfo reference = 'A'.	self assert: pie portions second piePortionInfo reference = 'B'.	self assert: pie portions third piePortionInfo reference = 'C'! !!PCPieChartMorphTest methodsFor: 'Testing' stamp: 'gm 3/10/2003 06:36'!testSize	| pie |	pie _ PCPieChartMorph values: {1. 2. 3} asOrderedCollection.	self assert: pie size = 3.	pie		addValue: 4.	self assert: pie size = 4.! !!PCPieChartMorphTest methodsFor: 'Testing' stamp: 'gm 3/11/2003 09:38'!testSum	| pie |	pie _ PCPieChartMorph values: {1. 2. 3} asOrderedCollection.	self assert: pie sum = 6.	pie addValue: 4.	self assert: pie sum = 10! !!PCPieChartMorphTest methodsFor: 'Testing' stamp: 'gm 3/10/2003 01:10'!testTitle	| pie |	pie _ PCPieChartMorph new.	pie title: 'test1'.	self assert: pie title = 'test1'.	pie title: 'test2'.	self assert: pie title = 'test2'! !!PCPieChartMorphTest methodsFor: 'Testing' stamp: 'gm 3/10/2003 01:12'!testTitleHeight	| pie |	pie _ PCPieChartMorph new.	pie title: ''.	self assert: pie titleHeight = 0.	pie title: 'test'.	self assert: pie titleHeight > 0! !!PCPieChartMorphTest methodsFor: 'Testing' stamp: 'gm 3/11/2003 22:18'!testValues	| pie |	pie _ PCPieChartMorph values: {1. 2. 3} asOrderedCollection.	self assert: pie portions first piePortionInfo value = 1.	self assert: pie portions second piePortionInfo value = 2.	self assert: pie portions third piePortionInfo value = 3.	pie values: {6. 5. 4} asOrderedCollection.	self assert: pie portions first piePortionInfo value = 6.	self assert: pie portions second piePortionInfo value = 5.	self assert: pie portions third piePortionInfo value = 4! !!PCPieChartMorphTest methodsFor: 'Testing' stamp: 'gm 3/12/2003 23:54'!testValuesSizeChange	| pie |	pie _ PCPieChartMorph values: {1. 2. 3} asOrderedCollection.	self assert: pie portions first piePortionInfo value = 1.	self assert: pie portions second piePortionInfo value = 2.	self assert: pie portions third piePortionInfo value = 3.	pie values: {7. 6. 5. 4} asOrderedCollection.	self assert: pie portions first piePortionInfo value = 7.	self assert: pie portions second piePortionInfo value = 6.	self assert: pie portions third piePortionInfo value = 5.	self assert: pie portions last piePortionInfo value = 4!]style[(20 3 4 4 3 3 15 10 1 2 1 2 1 24 4 9 3 39 1 3 4 9 3 40 1 3 4 9 3 39 1 3 3 10 4 2 1 2 1 24 4 9 3 39 1 3 4 9 3 40 1 3 4 9 3 39 1 3 4 9 3 38 1)f1b,f1,f1cblue;i,f1,f1cblue;i,f1,f1cmagenta;,f1,f1c197197121,f1,f1c197197121,f1,f1c197197121,f1,f1cmagenta;,f1,f1cblue;i,f1,f1c197197121,f1,f1cmagenta;,f1,f1cblue;i,f1,f1c197197121,f1,f1cmagenta;,f1,f1cblue;i,f1,f1c197197121,f1,f1cblue;i,f1,f1c197197121,f1,f1c197197121,f1,f1c197197121,f1,f1cmagenta;,f1,f1cblue;i,f1,f1c197197121,f1,f1cmagenta;,f1,f1cblue;i,f1,f1c197197121,f1,f1cmagenta;,f1,f1cblue;i,f1,f1c197197121,f1,f1cmagenta;,f1,f1cblue;i,f1,f1c197197121! !!PCPieChartMorphTest methodsFor: 'Testing' stamp: 'gm 3/15/2003 02:37'!testWheelColor	| pie colors newColors |	pie _ PCPieChartMorph values: {5. 3. 2}.	colors _ {Color red. Color green. Color blue} asOrderedCollection.	pie colors: colors.	self assert: pie colors = colors.	self assert: pie portions first piePortionInfo color = Color red.	self assert: pie portions second piePortionInfo color = Color green.	self assert: pie portions third piePortionInfo color = Color blue.	newColors _ (Color yellow wheel: 3) asOrderedCollection.	pie wheelColor: Color yellow.	self assert: pie colors = newColors.	self assert: pie portions first piePortionInfo color = newColors first.	self assert: pie portions second piePortionInfo color = newColors second.	self assert: pie portions third piePortionInfo color = newColors third!]style[(14 3 21 4 3 3 15 10 1 2 1 2 1 4 6 4 5 6 5 8 5 29 3 9 6 3 4 9 3 10 6 3 4 9 3 39 5 7 4 9 3 40 5 9 4 9 3 39 5 8 9 4 5 15 1 24 3 13 5 10 4 9 3 10 9 3 4 9 3 39 9 9 4 9 3 40 9 10 4 9 3 39 9 6)f1b,f1,f1cblue;i,f1,f1cblue;i,f1,f1cmagenta;,f1,f1c197197121,f1,f1c197197121,f1,f1c197197121,f1,f1cblue;i,f1,f1cmagenta;,f1,f1cmagenta;,f1,f1cmagenta;,f1,f1cblue;i,f1,f1cblue;i,f1,f1cmagenta;,f1,f1cblue;i,f1,f1cblue;i,f1,f1cmagenta;,f1,f1cblue;i,f1,f1cmagenta;,f1,f1cmagenta;,f1,f1cblue;i,f1,f1cmagenta;,f1,f1cmagenta;,f1,f1cblue;i,f1,f1cmagenta;,f1,f1cblue;i,f1,f1cmagenta;,f1,f1c197197121,f1,f1cblue;i,f1,f1cmagenta;,f1,f1cmagenta;,f1,f1cblue;i,f1,f1cblue;i,f1,f1cmagenta;,f1,f1cblue;i,f1,f1cblue;i,f1,f1cmagenta;,f1,f1cblue;i,f1,f1cblue;i,f1,f1cmagenta;,f1,f1cblue;i,f1,f1cblue;i,f1! !!PCPiePortionInfo methodsFor: 'accessing' stamp: 'gm 3/3/2004 01:00'!color	"answers the color"	^color! !!PCPiePortionInfo methodsFor: 'accessing' stamp: 'gm 3/3/2004 01:00'!color: aColor 	"sets the color"	color := aColor! !!PCPiePortionInfo methodsFor: 'accessing' stamp: 'gm 3/3/2004 00:59'!reference	"answers the reference"	^reference! !!PCPiePortionInfo methodsFor: 'accessing' stamp: 'gm 3/3/2004 01:00'!reference: aString 	"sets the reference"	reference := aString! !!PCPiePortionInfo methodsFor: 'accessing' stamp: 'gm 3/3/2004 01:00'!value	"answers the value"	^value! !!PCPiePortionInfo methodsFor: 'accessing' stamp: 'gm 3/3/2004 01:00'!value: aNumber 	"sets the value"	value := aNumber! !!PCPiePortionInfo methodsFor: 'printing' stamp: 'gm 3/3/2004 00:59'!printOn: aStream 	"Append to the argument, aStream, a sequence of characters that 	identifies the receiver."	aStream nextPutAll: 'value:';		 print: value;		 nextPutAll: ' reference:';		 print: reference;		 nextPutAll: ' color:';		 print: color! !!PCPiePortionInfo methodsFor: 'arithmetic' stamp: 'gm 3/3/2004 01:02'!+ aPCPiePortionInfo 	"answers the sum of the receiver and aPCPiePortionInfo"	^self class 		value: value + aPCPiePortionInfo value		reference: (reference ifNil: ['']) , '+' 				, (aPCPiePortionInfo reference ifNil: [''])		color: color + aPCPiePortionInfo color! !!PCPiePortionInfo methodsFor: 'arithmetic' stamp: 'gm 3/3/2004 01:03'!- aPCPiePortionInfo 	"answers the difference of the receiver and aPCPiePortionInfo"	^self class 		value: value - aPCPiePortionInfo value		reference: (reference ifNil: ['']) , '-' 				, (aPCPiePortionInfo reference ifNil: [''])		color: color - aPCPiePortionInfo color! !!PCPiePortionInfo methodsFor: 'initializing' stamp: 'gm 3/3/2004 00:58'!initialize	"initializes this instance"	value := 0.	reference := ''.	color := Color white! !!PCPiePortionInfo methodsFor: 'initializing' stamp: 'gm 3/3/2004 00:58'!initializeValue: aNumber 	"initializes this instance with a value"	value := aNumber! !!PCPiePortionInfo methodsFor: 'initializing' stamp: 'gm 3/3/2004 00:58'!initializeValue: aNumber reference: aString color: aColor 	"initializes this instance with a value, a reference and a color"	self initializeValue: aNumber.	reference := aString.	color := aColor! !!PCPiePortionInfo class methodsFor: 'instance creation' stamp: 'gm 3/15/2003 02:22'!new	^ super new initialize! !!PCPiePortionInfo class methodsFor: 'instance creation' stamp: 'gm 3/12/2003 23:58'!value: aNumber	^ self new		initializeValue: aNumber! !!PCPiePortionInfo class methodsFor: 'instance creation' stamp: 'gm 3/12/2003 23:57'!value: aNumber reference: aString color: aColor 	^ self new initializeValue: aNumber reference: aString color: aColor ! !!PCPiePortionInfoTest methodsFor: 'Testing' stamp: 'gm 3/11/2003 22:09'!testColor	| piePortionInfo |	piePortionInfo _ PCPiePortionInfo new.	piePortionInfo color: Color red.	self assert: piePortionInfo color = Color red.	piePortionInfo color: Color blue.	self assert: piePortionInfo color = Color blue! !!PCPiePortionInfoTest methodsFor: 'Testing' stamp: 'gm 3/11/2003 22:09'!testReference	| piePortionInfo |	piePortionInfo _ PCPiePortionInfo new.	piePortionInfo reference: 'A'.	self assert: piePortionInfo reference = 'A'.	piePortionInfo reference: 'B'.	self assert: piePortionInfo reference = 'B'! !!PCPiePortionInfoTest methodsFor: 'Testing' stamp: 'gm 3/11/2003 22:08'!testValue	| piePortionInfo |	piePortionInfo _ PCPiePortionInfo new.	piePortionInfo value: 2.	self assert: piePortionInfo value = 2.	piePortionInfo value: 8.	self assert: piePortionInfo value = 8! !!PCPiePortionMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 19:13'!centerRadians	"calculates the center angle, in radians"	^self fromRadians + ((self toRadians - self fromRadians) / 2)! !!PCPiePortionMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 19:13'!color	"answers the color"	^piePortionInfo isNil 		ifTrue: [self defaultColor]		ifFalse: [piePortionInfo color]! !!PCPiePortionMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 19:12'!color: aColor 	"sets the color"	piePortionInfo notNil ifTrue: [piePortionInfo color: aColor]! !!PCPiePortionMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 19:14'!hideLabel	"hides the label"	label delete! !!PCPiePortionMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 19:12'!label	"answers the label"	^label contents! !!PCPiePortionMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 19:12'!label: aString 	"sets the label"	label contents: aString.	self changed! !!PCPiePortionMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 19:15'!pie: aPCPieChartMorph 	"sets the owner pie"	pie := aPCPieChartMorph! !!PCPiePortionMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 23:41'!piePortionInfo	"answers the pie portion info"	^piePortionInfo! !!PCPiePortionMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 23:41'!piePortionInfo: aPCPiePortionInfo 	"sets the pie portion info"	piePortionInfo := aPCPiePortionInfo.	piePortionInfo color notNil ifTrue: [self color: piePortionInfo color].	piePortionInfo reference notNil 		ifTrue: [self label: piePortionInfo reference]! !!PCPiePortionMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 23:58'!portionBalloonText	"answers the balloon text for this portion, based on the reference and 	the value"	| text |	piePortionInfo value isNil		ifTrue: [^ ''].	text _ WriteStream on: String new.	piePortionInfo reference notNil & piePortionInfo reference notEmpty		ifTrue: [text nextPutAll: piePortionInfo reference;				 nextPutAll: ' - '].	text nextPutAll: piePortionInfo value asString;		 nextPutAll: ' - ';		 nextPutAll: (100 * piePortionInfo value / pie sum) asInteger asString;		 nextPutAll: '%'.	^ text contents! !!PCPiePortionMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 23:53'!portionCenter	"calculates the center of this pie portion"	"that is, the point in the central angle of the pie, at a distance of  	radius/2 from the center"	"example with a big pie portion, from=10, to=280, radius=50  	the portionCenter is: direction=145 degrees, distance from center=25"	| portionCenterX portionCenterY distanceFromCenter |	distanceFromCenter _ self radius / 2.	portionCenterX _ self center x + (self centerRadians cos * distanceFromCenter).	portionCenterY _ self center y - (self centerRadians sin * distanceFromCenter).	^ portionCenterX @ portionCenterY! !!PCPiePortionMorph methodsFor: 'accessing' stamp: 'gm 3/3/2004 19:14'!showLabel	"shows the label"	piePortionInfo reference notNil 		ifTrue: [self label: piePortionInfo reference].	self addMorph: label! !!PCPiePortionMorph methodsFor: 'initialization' stamp: 'gm 3/3/2004 23:40'!defaultColor	"answers the default color"	^Color red! !!PCPiePortionMorph methodsFor: 'initialization' stamp: 'gm 3/3/2004 23:40'!initialize	"initializes this instance"	super initialize.	piePortionInfo := PCPiePortionInfo new.	label := StringMorph contents: ''! !!PCPiePortionMorph methodsFor: 'printing' stamp: 'gm 3/3/2004 00:59'!printOn: aStream 	"Append to the argument, aStream, a sequence of characters that 	identifies the receiver."	super printOn: aStream.	aStream nextPutAll: ' title:';		 print: self portionBalloonText! !!PCPiePortionMorph methodsFor: 'change reporting' stamp: 'gm 3/3/2004 23:40'!changed	"the receiver has changed, update the position of the label so it looks right"	label notNil ifTrue: [label center: self portionCenter].	^super changed! !!PCPiePortionMorphTest methodsFor: 'Testing' stamp: 'gm 3/15/2003 20:20'!testCenterRadians	| piePortionMorph |	piePortionMorph _ PCPiePortionMorph fromDegrees: 0 toDegrees: 90.	self assert: (piePortionMorph centerRadians closeTo: 45 degreesToRadians).	piePortionMorph _ PCPiePortionMorph fromDegrees: 90 toDegrees: 180.	self assert: (piePortionMorph centerRadians closeTo: 135 degreesToRadians).	piePortionMorph _ PCPiePortionMorph fromDegrees: 0 toDegrees: 180.	self assert: (piePortionMorph centerRadians closeTo: 90 degreesToRadians).	piePortionMorph _ PCPiePortionMorph fromDegrees: 120 toDegrees: 280.	self assert: (piePortionMorph centerRadians closeTo: 200 degreesToRadians)!]style[(17 3 16 4 15 3 17 14 1 12 2 3 4 10 15 24 2 21 15 3 17 14 2 12 3 3 4 10 15 24 3 21 15 3 17 14 1 12 3 3 4 10 15 24 2 21 15 3 17 14 3 12 3 3 4 10 15 24 3 18)f1b,f1,f1cblue;i,f1,f1cblue;i,f1,f1cmagenta;,f1,f1c197197121,f1,f1c197197121,f1,f1cmagenta;,f1,f1cblue;i,f1,f1c197197121,f1,f1cblue;i,f1,f1cmagenta;,f1,f1c197197121,f1,f1c197197121,f1,f1cmagenta;,f1,f1cblue;i,f1,f1c197197121,f1,f1cblue;i,f1,f1cmagenta;,f1,f1c197197121,f1,f1c197197121,f1,f1cmagenta;,f1,f1cblue;i,f1,f1c197197121,f1,f1cblue;i,f1,f1cmagenta;,f1,f1c197197121,f1,f1c197197121,f1,f1cmagenta;,f1,f1cblue;i,f1,f1c197197121,f1! !!PCPiePortionMorphTest methodsFor: 'Testing' stamp: 'gm 3/17/2003 21:23'!testColor	| piePortionMorph piePortionInfo |	piePortionInfo _ PCPiePortionInfo new.	piePortionInfo color: Color blue.	piePortionMorph _ PCPiePortionMorph new.	piePortionMorph piePortionInfo: piePortionInfo.	self assert: piePortionMorph color = Color blue.	self assert: piePortionInfo color = Color blue.	piePortionMorph color: Color red. 	self assert: piePortionMorph color = Color red.	self assert: piePortionInfo color = Color red.! !!PCPiePortionMorphTest methodsFor: 'Testing' stamp: 'gm 3/17/2003 23:55'!testHideLabel	| piePortionMorph |	piePortionMorph := PCPiePortionMorph new.	piePortionMorph label: 'A'.	piePortionMorph showLabel.	self assert: piePortionMorph submorphs size = 1.	piePortionMorph hideLabel.	self assert: piePortionMorph submorphs isEmpty! !!PCPiePortionMorphTest methodsFor: 'Testing' stamp: 'gm 3/17/2003 21:26'!testLabel	| piePortionMorph piePortionInfo |	piePortionInfo _ PCPiePortionInfo new.	piePortionInfo reference: 'A'.	piePortionMorph _ PCPiePortionMorph new.	piePortionMorph piePortionInfo: piePortionInfo.	self assert: piePortionMorph label = 'A'.	piePortionMorph label: 'B'.	self assert: piePortionMorph label = 'B'.! !!PCPiePortionMorphTest methodsFor: 'Testing' stamp: 'gm 3/17/2003 23:55'!testLabelPosition	| piePortionMorph |	piePortionMorph := PCPiePortionMorph new.	piePortionMorph label: 'A'.	piePortionMorph showLabel.	self assert: piePortionMorph submorphs first center 				= piePortionMorph portionCenter! !!PCPiePortionMorphTest methodsFor: 'Testing' stamp: 'gm 3/11/2003 12:23'!testPortionBalloonText	| pie |	pie _ PCPieChartMorph values: {1. 2. 3} asOrderedCollection.	self assert: pie portions first portionBalloonText = '1 - 16%'.	self assert: pie portions second portionBalloonText = '2 - 33%'.	self assert: pie portions third portionBalloonText = '3 - 50%'! !!PCPiePortionMorphTest methodsFor: 'Testing' stamp: 'gm 3/15/2003 20:38'!testPortionCenter	| piePortionMorph |	piePortionMorph _ PCPiePortionMorph fromDegrees: 0 toDegrees: 90.	piePortionMorph borderWidth: 0.	piePortionMorph		bounds: (0 @ 0 extent: 100 @ 100).	self assert: (piePortionMorph portionCenter x closeTo: 67.6776695296637).	self assert: (piePortionMorph portionCenter y closeTo: 32.3223304703363).!]style[(17 3 16 4 15 3 17 14 1 12 2 3 15 14 1 3 15 12 1 3 1 9 3 3 3 4 4 10 15 46 4 10 15 45)f1b,f1,f1cblue;i,f1,f1cblue;i,f1,f1cmagenta;,f1,f1c197197121,f1,f1c197197121,f1,f1cblue;i,f1,f1c197197121,f1,f1cblue;i,f1,f1c197197121,f1,f1c197197121,f1,f1c197197121,f1,f1c197197121,f1,f1cmagenta;,f1,f1cblue;i,f1,f1cmagenta;,f1,f1cblue;i,f1! !!PCPiePortionMorphTest methodsFor: 'Testing' stamp: 'gm 3/17/2003 23:55'!testShowLabel	| piePortionMorph |	piePortionMorph := PCPiePortionMorph new.	piePortionMorph label: 'A'.	self assert: piePortionMorph submorphs isEmpty.	piePortionMorph showLabel.	self assert: piePortionMorph submorphs size = 1! !!PCSemiArc methodsFor: 'accessing' stamp: 'gm 9/3/2003 16:18'!center	"Answers the center. Used only in UnitTests."	^ center! !!PCSemiArc methodsFor: 'accessing' stamp: 'gm 9/3/2003 16:18'!radiansFrom	"Answers the starting angle. Used only in UnitTests."	^ radiansFrom! !!PCSemiArc methodsFor: 'accessing' stamp: 'gm 9/3/2003 16:18'!radiansTo	"Answers the finishing angle. Used only in UnitTests."	^ radiansTo! !!PCSemiArc methodsFor: 'accessing' stamp: 'gm 9/3/2003 16:18'!radius	"Answers the radius. Used only in UnitTests."	^ radius! !!PCSemiArc methodsFor: 'accessing' stamp: 'gm 9/3/2003 16:21'!vertices	"Answers the calculated vertices for this SemiArc."	^ vertices! !!PCSemiArc methodsFor: 'initializing' stamp: 'gm 3/3/2004 00:50'!initialize	"initializes this instance"	vertices := OrderedCollection new! !!PCSemiArc methodsFor: 'initializing' stamp: 'gm 3/3/2004 00:51'!initializeRadiansFrom: fromNumber radiansTo: toNumber center: aPoint radius: radiusNumber 	"initializes this instance with from/to radians, a center and a radius"	self initialize.	radiansFrom := fromNumber.	radiansTo := toNumber.	center := aPoint.	radius := radiusNumber.	self calculateVertices! !!PCSemiArc methodsFor: 'private' stamp: 'gm 9/3/2003 17:58'!addIntermediatePoints	"Adds the Points between From and To"	| arcBeginX arcEndX |	arcBeginX _ (radiansFrom cos * radius) rounded.	arcEndX _ (radiansTo cos * radius) rounded.	arcBeginX = arcEndX		ifTrue: [vertices				add: (self pointAtX: arcBeginX)]		ifFalse: [arcBeginX				to: arcEndX				by: (arcEndX - arcBeginX) sign				do: [:each | vertices						add: (self pointAtX: each)]]! !!PCSemiArc methodsFor: 'private' stamp: 'gm 9/3/2003 16:22'!addPointAtFrom	"Adds the Point at the starting angle"	vertices		add: (self pointAtRadians: radiansFrom)! !!PCSemiArc methodsFor: 'private' stamp: 'gm 9/3/2003 16:22'!addPointAtTo	"Adds the Point at the finishing angle"	vertices		add: (self pointAtRadians: radiansTo)! !!PCSemiArc methodsFor: 'private' stamp: 'gm 9/3/2003 17:59'!calculateVertices	"Calculates the vertices for this SemiArc."	(self fromAfterTo			or: [self fromAndToInDifferentSide])		ifTrue: [^ self].	self addPointAtFrom; addIntermediatePoints; addPointAtTo; invertIfNeeded; removeInvalidPoints; translateToCenter! !!PCSemiArc methodsFor: 'private' stamp: 'gm 9/3/2003 17:55'!fromAfterTo	"answers if From is after To, which makes this SemiArc useless"	^ radiansFrom >= radiansTo! !!PCSemiArc methodsFor: 'private' stamp: 'gm 9/3/2003 17:57'!fromAndToInDifferentSide	"answers if From and To are in different side corresponding to Float pi (180 degrees)"	^ radiansFrom < Float pi & (radiansTo > Float pi)! !!PCSemiArc methodsFor: 'private' stamp: 'gm 3/3/2004 00:53'!invertIfNeeded	"inverts the arc vertices if the arc is on the lower half of the circle"	| isUpSide |	isUpSide := radiansFrom <= Float pi & (radiansTo <= Float pi).	isUpSide 		ifTrue: [vertices := vertices collect: [:each | each x @ each y negated]]! !!PCSemiArc methodsFor: 'private' stamp: 'gm 3/3/2004 00:53'!pointAtRadians: radiansNumber 	"answers the arc's point at angle radiansNumber"	| x y |	x := (radius * radiansNumber cos) rounded.	y := (radius * radiansNumber sin) rounded abs.	^x @ y! !!PCSemiArc methodsFor: 'private' stamp: 'gm 3/3/2004 00:54'!pointAtX: xNumber 	"answers the arc's point x@y when x is xNumber"	| y |	radius = 0 ifTrue: [^0 @ 0].	y := (xNumber * (xNumber / radius) arcCos tan) rounded.	^xNumber @ y! !!PCSemiArc methodsFor: 'private' stamp: 'gm 3/3/2004 00:54'!removeInvalidPoints	"remove invalid points from the vertices collection"	vertices removeAll: (vertices select: [:each | each x = 0 & (each y = 0)])! !!PCSemiArc methodsFor: 'private' stamp: 'gm 3/3/2004 00:55'!translateToCenter	"translates vertices from relative positions around 0@0 to the real positions around the specified center"	vertices := vertices 				collect: [:each | each translateBy: center x @ center y]! !!PCSemiArc class methodsFor: 'instance creation' stamp: 'gm 2/21/2003 23:24'!radiansFrom: fromNumber radiansTo: toNumber center: aPoint radius: radiusNumber 	^self new 		initializeRadiansFrom: fromNumber		radiansTo: toNumber		center: aPoint		radius: radiusNumber! !!PCSemiArcTest methodsFor: 'Testing' stamp: 'gm 2/21/2003 23:30'!testCreation1st	| semiArc |	semiArc _ PCSemiArc				radiansFrom: 10 degreesToRadians				radiansTo: 20 degreesToRadians				center: 30 @ 30				radius: 50.	self assert: semiArc radiansFrom = 10 degreesToRadians.	self assert: semiArc radiansTo = 20 degreesToRadians.	self assert: semiArc center = (30 @ 30).	self assert: semiArc radius = 50! !!PCSemiArcTest methodsFor: 'Testing' stamp: 'gm 2/21/2003 23:31'!testCreation1stTo2nd	| semiArc |	semiArc _ PCSemiArc				radiansFrom: 10 degreesToRadians				radiansTo: 170 degreesToRadians				center: 30 @ 30				radius: 50.	self assert: semiArc radiansFrom = 10 degreesToRadians.	self assert: semiArc radiansTo = 170 degreesToRadians.	self assert: semiArc center = (30 @ 30).	self assert: semiArc radius = 50! !!PCSemiArcTest methodsFor: 'Testing' stamp: 'gm 2/21/2003 23:33'!testCreation1stTo4th	| semiArc |	semiArc _ PCSemiArc				radiansFrom: 10 degreesToRadians				radiansTo: 340 degreesToRadians				center: 30 @ 30				radius: 50.	self assert: semiArc radiansFrom = 10 degreesToRadians.	self assert: semiArc radiansTo = 340 degreesToRadians.	self assert: semiArc center = (30 @ 30).	self assert: semiArc radius = 50! !!PCSemiArcTest methodsFor: 'Testing' stamp: 'gm 2/21/2003 23:30'!testCreation2nd	| semiArc |	semiArc _ PCSemiArc				radiansFrom: 100 degreesToRadians				radiansTo: 150 degreesToRadians				center: 30 @ 30				radius: 50.	self assert: semiArc radiansFrom = 100 degreesToRadians.	self assert: semiArc radiansTo = 150 degreesToRadians.	self assert: semiArc center = (30 @ 30).	self assert: semiArc radius = 50! !!PCSemiArcTest methodsFor: 'Testing' stamp: 'gm 2/21/2003 23:32'!testCreation2ndTo3rd	| semiArc |	semiArc _ PCSemiArc				radiansFrom: 150 degreesToRadians				radiansTo: 250 degreesToRadians				center: 30 @ 30				radius: 50.	self assert: semiArc radiansFrom = 150 degreesToRadians.	self assert: semiArc radiansTo = 250 degreesToRadians.	self assert: semiArc center = (30 @ 30).	self assert: semiArc radius = 50! !!PCSemiArcTest methodsFor: 'Testing' stamp: 'gm 2/21/2003 23:31'!testCreation3rd	| semiArc |	semiArc _ PCSemiArc				radiansFrom: 200 degreesToRadians				radiansTo: 250 degreesToRadians				center: 30 @ 30				radius: 50.	self assert: semiArc radiansFrom = 200 degreesToRadians.	self assert: semiArc radiansTo = 250 degreesToRadians.	self assert: semiArc center = (30 @ 30).	self assert: semiArc radius = 50! !!PCSemiArcTest methodsFor: 'Testing' stamp: 'gm 2/21/2003 23:32'!testCreation3rdTo4th	| semiArc |	semiArc _ PCSemiArc				radiansFrom: 250 degreesToRadians				radiansTo: 350 degreesToRadians				center: 30 @ 30				radius: 50.	self assert: semiArc radiansFrom = 250 degreesToRadians.	self assert: semiArc radiansTo = 350 degreesToRadians.	self assert: semiArc center = (30 @ 30).	self assert: semiArc radius = 50! !!PCSemiArcTest methodsFor: 'Testing' stamp: 'gm 2/21/2003 23:31'!testCreation4th	| semiArc |	semiArc _ PCSemiArc				radiansFrom: 300 degreesToRadians				radiansTo: 350 degreesToRadians				center: 30 @ 30				radius: 50.	self assert: semiArc radiansFrom = 300 degreesToRadians.	self assert: semiArc radiansTo = 350 degreesToRadians.	self assert: semiArc center = (30 @ 30).	self assert: semiArc radius = 50! !!PCSemiArcTest methodsFor: 'Testing' stamp: 'gm 2/21/2003 23:33'!testCreation4thTo1st	| semiArc |	semiArc _ PCSemiArc				radiansFrom: 350 degreesToRadians				radiansTo: 10 degreesToRadians				center: 30 @ 30				radius: 50.	self assert: semiArc radiansFrom = 350 degreesToRadians.	self assert: semiArc radiansTo = 10 degreesToRadians.	self assert: semiArc center = (30 @ 30).	self assert: semiArc radius = 50! !PCPieChartMorph removeSelector: #balloonTextFor:!----End fileIn of D:\Users\Christian\Documents\Studienarbeit\Quellen\ATEO 1.5_SAM 2.0 (final)\universetmp\PieChartMorph-gm.5.cs----!!RBParseTreeRule commentStamp: 'md 8/9/2005 14:55' prior: 0!RBParseTreeRule is the abstract superclass of all of the parse tree searching rules. A parse tree rule is the first class representation of a particular rule to search for. The owner of a rule is the algorithm that actually executes the search. This arrangement allows multiple searches to be conducted by a single Searcher.Instance Variables:	owner	<ParseTreeSearcher>	The searcher that is actually performing the search.	searchTree	<RBProgramNode>	The parse tree to be searched.!!RBParseTreeRule class methodsFor: 'instance creation'!methodSearch: aString 	^(self new)		methodSearchString: aString;		yourself! !!RBParseTreeRule class methodsFor: 'instance creation'!search: aString 	^(self new)		searchString: aString;		yourself! !!RBParseTreeRule methodsFor: 'matching'!canMatch: aProgramNode 	^true! !!RBParseTreeRule methodsFor: 'private'!context	^owner context! !!RBParseTreeRule methodsFor: 'matching'!foundMatchFor: aProgramNode	^aProgramNode! !!RBParseTreeRule methodsFor: 'initialize-release'!methodSearchString: aString 	searchTree := RBParser parseRewriteMethod: aString! !!RBParseTreeRule methodsFor: 'initialize-release'!owner: aParseTreeSearcher	owner := aParseTreeSearcher! !!RBParseTreeRule methodsFor: 'matching'!performOn: aProgramNode 	self context empty.	^((searchTree match: aProgramNode inContext: self context) 		and: [self canMatch: aProgramNode]) 			ifTrue: 				[owner recusivelySearchInContext.				self foundMatchFor: aProgramNode]			ifFalse: [nil]! !!RBParseTreeRule methodsFor: 'initialize-release'!searchString: aString 	searchTree := RBParser parseRewriteExpression: aString! !!RBParseTreeRule methodsFor: 'accessing'!sentMessages	^searchTree sentMessages! !!RBReplaceRule commentStamp: 'md 8/9/2005 14:56' prior: 0!RBReplaceRule is the abstract superclass of all of the transforming rules. The rules change the source code by replacing the node that matches the rule. Subclasses implement different strategies for this replacement.Subclasses must implement the following messages:	matching		foundMatchFor:Instance Variables:	verificationBlock	<BlockClosure>	Is evaluated with the matching node. This allows for further verification of a match beyond simple tree matching.!!RBBlockReplaceRule commentStamp: 'md 8/9/2005 14:55' prior: 0!RBBlockReplaceRule replaces the matching node by the result of evaluating replaceBlock. This allows arbitrary computation to come up with a replacement.Instance Variables:	replaceBlock	<BlockClosure>	The block that returns the node to replace to matching node with.!!RBBlockReplaceRule class methodsFor: 'instance creation'!searchFor: searchString replaceWith: replaceBlock 	^self new searchFor: searchString replaceWith: replaceBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchFor: searchString replaceWith: replaceBlock when: aBlock 	^self new 		searchFor: searchString		replaceWith: replaceBlock		when: aBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchForMethod: searchString replaceWith: replaceBlock 	^self new searchForMethod: searchString replaceWith: replaceBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchForMethod: searchString replaceWith: replaceBlock when: aBlock 	^self new 		searchForMethod: searchString		replaceWith: replaceBlock		when: aBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchForTree: searchString replaceWith: replaceBlock 	^self new searchForTree: searchString replaceWith: replaceBlock! !!RBBlockReplaceRule class methodsFor: 'instance creation'!searchForTree: searchString replaceWith: replaceBlock when: aBlock 	^self new 		searchFor: searchString		replaceWith: replaceBlock		when: aBlock! !!RBBlockReplaceRule methodsFor: 'matching'!foundMatchFor: aProgramNode 	^replaceBlock value: aProgramNode! !!RBBlockReplaceRule methodsFor: 'initialize-release'!initialize	super initialize.	replaceBlock := [:aNode | aNode]! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchFor: searchString replaceWith: aBlock 	self searchString: searchString.	replaceBlock := aBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchFor: searchString replaceWith: replBlock when: verifyBlock 	self searchFor: searchString replaceWith: replBlock.	verificationBlock := verifyBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchForMethod: searchString replaceWith: aBlock 	self methodSearchString: searchString.	replaceBlock := aBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchForMethod: searchString replaceWith: replBlock when: verifyBlock 	self searchForMethod: searchString replaceWith: replBlock.	verificationBlock := verifyBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode replaceWith: aBlock 	searchTree := aBRProgramNode.	replaceBlock := aBlock! !!RBBlockReplaceRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode replaceWith: replBlock when: verifyBlock 	self searchForTree: aBRProgramNode replaceWith: replBlock.	verificationBlock := verifyBlock! !!RBReplaceRule methodsFor: 'matching'!canMatch: aProgramNode 	^verificationBlock value: aProgramNode! !!RBReplaceRule methodsFor: 'matching'!foundMatchFor: aProgramNode 	self subclassResponsibility! !!RBReplaceRule methodsFor: 'initialize-release'!initialize	super initialize.	verificationBlock := [:aNode | true]! !!RBStringReplaceRule commentStamp: 'md 8/9/2005 14:56' prior: 0!RBStringReplaceRule replaces a matched tree with another tree (which may include metavariable from the matching tree). This is a very succint syntax for specifying most rewrites.Instance Variables:	replaceTree	<RBProgramNode>	The tree to replace the matched tree with.!!RBStringReplaceRule class methodsFor: 'instance creation'!searchFor: searchString replaceWith: replaceString 	^self new searchFor: searchString replaceWith: replaceString! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchFor: searchString replaceWith: replaceString when: aBlock 	^self new 		searchFor: searchString		replaceWith: replaceString		when: aBlock! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchForMethod: searchString replaceWith: replaceString	^self new searchForMethod: searchString replaceWith: replaceString! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchForMethod: searchString replaceWith: replaceString when: aBlock 	^self new 		searchForMethod: searchString		replaceWith: replaceString		when: aBlock! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchForTree: searchString replaceWith: replaceString 	^self new searchForTree: searchString replaceWith: replaceString! !!RBStringReplaceRule class methodsFor: 'instance creation'!searchForTree: searchString replaceWith: replaceString when: aBlock 	^self new 		searchForTree: searchString		replaceWith: replaceString		when: aBlock! !!RBStringReplaceRule methodsFor: 'matching'!foundMatchFor: aProgramNode 	| newTree |	newTree := replaceTree copyInContext: self context.	newTree copyCommentsFrom: aProgramNode.	^newTree! !!RBStringReplaceRule methodsFor: 'initialize-release'!methodReplaceString: replaceString 	replaceTree := RBParser parseRewriteMethod: replaceString! !!RBStringReplaceRule methodsFor: 'initialize-release'!replaceString: replaceString 	replaceTree := RBParser parseRewriteExpression: replaceString.	searchTree isSequence = replaceTree isSequence 		ifFalse: 			[searchTree isSequence 				ifTrue: [replaceTree := RBSequenceNode statements: (Array with: replaceTree)]				ifFalse: [searchTree := RBSequenceNode statements: (Array with: searchTree)]]! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchFor: searchString replaceWith: replaceString 	self searchString: searchString.	self replaceString: replaceString! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchFor: searchString replaceWith: replaceString when: aBlock 	self searchFor: searchString replaceWith: replaceString.	verificationBlock := aBlock! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchForMethod: searchString replaceWith: replaceString 	self methodSearchString: searchString.	self methodReplaceString: replaceString! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchForMethod: searchString replaceWith: replaceString when: aBlock 	self searchForMethod: searchString replaceWith: replaceString.	verificationBlock := aBlock! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode replaceWith: replaceNode 	searchTree := aBRProgramNode.	replaceTree := replaceNode! !!RBStringReplaceRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode replaceWith: replaceString when: aBlock 	self searchForTree: aBRProgramNode replaceWith: replaceString.	verificationBlock := aBlock! !!RBSearchRule commentStamp: 'md 8/9/2005 14:56' prior: 0!RBSearchRule is a parse tree rule that simply searches for matches to the rule. Every time a match is found, answerBlock is evaluated with the node that matches and the cureent answer. This two-argument approach allows a collection to be formed from all of the matches (Think inject:into:).Instance Variables:	answerBlock	<BlockClosure>	Block to evaluate with the matching node and the current answer.!!RBSearchRule class methodsFor: 'instance creation'!searchFor: aString thenDo: aBlock 	^self new searchFor: aString thenDo: aBlock! !!RBSearchRule class methodsFor: 'instance creation'!searchForMethod: aString thenDo: aBlock 	^self new searchForMethod: aString thenDo: aBlock! !!RBSearchRule class methodsFor: 'instance creation'!searchForTree: aBRProgramNode thenDo: aBlock 	^self new searchForTree: aBRProgramNode thenDo: aBlock! !!RBSearchRule methodsFor: 'testing' stamp: 'bh 4/29/2000 18:15'!canMatch: aProgramNode 	self needsWork.	"testing #copy to attempt to fix block closure issue"	owner answer: (answerBlock copy value: aProgramNode value: owner answer).	^ true! !!RBSearchRule methodsFor: 'initialize-release'!searchFor: aString thenDo: aBlock 	self searchString: aString.	answerBlock := aBlock! !!RBSearchRule methodsFor: 'initialize-release'!searchForMethod: aString thenDo: aBlock 	self methodSearchString: aString.	answerBlock := aBlock! !!RBSearchRule methodsFor: 'initialize-release'!searchForTree: aBRProgramNode thenDo: aBlock 	searchTree := aBRProgramNode.	answerBlock := aBlock! !!RBParser commentStamp: 'md 8/9/2005 14:54' prior: 0!RBParser takes a source code string and generates an AST for it. This is a hand-written, recursive descent parser and has been optimized for speed. The simplest way to call this is either 'RBParser parseExpression: aString' if you want the AST for an expression, or 'RBParser parseMethod: aString' if you want to parse an entire method.Instance Variables:	currentToken	<RBToken>	The current token being processed.	emptyStatements	<Boolean>	True if empty statements are allowed. In IBM, they are, in VW they aren't.	errorBlock	<BlockClosure>	The block to evaluate on a syntax error.	nextToken	<RBToken>	The next token that will be processed. This allows one-token lookahead.	scanner	<RBScanner>	The scanner that generates a stream of tokens to parse.	source	<String>	The source code to parse	tags	<Collection of: Interval>	The source intervals of the tags appearing at the top of a method (e.g. Primitive calls)Shared Variables:	ParserType	<Symbol>	the type code we are parsing!!RBParser class methodsFor: 'accessing' stamp: 'md 7/17/2006 10:39'!format: textOrStream in: aClass notifying: aRequestor contentsSymbol: aSymbol	"Compile a parse tree from the argument, textOrStream. Answer a string containing the original code, formatted nicely.  If aBoolean is true, then decorate the resulting text with color and hypertext actions"	^self format: textOrStream asString in: aClass notifying: aRequestor decorated: (aSymbol == #colorPrint)! !!RBParser class methodsFor: 'accessing' stamp: 'nk 2/23/2005 18:28'!format: aString in: anIgnoredClass notifying: aRequester decorated: decorated 	| parser squeakString node errorBlock |	squeakString := aString asString withBlanksTrimmed.	squeakString isEmpty ifTrue: [ ^squeakString ].	errorBlock := [:message :position | self error: ('{1} at position {2}' format: { message. position}) ].	parser := self new.	parser errorBlock: errorBlock.	parser initializeParserWith: squeakString type: #on:errorBlock:.	node := parser parseMethod: squeakString.	^decorated 		ifTrue: [node colorizedFormattedCode]		ifFalse: [node formattedCode]! !!RBParser class methodsFor: 'accessing'!parseExpression: aString 	^self parseExpression: aString onError: nil! !!RBParser class methodsFor: 'accessing' stamp: 'dvf 11/8/2003 15:02'!parseExpression: aString onError: aBlock 	| node parser |	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: aString type: #on:errorBlock:.	node := parser parseExpression.	^(node statements size == 1 and: [node temporaries isEmpty])		ifTrue: [node statements first]		ifFalse: [node]! !!RBParser class methodsFor: 'accessing'!parseMethod: aString 	^self parseMethod: aString onError: nil! !!RBParser class methodsFor: 'accessing' stamp: 'dvf 11/8/2003 04:44'!parseMethod: aString onError: aBlock 	| parser squeakString |	squeakString := aString .	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: squeakString type: #on:errorBlock:.	^parser parseMethod: squeakString! !!RBParser class methodsFor: 'parsing'!parseMethodPattern: aString 	| parser |	parser := self new.	parser errorBlock: [:error :position | ^nil].	parser initializeParserWith: aString type: #on:errorBlock:.	^parser parseMessagePattern selector! !!RBParser class methodsFor: 'accessing' stamp: 'bh 3/7/2000 01:35'!parseMethodWithNoComments: aString 	^ self parseMethodWithNoComments: aString onError: nil! !!RBParser class methodsFor: 'accessing' stamp: 'bh 3/7/2000 01:34'!parseMethodWithNoComments: aString onError: aBlock 	| parser |	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: aString type: #on:errorBlock:.	^ parser parseMethodWithNoComments: aString! !!RBParser class methodsFor: 'accessing'!parseRewriteExpression: aString 	^self parseRewriteExpression: aString onError: nil! !!RBParser class methodsFor: 'accessing'!parseRewriteExpression: aString onError: aBlock 	| node parser |	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: aString type: #rewriteOn:errorBlock:.	node := parser parseExpression.	^(node statements size == 1 and: [node temporaries isEmpty])		ifTrue: [node statements first]		ifFalse: [node]! !!RBParser class methodsFor: 'accessing'!parseRewriteMethod: aString 	^self parseRewriteMethod: aString onError: nil! !!RBParser class methodsFor: 'accessing'!parseRewriteMethod: aString onError: aBlock 	| parser |	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: aString type: #rewriteOn:errorBlock:.	^parser parseMethod: aString! !!RBParser methodsFor: 'private' stamp: 'tween 6/29/2006 18:42'!addCommentsTo: aNode	| existingComments newComments allComments |		existingComments := aNode comments ifNil:[OrderedCollection new].	newComments := scanner getComments ifNil:[OrderedCollection new].	allComments := existingComments, newComments.	allComments isEmpty ifTrue:[allComments := nil].	aNode comments: allComments! !!RBParser methodsFor: 'testing'!atEnd	^currentToken class == RBToken! !!RBParser methodsFor: 'error handling'!errorBlock	^errorBlock isNil		ifTrue: [[:message :position | ]]		ifFalse: [errorBlock]! !!RBParser methodsFor: 'accessing'!errorBlock: aBlock 	errorBlock := aBlock.	scanner notNil ifTrue: [scanner errorBlock: aBlock]! !!RBParser methodsFor: 'error handling'!errorPosition	^currentToken start! !!RBParser methodsFor: 'initialize-release' stamp: 'ls 1/30/2000 17:55'!initializeForSqueak	emptyStatements := true.	negatedNumbers := true.	scanner notNil ifTrue: [scanner initializeForSqueak]! !!RBParser methodsFor: 'accessing'!initializeParserWith: aString type: aSymbol 	source := aString.	self scanner: (RBScanner 				perform: aSymbol				with: (ReadStream on: aString)				with: self errorBlock)! !!RBParser methodsFor: 'private'!nextToken	^nextToken isNil		ifTrue: [nextToken := scanner next]		ifFalse: [nextToken]! !!RBParser methodsFor: 'private-parsing'!parseArgs	| args |	args := OrderedCollection new.	[currentToken isIdentifier]		whileTrue: [args add: self parseVariableNode].	^args! !!RBParser methodsFor: 'private-parsing' stamp: 'ls 1/24/2000 00:11'!parseArray	"parse Squeak's {} construct"	| leftBrace node rightBrace |	leftBrace := currentToken start.	self step.	node := RBArrayNode new.	self parseStatementList: false  into: node.	(currentToken isSpecial and: [currentToken value == $}]) ifFalse: [		self parserError: 'expected }' ].	rightBrace := currentToken start.	self step.	node leftBrace: leftBrace.	node rightBrace: rightBrace.	^node! !!RBParser methodsFor: 'private-parsing'!parseAssignment	"Need one token lookahead to see if we have a ':='. This method could 	make it possible to assign the literals true, false and nil."	| node position |	(currentToken isIdentifier and: [self nextToken isAssignment]) 		ifFalse: [^self parseCascadeMessage].	node := self parseVariableNode.	position := currentToken start.	self step.	^RBAssignmentNode 		variable: node		value: self parseAssignment		position: position! !!RBParser methodsFor: 'private-parsing'!parseBinaryMessage	| node |	node := self parseUnaryMessage.		[currentToken isLiteral ifTrue: [self patchNegativeLiteral].	currentToken isBinary] 			whileTrue: [node := self parseBinaryMessageWith: node].	^node! !!RBParser methodsFor: 'private-parsing'!parseBinaryMessageWith: aNode 	| binaryToken |	binaryToken := currentToken.	self step.	^RBMessageNode 		receiver: aNode		selectorParts: (Array with: binaryToken)		arguments: (Array with: self parseUnaryMessage)! !!RBParser methodsFor: 'private-parsing'!parseBinaryPattern	| binaryToken |	currentToken isBinary 		ifFalse: [self parserError: 'Message pattern expected'].	binaryToken := currentToken.	self step.	^RBMethodNode selectorParts: (Array with: binaryToken)		arguments: (Array with: self parseVariableNode)! !!RBParser methodsFor: 'private-parsing'!parseBlock	| position node |	position := currentToken start.	self step.	node := self parseBlockArgsInto: RBBlockNode new.	node left: position.	node body: (self parseStatements: false).	(currentToken isSpecial and: [currentToken value == $]]) 		ifFalse: [self parserError: ''']'' expected'].	node right: currentToken start.	self step.	^node! !!RBParser methodsFor: 'private-parsing'!parseBlockArgsInto: node 	| verticalBar args colons |	args := OrderedCollection new: 2.	colons := OrderedCollection new: 2.	verticalBar := false.	[currentToken isSpecial and: [currentToken value == $:]] whileTrue: 			[colons add: currentToken start.			self step.	":"			verticalBar := true.			args add: self parseVariableNode].	verticalBar 		ifTrue: 			[currentToken isBinary 				ifTrue: 					[node bar: currentToken start.					currentToken value == #| 						ifTrue: [self step]						ifFalse: 							[currentToken value == #'||' 								ifTrue: 									["Hack the current token to be the start 									of temps bar"									currentToken										value: #|;										start: currentToken start + 1]								ifFalse: [self parserError: '''|'' expected']]]				ifFalse: 					[(currentToken isSpecial and: [currentToken value == $]]) 						ifFalse: [self parserError: '''|'' expected']]].	node		arguments: args;		colons: colons.	^node! !!RBParser methodsFor: 'private-parsing'!parseCascadeMessage	| node receiver messages semicolons |	node := self parseKeywordMessage.	(currentToken isSpecial 		and: [currentToken value == $; and: [node isMessage]]) ifFalse: [^node].	receiver := node receiver.	messages := OrderedCollection new: 3.	semicolons := OrderedCollection new: 3.	messages add: node.	[currentToken isSpecial and: [currentToken value == $;]] whileTrue: 			[semicolons add: currentToken start.			self step.			messages add: (currentToken isIdentifier 						ifTrue: [self parseUnaryMessageWith: receiver]						ifFalse: 							[currentToken isKeyword 								ifTrue: [self parseKeywordMessageWith: receiver]								ifFalse: 									[| temp |									currentToken isLiteral ifTrue: [self patchNegativeLiteral].									currentToken isBinary ifFalse: [self parserError: 'Message expected'].									temp := self parseBinaryMessageWith: receiver.									temp == receiver ifTrue: [self parserError: 'Message expected'].									temp]])].	^RBCascadeNode messages: messages semicolons: semicolons! !!RBParser methodsFor: 'accessing'!parseExpression	| node |	node := self parseStatements: false.	self atEnd ifFalse: [self parserError: 'Unknown input at end'].	^node! !!RBParser methodsFor: 'private-parsing'!parseKeywordMessage	^self parseKeywordMessageWith: self parseBinaryMessage! !!RBParser methodsFor: 'private-parsing'!parseKeywordMessageWith: node 	| args isKeyword keywords |	args := OrderedCollection new: 3.	keywords := OrderedCollection new: 3.	isKeyword := false.	[currentToken isKeyword] whileTrue: 			[keywords add: currentToken.			self step.			args add: self parseBinaryMessage.			isKeyword := true].	^isKeyword 		ifTrue: 			[RBMessageNode 				receiver: node				selectorParts: keywords				arguments: args]		ifFalse: [node]! !!RBParser methodsFor: 'private-parsing'!parseKeywordPattern	| keywords args |	keywords := OrderedCollection new: 2.	args := OrderedCollection new: 2.	[currentToken isKeyword] whileTrue: 			[keywords add: currentToken.			self step.			args add: self parseVariableNode].	^RBMethodNode selectorParts: keywords arguments: args! !!RBParser methodsFor: 'private-parsing' stamp: 'ms 9/16/2006 20:43'!parseMessagePattern	^currentToken isIdentifier		ifTrue: [self parseUnaryPattern]		ifFalse: 			[currentToken isKeyword				ifTrue: [self parseKeywordPattern]				ifFalse: [self parseBinaryPattern]]! !!RBParser methodsFor: 'private-parsing'!parseMethod	| methodNode |	methodNode := self parseMessagePattern.	self parseResourceTag.	self addCommentsTo: methodNode.	methodNode body: (self parseStatements: true).	methodNode tags: tags.	^methodNode! !!RBParser methodsFor: 'accessing'!parseMethod: aString 	| node |	node := self parseMethod.	self atEnd ifFalse: [self parserError: 'Unknown input at end'].	node source: aString.	^node! !!RBParser methodsFor: 'private-parsing' stamp: 'bh 3/7/2000 01:36'!parseMethodWithNoComments	| methodNode |	methodNode := self parseMessagePattern.	self parseResourceTag.	"self addCommentsTo: methodNode."	methodNode body: (self parseStatements: true).	methodNode tags: tags.	^ methodNode! !!RBParser methodsFor: 'accessing' stamp: 'bh 3/7/2000 01:40'!parseMethodWithNoComments: aString 	| node |	node := self parseMethodWithNoComments.	self atEnd ifFalse: [self parserError: 'Unknown input at end'].	node source: aString.	^ node! !!RBParser methodsFor: 'private-parsing' stamp: 'ls 1/30/2000 18:16'!parseNegatedNumber	| token |	(self nextToken isLiteral not or: [ self nextToken realValue isNumber not ])		ifTrue: [ self parserError: 'only numbers may be negated' ].	"create a new token out of the $- and the number"	token := RBLiteralToken value: (self nextToken realValue negated) start: currentToken start stop: nextToken stop.	self step.	self step.	^RBLiteralNode literalToken: token! !!RBParser methodsFor: 'private-parsing'!parseParenthesizedExpression	| leftParen node |	leftParen := currentToken start.	self step.	node := self parseAssignment.	^(currentToken isSpecial and: [currentToken value == $)])		ifTrue: 			[node addParenthesis: (leftParen to: currentToken start).			self step.			node]		ifFalse: [self parserError: ''')'' expected']! !!RBParser methodsFor: 'private-parsing'!parsePatternBlock	| position node |	position := currentToken start.	self step.	node := self parseBlockArgsInto: RBPatternBlockNode new.	node left: position.	node body: (self parseStatements: false).	(currentToken isSpecial and: [currentToken value == $}]) 		ifFalse: [self parserError: '''}'' expected'].	node right: currentToken start.	self step.	^node! !!RBParser methodsFor: 'private-parsing' stamp: 'tween 6/29/2006 18:15'!parsePrimitiveIdentifier	| token answer |	token := currentToken.	self step.	answer := RBVariableNode identifierToken: token.	self addCommentsTo: answer.	^answer! !!RBParser methodsFor: 'private-parsing'!parsePrimitiveLiteral	| token |	token := currentToken.	self step.	^RBLiteralNode literalToken: token! !!RBParser methodsFor: 'private-parsing' stamp: 'pmm 9/24/2005 10:49'!parsePrimitiveObject	currentToken isIdentifier ifTrue: [^self parsePrimitiveIdentifier].	currentToken isLiteral ifTrue: [^self parsePrimitiveLiteral].	currentToken isSpecial ifTrue: 			[currentToken value == $[ ifTrue: [^self parseBlock].			currentToken value == $( ifTrue: [^self parseParenthesizedExpression].			currentToken value == ${ ifTrue: [^self parseArray]].	(negatedNumbers and: 		[ currentToken isBinary and:		[ currentToken value == #- ] ]) 	ifTrue:		[ ^self parseNegatedNumber ].	currentToken isPatternBlock ifTrue:[^self parsePatternBlock].	self parserError: 'Variable expected'! !!RBParser methodsFor: 'private-parsing'!parseResourceTag	| start |	[currentToken isBinary and: [currentToken value == #<]] whileTrue: 			[start := currentToken start.			self step.			[scanner atEnd or: [currentToken isBinary and: [currentToken value == #>]]] 				whileFalse: [self step].			(currentToken isBinary and: [currentToken value == #>]) 				ifFalse: [self parserError: '''>'' expected'].			tags isNil 				ifTrue: [tags := OrderedCollection with: (start to: currentToken stop)]				ifFalse: [tags add: (start to: currentToken stop)].			self step]! !!RBParser methodsFor: 'private-parsing' stamp: 'tween 6/29/2006 18:30'!parseStatementList: tagBoolean into: sequenceNode 	| statements return periods returnPosition node |	return := false.	statements := OrderedCollection new.	periods := OrderedCollection new.	self addCommentsTo: sequenceNode.	tagBoolean ifTrue: [self parseResourceTag].		["skip empty statements"		emptyStatements ifTrue: 			[[currentToken isSpecial and: [currentToken value == $.]] whileTrue: 					[periods add: currentToken start.					self step]].		"check if we are finished yet"	 	self atEnd 			or: [currentToken isSpecial and: ['])}' includes: currentToken value]]] 			whileFalse: 				[return ifTrue: [self parserError: 'End of statement list encounted'].				(currentToken isSpecial and: [currentToken value == $^]) 					ifTrue: 						[returnPosition := currentToken start.						self step.						node := RBReturnNode return: returnPosition value: self parseAssignment.						self addCommentsTo: node.						statements add: node.						return := true]					ifFalse: 						[node := self parseAssignment.						self addCommentsTo: node.						statements add: node].				(currentToken isSpecial and: [currentToken value == $.]) 					ifTrue: 						[periods add: currentToken start.						self step]					ifFalse: [return := true].				].	statements notEmpty ifTrue: [self addCommentsTo: statements last].	sequenceNode		statements: statements;		periods: periods.	^sequenceNode! !!RBParser methodsFor: 'private-parsing'!parseStatements: tagBoolean 	| args leftBar rightBar |	args := #().	leftBar := rightBar := nil.	currentToken isBinary 		ifTrue: 			[currentToken value == #| 				ifTrue: 					[leftBar := currentToken start.					self step.					args := self parseArgs.					(currentToken isBinary and: [currentToken value = #|]) 						ifFalse: [self parserError: '''|'' expected'].					rightBar := currentToken start.					self step]				ifFalse: 					[currentToken value == #'||' 						ifTrue: 							[rightBar := (leftBar := currentToken start) + 1.							self step]]].	^self parseStatementList: tagBoolean		into: (RBSequenceNode 				leftBar: leftBar				temporaries: args				rightBar: rightBar)! !!RBParser methodsFor: 'private-parsing' stamp: 'tween 6/29/2006 18:30'!parseUnaryMessage	| node |	node := self parsePrimitiveObject.	self addCommentsTo: node.	[currentToken isLiteral ifTrue: [self patchLiteralMessage].	currentToken isIdentifier] 			whileTrue: [node := self parseUnaryMessageWith: node].	self addCommentsTo: node.	^node! !!RBParser methodsFor: 'private-parsing'!parseUnaryMessageWith: aNode 	| selector |	selector := currentToken.	self step.	^RBMessageNode 		receiver: aNode		selectorParts: (Array with: selector)		arguments: #()! !!RBParser methodsFor: 'private-parsing'!parseUnaryPattern	| selector |	selector := currentToken.	self step.	^RBMethodNode selectorParts: (Array with: selector) arguments: #()! !!RBParser methodsFor: 'private-parsing'!parseVariableNode	currentToken isIdentifier 		ifFalse: [self parserError: 'Variable name expected'].	^self parsePrimitiveIdentifier! !!RBParser methodsFor: 'error handling'!parserError: aString 	"Evaluate the block. If it returns raise an error"	self errorBlock value: aString value: self errorPosition.	self error: aString! !!RBParser methodsFor: 'private' stamp: 'pmm 7/12/2006 15:24'!patchLiteralMessage	currentToken value == true 		ifTrue: 			[^currentToken := RBIdentifierToken value: 'true' start: currentToken start].	currentToken value == false 		ifTrue: 			[^currentToken := RBIdentifierToken value: 'false' start: currentToken start].	currentToken value isNil		ifTrue: 			[^currentToken := RBIdentifierToken value: 'nil' start: currentToken start]! !!RBParser methodsFor: 'private' stamp: 'pmm 7/12/2006 15:14'!patchNegativeLiteral	"Handle the special negative number case for binary message sends."	currentToken value isNumber ifFalse: [^self].	currentToken value <= 0 ifFalse: [^self].	currentToken value = 0 		ifTrue: 			[(source notNil and: 					[source isEmpty not 						and: [(source at: (currentToken start min: source size)) == $-]]) 				ifFalse: [^self]].	nextToken := currentToken.	currentToken := RBBinarySelectorToken value: #- start: nextToken start.	nextToken value: nextToken value negated.	nextToken start: nextToken start + 1! !!RBParser methodsFor: 'initialize-release' stamp: 'md 10/11/2005 15:49'!scanner: aScanner 	scanner := aScanner.	tags := nil.	self initializeForSqueak.	self step! !!RBParser methodsFor: 'private'!step	nextToken notNil ifTrue: 			[currentToken := nextToken.			nextToken := nil.			^currentToken].	currentToken := scanner next! !!RBProgramNode commentStamp: 'md 8/9/2005 14:59' prior: 0!RBProgramNode is an abstract class that represents an abstract syntax tree node in a Smalltalk program.Subclasses must implement the following messages:	accessing		start		stop	visitor		acceptVisitor:The #start and #stop methods are used to find the source that corresponds to this node. "source copyFrom: self start to: self stop" should return the source for this node.The #acceptVisitor: method is used by RBProgramNodeVisitors (the visitor pattern). This will also require updating all the RBProgramNodeVisitors so that they know of the new node.Subclasses might also want to redefine match:inContext: and copyInContext: to do parse tree searching and replacing.Subclasses that contain other nodes should override equalTo:withMapping: to compare nodes while ignoring renaming temporary variables, and children that returns a collection of our children nodes.Instance Variables:	comments	<Collection of: Interval>	the intervals in the source that have comments for this node	parent	<RBProgramNode>	the node we're contained inShared Variables:	FormatterClass	<Behavior>	the formatter class that is used when we are formatted!!RBDoItNode class methodsFor: 'instance creation' stamp: 'ajh 3/11/2003 19:08'!body: aSequenceNode	^ self new body: aSequenceNode! !!RBDoItNode methodsFor: 'comparing' stamp: 'ajh 2/26/2003 18:35'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	(self body = anObject body) ifFalse: [^false].	^true! !!RBDoItNode methodsFor: 'visitor' stamp: 'ajh 2/26/2003 18:31'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptDoItNode: self! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!addNode: aNode 	^body addNode: aNode! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!addReturn	body addReturn! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!addSelfReturn	^body addSelfReturn! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!body	^body! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!body: stmtsNode 	body := stmtsNode.	body parent: self! !!RBDoItNode methodsFor: 'accessing' stamp: 'md 6/29/2005 12:21'!byteSurgeon	byteSurgeon ifNil: [byteSurgeon := false].	^byteSurgeon! !!RBDoItNode methodsFor: 'accessing' stamp: 'md 6/29/2005 12:20'!byteSurgeon: boolean	byteSurgeon := boolean.! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:28'!children	^ {self body}! !!RBDoItNode methodsFor: 'matching' stamp: 'ajh 2/26/2003 18:24'!copyInContext: aDictionary 	^(self class new)		body: (body copyInContext: aDictionary);		source: (aDictionary at: '-source-');		yourself! !!RBDoItNode methodsFor: 'comparing' stamp: 'ajh 2/26/2003 18:35'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	(self body equalTo: anObject body withMapping: aDictionary) 		ifFalse: [^false].	^self primitiveSources = anObject primitiveSources! !!RBDoItNode methodsFor: 'semantics' stamp: 'ajh 7/8/2004 20:56'!freeNames	"Filter out hidden ones that have space in there name such as 'top env'"	^ ((self freeVars collect: [:var | var name])		reject: [:name | name includes: $ ]) asSortedCollection! !!RBDoItNode methodsFor: 'semantics' stamp: 'ajh 7/8/2004 20:59'!freeVars	"Return children variable node bindings that refer to variables outside my scope (ignoring global vars)"	| freeVars |	freeVars := Set new.	scope := self owningScope.	self nodesDo: [:node | | var |		(node isVariable or: [node isReturn and: [node binding notNil]]) ifTrue: [			var := node binding.			(scope hasOuter: var scope) ifTrue: [				var isGlobal ifFalse: [					freeVars add: var]]]].	^ freeVars! !!RBDoItNode methodsFor: 'comparing' stamp: 'ajh 2/26/2003 18:36'!hash	^ self body hash! !!RBDoItNode methodsFor: 'testing' stamp: 'ajh 6/29/2004 14:11'!isDoIt	^ true! !!RBDoItNode methodsFor: 'testing' stamp: 'ajh 2/26/2003 18:22'!isLast: aNode 	^body isLast: aNode! !!RBDoItNode methodsFor: 'testing' stamp: 'ajh 2/26/2003 18:22'!lastIsReturn	^body lastIsReturn! !!RBDoItNode methodsFor: 'matching' stamp: 'ajh 2/26/2003 18:28'!match: aNode inContext: aDictionary 	self class == aNode class ifFalse: [^false].	aDictionary at: '-source-' put: aNode source.	^ body match: aNode body inContext: aDictionary! !!RBDoItNode methodsFor: 'semantics' stamp: 'ajh 6/30/2004 14:07'!owningBlock	^ self! !!RBDoItNode methodsFor: 'semantics' stamp: 'ajh 3/13/2003 04:25'!owningScope	^ scope! !!RBDoItNode methodsFor: 'copying' stamp: 'pmm 9/19/2005 11:29'!postCopy	super postCopy.	body := body copy.	body parent: self.! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!primitiveSources	^self tags 		collect: [:each | self source copyFrom: each first to: each last]! !!RBDoItNode methodsFor: 'printing' stamp: 'ajh 2/26/2003 18:22'!printOn: aStream	aStream nextPutAll: self formattedCode! !!RBDoItNode methodsFor: 'testing' stamp: 'ajh 2/26/2003 18:22'!references: aVariableName 	^body references: aVariableName! !!RBDoItNode methodsFor: 'replacing' stamp: 'ajh 2/26/2003 18:57'!replaceNode: aNode withNode: anotherNode	aNode == body ifTrue: [self body: anotherNode].! !!RBDoItNode methodsFor: 'semantics' stamp: 'ajh 3/16/2003 08:33'!scope	^ scope ifNil: [		self verifyIn: nil parseScope.		scope	  ]! !!RBDoItNode methodsFor: 'semantics' stamp: 'ajh 3/17/2003 15:34'!scope: aSemScope	scope := aSemScope! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!source	^source! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!source: anObject	source := anObject! !!RBDoItNode methodsFor: 'debugging' stamp: 'ajh 6/29/2004 14:24'!sourceMap	"Return a mapping from bytecode pcs to source code ranges"	^ self ir sourceMap! !!RBDoItNode methodsFor: 'printing' stamp: 'ajh 6/29/2004 14:31'!sourceText	^ (self source ifNil: [self formattedCode]) asText! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!start	^1! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!stop	^source size! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!tags	^tags isNil ifTrue: [#()] ifFalse: [tags]! !!RBDoItNode methodsFor: 'accessing' stamp: 'ajh 2/26/2003 18:22'!tags: aCollectionOfIntervals 	tags := aCollectionOfIntervals! !!RBDoItNode methodsFor: 'debugging' stamp: 'ajh 6/29/2004 16:06'!tempNames	"All temp names in context order"	^ self scope tempVars allButFirst "without receiver" collect: [:var | var name]! !!RBDoItNode methodsFor: 'testing' stamp: 'ajh 2/26/2003 18:22'!uses: aNode 	^body == aNode and: [aNode lastIsReturn]! !!RBMethodNode commentStamp: 'md 8/9/2005 14:58' prior: 0!RBMethodNode is the AST that represents a Smalltalk method.Instance Variables:	arguments	<SequenceableCollection of: RBVariableNode>	the arguments to the method	body	<BRSequenceNode>	the body/statements of the method	nodeReplacements	<Dictionary>	a dictionary of oldNode -> newNode replacements	replacements	<Collection of: RBStringReplacement>	the collection of string replacements for each node replacement in the parse tree	selector	<Symbol | nil>	the method name (cached)	selectorParts	<SequenceableCollection of: RBValueToken>	the tokens for the selector keywords	source	<String>	the source we compiled	tags	<Collection of: Interval>	the source location of any resource/primitive tags!!RBMethodNode class methodsFor: 'instance creation'!selector: aSymbol arguments: variableNodes body: aSequenceNode 	^(self new)		arguments: variableNodes;		selector: aSymbol;		body: aSequenceNode;		yourself! !!RBMethodNode class methodsFor: 'instance creation'!selector: aSymbol body: aSequenceNode 	^self 		selector: aSymbol		arguments: #()		body: aSequenceNode! !!RBMethodNode class methodsFor: 'instance creation' stamp: 'pmm 7/12/2006 15:20'!selectorParts: tokenCollection arguments: variableNodes 	^((tokenCollection anySatisfy: [:each | each isPatternVariable]) 		ifTrue: [RBPatternMethodNode] ifFalse: [RBMethodNode]) 		new selectorParts: tokenCollection arguments: variableNodes! !!RBMethodNode methodsFor: 'comparing' stamp: 'pmm 7/12/2006 15:42'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	(self selector = anObject selector and: [self body = anObject body]) 		ifFalse: [^false].	^self arguments = anObject arguments! !!RBMethodNode methodsFor: 'visitor'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptMethodNode: self! !!RBMethodNode methodsFor: 'accessing'!addNode: aNode 	^body addNode: aNode! !!RBMethodNode methodsFor: 'accessing' stamp: 'ms 7/26/2006 21:52'!addPragma: aPragma	self properties addPragma: aPragma! !!RBMethodNode methodsFor: 'accessing'!addReturn	body addReturn! !!RBMethodNode methodsFor: 'accessing'!addSelfReturn	^body addSelfReturn! !!RBMethodNode methodsFor: 'replacing' stamp: 'ajh 3/13/2003 16:13'!adjustPositionsAfter: sourcePos by: delta	"Slide token positions after sourcePos by delta"	selectorParts do: [:token |		token start > sourcePos ifTrue: [			token start: token start + delta]	].	super adjustPositionsAfter: sourcePos by: delta.! !!RBMethodNode methodsFor: 'accessing'!allArgumentVariables	^(self argumentNames asOrderedCollection)		addAll: super allArgumentVariables;		yourself! !!RBMethodNode methodsFor: 'accessing'!allDefinedVariables	^(self argumentNames asOrderedCollection) addAll: super allDefinedVariables;		yourself! !!RBMethodNode methodsFor: 'accessing'!argumentNames	^self arguments collect: [:each | each name]! !!RBMethodNode methodsFor: 'accessing'!arguments	^arguments! !!RBMethodNode methodsFor: 'accessing'!arguments: variableNodes 	arguments := variableNodes.	arguments do: [:each | each parent: self]! !!RBMethodNode methodsFor: 'copying' stamp: 'ajh 3/3/2003 15:28'!asBlock	^ (RBBlockNode		arguments: arguments		body: body)		privIR: ir;		scope: scope! !!RBMethodNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:31'!basicFirstToken		^self selectorParts first! !!RBMethodNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:32'!basicLastToken		^self body lastToken ifNil:[^(RBPatternMethodNode selectorParts: self selectorParts arguments: self arguments) lastToken]! !!RBMethodNode methodsFor: 'accessing'!body	^body! !!RBMethodNode methodsFor: 'accessing'!body: stmtsNode 	body := stmtsNode.	body parent: self! !!RBMethodNode methodsFor: 'private'!buildSelector	| selectorStream |	selectorStream := WriteStream on: (String new: 50).	selectorParts do: [:each | selectorStream nextPutAll: each value].	^selectorStream contents asSymbol! !!RBMethodNode methodsFor: 'accessing' stamp: 'ms 9/11/2006 15:28'!children	^(self arguments copyWith: self body) addAll: (self pragmas copy); yourself! !!RBMethodNode methodsFor: 'matching'!copyInContext: aDictionary 	^(self class new)		selectorParts: (selectorParts collect: [:each | each removePositions]);		arguments: (arguments collect: [:each | each copyInContext: aDictionary]);		body: (body copyInContext: aDictionary);		source: (aDictionary at: '-source-');		yourself! !!RBMethodNode methodsFor: 'testing' stamp: 'pmm 7/12/2006 15:18'!defines: aName 	^arguments anySatisfy: [:each | each name = aName]! !!RBMethodNode methodsFor: 'comparing' stamp: 'pmm 7/12/2006 15:43'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	(self selector = anObject selector 		and: [self body equalTo: anObject body withMapping: aDictionary]) 			ifFalse: [^false].	self arguments with: anObject arguments do: [ :first :second |		(first equalTo: second withMapping: aDictionary)			ifFalse: [^false].		aDictionary removeKey: first name ].	^self primitiveSources = anObject primitiveSources! !!RBMethodNode methodsFor: 'semantics' stamp: 'ajh 7/8/2004 20:56'!freeNames	"Filter out hidden ones that have space in there name such as 'top env'"	^ ((self freeVars collect: [:var | var name])		reject: [:name | name includes: $ ]) asSortedCollection! !!RBMethodNode methodsFor: 'semantics' stamp: 'ajh 7/8/2004 20:59'!freeVars	"Return children variable node bindings that refer to variables outside my scope (ignoring global vars)"	| freeVars |	freeVars := Set new.	scope := self owningScope.	self nodesDo: [:node | | var |		(node isVariable or: [node isReturn and: [node binding notNil]]) ifTrue: [			var := node binding.			(scope hasOuter: var scope) ifTrue: [				var isGlobal ifFalse: [					freeVars add: var]]]].	^ freeVars! !!RBMethodNode methodsFor: 'comparing'!hash	^(self selector hash bitXor: self body hash)		bitXor: self arguments hash! !!RBMethodNode methodsFor: 'testing'!isLast: aNode 	^body isLast: aNode! !!RBMethodNode methodsFor: 'testing'!isMethod	^true! !!RBMethodNode methodsFor: 'testing' stamp: 'ms 9/4/2006 00:11'!isPrimitive	^(self primitiveNode num = 0) not! !!RBMethodNode methodsFor: 'testing'!lastIsReturn	^body lastIsReturn! !!RBMethodNode methodsFor: 'accessing-token' stamp: 'ms 9/17/2006 14:21'!lastTokenOfPatternMethod		^(RBPatternMethodNode new selectorParts: self selectorParts arguments: self arguments) lastToken! !!RBMethodNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	self class == aNode class ifFalse: [^false].	aDictionary at: '-source-' put: aNode source.	self selector == aNode selector ifFalse: [^false].	^(self matchList: arguments		against: aNode arguments		inContext: aDictionary)			and: [body match: aNode body inContext: aDictionary]! !!RBMethodNode methodsFor: 'accessing' stamp: 'ajh 3/11/2003 19:58'!methodPatternStop	^ self arguments isEmpty		ifTrue: [self selectorParts first stop]		ifFalse: [self arguments last stop]! !!RBMethodNode methodsFor: 'semantics' stamp: 'ajh 6/30/2004 14:07'!owningBlock	^ self! !!RBMethodNode methodsFor: 'semantics' stamp: 'ajh 3/13/2003 04:25'!owningScope	^ scope! !!RBMethodNode methodsFor: 'copying' stamp: 'pmm 12/5/2005 10:00'!postCopy	super postCopy.	body := body copy.	body parent: self.	arguments := arguments collect: [:each |		each copy		parent: self;		yourself ]! !!RBMethodNode methodsFor: 'accessing' stamp: 'ms 9/3/2006 23:54'!pragmas 	^pragmas ifNil: [pragmas := OrderedCollection new]! !!RBMethodNode methodsFor: 'accessing' stamp: 'ms 9/4/2006 00:04'!pragmas: aRBPragmasNode	pragmas := aRBPragmasNode.	pragmas do:[:each | each parent: self]! !!RBMethodNode methodsFor: 'semantics' stamp: 'ajh 3/11/2003 18:27'!primitiveNode	^ primitiveNode ifNil: [PrimitiveNode null]! !!RBMethodNode methodsFor: 'semantics' stamp: 'md 10/2/2006 17:23'!primitiveNode: aPrimitiveNode      (primitiveNode isNil              or: [ primitiveNode num = 0 ]              or: [ primitiveNode num = aPrimitiveNode num ])                      ifTrue: [ primitiveNode := aPrimitiveNode ]                      ifFalse: [ self notify: 'Ambigous primitives' ]! !!RBMethodNode methodsFor: 'accessing' stamp: 'ajh 3/19/2003 22:02'!primitiveSources	| tgs text |	tgs := self tags.	tgs isEmpty ifTrue: [		text := self primitiveText.		text isEmpty ifTrue: [^ #()].		^ {text}	].	^ tgs collect: [:each | self source copyFrom: each first to: each last]! !!RBMethodNode methodsFor: 'accessing' stamp: 'ajh 3/11/2003 18:32'!primitiveStartPosition	| set |	set := self tags.	set isEmpty ifTrue: [^ 0].	set size > 1 ifTrue: [self error: 'only one primitive string expected'].	^ set first first! !!RBMethodNode methodsFor: 'accessing' stamp: 'ajh 3/19/2003 22:02'!primitiveText	| set |	self tags isEmpty ifTrue: [		^ self primitiveNode			ifNil: ['']			ifNotNil: [self primitiveNode sourceText]	].	set := self primitiveSources.	set size > 1 ifTrue: [self error: 'only one primitive string expected'].	^ set first! !!RBMethodNode methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self formattedCode! !!RBMethodNode methodsFor: 'accessing' stamp: 'ms 7/14/2006 16:14'!properties	^properties ifNil: [properties := MethodProperties  new]! !!RBMethodNode methodsFor: 'accessing' stamp: 'ms 7/13/2006 17:05'!properties: aMethodeProperties 	properties := aMethodeProperties! !!RBMethodNode methodsFor: 'testing'!references: aVariableName 	^body references: aVariableName! !!RBMethodNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	aNode == body ifTrue: [self body: anotherNode].	self arguments: (arguments 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !!RBMethodNode methodsFor: 'semantics' stamp: 'ajh 3/16/2003 08:32'!scope	^ scope ifNil: [		self verifyIn: nil parseScope.		scope	  ]! !!RBMethodNode methodsFor: 'semantics' stamp: 'ajh 2/26/2003 15:46'!scope: aSemMethodScope	scope := aSemMethodScope! !!RBMethodNode methodsFor: 'accessing'!selector	^selector isNil		ifTrue: [selector := self buildSelector]		ifFalse: [selector]! !!RBMethodNode methodsFor: 'accessing'!selector: aSelector 	| keywords numArgs |	keywords := aSelector keywords.	numArgs := aSelector numArgs.	numArgs == arguments size 		ifFalse: 			[self 				error: 'Attempting to assign selector with wrong number of arguments.'].	selectorParts := numArgs == 0 				ifTrue: [Array with: (RBIdentifierToken value: keywords first start: nil)]				ifFalse: 					[keywords first last == $: 						ifTrue: [keywords collect: [:each | RBKeywordToken value: each start: nil]]						ifFalse: [Array with: (RBBinarySelectorToken value: aSelector start: nil)]].	selector := aSelector! !!RBMethodNode methodsFor: 'private'!selectorParts	^selectorParts! !!RBMethodNode methodsFor: 'private'!selectorParts: tokenCollection 	selectorParts := tokenCollection! !!RBMethodNode methodsFor: 'initialize-release'!selectorParts: tokenCollection arguments: variableNodes 	selectorParts := tokenCollection.	self arguments: variableNodes! !!RBMethodNode methodsFor: 'accessing'!source	^source! !!RBMethodNode methodsFor: 'accessing'!source: anObject	source := anObject! !!RBMethodNode methodsFor: 'debugging' stamp: 'ajh 2/27/2003 23:58'!sourceMap	"Return a mapping from bytecode pcs to source code ranges"	^ self ir sourceMap! !!RBMethodNode methodsFor: 'printing' stamp: 'ajh 2/27/2003 22:44'!sourceText	^ (self source ifNil: [self formattedCode]) asText! !!RBMethodNode methodsFor: 'accessing'!start	^1! !!RBMethodNode methodsFor: 'accessing'!stop	^source size! !!RBMethodNode methodsFor: 'accessing'!tags	^tags isNil ifTrue: [#()] ifFalse: [tags]! !!RBMethodNode methodsFor: 'accessing' stamp: 'ms 7/27/2006 10:27'!tags: aCollectionOfIntervals 	tags := aCollectionOfIntervals! !!RBMethodNode methodsFor: 'debugging' stamp: 'ajh 6/29/2004 16:06'!tempNames	"All temp names in context order"	^ self scope tempVars allButFirst "without self" collect: [:var | var name]! !!RBMethodNode methodsFor: 'testing'!uses: aNode 	^body == aNode and: [aNode lastIsReturn]! !!RBPatternMethodNode commentStamp: 'md 8/9/2005 14:59' prior: 0!RBPatternMethodNode is a RBMethodNode that will match other method nodes without their selectors being equal. Instance Variables:	isList	<Boolean>	are we matching each keyword or matching all keywords together (e.g., `keyword1: would match a one argument method whereas `@keywords: would match 0 or more arguments)!!RBPatternMethodNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:32'!basicLastToken	self arguments ifEmpty: [^self selectorParts last] ifNotEmpty: [ ^self arguments last token]! !!RBPatternMethodNode methodsFor: 'matching'!copyInContext: aDictionary 	| selectors |	selectors := self isSelectorList 				ifTrue: [(aDictionary at: selectorParts first value) keywords]				ifFalse: [selectorParts collect: [:each | aDictionary at: each value]].	^(RBMethodNode new)		selectorParts: (selectors collect: 						[:each | 						(each last == $: ifTrue: [RBKeywordToken] ifFalse: [RBIdentifierToken]) 							value: each							start: nil]);		arguments: (self copyList: arguments inContext: aDictionary);		body: (body copyInContext: aDictionary);		source: (aDictionary at: '-source-');		yourself! !!RBPatternMethodNode methodsFor: 'testing-matching'!isPatternNode	^true! !!RBPatternMethodNode methodsFor: 'testing'!isSelectorList	^isList! !!RBPatternMethodNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	aNode class == self matchingClass ifFalse: [^false].	aDictionary at: '-source-' put: aNode source.	self isSelectorList ifTrue: 			[^(aDictionary at: selectorParts first value ifAbsentPut: [aNode selector])				= aNode selector and: 						[(aDictionary at: arguments first ifAbsentPut: [aNode arguments])							= aNode arguments and: [body match: aNode body inContext: aDictionary]]].	^(self matchArgumentsAgainst: aNode inContext: aDictionary)		and: [body match: aNode body inContext: aDictionary]! !!RBPatternMethodNode methodsFor: 'matching' stamp: 'pmm 7/12/2006 15:45'!matchArgumentsAgainst: aNode inContext: aDictionary 	self arguments size == aNode arguments size ifFalse: [^false].	(self matchSelectorAgainst: aNode inContext: aDictionary) 		ifFalse: [^false].	self arguments with: aNode arguments do: [ :first :second |		(first match: second inContext: aDictionary)			ifFalse: [^false]].	^true! !!RBPatternMethodNode methodsFor: 'matching'!matchSelectorAgainst: aNode inContext: aDictionary 	| keyword |	1 to: selectorParts size		do: 			[:i | 			keyword := selectorParts at: i.			(aDictionary at: keyword value				ifAbsentPut: 					[keyword isPatternVariable 						ifTrue: [(aNode selectorParts at: i) value]						ifFalse: [keyword value]]) 					= (aNode selectorParts at: i) value ifFalse: [^false]].	^true! !!RBPatternMethodNode methodsFor: 'private'!matchingClass	^RBMethodNode! !!RBPatternMethodNode methodsFor: 'initialize-release'!selectorParts: tokenCollection arguments: variableNodes 	super selectorParts: tokenCollection arguments: variableNodes.	isList := (tokenCollection first value at: 2) == self listCharacter! !!RBPragmaNode class methodsFor: 'instance creation' stamp: 'ms 9/17/2006 01:50'!pragma: aPragma spec: aSpec start: startPosition stop: stopPosition	^self new pragma: aPragma spec: aSpec start: startPosition stop: stopPosition! !!RBPragmaNode class methodsFor: 'instance creation' stamp: 'ms 9/17/2006 01:41'!pragma: aPragma spec: aSpec start: startPosition stop: stopPosition firstToken: fToken lastToken: lToken	^self new pragma: aPragma spec: aSpec start: startPosition stop: stopPosition firstToken: fToken lastToken: lToken	! !!RBPragmaNode methodsFor: 'visitor' stamp: 'ms 9/4/2006 00:06'!acceptVisitor: aProgramNodeVisitor		^aProgramNodeVisitor acceptPragmaNode: self! !!RBPragmaNode methodsFor: 'testing' stamp: 'pmm 10/4/2006 14:23'!isPrimitive		^#( primitive: primitive:module: )  includes: self pragma keyword! !!RBPragmaNode methodsFor: 'accessing' stamp: 'pmm 10/4/2006 14:12'!method	^self parent! !!RBPragmaNode methodsFor: 'accessing' stamp: 'ms 9/2/2006 18:30'!pragma		^pragma! !!RBPragmaNode methodsFor: 'accessing' stamp: 'ms 9/17/2006 01:50'!pragma: aPragma spec: aSpec start: startPosition stop: stopPosition		pragma := aPragma.	spec := aSpec.	start := startPosition.	stop := stopPosition! !!RBPragmaNode methodsFor: 'accessing' stamp: 'ms 9/17/2006 01:22'!pragma: aPragma spec: aSpec start: startPosition stop: stopPosition firstToken: fToken lastToken: lToken		pragma := aPragma.	spec := aSpec.	start := startPosition.	stop := stopPosition.	firstToken := fToken.	lastToken := lToken! !!RBPragmaNode methodsFor: 'accessing' stamp: 'pmm 10/4/2006 14:24'!primitive	^self isPrimitive		 ifTrue:[ PrimitiveNode new			num: self primitiveNumber;			spec: self spec;			yourself]		 ifFalse:[ PrimitiveNode null ]	! !!RBPragmaNode methodsFor: 'accessing' stamp: 'ms 9/3/2006 23:36'!primitiveNumber		^primitiveNumber ifNil:[primitiveNumber := 0]! !!RBPragmaNode methodsFor: 'accessing' stamp: 'ms 9/2/2006 18:42'!primitiveNumber: aNum		primitiveNumber := aNum! !!RBPragmaNode methodsFor: 'accessing' stamp: 'ms 9/2/2006 18:31'!spec		^spec! !!RBPragmaNode methodsFor: 'accessing' stamp: 'ms 9/2/2006 18:43'!start		^start! !!RBPragmaNode methodsFor: 'accessing' stamp: 'ms 9/2/2006 18:43'!stop		^stop! !!RBProgramNode class methodsFor: 'accessing' stamp: 'nk 1/29/2005 10:25'!colorFormatterClass	^Smalltalk at: #RBColorFormatter ifAbsent: [ self formatterClass ]! !!RBProgramNode class methodsFor: 'accessing'!formatterClass	^FormatterClass isNil ifTrue: [RBFormatter] ifFalse: [FormatterClass]! !!RBProgramNode class methodsFor: 'accessing'!formatterClass: aClass 	FormatterClass := aClass! !!RBProgramNode class methodsFor: 'accessing' stamp: 'md 10/11/2005 15:08'!initialize	"self initialize"	Preferences 		addPreference: #useRBASTForPrettyPrint		categories: #(#browsing )		default: false		balloonHelp: 'if set, the RB AST formatter will be used for pretty-printing'! !!RBProgramNode class methodsFor: 'accessing'!optimizedSelectors	^#(#== #ifTrue: #ifTrue:ifFalse: #ifFalse: #ifFalse:ifTrue: #whileTrue: #whileTrue #whileFalse: #whileFalse #to:do: #yourself #and: #or:)! !!RBProgramNode class methodsFor: 'accessing' stamp: 'md 10/11/2005 15:09'!unload	Preferences removePreference: #useRBASTForPrettyPrint ! !!RBProgramNode methodsFor: 'visitor' stamp: 'rr 4/10/2004 16:54'!acceptVisitor: aProgramNodeVisitor 	"self subclassResponsibility"! !!RBProgramNode methodsFor: 'replacing' stamp: 'ajh 3/13/2003 16:09'!adjustPositionsAfter: sourcePos by: delta	"Slide token positions after sourcePos by delta"	self children do: [:node |		node adjustPositionsAfter: sourcePos by: delta]! !!RBProgramNode methodsFor: 'accessing'!allArgumentVariables	| children |	children := self children.	children isEmpty ifTrue: [^#()].	^children inject: OrderedCollection new		into: 			[:vars :each | 			vars				addAll: each allArgumentVariables;				yourself]! !!RBProgramNode methodsFor: 'iterating' stamp: 'bh 3/13/2000 01:48'!allChildren	^self children inject:(OrderedCollection new addAll:self children; yourself) into:[:answer :child| answer addAll:child allChildren; yourself].! !!RBProgramNode methodsFor: 'accessing'!allDefinedVariables	| children |	children := self children.	children isEmpty ifTrue: [^#()].	^children inject: OrderedCollection new		into: 			[:vars :each | 			vars addAll: each allDefinedVariables;				yourself]! !!RBProgramNode methodsFor: 'accessing'!allTemporaryVariables	| children |	children := self children.	children isEmpty ifTrue: [^#()].	^children inject: OrderedCollection new		into: 			[:vars :each | 			vars				addAll: each allTemporaryVariables;				yourself]! !!RBProgramNode methodsFor: 'accessing'!asReturn	"Change the current node to a return node."	parent isNil ifTrue: [self error: 'Cannot change to a return without a parent node.'].	parent isSequence ifFalse: [self error: 'Parent node must be a sequence node.'].	(parent isLast: self)		ifFalse: [self error: 'Return node must be last.'].	^parent addReturn! !!RBProgramNode methodsFor: 'testing' stamp: 'pmm 7/12/2006 15:20'!assigns: aVariableName 	^self children anySatisfy: [:each | each assigns: aVariableName]! !!RBProgramNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:28'!basicFirstToken	^self subclassResponsibility! !!RBProgramNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:29'!basicLastToken	^self subclassResponsibility! !!RBProgramNode methodsFor: 'querying'!bestNodeFor: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	selectedChildren := self children 				select: [:each | each intersectsInterval: anInterval].	^selectedChildren size == 1 		ifTrue: [selectedChildren first bestNodeFor: anInterval]		ifFalse: [self]! !!RBProgramNode methodsFor: 'accessing'!blockVariables	^parent isNil		ifTrue: [#()]		ifFalse: [parent blockVariables]! !!RBProgramNode methodsFor: 'testing-matching' stamp: 'pmm 7/12/2006 16:06'!canMatchMethod: aCompiledMethod 	^self sentMessages allSatisfy: [:each | 		(self class optimizedSelectors includes: each) 			or: [aCompiledMethod refersToLiteral: each]].! !!RBProgramNode methodsFor: 'meta variable-accessing'!cascadeListCharacter	^$;! !!RBProgramNode methodsFor: 'accessing'!children	^#()! !!RBProgramNode methodsFor: 'enumeration'!collect: aBlock 	"Hacked to fit collection protocols"	^aBlock value: self! !!RBProgramNode methodsFor: 'accessing' stamp: 'nk 1/29/2005 10:24'!colorFormatterClass	^self class colorFormatterClass! !!RBProgramNode methodsFor: 'accessing' stamp: 'nk 1/29/2005 10:23'!colorizedFormattedCode	^self colorFormatterClass new format: self! !!RBProgramNode methodsFor: 'accessing' stamp: 'ajh 3/17/2003 00:28'!comment	^ (comments isNil or: [comments isEmpty])		ifTrue: [nil]		ifFalse: [comments first]! !!RBProgramNode methodsFor: 'accessing'!comments	^comments isNil		ifTrue: [#()]		ifFalse: [comments]! !!RBProgramNode methodsFor: 'accessing'!comments: aCollection	comments := aCollection! !!RBProgramNode methodsFor: 'testing'!containedBy: anInterval 	^anInterval first <= self start and: [anInterval last >= self stop]! !!RBProgramNode methodsFor: 'testing' stamp: 'pmm 7/12/2006 15:21'!containsReturn	^self children anySatisfy: [:each | each containsReturn]! !!RBProgramNode methodsFor: 'copying'!copyCommentsFrom: aNode 	"Add all comments from aNode to us. If we already have the comment, then don't add it."	| newComments |	newComments := OrderedCollection new.	aNode nodesDo: [:each | newComments addAll: each comments].	self nodesDo: 			[:each | 			each comments do: [:comment | newComments remove: comment ifAbsent: []]].	newComments isEmpty ifTrue: [^self].	newComments := newComments asSortedCollection: [:a :b | a first < b first].	self comments: newComments! !!RBProgramNode methodsFor: 'matching'!copyInContext: aDictionary	^self copy! !!RBProgramNode methodsFor: 'matching'!copyList: matchNodes inContext: aDictionary 	| newNodes |	newNodes := OrderedCollection new.	matchNodes do: 			[:each | 			| object |			object := each copyInContext: aDictionary.			newNodes addAll: object].	^newNodes! !!RBProgramNode methodsFor: 'accessing' stamp: 'ajh 3/15/2003 15:17'!debugHighlightStart	^ self start! !!RBProgramNode methodsFor: 'accessing' stamp: 'ajh 3/15/2003 15:18'!debugHighlightStop	^ self stop! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ajh 3/15/2003 14:57'!decompileString	^ self formattedCode! !!RBProgramNode methodsFor: 'testing'!defines: aName	^false! !!RBProgramNode methodsFor: 'testing'!directlyUses: aNode	^true! !!RBProgramNode methodsFor: 'enumeration'!do: aBlock 	"Hacked to fit collection protocols"	aBlock value: self! !!RBProgramNode methodsFor: 'comparing'!equalTo: aNode exceptForVariables: variableNameCollection 	| dictionary |	dictionary := Dictionary new.	(self equalTo: aNode withMapping: dictionary) ifFalse: [^false].	dictionary keysAndValuesDo: 			[:key :value | 			(key = value or: [variableNameCollection includes: key]) ifFalse: [^false]].	^true! !!RBProgramNode methodsFor: 'comparing'!equalTo: aNode withMapping: aDictionary 	^self = aNode! !!RBProgramNode methodsFor: 'testing'!evaluatedFirst: aNode 	self children do: 			[:each | 			each == aNode ifTrue: [^true].			each isImmediate ifFalse: [^false]].	^false! !!RBProgramNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:28'!firstToken	^firstToken ifNil:[^self basicFirstToken] ! !!RBProgramNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 07:50'!firstToken: aToken	firstToken := aToken! !!RBProgramNode methodsFor: 'accessing'!formattedCode	^self formatterClass new format: self! !!RBProgramNode methodsFor: 'accessing'!formatterClass	^self class formatterClass! !!RBProgramNode methodsFor: 'testing' stamp: 'pmm 9/24/2005 10:53'!hasParent	^self parent notNil! !!RBProgramNode methodsFor: 'initialize' stamp: 'ms 9/19/2006 13:14'!initialize		comments := OrderedCollection new! !!RBProgramNode methodsFor: 'testing'!intersectsInterval: anInterval 	^(anInterval first between: self start and: self stop) 		or: [self start between: anInterval first and: anInterval last]! !!RBProgramNode methodsFor: 'testing' stamp: 'ajh 2/25/2003 14:34'!isArray	^false! !!RBProgramNode methodsFor: 'testing'!isAssignment	^false! !!RBProgramNode methodsFor: 'testing'!isBlock	^false! !!RBProgramNode methodsFor: 'testing'!isCascade	^false! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ajh 3/4/2003 00:50'!isCaseBranch	^ false! !!RBProgramNode methodsFor: 'testing'!isDirectlyUsed	"This node is directly used as an argument, receiver, or part of an assignment."	^parent isNil		ifTrue: [false]		ifFalse: [parent directlyUses: self]! !!RBProgramNode methodsFor: 'testing' stamp: 'ajh 6/29/2004 14:12'!isDoIt	^ false! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ajh 3/2/2003 23:22'!isDup	^ false! !!RBProgramNode methodsFor: 'testing'!isEvaluatedFirst	"Return true if we are the first thing evaluated in this statement."	^parent isNil or: [parent isSequence or: [parent evaluatedFirst: self]]! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ajh 3/2/2003 23:22'!isGoto	^ false! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ajh 3/1/2003 20:12'!isIf	^ false! !!RBProgramNode methodsFor: 'testing'!isImmediate	^false! !!RBProgramNode methodsFor: 'inline' stamp: 'ajh 2/25/2003 19:48'!isInline	^ false! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ajh 3/2/2003 23:22'!isLabel	^ false! !!RBProgramNode methodsFor: 'testing'!isLast: aNode 	| children |	children := self children.	^children isEmpty not and: [children last == aNode]! !!RBProgramNode methodsFor: 'testing-matching'!isList	^false! !!RBProgramNode methodsFor: 'testing'!isLiteral	^false! !!RBProgramNode methodsFor: 'testing' stamp: 'ajh 3/3/2003 22:28'!isLiteral: valueTestBlock	^false! !!RBProgramNode methodsFor: 'testing'!isMessage	^false! !!RBProgramNode methodsFor: 'testing'!isMethod	^false! !!RBProgramNode methodsFor: 'testing-matching'!isPatternNode	^false! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ajh 3/2/2003 23:22'!isPop	^ false! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ajh 3/3/2003 18:42'!isPseudo	^ false! !!RBProgramNode methodsFor: 'decompiling' stamp: 'ajh 3/23/2003 22:23'!isPseudoSend	^ false! !!RBProgramNode methodsFor: 'testing'!isReturn	^false! !!RBProgramNode methodsFor: 'testing'!isSequence	^false! !!RBProgramNode methodsFor: 'testing'!isUsed	"Answer true if this node could be used as part of another expression. For example, you could use the 	result of this node as a receiver of a message, an argument, the right part of an assignment, or the 	return value of a block. This differs from isDirectlyUsed in that it is conservative since it also includes 	return values of blocks."	^parent isNil		ifTrue: [false]		ifFalse: [parent uses: self]! !!RBProgramNode methodsFor: 'testing'!isValue	^false! !!RBProgramNode methodsFor: 'testing'!isVariable	^false! !!RBProgramNode methodsFor: 'testing'!lastIsReturn	^self isReturn! !!RBProgramNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:30'!lastToken	^lastToken ifNil:[^self basicLastToken] ! !!RBProgramNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 07:50'!lastToken: aToken	lastToken :=  aToken! !!RBProgramNode methodsFor: 'meta variable-accessing'!listCharacter	^$@! !!RBProgramNode methodsFor: 'meta variable-accessing'!literalCharacter	^$#! !!RBProgramNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	^self = aNode! !!RBProgramNode methodsFor: 'matching'!matchList: matchNodes against: programNodes inContext: aDictionary 	^self		matchList: matchNodes		index: 1		against: programNodes		index: 1		inContext: aDictionary! !!RBProgramNode methodsFor: 'matching'!matchList: matchNodes index: matchIndex against: programNodes index: programIndex inContext: aDictionary 	| node currentIndex currentDictionary nodes |	matchNodes size < matchIndex ifTrue: [^programNodes size < programIndex].	node := matchNodes at: matchIndex.	node isList 		ifTrue: 			[currentIndex := programIndex - 1.						[currentDictionary := aDictionary copy.			programNodes size < currentIndex or: 					[nodes := programNodes copyFrom: programIndex to: currentIndex.					(currentDictionary at: node ifAbsentPut: [nodes]) = nodes and: 							[(self 								matchList: matchNodes								index: matchIndex + 1								against: programNodes								index: currentIndex + 1								inContext: currentDictionary) 									ifTrue: 										[currentDictionary keysAndValuesDo: [:key :value | aDictionary at: key put: value].										^true].							false]]] 					whileFalse: [currentIndex := currentIndex + 1].			^false].	programNodes size < programIndex ifTrue: [^false].	(node match: (programNodes at: programIndex) inContext: aDictionary) 		ifFalse: [^false].	^self 		matchList: matchNodes		index: matchIndex + 1		against: programNodes		index: programIndex + 1		inContext: aDictionary! !!RBProgramNode methodsFor: 'querying' stamp: 'nk 2/24/2005 14:28'!methodNode	(parent isNil or: [self isMethod]) ifTrue: [^self].	^parent methodNode! !!RBProgramNode methodsFor: 'iterating'!nodesDo: aBlock 	aBlock value: self.	self children do: [:each | each nodesDo: aBlock]! !!RBProgramNode methodsFor: 'semantics' stamp: 'ajh 6/30/2004 14:08'!owningBlock	^ parent owningBlock! !!RBProgramNode methodsFor: 'semantics' stamp: 'ajh 3/13/2003 04:19'!owningScope	^ parent owningScope! !!RBProgramNode methodsFor: 'accessing'!parent	^parent! !!RBProgramNode methodsFor: 'accessing'!parent: anObject	parent := anObject! !!RBProgramNode methodsFor: 'accessing'!precedence	^6! !!RBProgramNode methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: self class name;		nextPut: $(;		nextPutAll: self formattedCode;		nextPut: $)! !!RBProgramNode methodsFor: 'testing-matching'!recurseInto	^false! !!RBProgramNode methodsFor: 'meta variable-accessing'!recurseIntoCharacter	^$`! !!RBProgramNode methodsFor: 'testing' stamp: 'pmm 7/12/2006 15:21'!references: aVariableName 	^self children anySatisfy: [:each | each references: aVariableName]! !!RBProgramNode methodsFor: 'replacing'!removeDeadCode	self children do: [:each | each removeDeadCode]! !!RBProgramNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	self error: 'I don''t store other nodes'! !!RBProgramNode methodsFor: 'replacing'!replaceWith: aNode 	parent isNil ifTrue: [self error: 'This node doesn''t have a parent'].	parent replaceNode: self withNode: aNode! !!RBProgramNode methodsFor: 'querying' stamp: 'ajh 2/27/2003 22:40'!root	^ parent		ifNil: [self]		ifNotNil: [parent root]! !!RBProgramNode methodsFor: 'querying'!selfMessages	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: 'self `@msg: ``@args'		do: 			[:aNode :answer | 			answer				add: aNode selector;				yourself].	^searcher executeTree: self initialAnswer: Set new! !!RBProgramNode methodsFor: 'accessing'!sentMessages	| messages |	messages := Set new.	self children do: [:each | messages addAll: each sentMessages].	^messages! !!RBProgramNode methodsFor: 'printing' stamp: 'md 7/28/2006 15:25'!shortPrintOn: aStream 		aStream nextPutAll: self formattedCode.! !!RBProgramNode methodsFor: 'enumeration'!size	"Hacked to fit collection protocols"	^1! !!RBProgramNode methodsFor: 'accessing'!source	^parent notNil ifTrue: [parent source] ifFalse: [nil]! !!RBProgramNode methodsFor: 'accessing'!sourceInterval	^self start to: self stop! !!RBProgramNode methodsFor: 'accessing'!start	self subclassResponsibility! !!RBProgramNode methodsFor: 'meta variable-accessing'!statementCharacter	^$.! !!RBProgramNode methodsFor: 'querying'!statementNode	"Return your topmost node that is contained by a sequence node."	(parent isNil or: [parent isSequence]) ifTrue: [^self].	^parent statementNode! !!RBProgramNode methodsFor: 'accessing'!stop	self subclassResponsibility! !!RBProgramNode methodsFor: 'querying'!superMessages	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: 'super `@msg: ``@args'		do: 			[:aNode :answer | 			answer				add: aNode selector;				yourself].	^searcher executeTree: self initialAnswer: Set new! !!RBProgramNode methodsFor: 'accessing'!temporaryVariables	^parent isNil		ifTrue: [#()]		ifFalse: [parent temporaryVariables]! !!RBProgramNode methodsFor: 'testing'!uses: aNode	^true! !!RBProgramNode methodsFor: 'querying'!whichNodeIsContainedBy: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	selectedChildren := self children 				select: [:each | each intersectsInterval: anInterval].	^selectedChildren size == 1 		ifTrue: [selectedChildren first whichNodeIsContainedBy: anInterval]		ifFalse: [nil]! !!RBProgramNode methodsFor: 'querying'!whoDefines: aName 	^(self defines: aName)		ifTrue: [self]		ifFalse: [parent notNil				ifTrue: [parent whoDefines: aName]				ifFalse: [nil]]! !!RBPseudoNode commentStamp: 'ajh 6/27/2004 15:13' prior: 0!Used by IRDecompiler to represent intermediate nodes that eventually get reduced to real parse nodes.!!RBPseudoBlockNode methodsFor: 'accessing' stamp: 'md 11/17/2004 12:20'!arguments	^arguments! !!RBPseudoBlockNode methodsFor: 'accessing' stamp: 'md 11/17/2004 12:20'!arguments: aCollection	arguments := aCollection! !!RBPseudoBlockNode methodsFor: 'accessing' stamp: 'md 10/21/2004 14:58'!block	^ block.! !!RBPseudoBlockNode methodsFor: 'accessing' stamp: 'md 10/21/2004 14:59'!block: aSeqNum	block := aSeqNum.! !!RBPseudoBlockNode methodsFor: 'testing' stamp: 'md 10/21/2004 15:01'!isBlock	^true.! !!RBPseudoBlockNode methodsFor: 'accessing' stamp: 'md 10/21/2004 14:59'!successor	^successor.! !!RBPseudoBlockNode methodsFor: 'accessing' stamp: 'md 10/21/2004 14:59'!successor: aSeqNum	successor := aSeqNum.! !!RBPseudoDupNode methodsFor: 'testing' stamp: 'ajh 3/2/2003 23:24'!isDup	^ true! !!RBPseudoGotoNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/3/2003 21:20'!destination	^ destination! !!RBPseudoGotoNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/9/2003 13:44'!destination: seqNum	destination := seqNum! !!RBPseudoGotoNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/20/2003 01:16'!forValue	"true if sequence before me is for value, false if for effect"	^ forValue and: [self isRet not]! !!RBPseudoGotoNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/4/2003 22:18'!forValue: boolean	"true if sequence before me is for value, false if for effect"	forValue := boolean! !!RBPseudoGotoNode methodsFor: 'testing' stamp: 'ajh 3/2/2003 23:23'!isGoto	^ true! !!RBPseudoGotoNode methodsFor: 'testing' stamp: 'ajh 3/20/2003 19:05'!isRet	"is return"	^ self destination = #return! !!RBPseudoIfNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/3/2003 21:20'!boolean	^ boolean! !!RBPseudoIfNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/1/2003 23:08'!boolean: bool	boolean := bool! !!RBPseudoIfNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/3/2003 21:20'!destination	^ destination! !!RBPseudoIfNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/9/2003 13:45'!destination: seqNum	destination := seqNum! !!RBPseudoIfNode methodsFor: 'testing' stamp: 'ajh 3/1/2003 20:13'!isIf	^ true! !!RBPseudoIfNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/3/2003 21:20'!otherwise	^ otherwise! !!RBPseudoIfNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/2/2003 23:19'!otherwise: instructionSequence	otherwise := instructionSequence! !!RBPseudoLabelNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/3/2003 21:21'!destination	^ destination! !!RBPseudoLabelNode methodsFor: 'as yet unclassified' stamp: 'ajh 3/9/2003 13:45'!destination: seqNum	destination := seqNum! !!RBPseudoLabelNode methodsFor: 'testing' stamp: 'ajh 3/2/2003 23:23'!isLabel	^ true! !!RBPseudoNode methodsFor: 'visitor' stamp: 'ajh 3/17/2003 00:25'!acceptVisitor: aProgramNodeVisitor	^ aProgramNodeVisitor acceptPseudoNode: self! !!RBPseudoNode methodsFor: 'testing' stamp: 'md 10/21/2004 15:01'!isBlock	^false.! !!RBPseudoNode methodsFor: 'testing' stamp: 'ajh 3/3/2003 18:41'!isPseudo	^ true! !!RBPseudoNode methodsFor: 'accessing' stamp: 'ajh 3/20/2003 17:20'!mapInstr	^ mapInstr! !!RBPseudoNode methodsFor: 'accessing' stamp: 'ajh 3/20/2003 17:19'!mapInstr: irInstr	mapInstr := irInstr! !!RBPseudoPopNode methodsFor: 'testing' stamp: 'ajh 3/2/2003 23:23'!isPop	^ true! !!RBPseudoSendNode methodsFor: 'accessing' stamp: 'md 11/15/2004 18:07'!arguments	^arguments! !!RBPseudoSendNode methodsFor: 'accessing' stamp: 'md 11/15/2004 18:07'!arguments: aCollection	arguments:= aCollection.! !!RBPseudoSendNode methodsFor: 'testing' stamp: 'ajh 3/23/2003 22:23'!isPseudoSend	^ true! !!RBPseudoSendNode methodsFor: 'accessing' stamp: 'ajh 3/23/2003 22:23'!selector	^ selector! !!RBPseudoSendNode methodsFor: 'accessing' stamp: 'ajh 3/23/2003 22:23'!selector: aSelector	selector := aSelector! !!RBReturnNode commentStamp: 'md 8/9/2005 14:59' prior: 0!RBReturnNode is an AST node that represents a return expression.Instance Variables:	return	<Integer>	the position of the ^ character	value	<RBValueNode>	the value that is being returned!!RBReturnNode class methodsFor: 'instance creation'!return: returnInteger value: aValueNode 	^self new return: returnInteger value: aValueNode! !!RBReturnNode class methodsFor: 'instance creation'!value: aNode	^self return: nil value: aNode! !!RBReturnNode methodsFor: 'comparing'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^self value = anObject value! !!RBReturnNode methodsFor: 'visitor'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptReturnNode: self! !!RBReturnNode methodsFor: 'replacing' stamp: 'ajh 3/19/2003 16:16'!adjustPositionsAfter: sourcePos by: delta	"Slide token positions after sourcePos by delta"	self return: return + delta.	super adjustPositionsAfter: sourcePos by: delta.! !!RBReturnNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:34'!basicFirstToken		^self value firstToken! !!RBReturnNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:34'!basicLastToken		^self value lastToken! !!RBReturnNode methodsFor: 'semantics' stamp: 'ajh 7/8/2004 20:57'!binding	^  self homeBinding! !!RBReturnNode methodsFor: 'accessing'!children	^Array with: value! !!RBReturnNode methodsFor: 'testing'!containsReturn	^true! !!RBReturnNode methodsFor: 'matching'!copyInContext: aDictionary 	^(self class new) value: (value copyInContext: aDictionary); yourself! !!RBReturnNode methodsFor: 'comparing'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	^self value equalTo: anObject value withMapping: aDictionary! !!RBReturnNode methodsFor: 'comparing'!hash	^self value hash! !!RBReturnNode methodsFor: 'semantics' stamp: 'ajh 2/26/2003 14:48'!homeBinding	^  homeBinding! !!RBReturnNode methodsFor: 'semantics' stamp: 'ajh 2/26/2003 14:40'!homeBinding: aSemVar	homeBinding := aSemVar! !!RBReturnNode methodsFor: 'testing'!isReturn	^true! !!RBReturnNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	^value match: aNode value inContext: aDictionary! !!RBReturnNode methodsFor: 'copying' stamp: 'pmm 9/19/2005 11:30'!postCopy	super postCopy.	value := value copy.	value parent: self! !!RBReturnNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	value == aNode ifTrue: [self value: anotherNode]! !!RBReturnNode methodsFor: 'initialize-release' stamp: 'ajh 3/19/2003 13:51'!return: returnInteger	return := returnInteger! !!RBReturnNode methodsFor: 'initialize-release'!return: returnInteger value: aValueNode 	return := returnInteger.	self value: aValueNode! !!RBReturnNode methodsFor: 'accessing'!start	^return! !!RBReturnNode methodsFor: 'accessing'!stop	^value stop! !!RBReturnNode methodsFor: 'accessing'!value	^value! !!RBReturnNode methodsFor: 'accessing'!value: valueNode 	value := valueNode.	value parent: self! !!RBSequenceNode commentStamp: 'md 8/9/2005 14:59' prior: 0!RBSequenceNode is an AST node that represents a sequence of statements. Both RBBlockNodes and RBMethodNodes contain these.Instance Variables:	leftBar	<Integer | nil>	the position of the left | in the temporaries definition	periods	<SequenceableCollection of: Integer>	the positions of all the periods that separate the statements	rightBar	<Integer | nil>	the position of the right | in the temporaries definition	statements	<SequenceableCollection of: RBStatementNode>	the statement nodes	temporaries	<SequenceableCollection of: RBVariableNode>	the temporaries defined!!RBSequenceNode class methodsFor: 'instance creation'!leftBar: leftInteger temporaries: variableNodes rightBar: rightInteger 	^self new		leftBar: leftInteger		temporaries: variableNodes		rightBar: rightInteger! !!RBSequenceNode class methodsFor: 'instance creation'!statements: statementNodes 	^self temporaries: #() statements: statementNodes! !!RBSequenceNode class methodsFor: 'instance creation'!temporaries: variableNodes statements: statementNodes 	^(self new)		temporaries: variableNodes;		statements: statementNodes;		yourself! !!RBSequenceNode methodsFor: 'comparing' stamp: 'pmm 7/12/2006 15:45'!= anObject 	"Can't send = to the temporaries and statements collection since they might change from arrays to OCs"	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	self temporaries size = anObject temporaries size ifFalse: [^false].	^self temporaries = anObject temporaries		and: [ self statements = anObject statements ]! !!RBSequenceNode methodsFor: 'visitor'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptSequenceNode: self! !!RBSequenceNode methodsFor: 'adding nodes'!addNode: aNode 	aNode parent: self.	(statements isEmpty not and: [statements last isReturn])		ifTrue: [self error: 'Cannot add statement after return node'].	statements := statements asOrderedCollection add: aNode; yourself! !!RBSequenceNode methodsFor: 'adding nodes' stamp: 'pmm 9/19/2005 17:54'!addNode: aNode after: anotherNode 	| index |	index := self indexOfNode: anotherNode.	index = 0 ifTrue: [^self addNode: aNode].	statements := (statements asOrderedCollection)				add: aNode afterIndex: index;				yourself.	aNode parent: self! !!RBSequenceNode methodsFor: 'adding nodes'!addNode: aNode before: anotherNode 	| index |	index := self indexOfNode: anotherNode.	index = 0 ifTrue: [^self addNode: aNode].	statements := (statements asOrderedCollection)				add: aNode beforeIndex: index;				yourself.	aNode parent: self! !!RBSequenceNode methodsFor: 'adding nodes'!addNodeFirst: aNode 	aNode parent: self.	statements := (statements asOrderedCollection)				addFirst: aNode;				yourself! !!RBSequenceNode methodsFor: 'adding nodes'!addNodes: aCollection 	aCollection do: [:each | each parent: self].	(statements isEmpty not and: [statements last isReturn]) 		ifTrue: [self error: 'Cannot add statement after return node'].	statements := (statements asOrderedCollection)				addAll: aCollection;				yourself! !!RBSequenceNode methodsFor: 'adding nodes' stamp: 'pmm 9/24/2005 10:52'!addNodes: aCollection after: anotherNode 	aCollection inject: anotherNode into: [ :node :each |		self addNode: each after: node.		each ]! !!RBSequenceNode methodsFor: 'adding nodes'!addNodes: aCollection before: anotherNode 	aCollection do: [:each | self addNode: each before: anotherNode]! !!RBSequenceNode methodsFor: 'adding nodes'!addNodesFirst: aCollection 	aCollection do: [:each | each parent: self].	statements := (statements asOrderedCollection)				addAllFirst: aCollection;				yourself! !!RBSequenceNode methodsFor: 'accessing'!addReturn	| node |	statements isEmpty ifTrue: [^nil].	statements last isReturn ifTrue: [^statements last].	node := RBReturnNode value: statements last.	statements at: statements size put: node.	node parent: self.	^node! !!RBSequenceNode methodsFor: 'adding nodes'!addSelfReturn	| node |	self lastIsReturn ifTrue: [^self].	node := RBReturnNode value: (RBVariableNode named: 'self').	self addNode: node! !!RBSequenceNode methodsFor: 'adding nodes'!addTemporariesNamed: aCollection 	aCollection do: [:each | self addTemporaryNamed: each]! !!RBSequenceNode methodsFor: 'adding nodes'!addTemporaryNamed: aString 	| variableNode |	variableNode := RBVariableNode named: aString.	variableNode parent: self.	temporaries := temporaries copyWith: variableNode! !!RBSequenceNode methodsFor: 'accessing'!allDefinedVariables	^(self temporaryNames asOrderedCollection) addAll: super allDefinedVariables;		yourself! !!RBSequenceNode methodsFor: 'accessing'!allTemporaryVariables	^(self temporaryNames asOrderedCollection)		addAll: super allTemporaryVariables;		yourself! !!RBSequenceNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:35'!basicFirstToken		self temporaries 			ifEmpty: [self statements 							ifEmpty:[^nil] 							ifNotEmpty:[| stat | 				     					stat := OrderedCollection newFrom: self statements.					 					[stat first firstToken = nil] 												whileTrue: [stat removeFirst.															stat ifEmpty:[^nil]].										^stat first firstToken]]			ifNotEmpty: [^self temporaries first firstToken]! !!RBSequenceNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:36'!basicLastToken		self statements 		ifEmpty:[self temporaries 						ifEmpty:[^nil]						ifNotEmpty:[^self temporaries last lastToken]] 		ifNotEmpty:[ | stat | 				      stat := OrderedCollection newFrom: self statements.					 [stat last lastToken = nil] 							whileTrue: [stat removeLast.										stat ifEmpty:[self temporaries 														ifEmpty:[^nil]														ifNotEmpty:[^self temporaries last lastToken]]].					^stat last lastToken]! !!RBSequenceNode methodsFor: 'querying'!bestNodeFor: anInterval 	| node |	node := super bestNodeFor: anInterval.	node == self 		ifTrue: 			[(temporaries isEmpty and: [statements size == 1]) 				ifTrue: [^statements first]].	^node! !!RBSequenceNode methodsFor: 'accessing'!children	^(OrderedCollection new) addAll: self temporaries;		addAll: self statements;		yourself! !!RBSequenceNode methodsFor: 'matching'!copyInContext: aDictionary 	^(self class new)		temporaries: (self copyList: temporaries inContext: aDictionary);		statements: (self copyList: statements inContext: aDictionary);		yourself! !!RBSequenceNode methodsFor: 'testing' stamp: 'pmm 7/12/2006 15:21'!defines: aName 	^temporaries anySatisfy: [:each | each name = aName]! !!RBSequenceNode methodsFor: 'testing'!directlyUses: aNode 	^false! !!RBSequenceNode methodsFor: 'comparing' stamp: 'pmm 7/13/2006 18:38'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	self statements size == anObject statements size ifFalse: [^false].	self statements with: anObject statements do: [ :first :second |		(first equalTo: second withMapping: aDictionary)			ifFalse: [^false]].	aDictionary values asSet size = aDictionary size ifFalse: [^false].	"Not a one-to-one mapping"	self temporaries		do: [:each | aDictionary removeKey: each name ifAbsent: []].	^true! !!RBSequenceNode methodsFor: 'comparing'!hash	^self temporaries hash bitXor: (self statements isEmpty			ifTrue: [0]			ifFalse: [self statements first hash])! !!RBSequenceNode methodsFor: 'private'!indexOfNode: aNode 	"Try to find the node by first looking for ==, and then for ="	^(1 to: statements size) detect: [:each | (statements at: each) == aNode]		ifNone: [statements indexOf: aNode]! !!RBSequenceNode methodsFor: 'testing'!isLast: aNode 	| last |	statements isEmpty ifTrue: [^false].	last := statements last.	^last == aNode or: [last isMessage and: [(#(#ifTrue:ifFalse: #ifFalse:ifTrue:) includes: last selector)				and: [last arguments inject: false into: [:bool :each | bool or: [each isLast: aNode]]]]]! !!RBSequenceNode methodsFor: 'testing'!isSequence	^true! !!RBSequenceNode methodsFor: 'testing'!lastIsReturn	^statements isEmpty not and: [statements last lastIsReturn]! !!RBSequenceNode methodsFor: 'initialize-release'!leftBar: leftInteger temporaries: variableNodes rightBar: rightInteger 	leftBar := leftInteger.	self temporaries: variableNodes.	rightBar := rightInteger! !!RBSequenceNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	self class == aNode class ifFalse: [^false].	^(self matchList: temporaries		against: aNode temporaries		inContext: aDictionary) and: 				[self matchList: statements					against: aNode statements					inContext: aDictionary]! !!RBSequenceNode methodsFor: 'accessing'!periods: anObject	periods := anObject! !!RBSequenceNode methodsFor: 'copying' stamp: 'pmm 9/19/2005 11:31'!postCopy	super postCopy.	temporaries := temporaries collect: [:each |		each copy		parent: self;		yourself ].	statements := statements collect: [:each |		each copy		parent: self;		yourself ]! !!RBSequenceNode methodsFor: 'testing' stamp: 'pmm 7/12/2006 15:21'!references: aVariableName 	^statements anySatisfy: [:each | each references: aVariableName]! !!RBSequenceNode methodsFor: 'replacing' stamp: 'md 8/2/2005 22:25'!removeDeadCode	(self isUsed ifTrue: [statements size - 1] ifFalse: [statements size]) 		to: 1		by: -1		do: [:i | (statements at: i) isImmediate ifTrue: [statements removeAt: i]].	super removeDeadCode! !!RBSequenceNode methodsFor: 'replacing'!removeNode: aNode	self replaceNode: aNode withNodes: #()! !!RBSequenceNode methodsFor: 'accessing'!removeTemporaryNamed: aName 	temporaries := temporaries reject: [:each | each name = aName]! !!RBSequenceNode methodsFor: 'replacing' stamp: 'pmm 10/3/2005 11:28'!replaceNode: aNode withNode: anotherNode 	self statements: (statements 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]]).	self temporaries: (temporaries 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]]).	anotherNode parent: self! !!RBSequenceNode methodsFor: 'replacing'!replaceNode: aNode withNodes: aCollection 	| index newStatements |	index := self indexOfNode: aNode.	newStatements := OrderedCollection new: statements size + aCollection size.	1 to: index - 1 do: [:i | newStatements add: (statements at: i)].	newStatements addAll: aCollection.	index + 1 to: statements size		do: [:i | newStatements add: (statements at: i)].	aCollection do: [:each | each parent: self].	statements := newStatements! !!RBSequenceNode methodsFor: 'accessing'!start	^leftBar isNil 		ifTrue: [statements isEmpty ifTrue: [1] ifFalse: [statements first start]]		ifFalse: [leftBar]! !!RBSequenceNode methodsFor: 'accessing'!statements	^statements! !!RBSequenceNode methodsFor: 'accessing'!statements: stmtCollection 	statements := stmtCollection.	statements do: [:each | each parent: self]! !!RBSequenceNode methodsFor: 'accessing' stamp: 'ajh 3/16/2003 18:24'!stop	^ ((periods isNil or: [periods isEmpty])		ifTrue: [0]		ifFalse: [periods last])		max: (statements isEmpty				ifTrue: [0]				ifFalse: [statements last stop])! !!RBSequenceNode methodsFor: 'accessing'!temporaries	^temporaries! !!RBSequenceNode methodsFor: 'accessing'!temporaries: tempCollection 	temporaries := tempCollection.	temporaries do: [:each | each parent: self]! !!RBSequenceNode methodsFor: 'accessing'!temporaryNames	^temporaries collect: [:each | each name]! !!RBSequenceNode methodsFor: 'accessing'!temporaryVariables	^(super temporaryVariables asOrderedCollection) addAll: self temporaryNames;		yourself! !!RBSequenceNode methodsFor: 'testing'!uses: aNode 	statements isEmpty ifTrue: [^false].	aNode == statements last ifFalse: [^false].	^self isUsed! !!RBSequenceNode methodsFor: 'querying'!whichNodeIsContainedBy: anInterval 	| node |	node := super whichNodeIsContainedBy: anInterval.	node == self 		ifTrue: 			[(temporaries isEmpty and: [statements size == 1]) 				ifTrue: [^statements first]].	^node! !!RBValueNode commentStamp: 'md 8/9/2005 14:59' prior: 0!RBValueNode is an abstract class that represents a node that returns some value.Subclasses must implement the following messages:	accessing		startWithoutParentheses		stopWithoutParentheses	testing		needsParenthesisInstance Variables:	parentheses	<SequenceableCollection of: Inteval>	the positions of the parethesis around this node. We need a collection of intervals for stupid code such as "((3 + 4))" that has multiple parethesis around the same expression.!!RBArrayNode class methodsFor: 'instance creation' stamp: 'ls 1/23/2000 23:56'!leftBrace: leftBrace  rightBrace: rightBrace  statements: statements	^self new leftBrace: leftBrace  rightBrace: rightBrace  statements: statements! !!RBArrayNode class methodsFor: 'instance creation' stamp: 'ajh 3/4/2003 02:03'!statements: statements	^ self new statements: statements! !!RBArrayNode methodsFor: 'comparing' stamp: 'bh 4/3/2000 12:46'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^statements = anObject statements.! !!RBArrayNode methodsFor: 'visitor' stamp: 'ajh 3/17/2003 00:25'!acceptVisitor: aProgramNodeVisitor	^ aProgramNodeVisitor acceptArrayNode: self! !!RBArrayNode methodsFor: 'replacing' stamp: 'ajh 3/19/2003 16:14'!adjustPositionsAfter: sourcePos by: delta	"Slide token positions after sourcePos by delta"	self leftBrace: leftBrace + delta.	self rightBrace: rightBrace + delta.	super adjustPositionsAfter: sourcePos by: delta.! !!RBArrayNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:36'!basicFirstToken	self statements 		ifEmpty:[^nil] 		ifNotEmpty:[| stat | 		     		stat := self statements copy.			 		[stat first firstToken = nil] 							whileTrue: [stat removeFirst.										stat ifEmpty:[^nil]].					^stat first firstToken]! !!RBArrayNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:37'!basicLastToken	self statements 		ifEmpty:[^nil] 		ifNotEmpty:[ | stat | 				      stat := OrderedCollection newFrom: self statements.					 [stat last lastToken = nil] 							whileTrue: [stat removeLast.										stat ifEmpty:[^nil]].					^stat last lastToken]! !!RBArrayNode methodsFor: 'accessing' stamp: 'ls 1/24/2000 00:00'!children	^statements! !!RBArrayNode methodsFor: 'comparing' stamp: 'bh 4/3/2000 12:46'!hash	^statements hash.! !!RBArrayNode methodsFor: 'testing' stamp: 'ajh 2/25/2003 14:34'!isArray	^ true! !!RBArrayNode methodsFor: 'testing' stamp: 'ls 1/24/2000 00:28'!lastIsReturn	statements isEmpty ifTrue:[ ^false ].	^statements last lastIsReturn! !!RBArrayNode methodsFor: 'accessing' stamp: 'ls 1/24/2000 00:02'!leftBrace: leftBrace0	leftBrace := leftBrace0.! !!RBArrayNode methodsFor: 'initialization' stamp: 'ajh 3/4/2003 02:04'!leftBrace: leftBrace0  rightBrace: rightBrace0  statements: statements0	self leftBrace: leftBrace0.	self rightBrace: rightBrace0.	self statements: statements0.! !!RBArrayNode methodsFor: 'accessing' stamp: 'ls 1/24/2000 00:02'!periods: periods	"ignored"! !!RBArrayNode methodsFor: 'copying' stamp: 'pmm 2/24/2006 11:00'!postCopy	super postCopy.	statements := statements collect: [ :statement |		statement copy		parent: self;		yourself ]! !!RBArrayNode methodsFor: 'accessing' stamp: 'nk 3/3/2005 09:47'!precedence	^0! !!RBArrayNode methodsFor: 'replacing' stamp: 'ls 1/24/2000 00:27'!replaceNode: oldNode  withNode: newNode	statements := statements collect: [ :statement |		statement == oldNode 			ifTrue: [ newNode ]			ifFalse: [ statement ] ]! !!RBArrayNode methodsFor: 'accessing' stamp: 'ls 1/24/2000 00:02'!rightBrace: rightBrace0	rightBrace := rightBrace0.! !!RBArrayNode methodsFor: 'accessing' stamp: 'ls 1/23/2000 23:58'!start	^leftBrace! !!RBArrayNode methodsFor: 'accessing' stamp: 'rr 10/12/2005 14:59'!startWithoutParentheses 	^ leftBrace! !!RBArrayNode methodsFor: 'accessing' stamp: 'ls 1/24/2000 00:32'!statements	^statements! !!RBArrayNode methodsFor: 'accessing' stamp: 'dvf 11/12/2002 00:47'!statements: statements0 	statements ifNotNil: [self error: 'double initialization'].	statements := statements0.	statements do: [:statement | statement parent: self]! !!RBArrayNode methodsFor: 'accessing' stamp: 'ls 1/23/2000 23:58'!stop	^rightBrace! !!RBArrayNode methodsFor: 'accessing' stamp: 'rr 10/12/2005 14:59'!stopWithoutParentheses 	^ rightBrace! !!RBAssignmentNode commentStamp: 'md 8/9/2005 14:57' prior: 0!RBAssignmentNode is an AST node for assignment statementsInstance Variables:	assignment	<Integer>	position of the :=	value	<RBValueNode>	the value that we're assigning	variable	<RBVariableNode>	the variable being assigned!!RBAssignmentNode class methodsFor: 'instance creation'!variable: aVariableNode value: aValueNode 	^self 		variable: aVariableNode		value: aValueNode		position: nil! !!RBAssignmentNode class methodsFor: 'instance creation'!variable: aVariableNode value: aValueNode position: anInteger 	^self new		variable: aVariableNode		value: aValueNode		position: anInteger! !!RBAssignmentNode methodsFor: 'comparing'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^self variable = anObject variable and: [self value = anObject value]! !!RBAssignmentNode methodsFor: 'visitor'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptAssignmentNode: self! !!RBAssignmentNode methodsFor: 'testing'!assigns: aVariableName 	^variable name = aVariableName or: [value assigns: aVariableName]! !!RBAssignmentNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:38'!basicFirstToken		^self variable firstToken! !!RBAssignmentNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:38'!basicLastToken		^self value lastToken! !!RBAssignmentNode methodsFor: 'querying'!bestNodeFor: anInterval 	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	assignment isNil ifTrue: [^super bestNodeFor: anInterval].	((anInterval first between: assignment and: assignment + 1) 		or: [assignment between: anInterval first and: anInterval last]) 			ifTrue: [^self].	self children do: 			[:each | 			| node |			node := each bestNodeFor: anInterval.			node notNil ifTrue: [^node]]! !!RBAssignmentNode methodsFor: 'accessing'!children	^Array with: value with: variable! !!RBAssignmentNode methodsFor: 'matching'!copyInContext: aDictionary 	^(self class new) variable: (variable copyInContext: aDictionary);		value: (value copyInContext: aDictionary);		yourself! !!RBAssignmentNode methodsFor: 'testing'!directlyUses: aNode 	^aNode = value ifTrue: [true] ifFalse: [self isDirectlyUsed]! !!RBAssignmentNode methodsFor: 'comparing'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	^(self variable equalTo: anObject variable withMapping: aDictionary)		and: [self value equalTo: anObject value withMapping: aDictionary]! !!RBAssignmentNode methodsFor: 'comparing'!hash	^self variable hash bitXor: self value hash! !!RBAssignmentNode methodsFor: 'testing'!isAssignment	^true! !!RBAssignmentNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	^(variable match: aNode variable inContext: aDictionary)		and: [value match: aNode value inContext: aDictionary]! !!RBAssignmentNode methodsFor: 'copying' stamp: 'pmm 2/24/2006 11:00'!postCopy	super postCopy.	variable := variable copy.	variable parent: self.	value := value copy.	value parent: self! !!RBAssignmentNode methodsFor: 'accessing'!precedence	^5! !!RBAssignmentNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	value == aNode ifTrue: [self value: anotherNode].	variable == aNode ifTrue: [self variable: anotherNode]! !!RBAssignmentNode methodsFor: 'accessing'!startWithoutParentheses	^variable start! !!RBAssignmentNode methodsFor: 'accessing'!stopWithoutParentheses	^value stop! !!RBAssignmentNode methodsFor: 'testing'!uses: aNode 	^aNode = value ifTrue: [true] ifFalse: [self isUsed]! !!RBAssignmentNode methodsFor: 'accessing'!value	^value! !!RBAssignmentNode methodsFor: 'accessing'!value: aValueNode 	value := aValueNode.	value parent: self! !!RBAssignmentNode methodsFor: 'accessing'!variable	^variable! !!RBAssignmentNode methodsFor: 'accessing'!variable: varNode 	variable := varNode.	variable parent: self! !!RBAssignmentNode methodsFor: 'initialize-release'!variable: aVariableNode value: aValueNode position: anInteger 	self variable: aVariableNode.	self value: aValueNode.	assignment := anInteger! !!RBBlockNode commentStamp: 'md 8/9/2005 14:57' prior: 0!RBBlockNode is an AST node that represents a block "[...]".Instance Variables:	arguments	<SequenceableCollection of: RBVariableNode>	the arguments for the block	bar	<Integer | nil>	position of the | after the arguments	body	<RBSequenceNode>	the code inside the block	colons	<SequenceableCollection of: Integer>	positions of each : before each argument	left	<Integer>	position of [	right	<Integer>	position of ]!!RBBlockNode class methodsFor: 'instance creation'!arguments: argNodes body: sequenceNode 	^(self new)		arguments: argNodes;		body: sequenceNode;		yourself! !!RBBlockNode class methodsFor: 'instance creation'!body: sequenceNode 	^self arguments: #() body: sequenceNode! !!RBBlockNode methodsFor: 'comparing' stamp: 'pmm 7/12/2006 15:39'!= anObject	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	self body = anObject body ifFalse: [^false].	^self arguments = anObject arguments! !!RBBlockNode methodsFor: 'visitor'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptBlockNode: self! !!RBBlockNode methodsFor: 'replacing' stamp: 'ajh 3/19/2003 16:15'!adjustPositionsAfter: sourcePos by: delta	"Slide token positions after sourcePos by delta"	self left: left + delta.	self right: right + delta.	super adjustPositionsAfter: sourcePos by: delta.! !!RBBlockNode methodsFor: 'accessing'!allArgumentVariables	^(self argumentNames asOrderedCollection)		addAll: super allArgumentVariables;		yourself! !!RBBlockNode methodsFor: 'accessing'!allDefinedVariables	^(self argumentNames asOrderedCollection) addAll: super allDefinedVariables;		yourself! !!RBBlockNode methodsFor: 'accessing'!argumentNames	^self arguments collect: [:each | each name]! !!RBBlockNode methodsFor: 'accessing'!arguments	^arguments! !!RBBlockNode methodsFor: 'accessing'!arguments: argCollection 	arguments := argCollection.	arguments do: [:each | each parent: self]! !!RBBlockNode methodsFor: 'accessing'!bar	^bar! !!RBBlockNode methodsFor: 'accessing'!bar: anObject	bar := anObject! !!RBBlockNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:39'!basicFirstToken		self arguments ifEmpty: [^self body firstToken] ifNotEmpty: [^self arguments first firstToken]! !!RBBlockNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:39'!basicLastToken		^self body lastToken ifNil:[ self arguments ifEmpty:[^nil] ifNotEmpty:[^self arguments last firstToken]]! !!RBBlockNode methodsFor: 'accessing'!blockVariables	| vars |	vars := super blockVariables asOrderedCollection.	vars addAll: self argumentNames.	^vars! !!RBBlockNode methodsFor: 'accessing'!body	^body! !!RBBlockNode methodsFor: 'accessing'!body: stmtsNode 	body := stmtsNode.	body parent: self! !!RBBlockNode methodsFor: 'accessing'!children	^self arguments copyWith: self body! !!RBBlockNode methodsFor: 'accessing'!colons: anObject	colons := anObject! !!RBBlockNode methodsFor: 'matching'!copyInContext: aDictionary 	^(self class new)		arguments: (self copyList: arguments inContext: aDictionary);		body: (body copyInContext: aDictionary);		yourself! !!RBBlockNode methodsFor: 'testing' stamp: 'pmm 7/12/2006 15:17'!defines: aName 	^arguments anySatisfy: [:each | each name = aName]! !!RBBlockNode methodsFor: 'testing'!directlyUses: aNode 	^false! !!RBBlockNode methodsFor: 'comparing' stamp: 'pmm 7/12/2006 15:39'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	self arguments size = anObject arguments size ifFalse: [^false].	self arguments with: anObject arguments do: [ :first :second |		(first equalTo: second withMapping: aDictionary)			ifFalse: [^false]].	(self body equalTo: anObject body withMapping: aDictionary)		ifFalse: [^false].	self arguments do: [:each | aDictionary removeKey: each name].	^true! !!RBBlockNode methodsFor: 'semantics' stamp: 'ajh 7/8/2004 20:56'!freeNames	"Filter out hidden ones that have space in there name such as 'top env'"	^ ((self freeVars collect: [:var | var name])		reject: [:name | name includes: $ ]) asSortedCollection! !!RBBlockNode methodsFor: 'semantics' stamp: 'ajh 7/8/2004 20:59'!freeVars	"Return children variable node bindings that refer to variables outside my scope (ignoring global vars)"	| freeVars |	freeVars := Set new.	scope := self owningScope.	self nodesDo: [:node | | var |		(node isVariable or: [node isReturn and: [node binding notNil]]) ifTrue: [			var := node binding.			(scope hasOuter: var scope) ifTrue: [				var isGlobal ifFalse: [					freeVars add: var]]]].	^ freeVars! !!RBBlockNode methodsFor: 'comparing'!hash	^self arguments hash bitXor: self body hash! !!RBBlockNode methodsFor: 'testing'!isBlock	^true! !!RBBlockNode methodsFor: 'testing'!isImmediate	^true! !!RBBlockNode methodsFor: 'inline' stamp: 'ajh 3/13/2003 02:43'!isInlined	(parent isMessage and: [parent isInlineAndOr]) ifTrue: [^ true].	(parent isMessage and: [parent isInlineIf]) ifTrue: [^ true].	(parent isMessage and: [parent isInlineIfNil]) ifTrue: [^ true].	(parent isMessage and: [parent isInlineToDo]) ifTrue: [^ true].	(parent isMessage and: [parent isInlineWhile]) ifTrue: [^ true].	(parent isMessage and: [parent parent isArray and: [parent parent parent isMessage and: [parent parent parent isInlineCase]]]) ifTrue: [^ true].	(parent isMessage and: [parent isInlineCase]) ifTrue: [^ true].  "otherwise branch"	^ false! !!RBBlockNode methodsFor: 'testing'!isLast: aNode 	^body isLast: aNode! !!RBBlockNode methodsFor: 'accessing'!left	^left! !!RBBlockNode methodsFor: 'accessing'!left: anObject	left := anObject! !!RBBlockNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	^(self matchList: arguments		against: aNode arguments		inContext: aDictionary)			and: [body match: aNode body inContext: aDictionary]! !!RBBlockNode methodsFor: 'semantics' stamp: 'ajh 6/30/2004 14:07'!owningBlock	^ self! !!RBBlockNode methodsFor: 'semantics' stamp: 'ajh 7/8/2004 10:43'!owningScope	^ scope ifNil: ["inlined" ^ parent owningScope]! !!RBBlockNode methodsFor: 'copying' stamp: 'pmm 9/19/2005 11:32'!postCopy	super postCopy.	arguments := arguments collect: [:each |		each copy		parent: self;		yourself ].	body := body copy.	body parent: self.! !!RBBlockNode methodsFor: 'accessing'!precedence	^0! !!RBBlockNode methodsFor: 'testing'!references: aVariableName 	^body references: aVariableName! !!RBBlockNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	body == aNode ifTrue: [self body: anotherNode].	self arguments: (arguments 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !!RBBlockNode methodsFor: 'accessing'!right	^right! !!RBBlockNode methodsFor: 'accessing'!right: anObject	right := anObject! !!RBBlockNode methodsFor: 'semantics' stamp: 'ajh 2/26/2003 15:52'!scope	^ scope! !!RBBlockNode methodsFor: 'semantics' stamp: 'ajh 2/26/2003 15:53'!scope: aSemClosureScope	scope := aSemClosureScope! !!RBBlockNode methodsFor: 'debugging' stamp: 'ajh 2/28/2003 00:18'!sourceMap	"Return a mapping from bytecode pcs to source code ranges"	^ self ir sourceMap! !!RBBlockNode methodsFor: 'printing' stamp: 'ajh 3/17/2003 09:12'!sourceText	| text |	self parent ifNil: [^ self formattedCode asText].	text := [self root sourceText]		on: Error		do: [^ self formattedCode asText].	text addAttribute: TextColor gray from: 1 to: self start - 1.	text addAttribute: TextColor gray from: self stop + 1 to: text size.	^ text! !!RBBlockNode methodsFor: 'accessing'!startWithoutParentheses	^left! !!RBBlockNode methodsFor: 'accessing'!stopWithoutParentheses	^right! !!RBBlockNode methodsFor: 'debugging' stamp: 'ajh 6/29/2004 16:05'!tempNames	"All temp names in context order"	^ self scope tempVars allButFirst "without self" collect: [:var | var name]! !!RBBlockNode methodsFor: 'testing'!uses: aNode 	aNode = body ifFalse: [^false].	^parent isMessage		ifTrue: [(#(#ifTrue:ifFalse: #ifTrue: #ifFalse: #ifFalse:ifTrue:) includes: parent selector) not or: [parent isUsed]]		ifFalse: [self isUsed]! !!RBPatternBlockNode commentStamp: 'md 8/9/2005 14:56' prior: 0!RBPatternBlockNode is the node in matching parse trees (it never occurs in normal Smalltalk code) that executes a block to determine if a match occurs. valueBlock takes two arguments, the first is the actual node that we are trying to match against, and second node is the dictionary that contains all the metavariable bindings that the matcher has made thus far.Instance Variables:	valueBlock	<BlockClosure>	The block to execute when attempting to match this to a node.!!RBPatternBlockNode methodsFor: 'matching'!addArgumentWithNameBasedOn: aString 	| name index vars |	name := aString.	vars := self allDefinedVariables.	index := 0.	[vars includes: name] whileTrue: 			[index := index + 1.			name := name , index printString].	arguments := arguments copyWith: (RBVariableNode named: name)! !!RBPatternBlockNode methodsFor: 'matching'!copyInContext: aDictionary 	^self replacingBlock value: aDictionary! !!RBPatternBlockNode methodsFor: 'matching' stamp: 'nk 2/26/2005 11:05'!createBlock	| source |	source := self formattedCode.	^Compiler evaluate: source for: self logged: false! !!RBPatternBlockNode methodsFor: 'matching' stamp: 'pmm 7/12/2006 15:25'!createMatchingBlock	self arguments size > 2 		ifTrue: 			[self 				error: 'Search blocks can only contain arguments for the node and matching dictionary'].	self arguments isEmpty 		ifTrue: [self error: 'Search blocks must contain one argument for the node'].	self arguments size = 1 		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary'].	^self createBlock! !!RBPatternBlockNode methodsFor: 'matching' stamp: 'pmm 7/12/2006 15:25'!createReplacingBlock	self arguments size > 1 		ifTrue: 			[self 				error: 'Replace blocks can only contain an argument for the matching dictionary'].	self arguments isEmpty 		ifTrue: [self addArgumentWithNameBasedOn: 'aDictionary'].	^self createBlock! !!RBPatternBlockNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	^self matchingBlock value: aNode value: aDictionary! !!RBPatternBlockNode methodsFor: 'matching'!matchingBlock	^valueBlock isNil 		ifTrue: [valueBlock := self createMatchingBlock]		ifFalse: [valueBlock]! !!RBPatternBlockNode methodsFor: 'matching'!replacingBlock	^valueBlock isNil 		ifTrue: [valueBlock := self createReplacingBlock]		ifFalse: [valueBlock]! !!RBPatternBlockNode methodsFor: 'accessing'!sentMessages	^OrderedCollection new! !!RBCascadeNode commentStamp: 'md 8/9/2005 14:57' prior: 0!RBCascadeNode is an AST node for cascaded messages (e.g., "self print1 ; print2").Instance Variables:	messages	<SequenceableCollection of: RBMessageNode>	the messages 	semicolons	<SequenceableCollection of: Integer>	positions of the ; between messages!!RBCascadeNode class methodsFor: 'instance creation'!messages: messageNodes 	^self new messages: messageNodes! !!RBCascadeNode class methodsFor: 'instance creation'!messages: messageNodes semicolons: integerCollection 	^self new messages: messageNodes semicolons: integerCollection! !!RBCascadeNode methodsFor: 'comparing' stamp: 'pmm 7/12/2006 15:58'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^self messages = anObject messages! !!RBCascadeNode methodsFor: 'visitor'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptCascadeNode: self! !!RBCascadeNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:39'!basicFirstToken		^self messages first firstToken! !!RBCascadeNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:39'!basicLastToken		^self messages last lastToken! !!RBCascadeNode methodsFor: 'querying'!bestNodeFor: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	messages 		reverseDo: [:each | (each containedBy: anInterval) ifTrue: [^each]].	selectedChildren := (messages 				collect: [:each | each bestNodeFor: anInterval]) 					reject: [:each | each isNil].	^selectedChildren detect: [:each | true] ifNone: [nil]! !!RBCascadeNode methodsFor: 'accessing'!children	^self messages! !!RBCascadeNode methodsFor: 'matching'!copyInContext: aDictionary 	^(self class new) messages: (self copyList: messages inContext: aDictionary);		yourself! !!RBCascadeNode methodsFor: 'testing'!directlyUses: aNode 	^messages last = aNode and: [self isDirectlyUsed]! !!RBCascadeNode methodsFor: 'comparing' stamp: 'pmm 7/13/2006 18:38'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	self messages size == anObject messages size ifFalse: [^false].	self messages with: anObject messages do: [ :first :second |		(first equalTo: second withMapping: aDictionary)			ifFalse: [^false]].	^true! !!RBCascadeNode methodsFor: 'comparing' stamp: 'bh 4/10/2001 15:59'!hash	^self messages asArray hash! !!RBCascadeNode methodsFor: 'testing'!isCascade	^true! !!RBCascadeNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	^self matchList: messages		against: aNode messages		inContext: aDictionary! !!RBCascadeNode methodsFor: 'accessing'!messages	^messages! !!RBCascadeNode methodsFor: 'accessing'!messages: messageNodeCollection 	messages := messageNodeCollection.	messages do: [:each | each parent: self]! !!RBCascadeNode methodsFor: 'initialize-release'!messages: messageNodes semicolons: integerCollection 	self messages: messageNodes.	semicolons := integerCollection! !!RBCascadeNode methodsFor: 'copying' stamp: 'pmm 9/19/2005 11:32'!postCopy	super postCopy.	messages := messages collect: [:each |		each copy		parent: self;		yourself ]! !!RBCascadeNode methodsFor: 'accessing'!precedence	^4! !!RBCascadeNode methodsFor: 'accessing' stamp: 'ajh 2/25/2003 01:12'!receiver	^ self messages first receiver! !!RBCascadeNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	self messages: (messages 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !!RBCascadeNode methodsFor: 'accessing'!startWithoutParentheses	^messages first start! !!RBCascadeNode methodsFor: 'accessing'!stopWithoutParentheses	^messages last stop! !!RBCascadeNode methodsFor: 'testing'!uses: aNode 	^messages last = aNode and: [self isUsed]! !!RBCascadeNode methodsFor: 'querying'!whichNodeIsContainedBy: anInterval 	| selectedChildren |	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	messages 		reverseDo: [:each | (each containedBy: anInterval) ifTrue: [^each]].	selectedChildren := (messages 				collect: [:each | each whichNodeIsContainedBy: anInterval]) 					reject: [:each | each isNil].	^selectedChildren detect: [:each | true] ifNone: [nil]! !!RBLiteralNode commentStamp: 'md 8/9/2005 14:58' prior: 0!RBLiteralNode is an AST node that represents literals (e.g., #foo, #(1 2 3), true, etc.).Instance Variables:	token	<RBLiteralToken>	the token that contains the literal value as well as its source positions!!RBLiteralNode class methodsFor: 'instance creation'!literalToken: aLiteralToken 	^self new literalToken: aLiteralToken! !!RBLiteralNode class methodsFor: 'instance creation' stamp: 'ajh 2/27/2003 17:22'!literalToken: aLiteralToken value: object	^self new literalToken: aLiteralToken; value: object! !!RBLiteralNode class methodsFor: 'instance creation'!value: aValue 	^self literalToken: (RBLiteralToken value: aValue)! !!RBLiteralNode methodsFor: 'comparing'!= anObject 	self == anObject ifTrue: [^true].	self class == anObject class ifFalse: [^false].	self value class == anObject value class ifFalse: [^false].	^self value = anObject value! !!RBLiteralNode methodsFor: 'visitor'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptLiteralNode: self! !!RBLiteralNode methodsFor: 'replacing' stamp: 'ajh 3/13/2003 16:11'!adjustPositionsAfter: sourcePos by: delta	"Slide token positions after sourcePos by delta"	token start > sourcePos ifTrue: [		token start: token start + delta]! !!RBLiteralNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:40'!basicFirstToken		^self token! !!RBLiteralNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:40'!basicLastToken		^self token! !!RBLiteralNode methodsFor: 'matching'!copyInContext: aDictionary	^self class literalToken: token removePositions! !!RBLiteralNode methodsFor: 'comparing'!hash	^self value hash! !!RBLiteralNode methodsFor: 'testing'!isImmediate	^true! !!RBLiteralNode methodsFor: 'testing'!isLiteral	^true! !!RBLiteralNode methodsFor: 'testing' stamp: 'ajh 3/3/2003 22:29'!isLiteral: valueTestBlock	^ valueTestBlock value: self value! !!RBLiteralNode methodsFor: 'initialize-release'!literalToken: aLiteralToken 	token := aLiteralToken! !!RBLiteralNode methodsFor: 'accessing'!precedence	^0! !!RBLiteralNode methodsFor: 'accessing'!startWithoutParentheses	^token start! !!RBLiteralNode methodsFor: 'accessing'!stopWithoutParentheses	^token stop! !!RBLiteralNode methodsFor: 'accessing'!token	^token! !!RBLiteralNode methodsFor: 'accessing' stamp: 'md 9/1/2005 16:04'!value	^ token isRBToken		ifTrue: [token realValue]		ifFalse: [value]! !!RBLiteralNode methodsFor: 'initialize-release' stamp: 'ajh 2/27/2003 17:22'!value: object	value := object! !!RBMessageNode commentStamp: 'md 8/9/2005 14:58' prior: 0!RBMessageNode is an AST node that represents a message send.Instance Variables:	arguments	<SequenceableCollection of: RBValueNode>	our argument nodes	receiver	<RBValueNode>	the receiver's node	selector	<Symbol | nil>	the selector we're sending (cached)	selectorParts	<SequenceableCollection of: RBValueToken>	the tokens for each keyword!!RBMessageNode class methodsFor: 'instance creation'!receiver: aValueNode selector: aSymbol 	^self 		receiver: aValueNode		selector: aSymbol		arguments: #()! !!RBMessageNode class methodsFor: 'instance creation'!receiver: aValueNode selector: aSymbol arguments: valueNodes 	^(self new)		receiver: aValueNode;		arguments: valueNodes;		selector: aSymbol;		yourself! !!RBMessageNode class methodsFor: 'instance creation' stamp: 'pmm 7/12/2006 15:18'!receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 	^((keywordTokens anySatisfy: [:each | each isPatternVariable])		ifTrue: [RBPatternMessageNode] ifFalse: [RBMessageNode]) 		new 			receiver: aValueNode			selectorParts: keywordTokens			arguments: valueNodes! !!RBMessageNode methodsFor: 'comparing' stamp: 'pmm 7/12/2006 15:40'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	(self receiver = anObject receiver 		and: [self selector = anObject selector]) ifFalse: [^false].	^self arguments = anObject arguments! !!RBMessageNode methodsFor: 'visitor'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptMessageNode: self! !!RBMessageNode methodsFor: 'replacing' stamp: 'ajh 3/13/2003 16:12'!adjustPositionsAfter: sourcePos by: delta	"Slide token positions after sourcePos by delta"	selectorParts do: [:token |		token start > sourcePos ifTrue: [			token start: token start + delta]	].	super adjustPositionsAfter: sourcePos by: delta.! !!RBMessageNode methodsFor: 'accessing'!arguments	^arguments isNil		ifTrue: [#()]		ifFalse: [arguments]! !!RBMessageNode methodsFor: 'accessing'!arguments: argCollection 	arguments := argCollection.	arguments do: [:each | each parent: self]! !!RBMessageNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:44'!basicFirstToken		^self receiver firstToken! !!RBMessageNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:44'!basicLastToken		self arguments ifEmpty:[^self selectorParts last] ifNotEmpty: [^self arguments last lastToken]! !!RBMessageNode methodsFor: 'querying'!bestNodeFor: anInterval 	(self intersectsInterval: anInterval) ifFalse: [^nil].	(self containedBy: anInterval) ifTrue: [^self].	selectorParts do: 			[:each | 			((anInterval first between: each start and: each stop) 				or: [each start between: anInterval first and: anInterval last]) 					ifTrue: [^self]].	self children do: 			[:each | 			| node |			node := each bestNodeFor: anInterval.			node notNil ifTrue: [^node]]! !!RBMessageNode methodsFor: 'private'!buildSelector	| selectorStream |	selectorStream := WriteStream on: (String new: 50).	selectorParts do: [:each | selectorStream nextPutAll: each value].	^selectorStream contents asSymbol! !!RBMessageNode methodsFor: 'replacing' stamp: 'ajh 3/17/2003 13:11'!changeSelectorParts: tokenCollection	| root oldToken newToken |	root := self root.	1 to: selectorParts size do: [:i |		oldToken := selectorParts at: i.		newToken := tokenCollection at: i.		root adjustPositionsAfter: oldToken stop			by: newToken stop - oldToken stop.		selectorParts at: i put: newToken.	].	selector := nil.! !!RBMessageNode methodsFor: 'accessing'!children	^(OrderedCollection with: self receiver) addAll: self arguments;		yourself! !!RBMessageNode methodsFor: 'matching'!copyInContext: aDictionary 	^(self class new) receiver: (receiver copyInContext: aDictionary);		selectorParts: (selectorParts collect: [:each | each removePositions]);		arguments: (arguments collect: [:each | each copyInContext: aDictionary]);		yourself! !!RBMessageNode methodsFor: 'accessing' stamp: 'ajh 3/15/2003 15:18'!debugHighlightStart	^ self selectorParts first start! !!RBMessageNode methodsFor: 'accessing' stamp: 'ajh 3/15/2003 15:19'!debugHighlightStop	^ self stopWithoutParentheses! !!RBMessageNode methodsFor: 'comparing' stamp: 'pmm 7/12/2006 15:40'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	((self receiver equalTo: anObject receiver withMapping: aDictionary)		and: [self selector = anObject selector]) ifFalse: [^false].	self arguments with: anObject arguments do: [ :first :second |		(first equalTo: second withMapping: aDictionary)			ifFalse: [^false]].	^true! !!RBMessageNode methodsFor: 'comparing'!hash	^(self receiver hash bitXor: self selector hash)		bitXor: (self arguments isEmpty ifTrue: [0] ifFalse: [self arguments first hash])! !!RBMessageNode methodsFor: 'testing'!isBinary	^(self isUnary or: [self isKeyword]) not! !!RBMessageNode methodsFor: 'testing'!isCascaded	^parent notNil and: [parent isCascade]! !!RBMessageNode methodsFor: 'testing'!isFirstCascaded	^self isCascaded and: [parent messages first == self]! !!RBMessageNode methodsFor: 'inline' stamp: 'ajh 2/25/2003 19:47'!isInline	self isInlineAndOr ifTrue: [^ true].	self isInlineCase ifTrue: [^ true].	self isInlineIf ifTrue: [^ true].	self isInlineIfNil ifTrue: [^ true].	self isInlineToDo ifTrue: [^ true].	self isInlineWhile ifTrue: [^ true].	^ false! !!RBMessageNode methodsFor: 'inline' stamp: 'pmm 7/24/2006 21:57'!isInlineAndOr	self receiver isBlock ifTrue: [^ false].	self isCascaded ifTrue: [^ false].	(self selectorParts allSatisfy: [ :each |		| value |		value := each isRBToken			ifTrue: [each realValue]			ifFalse: [each value].		#(and: or:) includes: value ]) ifFalse: [^ false].	(self arguments allSatisfy: [ :each | each isBlock ])  ifFalse: [^ false].	(self arguments allSatisfy: [ :each | each arguments isEmpty ])			ifFalse: [				self notify: 'and: (or:) takes zero-arg block'.				^ false ].	^ true! !!RBMessageNode methodsFor: 'inline' stamp: 'ajh 3/14/2003 21:23'!isInlineCase	self isCascaded ifTrue: [^ false].	(#(caseOf: caseOf:otherwise:) includes: self selectorString) ifFalse: [^ false].	self arguments size = 2 ifTrue: [  "otherwise block"		self arguments last isBlock ifFalse: [^ false]].	self arguments first isArray ifFalse: [^ false].	self arguments first statements do: [:assoc |		(assoc isMessage and: [assoc selectorString = #->]) ifFalse: [^ false].		assoc receiver isBlock ifFalse: [^ false].		assoc receiver arguments isEmpty ifFalse: [self notify: 'caseOf: takes zero-arg blocks'. ^ false].		assoc arguments first isBlock ifFalse: [^ false].		assoc arguments first arguments isEmpty ifFalse: [self notify: 'caseOf: takes zero-arg blocks'].	].	^ true! !!RBMessageNode methodsFor: 'inline' stamp: 'ajh 3/14/2003 21:23'!isInlineIf	self receiver isBlock ifTrue: [^ false].	self isCascaded ifTrue: [^ false].	(#(ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:) includes: self selectorString) ifFalse: [^ false].	self arguments do: [:node | node isBlock ifFalse: [^ false]].	self arguments do: [:block |		block arguments isEmpty ifFalse: [			self notify: 'ifTrue:ifFalse: takes zero-arg blocks'.			^ false		]	].	^ true! !!RBMessageNode methodsFor: 'inline' stamp: 'pmm 7/24/2006 20:26'!isInlineIfNil	| assertNone assertOneOrNone |	self receiver isBlock ifTrue: [^ false].	self isCascaded ifTrue: [^ false].	(#(ifNil: ifNotNil: ifNil:ifNotNil: ifNotNil:ifNil: ifNotNilDo:) includes: self selectorString) ifFalse: [^ false].	self arguments do: [:node | node isBlock ifFalse: [^ false]].	assertNone := [:block | 		block arguments isEmpty ifFalse: [self notify: 'ifNil: takes zero-arg block'. ^ false]	].	assertOneOrNone := [:block | 		block arguments size > 1 ifTrue: [self notify: 'ifNotNil: takes zero- or one-arg block'. ^ false]	].	self selectorString caseOf: {		[#ifNil:] 		 	-> [assertNone value: self arguments first].		[#ifNil:ifNotNil:] 	-> [assertNone value: self arguments first. 							   assertOneOrNone value: self arguments last].		[#ifNotNil:] 		  	-> [assertOneOrNone value: self arguments first].		[#ifNotNilDo:] 		  	-> [assertOneOrNone value: self arguments first].		[#ifNotNil:ifNil:] 	-> [assertOneOrNone value: self arguments first. 							   assertNone value: self arguments last]	}.	^ true! !!RBMessageNode methodsFor: 'inline' stamp: 'ajh 3/17/2003 09:02'!isInlineToDo	| block step |	self receiver isBlock ifTrue: [^ false].	self isCascaded ifTrue: [^ false].	(#(to:do: to:by:do:) includes: self selectorString) ifFalse: [^ false].	self arguments first isBlock ifTrue: [^ false].	block := self arguments last.	block isBlock ifFalse: [^ false].	block arguments size = 1 ifFalse: [		self notify: 'to:do: block must take one arg'. ^ false].	(ParseTreeSearcher new		matches: block arguments first name , ' := `@object' do: [:n :a | true];		executeTree: block initialAnswer: false) ifTrue: [^ false].	self arguments size = 3 "to:by:do:" ifTrue: [		step := self arguments second.		step isLiteral ifFalse: [^ false].		step value = 0 ifTrue: [self notify: 'by: step can''t be zero'. ^ false].	].	^ true! !!RBMessageNode methodsFor: 'inline' stamp: 'ajh 3/14/2003 21:25'!isInlineWhile	self isCascaded ifTrue: [^ false].	(#(whileFalse: whileTrue: whileFalse whileTrue) includes: self selectorString) ifFalse: [^ false].	self receiver isBlock ifFalse: [^ false].	self receiver arguments isEmpty ifFalse: [self notify: 'while receiver block must have no arguments'. ^ false].	self arguments isEmpty ifFalse: [		self arguments first isBlock ifFalse: [^ false].		self arguments first arguments isEmpty ifFalse: [self notify: 'while takes a zero-arg block as its argument'. ^ false].	].	^ true! !!RBMessageNode methodsFor: 'testing'!isKeyword	^selectorParts first value last == $:! !!RBMessageNode methodsFor: 'testing'!isMessage	^true! !!RBMessageNode methodsFor: 'testing' stamp: 'pmm 1/9/2006 12:05'!isSelfSend	^(self receiver isVariable)		and: [ self receiver name = 'self' ]! !!RBMessageNode methodsFor: 'testing' stamp: 'pmm 4/24/2006 22:30'!isSuperSend	^receiver isVariable		and: [ receiver name = 'super' ]		and: [ receiver binding name = 'self']! !!RBMessageNode methodsFor: 'testing'!isUnary	^arguments isEmpty! !!RBMessageNode methodsFor: 'testing' stamp: 'ajh 2/25/2003 17:16'!lastIsReturn	^ ((#(ifTrue:ifFalse: ifFalse:ifTrue: ifNil:ifNotNil: ifNotNil:ifNil:) includes: self selector)		and: [arguments first isBlock and: 			[arguments first body lastIsReturn				and: [arguments last isBlock and: [arguments last body lastIsReturn]]]])	  or: [(#(caseOf: caseOf:otherwise:) includes: self selector)		and: [arguments first isArray and: [arguments first statements allSatisfy: [:assocMessage | assocMessage arguments first isBlock and: [assocMessage arguments first body lastIsReturn]]]			and: [selector == #caseOf: or: [arguments second isBlock and: [arguments second body lastIsReturn]]]]]! !!RBMessageNode methodsFor: 'matching' stamp: 'pmm 7/12/2006 15:41'!match: aNode inContext: aDictionary 	aNode class == self class ifFalse: [^false].	self selector == aNode selector ifFalse: [^false].	(receiver match: aNode receiver inContext: aDictionary) ifFalse: [^false].	self arguments with: aNode arguments do: [ :first :second |		(first match: second inContext: aDictionary)			ifFalse: [^false]].	^true! !!RBMessageNode methodsFor: 'copying' stamp: 'pmm 9/19/2005 11:32'!postCopy	super postCopy.	receiver := receiver copy.	receiver parent: self.	arguments := arguments collect: [:each |		each copy		parent: self;		yourself ]! !!RBMessageNode methodsFor: 'accessing'!precedence	^self isUnary ifTrue: [1] ifFalse: [self isKeyword ifTrue: [3] ifFalse: [2]]! !!RBMessageNode methodsFor: 'accessing'!receiver	^receiver! !!RBMessageNode methodsFor: 'accessing'!receiver: aValueNode 	receiver := aValueNode.	receiver parent: self! !!RBMessageNode methodsFor: 'initialize-release'!receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 	self receiver: aValueNode.	selectorParts := keywordTokens.	self arguments: valueNodes! !!RBMessageNode methodsFor: 'replacing'!replaceNode: aNode withNode: anotherNode 	"If we're inside a cascade node and are changing the receiver, change all the receivers"	receiver == aNode 		ifTrue: 			[self receiver: anotherNode.			(parent notNil and: [parent isCascade]) 				ifTrue: [parent messages do: [:each | each receiver: anotherNode]]].	self arguments: (arguments 				collect: [:each | each == aNode ifTrue: [anotherNode] ifFalse: [each]])! !!RBMessageNode methodsFor: 'accessing'!selector	^selector isNil		ifTrue: [selector := self buildSelector]		ifFalse: [selector]! !!RBMessageNode methodsFor: 'accessing'!selector: aSelector 	| keywords numArgs |	keywords := aSelector keywords.	numArgs := aSelector numArgs.	numArgs == arguments size 		ifFalse: 			[self 				error: 'Attempting to assign selector with wrong number of arguments.'].	selectorParts := numArgs == 0 				ifTrue: [Array with: (RBIdentifierToken value: keywords first start: nil)]				ifFalse: 					[keywords first last == $: 						ifTrue: [keywords collect: [:each | RBKeywordToken value: each start: nil]]						ifFalse: [Array with: (RBBinarySelectorToken value: aSelector start: nil)]].	selector := aSelector! !!RBMessageNode methodsFor: 'accessing' stamp: 'ajh 3/11/2003 23:16'!selectorPartIntervals	^ selectorParts collect: [:token | token sourceInterval]! !!RBMessageNode methodsFor: 'private'!selectorParts	^selectorParts! !!RBMessageNode methodsFor: 'private' stamp: 'ajh 3/11/2003 23:40'!selectorParts: tokenCollection 	selectorParts := tokenCollection.	selector := nil.! !!RBMessageNode methodsFor: 'accessing' stamp: 'ajh 3/11/2003 22:48'!selectorString	| selectorStream |	selectorStream := WriteStream on: (String new: 50).	selectorParts do: [:each | selectorStream nextPutAll: each value].	^ selectorStream contents! !!RBMessageNode methodsFor: 'accessing'!sentMessages	^(super sentMessages)		add: self selector;		yourself! !!RBMessageNode methodsFor: 'accessing'!startWithoutParentheses	^receiver start! !!RBMessageNode methodsFor: 'accessing'!stopWithoutParentheses	^arguments isEmpty 		ifTrue: [selectorParts first stop]		ifFalse: [arguments last stop]! !!RBPatternMessageNode commentStamp: 'md 8/9/2005 14:58' prior: 0!RBPatternMessageNode is a RBMessageNode that will match other message nodes without their selectors being equal. Instance Variables:	isCascadeList	<Boolean>	are we matching a list of message nodes in a cascaded message	isList	<Boolean>	are we matching each keyword or matching all keywords together (e.g., `keyword1: would match a one argument method whereas `@keywords: would match 0 or more arguments)!!RBPatternMessageNode methodsFor: 'matching'!copyInContext: aDictionary 	| selectors |	self isList ifTrue: [^aDictionary at: self].	selectors := self isSelectorList 				ifTrue: [(aDictionary at: selectorParts first value) keywords]				ifFalse: [selectorParts collect: [:each | aDictionary at: each value]].	^(RBMessageNode new)		receiver: (receiver copyInContext: aDictionary);		selectorParts: (selectors collect: 						[:each | 						(each last == $: ifTrue: [RBKeywordToken] ifFalse: [RBIdentifierToken]) 							value: each							start: nil]);		arguments: (self copyList: arguments inContext: aDictionary);		yourself! !!RBPatternMessageNode methodsFor: 'testing-matching'!isList	^isCascadeList and: [parent notNil and: [parent isCascade]]! !!RBPatternMessageNode methodsFor: 'testing-matching'!isPatternNode	^true! !!RBPatternMessageNode methodsFor: 'testing-matching'!isSelectorList	^isList! !!RBPatternMessageNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	aNode class == self matchingClass ifFalse: [^false].	(receiver match: aNode receiver inContext: aDictionary) ifFalse: [^false].	self isSelectorList ifTrue: 			[^(aDictionary at: selectorParts first value ifAbsentPut: [aNode selector])				== aNode selector and: 						[(aDictionary at: arguments first ifAbsentPut: [aNode arguments])							= aNode arguments]].	^self matchArgumentsAgainst: aNode inContext: aDictionary! !!RBPatternMessageNode methodsFor: 'matching' stamp: 'pmm 7/12/2006 15:44'!matchArgumentsAgainst: aNode inContext: aDictionary 	self arguments size == aNode arguments size ifFalse: [^false].	(self matchSelectorAgainst: aNode inContext: aDictionary) 		ifFalse: [^false].	self arguments with: aNode arguments do: [ :first :second |		(first match: second inContext: aDictionary)			ifFalse: [^false]].	^true! !!RBPatternMessageNode methodsFor: 'matching'!matchSelectorAgainst: aNode inContext: aDictionary 	| keyword |	1 to: selectorParts size		do: 			[:i | 			keyword := selectorParts at: i.			(aDictionary at: keyword value				ifAbsentPut: 					[keyword isPatternVariable 						ifTrue: [(aNode selectorParts at: i) value]						ifFalse: [keyword value]]) 					= (aNode selectorParts at: i) value ifFalse: [^false]].	^true! !!RBPatternMessageNode methodsFor: 'private'!matchingClass	^RBMessageNode! !!RBPatternMessageNode methodsFor: 'initialize-release'!receiver: aValueNode selectorParts: keywordTokens arguments: valueNodes 	| message |	super 		receiver: aValueNode		selectorParts: keywordTokens		arguments: valueNodes.	isCascadeList := isList := false.	message := keywordTokens first value.	2 to: message size		do: 			[:i | 			| character |			character := message at: i.			character == self listCharacter 				ifTrue: [isList := true]				ifFalse: 					[character == self cascadeListCharacter 						ifTrue: [isCascadeList := true]						ifFalse: [^self]]]! !!RBPatternMessageNode methodsFor: 'accessing'!sentMessages	^(super sentMessages)		remove: self selector ifAbsent: [];		yourself! !!RBValueNode methodsFor: 'accessing'!addParenthesis: anInterval 	parentheses isNil ifTrue: [parentheses := OrderedCollection new: 1].	parentheses add: anInterval! !!RBValueNode methodsFor: 'testing'!containedBy: anInterval 	^anInterval first <= self startWithoutParentheses 		and: [anInterval last >= self stopWithoutParentheses]! !!RBValueNode methodsFor: 'testing'!hasParentheses	^self parentheses isEmpty not! !!RBValueNode methodsFor: 'testing'!isValue	^true! !!RBValueNode methodsFor: 'accessing'!parentheses	^parentheses isNil		ifTrue: [#()]		ifFalse: [parentheses]! !!RBValueNode methodsFor: 'accessing'!start	^parentheses isNil 		ifTrue: [self startWithoutParentheses]		ifFalse: [parentheses last first]! !!RBValueNode methodsFor: 'accessing'!startWithoutParentheses	^self subclassResponsibility! !!RBValueNode methodsFor: 'accessing'!stop	^parentheses isNil		ifTrue: [self stopWithoutParentheses]		ifFalse: [parentheses last last]! !!RBValueNode methodsFor: 'accessing'!stopWithoutParentheses	^self subclassResponsibility! !!RBVariableNode commentStamp: 'md 8/9/2005 15:00' prior: 0!RBVariableNode is an AST node that represent a variable (global, inst var, temp, etc.).Instance Variables:	token	<RBValueToken>	the token that contains our name and position!!RBPatternVariableNode commentStamp: 'md 8/9/2005 14:59' prior: 0!RBPatternVariableNode is an AST node that is used to match several other types of nodes (literals, variables, value nodes, statement nodes, and sequences of statement nodes).The different types of matches are determined by the name of the node. If the name contains a # character, then it will match a literal. If it contains, a . then it matches statements. If it contains no extra characters, then it matches only variables. These options are mutually exclusive.The @ character can be combined with the name to match lists of items. If combined with the . character, then it will match a list of statement nodes (0 or more). If used without the . or # character, then it matches anything except for list of statements. Combining the @ with the # is not supported.Adding another ` in the name will cause the search/replace to look for more matches inside the node that this node matched. This option should not be used for top level expressions since that would cause infinite recursion (e.g., searching only for "``@anything").Instance Variables:	isAnything	<Boolean>	can we match any type of node	isList	<Boolean>	can we match a list of items (@)	isLiteral	<Boolean>	only match a literal node (#)	isStatement	<Boolean>	only match statements (.)	recurseInto	<Boolean>	search for more matches in the node we match (`)!!RBPatternVariableNode methodsFor: 'matching'!copyInContext: aDictionary 	^aDictionary at: self! !!RBPatternVariableNode methodsFor: 'initialize-release'!identifierToken: anIdentifierToken 	super identifierToken: anIdentifierToken.	self initializePatternVariables! !!RBPatternVariableNode methodsFor: 'initialize-release'!initializePatternVariables	| name |	name := self name.	isAnything := isList := isLiteral := isStatement := recurseInto := false.	2 to: name size		do: 			[:i | 			| character |			character := name at: i.			character == self listCharacter 				ifTrue: [isAnything := isList := true]				ifFalse: 					[character == self literalCharacter 						ifTrue: [isLiteral := true]						ifFalse: 							[character == self statementCharacter 								ifTrue: [isStatement := true]								ifFalse: 									[character == self recurseIntoCharacter 										ifTrue: [recurseInto := true]										ifFalse: [^self]]]]]! !!RBPatternVariableNode methodsFor: 'testing-matching'!isAnything	^isAnything! !!RBPatternVariableNode methodsFor: 'testing-matching'!isList	^isList! !!RBPatternVariableNode methodsFor: 'testing-matching'!isLiteral	^isLiteral! !!RBPatternVariableNode methodsFor: 'testing-matching'!isPatternNode	^true! !!RBPatternVariableNode methodsFor: 'testing-matching'!isStatement	^isStatement! !!RBPatternVariableNode methodsFor: 'matching'!match: aNode inContext: aDictionary 	self isAnything ifTrue: [^(aDictionary at: self ifAbsentPut: [aNode]) = aNode].	self isLiteral ifTrue: [^self matchLiteral: aNode inContext: aDictionary].	self isStatement		ifTrue: [^self matchStatement: aNode inContext: aDictionary].	aNode class == self matchingClass ifFalse: [^false].	^(aDictionary at: self ifAbsentPut: [aNode]) = aNode! !!RBPatternVariableNode methodsFor: 'matching'!matchLiteral: aNode inContext: aDictionary 	^aNode class == RBLiteralNode 		and: [(aDictionary at: self ifAbsentPut: [aNode]) = aNode]! !!RBPatternVariableNode methodsFor: 'matching'!matchStatement: aNode inContext: aDictionary 	(aNode parent notNil and: [aNode parent isSequence]) ifFalse: [^false].	^(aDictionary at: self ifAbsentPut: [aNode]) = aNode! !!RBPatternVariableNode methodsFor: 'private'!matchingClass	^RBVariableNode! !!RBPatternVariableNode methodsFor: 'accessing'!parent: aBRProgramNode 	"Fix the case where '``@node' should match a single node, not a sequence node."	super parent: aBRProgramNode.	parent isSequence 		ifTrue: 			[(self isStatement or: [parent temporaries includes: self]) 				ifFalse: [isList := false]]! !!RBPatternVariableNode methodsFor: 'testing-matching'!recurseInto	^recurseInto! !!RBVariableNode class methodsFor: 'instance creation'!identifierToken: anIdentifierToken 	^(anIdentifierToken isPatternVariable 		ifTrue: [RBPatternVariableNode]		ifFalse: [RBVariableNode]) new 		identifierToken: anIdentifierToken! !!RBVariableNode class methodsFor: 'instance creation'!named: aString 	^self identifierToken: (RBIdentifierToken value: aString start: 0)! !!RBVariableNode methodsFor: 'comparing'!= anObject 	self == anObject ifTrue: [^true].	self class = anObject class ifFalse: [^false].	^self name = anObject name! !!RBVariableNode methodsFor: 'visitor'!acceptVisitor: aProgramNodeVisitor 	^aProgramNodeVisitor acceptVariableNode: self! !!RBVariableNode methodsFor: 'replacing' stamp: 'ajh 3/13/2003 16:13'!adjustPositionsAfter: sourcePos by: delta	"Slide token positions after sourcePos by delta"	token start > sourcePos ifTrue: [		token start: token start + delta]! !!RBVariableNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:44'!basicFirstToken		^self token! !!RBVariableNode methodsFor: 'accessing-token' stamp: 'ms 9/18/2006 17:45'!basicLastToken		^self token! !!RBVariableNode methodsFor: 'semantics' stamp: 'ajh 2/25/2003 00:50'!binding	^ binding! !!RBVariableNode methodsFor: 'semantics' stamp: 'ajh 2/25/2003 23:41'!binding: aSemVar	binding := aSemVar! !!RBVariableNode methodsFor: 'replacing' stamp: 'ajh 3/17/2003 13:12'!changeToken: newToken	self root adjustPositionsAfter: token stop by: newToken stop - token stop.	token := newToken.! !!RBVariableNode methodsFor: 'matching'!copyInContext: aDictionary 	^self class identifierToken: token removePositions! !!RBVariableNode methodsFor: 'comparing'!equalTo: anObject withMapping: aDictionary 	self class = anObject class ifFalse: [^false].	^(aDictionary at: self name ifAbsentPut: [anObject name]) = anObject name! !!RBVariableNode methodsFor: 'comparing'!hash	^self name hash! !!RBVariableNode methodsFor: 'initialize-release'!identifierToken: anIdentifierToken 	token := anIdentifierToken! !!RBVariableNode methodsFor: 'testing' stamp: 'pmm 10/8/2005 11:21'!isGlobal	^self binding isGlobal! !!RBVariableNode methodsFor: 'testing'!isImmediate	^true! !!RBVariableNode methodsFor: 'testing' stamp: 'pmm 10/8/2005 11:57'!isInstance	^self binding isInstance! !!RBVariableNode methodsFor: 'testing' stamp: 'pmm 2/6/2006 12:31'!isRead	^self isWrite not! !!RBVariableNode methodsFor: 'testing' stamp: 'pmm 10/8/2005 11:21'!isTemp	^self binding isTemp! !!RBVariableNode methodsFor: 'testing'!isVariable	^true! !!RBVariableNode methodsFor: 'testing' stamp: 'pmm 2/6/2006 12:31'!isWrite	^self parent isAssignment		and: [ self parent variable == self ]! !!RBVariableNode methodsFor: 'accessing'!name	^token value! !!RBVariableNode methodsFor: 'decorating' stamp: 'ms 9/20/2006 20:21'!peekBeforeComment	| tokenStream tok |	self parent isMethod 		ifFalse: [^ super peekBeforeComment]		ifTrue: 			[beforeComment ifNil: 					[beforeComment := OrderedCollection new.					tokenStream := SqueakTokenStream backwardOn: self firstToken previous.										[tok := tokenStream next.					tok isSignificant or: [tokenStream atEnd]] 							whileFalse: [tok isComment ifTrue: [beforeComment add: tok eatToken]].					beforeComment do: [:each | self comments add: (each start to: each stop)]].			^ beforeComment]! !!RBVariableNode methodsFor: 'accessing'!precedence	^0! !!RBVariableNode methodsFor: 'testing'!references: aVariableName 	^self name = aVariableName! !!RBVariableNode methodsFor: 'accessing'!startWithoutParentheses	^token start! !!RBVariableNode methodsFor: 'accessing'!stopWithoutParentheses	^token stop! !!RBVariableNode methodsFor: 'accessing' stamp: 'ajh 3/13/2003 15:17'!token	^ token! !!RBProgramNodeVisitor commentStamp: '<historical>' prior: 0!RBProgramNodeVisitor is an abstract visitor for the RBProgramNodes.Here is a short Tutorial.We want to parse an expression:tree := RBParser parseExpression: '3 + 4'Now we have the AST (Abstrakt syntax tree). Have a look at it with the ObjectExplorerer:tree exploreWe can easyly walk across the tree using the RBProgramNodeVisitor:RBProgramNodeVisitor new visitNode: tree.Of course, nothing happens, as all the visitor-methods are only stubs in this class.So you need to subclass that to do anything usefull.As an example, we would like to walk the tree and get all Literals back.So we make a subclass:RBProgramNodeVisitor subclass: #TestVisitor	instanceVariableNames: 'literals'	classVariableNames: ''	poolDictionaries: ''	category: 'Compiler-AST-Visitors'initialize	literals := Set new.literals	^literalsacceptLiteralNode: aLiteralNode	literals add: aLiteralNode value.	 (TestVisitor new visitNode: tree) literals!!ParseTreeSearcher commentStamp: 'md 8/9/2005 14:55' prior: 0!ParseTreeSearcher walks over a normal source code parse tree using the visitor pattern, and then matches these nodes against the meta-nodes using the match:inContext: methods defined for the meta-nodes.Instance Variables:	answer	<Object>	the "answer" that is propagated between matches	argumentSearches	<Collection of: (Association key: RBProgramNode value: BlockClosure)>	argument searches (search for the BRProgramNode and perform the BlockClosure when its found)	context	<RBSmallDictionary>	a dictionary that contains what each meta-node matches against. This could be a normal Dictionary that is created for each search, but is created once and reused (efficiency).	messages	<Collection>	the sent messages in our searches	searches	<Collection of: (Association key: RBProgramNode value: BlockClosure)>	non-argument searches (search for the BRProgramNode and perform the BlockClosure when its found)!!ParseTreeRewriter commentStamp: 'md 8/9/2005 14:55' prior: 0!ParseTreeRewriter walks over and transforms its RBProgramNode (tree). If the tree is modified, then answer is set to true, and the modified tree can be retrieved by the #tree method.Instance Variables:	tree	<RBProgramNode>	the parse tree we're transforming!!ParseTreeRewriter class methodsFor: 'instance creation'!classVariable: aVarName getter: getMethod setter: setMethod 	^self 		variable: aVarName		getter: getMethod		setter: setMethod		receiver: 'self class'! !!ParseTreeRewriter class methodsFor: 'instance creation'!removeTemporaryNamed: aName 	| rewriteRule |	rewriteRule := self new.	rewriteRule replace: '| `@temps1 ' , aName , ' `@temps2 | ``@.Statements'		with: '| `@temps1  `@temps2 | ``@.Statements'.	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'instance creation'!rename: varName to: newVarName 	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: varName with: newVarName;		replaceArgument: varName with: newVarName.	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'instance creation'!rename: varName to: newVarName handler: aBlock 	"Rename varName to newVarName, evaluating aBlock if there is a 	temporary variable with the same name as newVarName. This 	does not change temporary variables with varName."	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: varName with: newVarName;		replaceArgument: newVarName			withValueFrom: 				[:aNode | 				aBlock value.				aNode].	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'accessing'!replace: code with: newCode in: aParseTree 	^(self 		replace: code		with: newCode		method: false)		executeTree: aParseTree;		tree! !!ParseTreeRewriter class methodsFor: 'accessing'!replace: code with: newCode in: aParseTree onInterval: anInterval 	| rewriteRule |	rewriteRule := self new.	^rewriteRule		replace: code			with: newCode			when: [:aNode | aNode intersectsInterval: anInterval];		executeTree: aParseTree;		tree! !!ParseTreeRewriter class methodsFor: 'instance creation'!replace: code with: newCode method: aBoolean 	| rewriteRule |	rewriteRule := self new.	aBoolean 		ifTrue: [rewriteRule replaceMethod: code with: newCode]		ifFalse: [rewriteRule replace: code with: newCode].	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'instance creation'!replaceLiteral: literal with: newLiteral 	| rewriteRule |	rewriteRule := self new.	rewriteRule 		replace: '`#literal'		withValueFrom: [:aNode | aNode]		when: 			[:aNode | 			self 				replaceLiteral: literal				with: newLiteral				inToken: aNode token].	^rewriteRule! !!ParseTreeRewriter class methodsFor: 'private'!replaceLiteral: literal with: newLiteral inToken: literalToken 	| value |	value := literalToken realValue.	(value class = literal class and: [value = literal]) 		ifTrue: 			[literalToken 				value: newLiteral				start: nil				stop: nil.			^true].	^value class == Array and: 			[literalToken value inject: false				into: 					[:bool :each | 					bool | (self 								replaceLiteral: literal								with: newLiteral								inToken: each)]]! !!ParseTreeRewriter class methodsFor: 'accessing'!replaceStatements: code with: newCode in: aParseTree onInterval: anInterval 	| tree searchStmt replaceStmt |	tree := self buildTree: code method: false.	tree lastIsReturn		ifTrue: 			[searchStmt := '| `@temps | `@.Statements. ' , code.			replaceStmt := '| `@temps | `@.Statements. ^' , newCode]		ifFalse: 			[searchStmt := '| `@temps | `@.Statements1. ' , code , '.  `@.Statements2'.			replaceStmt := '| `@temps | `@.Statements1. ' , newCode , '.  `@.Statements2'].	^self		replace: searchStmt		with: replaceStmt		in: aParseTree		onInterval: anInterval! !!ParseTreeRewriter class methodsFor: 'instance creation'!variable: aVarName getter: getMethod setter: setMethod 	^self 		variable: aVarName		getter: getMethod		setter: setMethod		receiver: 'self'! !!ParseTreeRewriter class methodsFor: 'instance creation'!variable: aVarName getter: getMethod setter: setMethod receiver: aString 	| rewriteRule |	rewriteRule := self new.	rewriteRule		replace: aVarName , ' := ``@object'			with: aString , ' ' , setMethod , ' ``@object';		replace: aVarName with: aString , ' ' , getMethod.	^rewriteRule! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching'!acceptAssignmentNode: anAssignmentNode 	anAssignmentNode variable: (self visitNode: anAssignmentNode variable).	anAssignmentNode value: (self visitNode: anAssignmentNode value)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'nk 1/29/2005 11:10'!acceptBlockNode: aBlockNode 	aBlockNode arguments: (self visitBlockArguments: aBlockNode arguments).	aBlockNode body: (self visitNode: aBlockNode body)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching'!acceptCascadeNode: aCascadeNode 	| newMessages notFound |	newMessages := OrderedCollection new: aCascadeNode messages size.	notFound := OrderedCollection new: aCascadeNode messages size.	aCascadeNode messages do: 			[:each | 			| newNode |			newNode := self performSearches: searches on: each.			newNode isNil 				ifTrue: 					[newNode := each.					notFound add: newNode].			newNode isMessage 				ifTrue: [newMessages add: newNode]				ifFalse: 					[newNode isCascade 						ifTrue: [newMessages addAll: newNode messages]						ifFalse: 							[Transcript								show: 'Cannot replace message node inside of cascaded node with non-message node.';								cr.							newMessages add: each]]].	notFound size == aCascadeNode messages size 		ifTrue: 			[| receiver |			receiver := self visitNode: aCascadeNode messages first receiver.			newMessages do: [:each | each receiver: receiver]].	notFound 		do: [:each | each arguments: (each arguments collect: [:arg | self visitNode: arg])].	aCascadeNode messages: newMessages! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching'!acceptMessageNode: aMessageNode 	aMessageNode receiver: (self visitNode: aMessageNode receiver).	aMessageNode 		arguments: (aMessageNode arguments collect: [:each | self visitNode: each])! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'nk 1/29/2005 11:10'!acceptMethodNode: aMethodNode 	aMethodNode arguments: (self visitMethodArguments: aMethodNode arguments).	aMethodNode body: (self visitNode: aMethodNode body)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching'!acceptReturnNode: aReturnNode 	aReturnNode value: (self visitNode: aReturnNode value)! !!ParseTreeRewriter methodsFor: 'visitor-double dispatching' stamp: 'nk 1/29/2005 11:10'!acceptSequenceNode: aSequenceNode 	aSequenceNode temporaries: (self visitTemporaryVariables: aSequenceNode temporaries).	aSequenceNode statements: (aSequenceNode statements collect: [:each | self visitNode: each])! !!ParseTreeRewriter methodsFor: 'accessing'!executeTree: aParseTree 	| oldContext |	oldContext := context.	context := RBSmallDictionary new.	answer := false.	tree := self visitNode: aParseTree.	context := oldContext.	^answer! !!ParseTreeRewriter methodsFor: 'private'!foundMatch	answer := true! !!ParseTreeRewriter methodsFor: 'private'!lookForMoreMatchesInContext: oldContext 	oldContext keysAndValuesDo: 			[:key :value | 			(key isString not and: [key recurseInto]) 				ifTrue: 					[oldContext at: key put: (value collect: [:each | self visitNode: each])]]! !!ParseTreeRewriter methodsFor: 'replacing'!replace: searchString with: replaceString 	self addRule: (RBStringReplaceRule searchFor: searchString				replaceWith: replaceString)! !!ParseTreeRewriter methodsFor: 'replacing'!replace: searchString with: replaceString when: aBlock 	self addRule: (RBStringReplaceRule 				searchFor: searchString				replaceWith: replaceString				when: aBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replace: searchString withValueFrom: replaceBlock 	self addRule: (RBBlockReplaceRule searchFor: searchString				replaceWith: replaceBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replace: searchString withValueFrom: replaceBlock when: conditionBlock 	self addRule: (RBBlockReplaceRule 				searchFor: searchString				replaceWith: replaceBlock				when: conditionBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString with: replaceString 	self addArgumentRule: (RBStringReplaceRule searchFor: searchString				replaceWith: replaceString)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString with: replaceString when: aBlock 	self addArgumentRule: (RBStringReplaceRule 				searchFor: searchString				replaceWith: replaceString				when: aBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString withValueFrom: replaceBlock 	self addArgumentRule: (RBBlockReplaceRule searchFor: searchString				replaceWith: replaceBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceArgument: searchString withValueFrom: replaceBlock when: conditionBlock 	self addArgumentRule: (RBBlockReplaceRule 				searchFor: searchString				replaceWith: replaceBlock				when: conditionBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString with: replaceString 	self addRule: (RBStringReplaceRule searchForMethod: searchString				replaceWith: replaceString)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString with: replaceString when: aBlock 	self addRule: (RBStringReplaceRule 				searchForMethod: searchString				replaceWith: replaceString				when: aBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString withValueFrom: replaceBlock 	self addRule: (RBBlockReplaceRule searchForMethod: searchString				replaceWith: replaceBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceMethod: searchString withValueFrom: replaceBlock when: conditionBlock 	self addRule: (RBBlockReplaceRule 				searchForMethod: searchString				replaceWith: replaceBlock				when: conditionBlock)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceTree: searchTree withTree: replaceTree 	self addRule: (RBStringReplaceRule searchForTree: searchTree				replaceWith: replaceTree)! !!ParseTreeRewriter methodsFor: 'replacing'!replaceTree: searchTree withTree: replaceTree when: aBlock 	self addRule: (RBStringReplaceRule 				searchForTree: searchTree				replaceWith: replaceTree				when: aBlock)! !!ParseTreeRewriter methodsFor: 'accessing'!tree	^tree! !!ParseTreeRewriter methodsFor: 'visiting'!visitArguments: aNodeCollection 	^aNodeCollection collect: [:each | self visitArgument: each]! !!ParseTreeRewriter methodsFor: 'visiting' stamp: 'nk 2/23/2005 15:20'!visitBlockArguments: aNodeCollection 	^aNodeCollection collect: [:each | self visitBlockArgument: each]! !!ParseTreeRewriter methodsFor: 'visiting' stamp: 'nk 2/23/2005 15:21'!visitMethodArguments: aNodeCollection 	^aNodeCollection collect: [:each | self visitMethodArgument: each]! !!ParseTreeRewriter methodsFor: 'visiting' stamp: 'nk 2/23/2005 15:22'!visitTemporaryVariables: aNodeCollection 	^aNodeCollection collect: [:each | self visitTemporaryVariable: each]! !!ParseTreeSearcher class methodsFor: 'private'!buildSelectorString: aSelector 	| stream keywords |	aSelector numArgs = 0 ifTrue: [^aSelector].	stream := WriteStream on: String new.	keywords := aSelector keywords.	1 to: keywords size		do: 			[:i | 			stream nextPutAll: (keywords at: i);				nextPutAll: ' ``@arg';				nextPutAll: i printString;				nextPut: $ ].	^stream contents! !!ParseTreeSearcher class methodsFor: 'private'!buildSelectorTree: aSelector 	aSelector isEmpty ifTrue: [^nil].	^RBParser parseRewriteExpression: '``@receiver ' 				, (self buildSelectorString: aSelector)		onError: [:err :pos | ^nil]! !!ParseTreeSearcher class methodsFor: 'private'!buildTree: aString method: aBoolean 	^aBoolean 		ifTrue: [RBParser parseRewriteMethod: aString]		ifFalse: [RBParser parseRewriteExpression: aString]! !!ParseTreeSearcher class methodsFor: 'instance creation'!getterMethod: aVarName 	^(self new)		matchesMethod: '`method ^' , aVarName do: [:aNode :ans | aNode selector];		yourself! !!ParseTreeSearcher class methodsFor: 'instance creation'!justSendsSuper	^(self new)		matchesAnyMethodOf: 				#('`@method: `@Args ^super `@method: `@Args' 				'`@method: `@Args super `@method: `@Args')			do: [:aNode :ans | true];		yourself! !!ParseTreeSearcher class methodsFor: 'instance creation'!returnSetterMethod: aVarName 	^(self new)		matchesMethod: '`method: `Arg ^' , aVarName , ' := `Arg'			do: [:aNode :ans | aNode selector];		yourself! !!ParseTreeSearcher class methodsFor: 'instance creation'!setterMethod: aVarName 	^(self new)		matchesAnyMethodOf: (Array with: '`method: `Arg ' , aVarName , ' := `Arg'					with: '`method: `Arg ^' , aVarName , ' := `Arg')			do: [:aNode :ans | aNode selector];		yourself! !!ParseTreeSearcher class methodsFor: 'accessing'!treeMatching: aString in: aParseTree 	(self new)		matches: aString do: [:aNode :answer | ^aNode];		executeTree: aParseTree.	^nil! !!ParseTreeSearcher class methodsFor: 'accessing'!treeMatchingStatements: aString in: aParseTree 	| notifier tree lastIsReturn |	notifier := self new.	tree := RBParser parseExpression: aString.	lastIsReturn := tree lastIsReturn.	notifier matches: (lastIsReturn 				ifTrue: ['| `@temps | `@.S1. ' , tree formattedCode]				ifFalse: ['| `@temps | `@.S1. ' , tree formattedCode , '. `@.S2'])		do: [:aNode :answer | ^tree].	notifier executeTree: aParseTree.	^nil! !!ParseTreeSearcher methodsFor: 'accessing'!addArgumentRule: aParseTreeRule 	argumentSearches add: aParseTreeRule.	aParseTreeRule owner: self! !!ParseTreeSearcher methodsFor: 'accessing'!addArgumentRules: ruleCollection 	ruleCollection do: [:each | self addArgumentRule: each]! !!ParseTreeSearcher methodsFor: 'accessing'!addRule: aParseTreeRule 	searches add: aParseTreeRule.	aParseTreeRule owner: self! !!ParseTreeSearcher methodsFor: 'accessing'!addRules: ruleCollection 	ruleCollection do: [:each | self addRule: each]! !!ParseTreeSearcher methodsFor: 'accessing'!answer	^answer! !!ParseTreeSearcher methodsFor: 'initialize-release'!answer: anObject	answer := anObject! !!ParseTreeSearcher methodsFor: 'testing' stamp: 'pmm 7/12/2006 15:17'!canMatchMethod: aCompiledMethod 	^self messages isEmpty		or: [ self messages anySatisfy: [:each | aCompiledMethod sendsSelector: each] ]! !!ParseTreeSearcher methodsFor: 'accessing'!context	^context! !!ParseTreeSearcher methodsFor: 'accessing'!executeMethod: aParseTree initialAnswer: anObject 	answer := anObject.	searches detect: [:each | (each performOn: aParseTree) notNil] ifNone: [].	^answer! !!ParseTreeSearcher methodsFor: 'accessing'!executeTree: aParseTree 	"Save our current context, in case someone is performing another search inside a match."	| oldContext |	oldContext := context.	context := RBSmallDictionary new.	self visitNode: aParseTree.	context := oldContext.	^answer! !!ParseTreeSearcher methodsFor: 'accessing'!executeTree: aParseTree initialAnswer: aValue 	answer := aValue.	^self executeTree: aParseTree! !!ParseTreeSearcher methodsFor: 'private'!foundMatch! !!ParseTreeSearcher methodsFor: 'initialize-release'!initialize	super initialize.	context := RBSmallDictionary new.	searches := OrderedCollection new.	argumentSearches := OrderedCollection new: 0.	answer := nil! !!ParseTreeSearcher methodsFor: 'private'!lookForMoreMatchesInContext: oldContext 	oldContext keysAndValuesDo: 			[:key :value | 			(key isString not and: [key recurseInto]) 				ifTrue: [value do: [:each | self visitNode: each]]]! !!ParseTreeSearcher methodsFor: 'searching'!matches: aString do: aBlock 	self addRule: (RBSearchRule searchFor: aString thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'searching'!matchesAnyArgumentOf: stringCollection do: aBlock 	stringCollection do: [:each | self matchesArgument: each do: aBlock]! !!ParseTreeSearcher methodsFor: 'searching'!matchesAnyMethodOf: aStringCollection do: aBlock 	aStringCollection do: [:each | self matchesMethod: each do: aBlock]! !!ParseTreeSearcher methodsFor: 'searching'!matchesAnyOf: aStringCollection do: aBlock 	aStringCollection do: [:each | self matches: each do: aBlock]! !!ParseTreeSearcher methodsFor: 'searching'!matchesAnyTreeOf: treeCollection do: aBlock 	treeCollection do: [:each | self matchesTree: each do: aBlock]! !!ParseTreeSearcher methodsFor: 'searching'!matchesArgument: aString do: aBlock 	self addArgumentRule: (RBSearchRule searchFor: aString thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'searching'!matchesArgumentTree: aBRProgramNode do: aBlock 	self 		addArgumentRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'searching'!matchesMethod: aString do: aBlock 	self addRule: (RBSearchRule searchForMethod: aString thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'searching'!matchesTree: aBRProgramNode do: aBlock 	self addRule: (RBSearchRule searchForTree: aBRProgramNode thenDo: aBlock)! !!ParseTreeSearcher methodsFor: 'accessing'!messages	messages notNil ifTrue: [^messages].	argumentSearches isEmpty ifFalse: [^messages := #()].	messages := Set new.	searches do: 			[:each | 			| searchMessages |			searchMessages := each sentMessages.			RBProgramNode optimizedSelectors 				do: [:sel | searchMessages remove: sel ifAbsent: []].			searchMessages isEmpty ifTrue: [^messages := #()].			messages addAll: searchMessages].	^messages := messages asArray! !!ParseTreeSearcher methodsFor: 'private' stamp: 'pmm 7/12/2006 15:35'!performSearches: aSearchCollection on: aNode 	| value |	 aSearchCollection do: [ :each |			value := each performOn: aNode.			value notNil ifTrue: [				self foundMatch.				^value ] ].	^nil! !!ParseTreeSearcher methodsFor: 'private'!recusivelySearchInContext	"We need to save the matched context since the other searches might overwrite it."	| oldContext |	oldContext := context.	context := RBSmallDictionary new.	self lookForMoreMatchesInContext: oldContext.	context := oldContext! !!ParseTreeSearcher methodsFor: 'visiting'!visitArgument: aNode 	| value |	value := self performSearches: argumentSearches on: aNode.	^value isNil 		ifTrue: 			[aNode acceptVisitor: self.			aNode]		ifFalse: [value]! !!ParseTreeSearcher methodsFor: 'visiting'!visitNode: aNode 	| value |	value := self performSearches: searches on: aNode.	^value isNil 		ifTrue: 			[aNode acceptVisitor: self.			aNode]		ifFalse: [value]! !!RBFormatter commentStamp: 'md 8/9/2005 14:50' prior: 0!RBFormatter formats a parse tree. It is an example of a Visitor. This is rarely called directly. Sending 'formattedCode' to a parse tree uses this algorithm to return a pretty-printed version.Instance Variables:	codeStream	<PositionableStream>	The buffer where the output is accumulated.	firstLineLength	<Integer>	The length of the first line of a message send.	lineStart	<Integer>	The position of the current line's start.	tabs	<Integer>	The number of tabs currently indented.!!RBColorFormatter commentStamp: '<historical>' prior: 0!I am a specialization of RBFormatter that produces a colorized Text instead of a String as my formatted output.!!RBColorFormatter methodsFor: 'visitor-double dispatching' stamp: 'nk 3/3/2005 10:50'!acceptLiteralNode: aNode	codeStream withStyleFor: #literal do: [ super acceptLiteralNode: aNode ]! !!RBColorFormatter methodsFor: 'visitor-double dispatching' stamp: 'nk 3/3/2005 11:21'!acceptVariableNode: aNode	| definer usage |	definer := aNode whoDefines: aNode name.	usage := #variable.	definer ifNotNil: [		definer isBlock ifTrue: [ usage := #blockArgument ].		definer isMethod ifTrue: [ usage := #methodArgument ].		definer isSequence ifTrue: [ usage := #temporaryVariable ].	].	^codeStream withStyleFor: usage do: [ super acceptVariableNode: aNode ]! !!RBColorFormatter methodsFor: 'private-formatting' stamp: 'nk 3/3/2005 10:51'!formatMessageSelectorPart: part	^codeStream withStyleFor: #keyword do: [ super formatMessageSelectorPart: part ]	! !!RBColorFormatter methodsFor: 'private-formatting' stamp: 'nk 3/3/2005 10:55'!formatStatementCommentFor: aNode	^codeStream withStyleFor: #comment do: [ super formatStatementCommentFor: aNode ]	! !!RBColorFormatter methodsFor: 'initialize-release' stamp: 'md 9/1/2005 13:50'!initialize	super initialize.	codeStream := ColoredCodeStream on: (Text new: 400).! !!RBColorFormatter methodsFor: 'visiting' stamp: 'nk 1/29/2005 11:15'!visitBlockArgument: aNode	^codeStream withStyleFor: #blockArgument do: [ super visitBlockArgument: aNode ]! !!RBColorFormatter methodsFor: 'visiting' stamp: 'nk 1/29/2005 11:15'!visitMethodArgument: aNode	^codeStream withStyleFor: #methodArgument do: [ super visitMethodArgument: aNode ]! !!RBColorFormatter methodsFor: 'visiting' stamp: 'nk 1/29/2005 11:15'!visitTemporaryVariable: aNode	^codeStream withStyleFor: #temporaryVariable do: [ super visitTemporaryVariable: aNode ]! !!RBFormatter class methodsFor: 'as yet unclassified' stamp: 'md 2/26/2006 15:18'!assignmentOperator		^':='! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'md 8/5/2005 11:09'!acceptArrayNode: anArrayNode	anArrayNode start ifNil: [anArrayNode leftBrace: self fullPosition + 1].	self maybeJoinLinesFrom: [		codeStream nextPutAll: '{ '.		self indent: 1 while: [			self indent.			self formatStatementsFor: anArrayNode.		].	].	codeStream nextPutAll: '}'.	anArrayNode stop ifNil: [anArrayNode rightBrace: self fullPosition].! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'md 8/12/2005 11:19'!acceptAssignmentNode: anAssignmentNode 	self indent: 2		while: 			[self visitNode: anAssignmentNode variable.			codeStream space; nextPutAll: self class assignmentOperator; space.			self visitNode: anAssignmentNode value]! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'md 8/12/2005 10:51'!acceptBlockNode: aBlockNode 	| seqNode multiline formattedBody formatter start |	seqNode := aBlockNode body.	formatter := (self copy) lineStart: 0;				yourself.	start := self fullPosition.	formattedBody := formatter format: seqNode.	multiline := self lineLength + formattedBody size > self maxLineSize				or: [formatter isMultiLine].	multiline ifTrue: [self indent].	codeStream nextPut: $[.	aBlockNode left ifNil: [aBlockNode left: self fullPosition].	aBlockNode arguments do: 			[:each | 			codeStream nextPut: $:.			self visitBlockArgument: each.			codeStream nextPut: $ ].	aBlockNode arguments isEmpty ifFalse: 			[codeStream nextPutAll: '| '.			multiline ifTrue: [self indent]].	aBlockNode right ifNil: [		"assume if block had no position seqNode had no position also"		seqNode adjustPositionsAfter: start by: self fullPosition - start.	].	codeStream nextPutAll: formattedBody.	codeStream nextPut: $].	aBlockNode right ifNil: [aBlockNode right: self fullPosition].! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'md 2/26/2006 15:01'!acceptCascadeNode: aCascadeNode 	| messages |	messages := aCascadeNode messages.	self visitNode: messages first receiver.	self indentWhile: 			[messages do: 					[:each | 					self						indent;						indentWhile: [self formatMessage: each cascade: true]]				separatedBy: [codeStream nextPut: $;]]! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'md 8/12/2005 11:15'!acceptLiteralNode: aLiteralNode	| start s |	start := self fullPosition + 1.	s := codeStream position + 1.	self formatLiteral: aLiteralNode value.	aLiteralNode token start ifNil: [		aLiteralNode token			start: start;			value: (codeStream originalContents copyFrom: s to: codeStream position)	].! !!RBFormatter methodsFor: 'visitor-double dispatching'!acceptMessageNode: aMessageNode 	| newFormatter code |	newFormatter := self copy.	code := newFormatter format: aMessageNode receiver.	codeStream nextPutAll: code.	codeStream nextPut: $ .	newFormatter isMultiLine		ifTrue: [lineStart := codeStream position - newFormatter lastLineLength].	self indent: (newFormatter isMultiLine ifTrue: [2] ifFalse: [1])		while: [self formatMessage: aMessageNode cascade: false]! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'SR 9/3/2006 10:13'!acceptMethodNode: aMethodNode 	self formatMethodPatternFor: aMethodNode.	self indentWhile: [			self formatPragmasFor: aMethodNode.			self formatMethodCommentFor: aMethodNode indentBefore: true.			self indent.			self tagBeforeTemporaries ifTrue: [self formatTagFor: aMethodNode].			aMethodNode body statements isEmpty 				ifFalse: [self visitNode: aMethodNode body]]! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'ms 9/4/2006 22:48'!acceptPragmaNode: aPragmaNode	aPragmaNode pragma printOn: codeStream! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'ajh 3/24/2003 13:15'!acceptPseudoNode: aPseudoNode	aPseudoNode isLabel ifTrue: [		codeStream nextPut: $L.		aPseudoNode destination printOn: codeStream.		^ self].	aPseudoNode isGoto ifTrue: [		codeStream nextPut: $G.		aPseudoNode destination printOn: codeStream.		^ self].	aPseudoNode isIf ifTrue: [		codeStream nextPutAll: 'If '.		codeStream nextPut: (aPseudoNode boolean ifTrue: [$t] ifFalse: [$f]).		codeStream space.		aPseudoNode destination printOn: codeStream.		codeStream space.		aPseudoNode otherwise printOn: codeStream.		^ self].! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'ajh 3/19/2003 14:13'!acceptReturnNode: aReturnNode	aReturnNode start ifNil: [aReturnNode return: self fullPosition + 1].	codeStream nextPut: $^; space.	self visitNode: aReturnNode value! !!RBFormatter methodsFor: 'visitor-double dispatching'!acceptSequenceNode: aSequenceNode 	self formatMethodCommentFor: aSequenceNode indentBefore: false.	self formatTemporariesFor: aSequenceNode.	self tagBeforeTemporaries ifFalse: 			[| parent |			parent := aSequenceNode parent.			(parent notNil and: [parent isMethod]) ifTrue: [self formatTagFor: parent]].	self formatStatementsFor: aSequenceNode! !!RBFormatter methodsFor: 'visitor-double dispatching' stamp: 'ajh 3/19/2003 14:13'!acceptVariableNode: aVariableNode	aVariableNode token start ifNil: [		aVariableNode token start: self fullPosition + 1].	codeStream nextPutAll: aVariableNode name! !!RBFormatter methodsFor: 'accessing'!firstLineLength	^firstLineLength isNil		ifTrue: [codeStream position]		ifFalse: [firstLineLength]! !!RBFormatter methodsFor: 'accessing'!format: aNode 	self visitNode: aNode.	^codeStream contents! !!RBFormatter methodsFor: 'private-formatting' stamp: 'md 2/26/2006 15:03'!formatLiteral: aValue 	| isArray |	(isArray := aValue class == Array) | (aValue class == ByteArray) ifTrue: 			[codeStream nextPutAll: (isArray ifTrue: ['#('] ifFalse: ['#[']).			self maybeJoinLinesFrom: 					[self indent: 1 while: 							[aValue do: [:each | 									self indent; formatLiteral: each]].					self indent.					codeStream nextPut: (isArray ifTrue: [$)] ifFalse: [$]])].			^self].	aValue isSymbol ifTrue:  [self formatSymbol: aValue. ^self].	aValue class == Character ifTrue: 			[codeStream nextPut: $$;				nextPut: aValue.			^self].	aValue isVariableBinding ifTrue: [		codeStream nextPutAll: '##'; nextPutAll: aValue key.		^ self].	aValue storeOn: codeStream! !!RBFormatter methodsFor: 'private-formatting' stamp: 'ajh 3/19/2003 16:03'!formatMessage: aMessageNode cascade: cascadeBoolean 	| selectorParts arguments multiLine formattedArgs indentFirst firstArgLength length start needsPos argStarts |	selectorParts := aMessageNode selectorParts.	needsPos := selectorParts first start isNil.	arguments := aMessageNode arguments.	formattedArgs := OrderedCollection new.	multiLine := aMessageNode selector numArgs > self maximumArgumentsPerLine.	length := aMessageNode selector size + arguments size + 1.	firstArgLength := 0.	start := self fullPosition.	self indentWhile: 			[1 to: arguments size				do: 					[:i | 					| formatter string |					formatter := (self copy) 								lineStart: (selectorParts at: i) length negated;								yourself.					string := formatter format: (arguments at: i).					formattedArgs add: string.					i == 1 ifTrue: [firstArgLength := formatter firstLineLength].					length := length + string size.					multiLine := multiLine or: [formatter isMultiLine]]].	multiLine := multiLine or: [length + self lineLength > self maxLineSize].	indentFirst := cascadeBoolean not and: 					[multiLine and: 							[(self startMessageSendOnNewLine: aMessageNode) or: 									[self lineLength + selectorParts first length + 2 + firstArgLength 										> self maxLineSize]]].	indentFirst ifTrue: [self indent].	argStarts := self 		formatMessageSelector: selectorParts		withArguments: formattedArgs		multiline: multiLine.	needsPos ifTrue: [		arguments with: argStarts do: [:node :pos |			node adjustPositionsAfter: start by: pos - start].	].! !!RBFormatter methodsFor: 'private-formatting' stamp: 'md 2/26/2006 15:19'!formatMessageSelector: selectorParts withArguments: formattedArgs multiline: multiLine	| selectorPart argStarts |	argStarts := Array new: formattedArgs size.	formattedArgs isEmpty 		ifTrue: [			selectorParts first start ifNil: [				selectorParts first start: self fullPosition + 1].			codeStream nextPutAll: selectorParts first value]		ifFalse: [1 to: formattedArgs size do: [:i | 					i ~~ 1 & multiLine not ifTrue: [codeStream nextPut: $ ].					selectorPart := selectorParts at: i.					selectorPart start ifNil: [selectorPart start: self fullPosition + 1].					self formatMessageSelectorPart: selectorPart.					codeStream nextPut: $ .					argStarts at: i put: self fullPosition.					codeStream nextPutAll: (formattedArgs at: i).					(multiLine and: [i < formattedArgs size]) ifTrue: [self indent]]].	^ argStarts! !!RBFormatter methodsFor: 'private-formatting' stamp: 'nk 1/29/2005 11:22'!formatMessageSelectorPart: part	codeStream nextPutAll: part value.! !!RBFormatter methodsFor: 'private-formatting'!formatMethodCommentFor: aNode indentBefore: aBoolean 	| source |	source := aNode source.	source isNil ifTrue: [^self].	aNode comments do: 			[:each | 			aBoolean ifTrue: [self indent].			codeStream nextPutAll: (aNode source copyFrom: each first to: each last);				cr.			aBoolean ifFalse: [self indent]]! !!RBFormatter methodsFor: 'private-formatting' stamp: 'md 8/5/2005 11:08'!formatMethodPatternFor: aMethodNode 	| selectorParts arguments |	selectorParts := aMethodNode selectorParts.	arguments := aMethodNode arguments.	arguments isEmpty		ifTrue: [			selectorParts first start ifNil: [selectorParts first start: self fullPosition + 1].			codeStream nextPutAll: selectorParts first value]		ifFalse: 			[selectorParts with: arguments				do: 					[:selector :arg | 					selector start ifNil: [selector start: self fullPosition + 1].					codeStream nextPutAll: selector value;						nextPut: $ .					self visitMethodArgument: arg.					codeStream nextPut: $ ]]! !!RBFormatter methodsFor: 'private-formatting' stamp: 'ms 9/4/2006 22:49'!formatPragmasFor: aNode	aNode pragmas 		do: [ : each |			self indent.			self visitNode: each ]! !!RBFormatter methodsFor: 'private-formatting'!formatStatementCommentFor: aNode 	| source |	source := aNode source.	source isNil ifTrue: [^self].	aNode comments do: 			[:each | 			| crs |			crs := self newLinesFor: source startingAt: each first.			(crs - 1 max: 0) timesRepeat: [codeStream cr].			crs == 0 ifTrue: [codeStream tab] ifFalse: [self indent].			codeStream nextPutAll: (source copyFrom: each first to: each last)]! !!RBFormatter methodsFor: 'private-formatting'!formatStatementsFor: aSequenceNode 	| statements |	statements := aSequenceNode statements.	statements isEmpty ifTrue: [^self].	1 to: statements size - 1		do: 			[:i | 			self visitNode: (statements at: i).			codeStream nextPut: $..			self formatStatementCommentFor: (statements at: i).			self indent].	self visitNode: statements last.	self formatStatementCommentFor: statements last! !!RBFormatter methodsFor: 'private-formatting' stamp: 'md 8/26/2004 18:34'!formatSymbol: aSymbol 	"Format the symbol, if its not a selector then we must put quotes around it. The and: case below, 	handles the VisualWorks problem of not accepting two bars as a symbol."	codeStream nextPut: $#.	((Scanner isLiteralSymbol: aSymbol) and: [aSymbol ~~ #'||']) 		ifTrue: [codeStream nextPutAll: aSymbol]		ifFalse: [aSymbol asString printOn: codeStream]	"	((RBScanner isSelector: aSymbol) and: [aSymbol ~~ #'||']) 		ifTrue: [codeStream nextPutAll: aSymbol]		ifFalse: [aSymbol asString printOn: codeStream]"! !!RBFormatter methodsFor: 'private-formatting'!formatTagFor: aMethodNode 	| primitiveSources |	primitiveSources := aMethodNode primitiveSources.	primitiveSources do: 			[:each | 			codeStream nextPutAll: each.			self indent]! !!RBFormatter methodsFor: 'private-formatting' stamp: 'nk 1/29/2005 11:30'!formatTemporariesFor: aSequenceNode 	| temps |	temps := aSequenceNode temporaries.	temps isEmpty ifTrue: [^self].	codeStream nextPutAll: '| '.	temps do: 			[:each | 			self visitTemporaryVariable: each.			codeStream nextPut: $ ].	codeStream nextPut: $|.	self indent! !!RBFormatter methodsFor: 'position fill' stamp: 'ajh 3/19/2003 14:12'!fullPosition	^ positionDelta + codeStream position! !!RBFormatter methodsFor: 'private'!indent	firstLineLength isNil ifTrue: [firstLineLength := codeStream position].	codeStream cr.	tabs timesRepeat: [codeStream tab].	lineStart := codeStream position! !!RBFormatter methodsFor: 'private'!indent: anInteger while: aBlock 	tabs := tabs + anInteger.	aBlock value.	tabs := tabs - anInteger! !!RBFormatter methodsFor: 'private'!indentWhile: aBlock 	self indent: 1 while: aBlock! !!RBFormatter methodsFor: 'initialize-release' stamp: 'md 2/26/2006 15:01'!initialize	super initialize.	codeStream := WriteStream on: (String new: 60).	tabs := 0.	lineStart := 0.	positionDelta := 0.! !!RBFormatter methodsFor: 'accessing'!isMultiLine	^firstLineLength notNil! !!RBFormatter methodsFor: 'accessing'!lastLineLength	^codeStream position - (lineStart max: 0)! !!RBFormatter methodsFor: 'private'!lineLength	^codeStream position - lineStart! !!RBFormatter methodsFor: 'private'!lineStart: aPosition 	lineStart := aPosition! !!RBFormatter methodsFor: 'private'!maxLineSize	^75! !!RBFormatter methodsFor: 'private'!maximumArgumentsPerLine	^2! !!RBFormatter methodsFor: 'private-formatting' stamp: 'apl 3/26/2005 14:51'!maybeJoinLinesFrom: aBlock 	| statementBegin statementEnd statementText statementLines initialLineLength |	initialLineLength := self lineLength.	statementBegin := codeStream position.	aBlock value.	statementEnd := codeStream position.	statementText := codeStream contents copyFrom: statementBegin + 1				to: statementEnd.	initialLineLength + statementText size < self maxLineSize 		ifTrue: 			[statementLines := statementText asString 						findTokens: String cr , String tab.			codeStream position: statementBegin.			statementLines do: [:line | codeStream nextPutAll: line]				separatedBy: [codeStream space]]! !!RBFormatter methodsFor: 'private'!needsParenthesisFor: aNode 	| parent grandparent |	aNode isValue ifFalse: [^false].	parent := aNode parent.	parent isNil ifTrue: [^false].	(aNode isMessage and: [parent isMessage and: [parent receiver == aNode]])		ifTrue: 			[grandparent := parent parent.			(grandparent notNil and: [grandparent isCascade]) ifTrue: [^true]].	aNode precedence < parent precedence ifTrue: [^false].	aNode isAssignment & parent isAssignment ifTrue: [^false].	aNode isAssignment | aNode isCascade ifTrue: [^true].	aNode precedence == 0 ifTrue: [^false].	aNode isMessage ifFalse: [^true].	aNode precedence = parent precedence ifFalse: [^true].	aNode isUnary ifTrue: [^false].	aNode isKeyword ifTrue: [^true].	parent receiver == aNode ifFalse: [^true].	^self precedenceOf: parent selector greaterThan: aNode selector! !!RBFormatter methodsFor: 'private-formatting'!newLinesFor: aString startingAt: anIndex 	| count cr lf index char |	cr := Character value: 13.	lf := Character value: 10.	count := 0.	index := anIndex - 1.	[index > 0 and: 			[char := aString at: index.			char isSeparator]] 		whileTrue: 			[char == lf 				ifTrue: 					[count := count + 1.					(aString at: (index - 1 max: 1)) == cr ifTrue: [index := index - 1]].			char == cr ifTrue: [count := count + 1].			index := index - 1].	^count! !!RBFormatter methodsFor: 'copying' stamp: 'pmm 2/24/2006 11:01'!postCopy	super postCopy.	positionDelta := positionDelta + codeStream position.	lineStart := self lineLength negated.	codeStream := (codeStream ifNil: [ WriteStream on: (String new: 60) ]		ifNotNil: [ codeStream class on: (codeStream contents class new: 60) ]).	firstLineLength := nil! !!RBFormatter methodsFor: 'private'!precedenceOf: parentSelector greaterThan: childSelector 	"Put parenthesis around things that are preceived to have 'lower' precedence. For example, 'a + b * c' 	-> '(a + b) * c' but 'a * b + c' -> 'a * b + c'"	| childIndex parentIndex operators |	operators := #(#($| $& $?) #($= $~ $< $>) #($- $+) #($* $/ $% $\) #($@)).	childIndex := 0.	parentIndex := 0.	1 to: operators size		do: 			[:i | 			((operators at: i) includes: parentSelector first) ifTrue: [parentIndex := i].			((operators at: i) includes: childSelector first) ifTrue: [childIndex := i]].	^childIndex < parentIndex! !!RBFormatter methodsFor: 'private'!selectorsToLeaveOnLine	^#(#to:do: #to:by: #to:by:do:)! !!RBFormatter methodsFor: 'private'!selectorsToStartOnNewLine	^#(#ifTrue:ifFalse: #ifFalse:ifTrue: #ifTrue: #ifFalse:)! !!RBFormatter methodsFor: 'testing'!startMessageSendOnNewLine: aMessageNode 	(self selectorsToStartOnNewLine includes: aMessageNode selector) 		ifTrue: [^true].	(self selectorsToLeaveOnLine includes: aMessageNode selector) ifTrue: [^false].	^aMessageNode selector numArgs > self maximumArgumentsPerLine! !!RBFormatter methodsFor: 'testing' stamp: 'md 2/26/2006 15:00'!tagBeforeTemporaries	^false! !!RBFormatter methodsFor: 'visiting'!visitNode: aNode 	| parenthesis |	parenthesis := self needsParenthesisFor: aNode.	parenthesis ifTrue: [codeStream nextPut: $(].	aNode acceptVisitor: self.	parenthesis ifTrue: [codeStream nextPut: $)]! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching' stamp: 'ls 1/24/2000 00:31'!acceptArrayNode: anArrayNode 	anArrayNode children do: [:each | self visitNode: each]! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching'!acceptAssignmentNode: anAssignmentNode 	self visitNode: anAssignmentNode variable.	self visitNode: anAssignmentNode value! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching' stamp: 'nk 1/29/2005 11:10'!acceptBlockNode: aBlockNode 	self visitBlockArguments: aBlockNode arguments.	self visitNode: aBlockNode body! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching'!acceptCascadeNode: aCascadeNode 	aCascadeNode messages do: [:each | self visitNode: each]! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching' stamp: 'ajh 2/26/2003 18:34'!acceptDoItNode: aDoItNode 	self visitNode: aDoItNode body! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching'!acceptLiteralNode: aLiteralNode! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching'!acceptMessageNode: aMessageNode 	(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 		ifTrue: [self visitNode: aMessageNode receiver].	aMessageNode arguments do: [:each | self visitNode: each]! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching' stamp: 'ms 9/19/2006 14:45'!acceptMethodNode: aMethodNode	self visitMethodArguments: aMethodNode arguments.	aMethodNode pragmas do: [:each | self visitNode: each].	self visitNode: aMethodNode body! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching' stamp: 'ms 9/4/2006 00:06'!acceptPragmaNode: aPragmaNode! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching' stamp: 'ajh 3/3/2003 12:43'!acceptPseudoNode: aVariableNode! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching'!acceptReturnNode: aReturnNode 	self visitNode: aReturnNode value! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching' stamp: 'nk 1/29/2005 11:08'!acceptSequenceNode: aSequenceNode 	self visitTemporaryVariables: aSequenceNode temporaries.	aSequenceNode statements do: [:each | self visitNode: each]! !!RBProgramNodeVisitor methodsFor: 'visitor-double dispatching'!acceptVariableNode: aVariableNode! !!RBProgramNodeVisitor methodsFor: 'copying'!postCopy! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitArgument: each 	"Here to allow subclasses to detect arguments or temporaries."	^self visitNode: each! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitArguments: aNodeCollection 	^aNodeCollection do: [:each | self visitArgument: each]! !!RBProgramNodeVisitor methodsFor: 'visiting' stamp: 'nk 1/29/2005 11:10'!visitBlockArgument: each 	"Here to allow subclasses to detect arguments or temporaries."	^self visitArgument: each! !!RBProgramNodeVisitor methodsFor: 'visiting' stamp: 'nk 1/29/2005 11:09'!visitBlockArguments: aNodeCollection 	^aNodeCollection do: [:each | self visitBlockArgument: each]! !!RBProgramNodeVisitor methodsFor: 'visiting' stamp: 'nk 1/29/2005 11:09'!visitMethodArgument: each 	"Here to allow subclasses to detect arguments or temporaries."	^self visitArgument: each! !!RBProgramNodeVisitor methodsFor: 'visiting' stamp: 'nk 1/29/2005 11:09'!visitMethodArguments: aNodeCollection 	^aNodeCollection do: [:each | self visitMethodArgument: each]! !!RBProgramNodeVisitor methodsFor: 'visiting'!visitNode: aNode 	^aNode acceptVisitor: self! !!RBProgramNodeVisitor methodsFor: 'visiting' stamp: 'nk 1/29/2005 11:14'!visitTemporaryVariable: aNode	^self visitArgument: aNode! !!RBProgramNodeVisitor methodsFor: 'visiting' stamp: 'nk 1/29/2005 11:07'!visitTemporaryVariables: aNodeCollection 	^aNodeCollection do: [:each | self visitTemporaryVariable: each]! !!RBReadBeforeWrittenTester class methodsFor: 'accessing' stamp: 'bh 3/15/2000 16:48'!isVariable: aString readBeforeWrittenIn: aBRProgramNode 	^(self isVariable: aString writtenBeforeReadIn: aBRProgramNode) not! !!RBReadBeforeWrittenTester class methodsFor: 'accessing' stamp: 'bh 3/15/2000 16:49'!isVariable: aString writtenBeforeReadIn: aBRProgramNode 	^(self readBeforeWritten: (Array with: aString) in: aBRProgramNode) 		isEmpty! !!RBReadBeforeWrittenTester class methodsFor: 'accessing' stamp: 'bh 3/15/2000 16:49'!readBeforeWritten: varNames in: aParseTree 	^(self new)		checkNewTemps: false;		initializeVars: varNames;		executeTree: aParseTree;		read! !!RBReadBeforeWrittenTester class methodsFor: 'accessing' stamp: 'bh 3/15/2000 16:49'!variablesReadBeforeWrittenIn: aParseTree 	^(self new)		executeTree: aParseTree;		read! !!RBReadBeforeWrittenTester methodsFor: 'visitor-double dispatching' stamp: 'bh 3/15/2000 16:45'!acceptAssignmentNode: anAssignmentNode 	self visitNode: anAssignmentNode value.	self variableWritten: anAssignmentNode! !!RBReadBeforeWrittenTester methodsFor: 'visitor-double dispatching' stamp: 'bh 3/15/2000 16:46'!acceptBlockNode: aBlockNode 	self processBlock: aBlockNode.! !!RBReadBeforeWrittenTester methodsFor: 'visitor-double dispatching' stamp: 'pmm 7/12/2006 15:51'!acceptMessageNode: aMessageNode 	((#(#whileTrue: #whileFalse: #whileTrue #whileFalse) 		includes: aMessageNode selector) and: [aMessageNode receiver isBlock]) 		ifTrue: [self executeTree: aMessageNode receiver body]		ifFalse: 			[(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 				ifTrue: [self visitNode: aMessageNode receiver]].	((#(#ifTrue:ifFalse: #ifFalse:ifTrue:) includes: aMessageNode selector) 		and: 			[ aMessageNode arguments allSatisfy: [:each | each isBlock] ]) 			ifTrue: [^self processIfTrueIfFalse: aMessageNode].	aMessageNode arguments do: [:each | self visitNode: each]! !!RBReadBeforeWrittenTester methodsFor: 'visitor-double dispatching' stamp: 'bh 3/15/2000 16:46'!acceptSequenceNode: aSequenceNode 	self processStatementNode: aSequenceNode! !!RBReadBeforeWrittenTester methodsFor: 'visitor-double dispatching' stamp: 'bh 3/15/2000 16:47'!acceptVariableNode: aVariableNode 	self variableRead: aVariableNode! !!RBReadBeforeWrittenTester methodsFor: 'initialize-release'!checkNewTemps: aBoolean 	checkNewTemps := aBoolean! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'bh 3/15/2000 16:40'!copyDictionary: aDictionary 	"We could send aDictionary the copy message, but that doesn't copy the associations."	| newDictionary |	newDictionary := Dictionary new: aDictionary size.	aDictionary		keysAndValuesDo: [:key :value | newDictionary at: key put: value].	^newDictionary! !!RBReadBeforeWrittenTester methodsFor: 'private'!createScope	scopeStack add: (self copyDictionary: scopeStack last)! !!RBReadBeforeWrittenTester methodsFor: 'private'!currentScope	^scopeStack last! !!RBReadBeforeWrittenTester methodsFor: 'accessing' stamp: 'bh 3/15/2000 16:39'!executeTree: aParseTree 	^self visitNode: aParseTree! !!RBReadBeforeWrittenTester methodsFor: 'initialize-release' stamp: 'bh 3/15/2000 16:37'!initialize	scopeStack := OrderedCollection with: Dictionary new.	read := Set new.	checkNewTemps := true.! !!RBReadBeforeWrittenTester methodsFor: 'initialize-release'!initializeVars: varNames 	varNames do: [:each | self currentScope at: each put: nil]! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'bh 3/15/2000 16:41'!processBlock: aNode 	| newScope |	self createScope.	self executeTree: aNode body.	newScope := self removeScope.	newScope keysAndValuesDo: 			[:key :value | 			(value == true and: [(self currentScope at: key) isNil]) 				ifTrue: [self currentScope at: key put: value]]! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'bh 3/15/2000 16:42'!processIfTrueIfFalse: aNode 	| trueScope falseScope |	self createScope.	self executeTree: aNode arguments first body.	trueScope := self removeScope.	self createScope.	self executeTree: aNode arguments last body.	falseScope := self removeScope.	self currentScope keysAndValuesDo: 			[:key :value | 			value isNil 				ifTrue: 					[(trueScope at: key) == (falseScope at: key) 						ifTrue: [self currentScope at: key put: (trueScope at: key)]						ifFalse: 							[((trueScope at: key) == true or: [(falseScope at: key) == true]) 								ifTrue: [self currentScope at: key put: true]]]]! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'bh 3/15/2000 16:42'!processStatementNode: aNode 	| temps |	(checkNewTemps not or: [aNode temporaries isEmpty]) 		ifTrue: 			[aNode statements do: [:each | self executeTree: each].			^self].	self createScope.	temps := aNode temporaries collect: [:each | each name].	self initializeVars: temps.	aNode statements do: [:each | self executeTree: each].	self removeScope keysAndValuesDo: 			[:key :value | 			(temps includes: key) 				ifTrue: [value == true ifTrue: [read add: key]]				ifFalse: 					[(self currentScope at: key) isNil 						ifTrue: [self currentScope at: key put: value]]]! !!RBReadBeforeWrittenTester methodsFor: 'accessing' stamp: 'bh 3/15/2000 16:39'!read	self currentScope		keysAndValuesDo: [:key :value | value == true ifTrue: [read add: key]].	^read! !!RBReadBeforeWrittenTester methodsFor: 'private'!removeScope	^scopeStack removeLast! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'bh 3/15/2000 16:44'!variableRead: aNode 	(self currentScope includesKey: aNode name) ifTrue: 			[(self currentScope at: aNode name) isNil				ifTrue: [self currentScope at: aNode name put: true]]! !!RBReadBeforeWrittenTester methodsFor: 'private' stamp: 'bh 3/15/2000 16:45'!variableWritten: aNode 	(self currentScope includesKey: aNode variable name) ifTrue: 			[(self currentScope at: aNode variable name) isNil				ifTrue: [self currentScope at: aNode variable name put: false]]! !!RBToken commentStamp: 'md 8/9/2005 14:53' prior: 0!RBToken is the abstract superclass of all of the RB tokens. These tokens (unlike the standard parser's) remember where they came from in the original source code.Subclasses must implement the following messages:	accessing		lengthInstance Variables:	sourcePointer	<Integer>	The position in the original source code where this token began.!!RBAssignmentToken commentStamp: 'md 8/9/2005 14:51' prior: 0!RBAssignmentToken is the first-class representation of the assignment token ':='!!RBAssignmentToken methodsFor: 'testing'!isAssignment	^true! !!RBAssignmentToken methodsFor: 'private' stamp: 'ls 1/11/2000 07:00'!length	^2! !!RBShortAssignmentToken methodsFor: 'private' stamp: 'ls 1/11/2000 07:00'!length	^1! !!RBToken class methodsFor: 'instance creation'!start: anInterval 	^self new start: anInterval! !!RBToken methodsFor: 'testing'!isAssignment	^false! !!RBToken methodsFor: 'testing'!isBinary	^false! !!RBToken methodsFor: 'testing'!isIdentifier	^false! !!RBToken methodsFor: 'testing'!isKeyword	^false! !!RBToken methodsFor: 'testing'!isLiteral	^false! !!RBToken methodsFor: 'testing'!isPatternBlock	^false! !!RBToken methodsFor: 'testing'!isPatternVariable	^false! !!RBToken methodsFor: 'testing' stamp: 'md 9/1/2005 16:02'!isRBToken	^true.! !!RBToken methodsFor: 'testing'!isSpecial	^false! !!RBToken methodsFor: 'accessing'!length	^self subclassResponsibility! !!RBToken methodsFor: 'accessing' stamp: 'ms 9/17/2006 02:05'!next	^next! !!RBToken methodsFor: 'accessing' stamp: 'ms 9/17/2006 02:05'!next: aToken	next := aToken! !!RBToken methodsFor: 'accessing' stamp: 'ms 9/17/2006 02:04'!previous	^previous! !!RBToken methodsFor: 'accessing' stamp: 'ms 9/17/2006 02:05'!previous: aToken	aToken ifNotNil:[aToken next: self].	previous := aToken! !!RBToken methodsFor: 'printing'!printOn: aStream 	aStream		nextPut: $ ;		nextPutAll: self class name! !!RBToken methodsFor: 'accessing'!removePositions	sourcePointer := nil! !!RBToken methodsFor: 'accessing'!start	^sourcePointer! !!RBToken methodsFor: 'initialize-release'!start: anInteger 	sourcePointer := anInteger! !!RBToken methodsFor: 'accessing'!stop	^self start + self length - 1! !!RBValueToken commentStamp: 'md 8/9/2005 14:53' prior: 0!RBValueToken is the abstract superclass of all tokens that have additional information attached. For example, the BinarySelector token holds onto the actual character (e.g. $+).Instance Variables:	value	<String>	The value of this token!!RBBinarySelectorToken commentStamp: 'md 8/9/2005 14:51' prior: 0!RBBinarySelectorToken is the first-class representation of a binary selector (e.g. +)!!RBBinarySelectorToken methodsFor: 'testing'!isBinary	^true! !!RBIdentifierToken commentStamp: 'md 8/9/2005 14:51' prior: 0!RBIdentifierToken is the first class representation of an identifier token (e.g. Class)!!RBIdentifierToken methodsFor: 'testing'!isIdentifier	^true! !!RBIdentifierToken methodsFor: 'testing' stamp: 'md 8/26/2004 18:36'!isPatternVariable	^value first == $`.		"value first == RBScanner patternVariableCharacter"! !!RBKeywordToken commentStamp: 'md 8/9/2005 14:52' prior: 0!RBKeywordToken is the first-class representation of a keyword token (e.g. add:)!!RBKeywordToken methodsFor: 'testing'!isKeyword	^true! !!RBKeywordToken methodsFor: 'testing' stamp: 'md 8/26/2004 18:37'!isPatternVariable		^value first == $`.		"value first == RBScanner patternVariableCharacter"! !!RBLiteralToken commentStamp: 'md 8/9/2005 14:52' prior: 0!RBLiteralToken is the first-class representation of a literal token (entire literals, even literal arrays, are a single token in the ST80 grammar.).Instance Variables:	stopPosition	<Integer>	The position within the source code where the token terminates.!!RBLiteralToken class methodsFor: 'instance creation'!value: anObject 	| literal |	literal := anObject class == Array 				ifTrue: [anObject collect: [:each | self value: each]]				ifFalse: [anObject].	^self 		value: literal		start: nil		stop: nil! !!RBLiteralToken class methodsFor: 'instance creation'!value: aString start: anInteger stop: stopInteger 	^self new		value: aString		start: anInteger		stop: stopInteger! !!RBLiteralToken methodsFor: 'testing'!isLiteral	^true! !!RBLiteralToken methodsFor: 'private'!length	^stopPosition - self start + 1! !!RBLiteralToken methodsFor: 'accessing'!stop: anObject 	stopPosition := anObject! !!RBLiteralToken methodsFor: 'initialize-release'!value: aString start: anInteger stop: stopInteger 	value := aString.	sourcePointer := anInteger.	stopPosition := stopInteger! !!RBPatternBlockToken commentStamp: 'md 8/9/2005 14:52' prior: 0!RBPatternBlockToken is the first-class representation of the pattern block token.!!RBPatternBlockToken methodsFor: 'testing'!isPatternBlock	^true! !!RBSpecialCharacterToken commentStamp: 'md 8/9/2005 14:53' prior: 0!RBSpecialCharacterToken is the first class representation of special characters.!!RBSpecialCharacterToken methodsFor: 'testing'!isSpecial	^true! !!RBSpecialCharacterToken methodsFor: 'private' stamp: 'md 8/30/2006 17:21'!length	^1! !!RBValueToken class methodsFor: 'instance creation'!value: aString start: anInteger 	^self new value: aString start: anInteger! !!RBValueToken methodsFor: 'private'!length	^value size! !!RBValueToken methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	value printOn: aStream.	aStream nextPutAll: ')'! !!RBValueToken methodsFor: 'accessing' stamp: 'pmm 7/31/2006 11:32'!realValue	^value class == Array		ifTrue: [value collect: [:each | each realValue]]		ifFalse: [value]! !!RBValueToken methodsFor: 'accessing'!value	^value! !!RBValueToken methodsFor: 'accessing'!value: anObject	value := anObject! !!RBValueToken methodsFor: 'initialize-release'!value: aString start: anInteger 	value := aString.	sourcePointer := anInteger! !!Behavior methodsFor: '*ast-override' stamp: 'md 7/13/2006 15:56' prior: 17342556!formatterClass	^Preferences useRBASTForPrettyPrint		ifFalse: [ self compilerClass ]		ifTrue: [ RBParser ]! !!Behavior methodsFor: '*ast'!parseTreeFor: aSymbol 	^RBParser parseMethod: (self sourceCodeAt: aSymbol)		onError: [:aString :pos | ^nil]! !!Behavior methodsFor: '*ast-override' stamp: 'md 7/13/2006 15:56' prior: 31945128!prettyPrinterClass	^Preferences useRBASTForPrettyPrint		ifFalse: [ self compilerClass ]		ifTrue: [ RBParser ]! !!RBSmallDictionary commentStamp: '<historical>' prior: 0!RBSmallDictionary is a special dictionary optimized for small collections. In addition to the normal dictionary protocol, it also supports an #empty message which "empties" the collection but may hang on to the original elements (so it could collect garbage). Without #empty we would either need to create a new dictionary or explicitly remove everything from the dictionary. Both of these take more time and #empty.Instance Variables:keys <Array of: Object> array of keys (we don't use Associations for our key value pairs)size <Integer> the size of the dictionaryvalues <Array of: Object> array of our values!!RBSmallDictionary class methodsFor: 'instance creation'!new	^self basicNew initialize! !!RBSmallDictionary class methodsFor: 'instance creation'!new: aSize 	"Ignore the size"	^self basicNew initialize! !!RBSmallDictionary methodsFor: 'adding'!add: anAssociation 	self at: anAssociation key put: anAssociation value.	^anAssociation! !!RBSmallDictionary methodsFor: 'enumerating'!associationsDo: aBlock 	self keysAndValuesDo: [:key :value | aBlock value: key -> value]! !!RBSmallDictionary methodsFor: 'accessing'!at: key ifAbsent: aBlock 	| index |	index := self findIndexFor: key.	^index == 0 ifTrue: [aBlock value] ifFalse: [values at: index]! !!RBSmallDictionary methodsFor: 'accessing'!at: key ifAbsentPut: aBlock 	| index |	index := self findIndexFor: key.	^index == 0 		ifTrue: [self privateAt: key put: aBlock value]		ifFalse: [values at: index]! !!RBSmallDictionary methodsFor: 'adding'!at: key put: value 	| index |	index := self findIndexFor: key.	^index == 0 		ifTrue: [self privateAt: key put: value]		ifFalse: [values at: index put: value]! !!RBSmallDictionary methodsFor: 'copying' stamp: 'bh 3/11/2000 02:18'!copy	^ self shallowCopy postCopy.! !!RBSmallDictionary methodsFor: 'enumerating'!do: aBlock 	1 to: size do: [:i | aBlock value: (values at: i)]! !!RBSmallDictionary methodsFor: 'accessing'!empty	size := 0! !!RBSmallDictionary methodsFor: 'private'!findIndexFor: aKey 	1 to: size do: [:i | (keys at: i) = aKey ifTrue: [^i]].	^0! !!RBSmallDictionary methodsFor: 'private'!growKeysAndValues	self growTo: size * 2! !!RBSmallDictionary methodsFor: 'private'!growTo: aSize 	| newKeys newValues |	newKeys := Array new: aSize.	newValues := Array new: aSize.	1 to: size		do: 			[:i | 			newKeys at: i put: (keys at: i).			newValues at: i put: (values at: i)].	keys := newKeys.	values := newValues! !!RBSmallDictionary methodsFor: 'testing'!includesKey: aKey 	^(self findIndexFor: aKey) ~~ 0! !!RBSmallDictionary methodsFor: 'initialize-release'!initialize	keys := Array new: 2.	values := Array new: 2.	size := 0! !!RBSmallDictionary methodsFor: 'as yet unclassified' stamp: 'nk 2/26/2005 11:12'!keyForPatternVariableNode: aString	^self keys detect: [ :ea | ea name = aString ] ifNone: [ ].! !!RBSmallDictionary methodsFor: 'enumerating'!keysAndValuesDo: aBlock 	1 to: size do: [:i | aBlock value: (keys at: i) value: (values at: i)]! !!RBSmallDictionary methodsFor: 'enumerating'!keysDo: aBlock 	1 to: size do: [:i | aBlock value: (keys at: i)]! !!RBSmallDictionary methodsFor: 'copying'!postCopy	keys := keys copy.	values := values copy! !!RBSmallDictionary methodsFor: 'private'!privateAt: key put: value 	size == keys size ifTrue: [self growKeysAndValues].	size := size + 1.	keys at: size put: key.	^values at: size put: value! !!RBSmallDictionary methodsFor: 'removing' stamp: 'bh 3/14/2000 22:59'!remove:anAssociation	self removeKey:anAssociation key.! !!RBSmallDictionary methodsFor: 'removing'!remove: oldObject ifAbsent: anExceptionBlock 	self removeKey: oldObject key ifAbsent: anExceptionBlock.	^oldObject! !!RBSmallDictionary methodsFor: 'removing'!removeKey: key ifAbsent: aBlock 	| index value |	index := self findIndexFor: key.	index == 0 ifTrue: [^aBlock value].	value := values at: index.	index to: size - 1		do: 			[:i | 			keys at: i put: (keys at: i + 1).			values at: i put: (values at: i + 1)].	keys at: size put: nil.	values at: size put: nil.	size := size - 1.	^value! !!RBSmallDictionary methodsFor: 'accessing'!size	^size! !!RBSmallDictionary methodsFor: 'as yet unclassified' stamp: 'nk 2/26/2005 11:12'!valueForPatternVariableNode: aString	^self at: (self keyForPatternVariableNode: aString) ifAbsent: [ ]! !!CompiledMethod methodsFor: '*ast' stamp: 'dvf 11/8/2003 15:01'!parseTree	^ RBParser parseMethod: self getSource asString.! !!RBScanner commentStamp: 'md 8/9/2005 14:54' prior: 0!RBScanner is a stream that returns a sequence of token from the string that it is created on. The tokens know where they came from in the source code and which comments were attached to them.Instance Variables:	buffer	<PositionableStream>	Accumulates the text for the current token.	characterType	<ByteSymbol>	The type of the next character. (e.g. #alphabetic, etc.)	classificationTable	<Array of: Symbol>	Mapping from Character values to their characterType.	comments	<Collection of: Interval>	Source intervals of scanned comments that must be attached to the next token.	currentCharacter	<Character>	The character currently being processed.	errorBlock	<BlockClosure>	The block to execute on lexical errors.	extendedLiterals	<Boolean>	True if IBM-type literals are allowed. In VW, this is false.	nameSpaceCharacter	<Character>	The character used to separate namespaces.	numberType	<ByteSymbol>	The method to perform: to scan a number. 	separatorsInLiterals	<Boolean>	True if separators are allowed within literals.	stream	<PositionableStream>	Contains the text to be scanned.	tokenStart	<Integer>	The source position of the beginning of the current tokenClass Instance Variables:	classificationTable	<Array>		the default classification table for all charactersShared Variables:	PatternVariableCharacter	<Character>	the character that starts a pattern node!!RBScanner class methodsFor: 'accessing'!classificationTable	ClassificationTable isNil ifTrue: [self initialize].	^ClassificationTable! !!RBScanner class methodsFor: 'class initialization' stamp: 'ls 3/20/2004 14:17'!initialize	PatternVariableCharacter := $`.	ClassificationTable := Array new: 255.	self initializeChars: 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ' to: #alphabetic.	self initializeChars: (128 to: 255) asByteArray asString to: #alphabetic.	self initializeChars: '01234567890' to: #digit.	self initializeChars: '!!!!%&*+,-/<=>?@\~|' to: #binary.	ClassificationTable at: 177 put: #binary.	"plus-or-minus"	ClassificationTable at: 183 put: #binary.	"centered dot"	ClassificationTable at: 215 put: #binary.	"times"	ClassificationTable at: 247 put: #binary.	"divide"	self initializeChars: '().:;[]^{}_' to: #special.	#(9 10 12 13 26 32) do: [:i | ClassificationTable at: i put: #separator]! !!RBScanner class methodsFor: 'class initialization'!initializeChars: characters to: aSymbol 	characters do: [:c | ClassificationTable at: c asInteger put: aSymbol]! !!RBScanner class methodsFor: 'testing'!isSelector: aSymbol 	| scanner token |	scanner := self basicNew.	scanner on: (ReadStream on: aSymbol asString).	scanner step.	token := scanner scanAnySymbol.	token isLiteral ifFalse: [^false].	token value isEmpty ifTrue: [^false].	^scanner atEnd! !!RBScanner class methodsFor: 'testing'!isVariable: aString 	| scanner token |	aString isString ifFalse: [^false].	aString isEmpty ifTrue: [^false].	(ClassificationTable at: aString first asInteger) == #alphabetic		ifFalse: [^false].	scanner := self basicNew.	scanner on: (ReadStream on: aString asString).	scanner errorBlock: [:s :p | ^false].	scanner step.	token := scanner scanIdentifierOrKeyword.	token isKeyword ifTrue: [^false].	^scanner atEnd! !!RBScanner class methodsFor: 'instance creation'!on: aStream 	| str |	str := self basicNew on: aStream.	str		step;		stripSeparators.	^str! !!RBScanner class methodsFor: 'instance creation'!on: aStream errorBlock: aBlock 	| str |	str := self basicNew on: aStream.	str		errorBlock: aBlock;		step;		stripSeparators.	^str! !!RBScanner class methodsFor: 'accessing'!patternVariableCharacter	^PatternVariableCharacter! !!RBScanner class methodsFor: 'instance creation'!rewriteOn: aStream 	| str |	str := self basicNew on: aStream.	str		extendedLanguage: true;		step;		stripSeparators.	^str! !!RBScanner class methodsFor: 'instance creation'!rewriteOn: aStream errorBlock: aBlock 	| str |	str := self basicNew on: aStream.	str		extendedLanguage: true;		errorBlock: aBlock;		step;		stripSeparators.	^str! !!RBScanner methodsFor: 'testing'!atEnd	^characterType == #eof! !!RBScanner methodsFor: 'accessing'!classificationTable: anObject	classificationTable := anObject! !!RBScanner methodsFor: 'private'!classify: aCharacter 	| index |	aCharacter isNil ifTrue: [^nil].	index := aCharacter asInteger.	index == 0 ifTrue: [^#separator].	index > 255 ifTrue: [^nil].	^classificationTable at: index! !!RBScanner methodsFor: 'accessing'!contents	| contentsStream |	contentsStream := WriteStream on: (Array new: 50).	self do: [:each | contentsStream nextPut: each].	^contentsStream contents! !!RBScanner methodsFor: 'error handling'!errorBlock	^errorBlock isNil		ifTrue: [[:message :position | ]]		ifFalse: [errorBlock]! !!RBScanner methodsFor: 'accessing'!errorBlock: aBlock 	errorBlock := aBlock! !!RBScanner methodsFor: 'error handling'!errorPosition	^stream position! !!RBScanner methodsFor: 'accessing'!extendedLanguage	^extendedLanguage! !!RBScanner methodsFor: 'accessing'!extendedLanguage: aBoolean 	extendedLanguage := aBoolean! !!RBScanner methodsFor: 'accessing'!flush! !!RBScanner methodsFor: 'accessing'!getComments	| oldComments |	comments isEmpty ifTrue: [^nil].	oldComments := comments.	comments := OrderedCollection new: 1.	^oldComments! !!RBScanner methodsFor: 'initialize-release' stamp: 'ls 1/30/2000 19:14'!initializeForSqueak	numberType := #scanNumberIBM.	separatorsInLiterals := true.	extendedLiterals := true.	extendedSymbols := true.	nameSpaceCharacter := nil.! !!RBScanner methodsFor: 'testing'!isReadable	^true! !!RBScanner methodsFor: 'testing'!isWritable	^false! !!RBScanner methodsFor: 'accessing'!next	| token |	buffer reset.	tokenStart := stream position.	characterType == #eof ifTrue: [^RBToken start: tokenStart + 1].	"The EOF token should occur after the end of input"	token := self scanToken.	self stripSeparators.	^token! !!RBScanner methodsFor: 'accessing'!nextPut: anObject 	"Provide an error notification that the receiver does not	implement this message."	self shouldNotImplement! !!RBScanner methodsFor: 'initialize-release' stamp: 'md 10/11/2005 15:49'!on: aStream 	buffer := WriteStream on: (String new: 60).	stream := aStream.	classificationTable := self class classificationTable.	extendedLanguage := false.	comments := OrderedCollection new.	self initializeForSqueak.! !!RBScanner methodsFor: 'private'!previousStepPosition	^characterType == #eof 		ifTrue: [stream position]		ifFalse: [stream position - 1]! !!RBScanner methodsFor: 'private-scanning'!scanAnySymbol	characterType == #alphabetic ifTrue: [^self scanSymbol].	characterType == #binary ifTrue: [^self scanBinary: RBLiteralToken].	^RBToken new! !!RBScanner methodsFor: 'private-scanning'!scanBinary: aClass 	"This doesn't parse according to the ANSI draft. It only parses 1 or 2 letter binary tokens."	| val |	buffer nextPut: currentCharacter.	self step.	(characterType == #binary and: [currentCharacter ~~ $-]) ifTrue: 			[buffer nextPut: currentCharacter.			self step].	val := buffer contents.	val := val asSymbol.	^aClass value: val start: tokenStart! !!RBScanner methodsFor: 'private-scanning'!scanByteArray	| byteStream number |	byteStream := WriteStream on: (ByteArray new: 100).	self step.		[self stripSeparators.	characterType == #digit] whileTrue: 				[number := self scanNumber value.				(number isInteger and: [number between: 0 and: 255]) 					ifFalse: [self scannerError: 'Expecting 8-bit integer'].				byteStream nextPut: number].	currentCharacter == $] ifFalse: [self scannerError: ''']'' expected'].	self step.	"]"	^RBLiteralToken 		value: byteStream contents		start: tokenStart		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning'!scanExponentMultipler	| exponent isExpNegative position |	currentCharacter == $e		ifTrue: 			[position := stream position.			self step.			(isExpNegative := currentCharacter == $-) ifTrue: [self step].			exponent := self scanNumberOfBase: 10.			exponent isNil				ifTrue: 					["Did not read a valid exponent, e must be start of a message send"					stream position: position - 1.					self step.					exponent := 0]				ifFalse: [isExpNegative ifTrue: [exponent := exponent negated]]]		ifFalse: [exponent := 0].	^10 raisedToInteger: exponent! !!RBScanner methodsFor: 'private-scanning' stamp: 'ls 1/30/2000 19:21'!scanExtendedSymbol	"scan symbols like #. which are allowed by Squeak but aren't standard"	| token |	token := RBLiteralToken value: (currentCharacter asString asSymbol) start: tokenStart stop: stream position.	self step.	^token! !!RBScanner methodsFor: 'private-scanning'!scanIdentifierOrKeyword	| tokenType token name |	self scanName.	currentCharacter == nameSpaceCharacter 		ifTrue: 			[token := self scanNamespaceName.			token notNil ifTrue: [^token]].	(currentCharacter == $: and: [stream peek ~~ $=]) 		ifTrue: 			[buffer nextPut: currentCharacter.			self step.	":"			tokenType := RBKeywordToken]		ifFalse: [tokenType := RBIdentifierToken].	name := buffer contents.	name = 'true' 		ifTrue: 			[^RBLiteralToken 				value: true				start: tokenStart				stop: self previousStepPosition].	name = 'false' 		ifTrue: 			[^RBLiteralToken 				value: false				start: tokenStart				stop: self previousStepPosition].	name = 'nil' 		ifTrue: 			[^RBLiteralToken 				value: nil				start: tokenStart				stop: self previousStepPosition].	^tokenType value: name start: tokenStart! !!RBScanner methodsFor: 'private-scanning' stamp: 'md 4/28/2006 15:02'!scanLiteral	self step.	separatorsInLiterals ifTrue: [self stripSeparators].	characterType == #alphabetic ifTrue: [^self scanSymbol].	characterType == #binary 		ifTrue: [^(self scanBinary: RBLiteralToken) stop: self previousStepPosition].	currentCharacter == $' ifTrue: [^self scanStringSymbol].	currentCharacter == $( ifTrue: [^self scanLiteralArray].	currentCharacter == $[ ifTrue: [^self scanByteArray].	(extendedSymbols and: [ '._' includes: currentCharacter ])		ifTrue: [^self scanExtendedSymbol ].	(separatorsInLiterals and: [currentCharacter == ${]) 		ifTrue: [^self scanQualifier].	self scannerError: 'Expecting a literal type'! !!RBScanner methodsFor: 'private-scanning'!scanLiteralArray	| arrayStream start |	arrayStream := WriteStream on: (Array new: 10).	self step.	start := tokenStart.		[self stripSeparators.	tokenStart := stream position.	currentCharacter == $)] 			whileFalse: 				[arrayStream nextPut: self scanLiteralArrayParts.				buffer reset].	self step.	^RBLiteralToken 		value: arrayStream contents		start: start		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning'!scanLiteralArrayParts	currentCharacter == $# ifTrue: [^self scanLiteral].	characterType == #alphabetic 		ifTrue: 			[| token value |			token := self scanSymbol.			value := token value.			value == #nil ifTrue: [token value: nil].			value == #true ifTrue: [token value: true].			value == #false ifTrue: [token value: false].			^token].	(characterType == #digit 		or: [currentCharacter == $- and: [(self classify: stream peek) == #digit]]) 			ifTrue: [^self scanNumber].	characterType == #binary 		ifTrue: [^(self scanBinary: RBLiteralToken) stop: self previousStepPosition].	currentCharacter == $' ifTrue: [^self scanLiteralString].	currentCharacter == $$ ifTrue: [^self scanLiteralCharacter].	currentCharacter == $( ifTrue: [^self scanLiteralArray].	currentCharacter == $[ ifTrue: [^self scanByteArray].	^self scannerError: 'Unknown character in literal array'! !!RBScanner methodsFor: 'private-scanning'!scanLiteralCharacter	| token |	self step.	"$"	token := RBLiteralToken 				value: currentCharacter				start: tokenStart				stop: stream position.	self step.	"char"	^token! !!RBScanner methodsFor: 'private-scanning'!scanLiteralString	self step.		[currentCharacter isNil 		ifTrue: [self scannerError: 'Unmatched '' in string literal.'].	currentCharacter == $' and: [self step ~~ $']] 			whileFalse: 				[buffer nextPut: currentCharacter.				self step].	^RBLiteralToken 		value: buffer contents		start: tokenStart		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning' stamp: 'pmm 7/12/2006 16:08'!scanName	[ #(alphabetic digit) includes: characterType ] whileTrue: 			[buffer nextPut: currentCharacter.			self step]! !!RBScanner methodsFor: 'private-scanning'!scanNamespaceName	extendedLiterals 		ifTrue: 			[stream peek == $: ifFalse: [^nil].			buffer next: 2 put: $:.			self step]		ifFalse: 			[(stream atEnd or: [(self classify: stream peek) ~~ #alphabetic]) 				ifTrue: [^nil].			buffer nextPut: $.].	self step.	self scanName.	currentCharacter == nameSpaceCharacter ifTrue: [self scanNamespaceName].	^RBIdentifierToken value: buffer contents start: tokenStart! !!RBScanner methodsFor: 'private-scanning'!scanNumber	^RBLiteralToken 		value: (self perform: numberType)		start: tokenStart		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning'!scanNumberIBM	| number isNegative |	isNegative := false.	currentCharacter == $- 		ifTrue: 			[isNegative := true.			self step].	number := self scanNumberWithoutExponent.	^(isNegative ifTrue: [number negated] ifFalse: [number]) 		* self scanExponentMultipler! !!RBScanner methodsFor: 'private-scanning'!scanNumberOfBase: anInteger 	"Scan a number. Return the number or nil if the current input isn't a valid number."	| number digits fraction isFloat succeeded |	digits := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ' copyFrom: 1 to: anInteger.	number := 0.	succeeded := false.	[digits includes: currentCharacter] whileTrue: 			[number := number * anInteger + (digits indexOf: currentCharacter) - 1.			self step.			succeeded := true].	succeeded ifFalse: [^nil].	isFloat := false.	(currentCharacter == $. and: [digits includes: stream peek]) ifTrue: 			[self step.			isFloat := true.			fraction := 1 / anInteger.			[digits includes: currentCharacter] whileTrue: 					[number := number + (((digits indexOf: currentCharacter) - 1) * fraction).					fraction := fraction / anInteger.					self step]].	^isFloat ifTrue: [number asFloat] ifFalse: [number]! !!RBScanner methodsFor: 'private-scanning'!scanNumberWithoutExponent	"Scan an IBM number with the radix -- don't scan the exponent though"	| number base |	base := self scanNumberOfBase: 10.	(currentCharacter == $r and: [base isInteger])		ifTrue: 			[| position |			position := stream position.			self step.			number := self scanNumberOfBase: base.			number isNil ifTrue: 					["Did not read a correct number, r must be start of a message send."					stream position: position - 1.					self step.					number := base]]		ifFalse: [number := base].	^number! !!RBScanner methodsFor: 'private-scanning'!scanPatternVariable	buffer nextPut: currentCharacter.	self step.	currentCharacter == ${ 		ifTrue: 			[self step.			^RBPatternBlockToken value: '`{' start: tokenStart].	[characterType == #alphabetic] whileFalse: 			[characterType == #eof 				ifTrue: [self scannerError: 'Meta variable expected'].			buffer nextPut: currentCharacter.			self step].	^self scanIdentifierOrKeyword! !!RBScanner methodsFor: 'private-scanning' stamp: 'bh 4/29/2000 18:01'!scanQualifier	| nameStream qualifierClass |	qualifierClass := Smalltalk at: #QualifiedName ifAbsent: [].	qualifierClass isNil ifTrue: [^ self scannerError: 'Unknown character'].	self step.	"{"	nameStream := WriteStream on: (String new: 10).	[currentCharacter == $}]		whileFalse: 			[nameStream nextPut: currentCharacter.			self step].	self step.	"}"	^ RBLiteralToken		value: (qualifierClass pathString: nameStream contents)		start: tokenStart		stop: self previousStepPosition! !!RBScanner methodsFor: 'private-scanning' stamp: 'ls 1/21/2000 22:38'!scanSpecialCharacter	| character |	currentCharacter == $: ifTrue: 			[self step.			^currentCharacter == $=				ifTrue: 					[self step.					RBAssignmentToken start: tokenStart]				ifFalse: [RBSpecialCharacterToken value: $: start: tokenStart]].	currentCharacter = $_ ifTrue:		[ self step.  ^RBShortAssignmentToken start: tokenStart ].	character := currentCharacter.	self step.	^RBSpecialCharacterToken value: character start: tokenStart! !!RBScanner methodsFor: 'private-scanning'!scanStringSymbol	| literalToken |	literalToken := self scanLiteralString.	literalToken value: literalToken value asSymbol.	^literalToken! !!RBScanner methodsFor: 'private-scanning'!scanSymbol	| lastPosition hasColon value startPosition |	hasColon := false.	startPosition := lastPosition := stream position.	[characterType == #alphabetic] whileTrue: 			[self scanName.			currentCharacter == $: 				ifTrue: 					[buffer nextPut: $:.					hasColon := true.					lastPosition := stream position.					self step]].	value := buffer contents.	(hasColon and: [value last ~~ $:]) 		ifTrue: 			[stream position: lastPosition.			self step.			value := value copyFrom: 1 to: lastPosition - startPosition + 1].	^RBLiteralToken 		value: value asSymbol		start: tokenStart		stop: self previousStepPosition! !!RBScanner methodsFor: 'accessing' stamp: 'bh 3/7/2000 02:17'!scanToken	"fast-n-ugly. Don't write stuff like this. Has been found to cause cancer in laboratory rats. Basically a 	case statement. Didn't use Dictionary because lookup is pretty slow."	characterType == #alphabetic ifTrue: [^self scanIdentifierOrKeyword].	(characterType == #digit 		or: [currentCharacter == $- and: [(self classify: stream peek) == #digit]]) 			ifTrue: [^self scanNumber].	characterType == #binary ifTrue: [^self scanBinary: RBBinarySelectorToken].	characterType == #special ifTrue: [^self scanSpecialCharacter].	currentCharacter == $' ifTrue: [^self scanLiteralString].	currentCharacter == $# ifTrue: [^self scanLiteral].	currentCharacter == $$ ifTrue: [^self scanLiteralCharacter].	extendedLanguage 		ifTrue: 			[currentCharacter == PatternVariableCharacter 				ifTrue: [^self scanPatternVariable].			currentCharacter == $} ifTrue: [^self scanSpecialCharacter]].	^self scannerError: 'Unknown character'! !!RBScanner methodsFor: 'error handling'!scannerError: aString 	"Evaluate the block. If it returns raise an error"	self errorBlock value: aString value: self errorPosition.	self error: aString! !!RBScanner methodsFor: 'private'!step	stream atEnd ifTrue: 			[characterType := #eof.			^currentCharacter := nil].	currentCharacter := stream next.	characterType := self classify: currentCharacter.	^currentCharacter! !!RBScanner methodsFor: 'private-scanning'!stripComment	| start stop |	start := stream position.	[self step == $"] whileFalse: 			[characterType == #eof				ifTrue: [self scannerError: 'Unmatched " in comment.']].	stop := stream position.	self step.	comments add: (start to: stop)! !!RBScanner methodsFor: 'private-scanning'!stripSeparators		[[characterType == #separator]		whileTrue: [self step].	currentCharacter == $"]		whileTrue: [self stripComment]! !!RBAbstractTest class methodsFor: 'accessing' stamp: 'ms 9/18/2006 17:54'!defaultParser		^SqueakParser! !!RBAbstractTest class methodsFor: 'testing' stamp: 'ms 9/16/2006 23:48'!isAbstract		^self  = RBAbstractTest! !!RBAbstractTest methodsFor: 'accessing' stamp: 'ms 9/16/2006 23:43'!defaultParser		^self class defaultParser! !!RBArrayNodeTest methodsFor: 'testing' stamp: 'ms 9/18/2006 17:57'!testFirstLastToken		| rbNode |	rbNode := (self defaultParser parseMethod: 'test {a := b. jo}') body statements first.	self assert: (rbNode firstToken value = '{').	self assert: (rbNode lastToken value = '}').		rbNode := (self defaultParser parseMethod: 'test ({a := b. 3. {si}})') body statements first.	self assert: (rbNode firstToken value = '(').	self assert: (rbNode lastToken value = ')')	! !!RBAssignmentNodeTest methodsFor: 'testing' stamp: 'ms 9/18/2006 18:37'!testFirstLastToken		| rbNode |	rbNode := (self defaultParser parseMethod: 'test a := b') body statements first.	self assert: (rbNode firstToken value = 'a').	self assert: (rbNode lastToken value = 'b').		rbNode := (self defaultParser parseMethod: 'test (a := b)') body statements first.	self assert: (rbNode firstToken value = '(').	self assert: (rbNode lastToken value = ')')! !!RBBlockNodeTest methodsFor: 'testing' stamp: 'ms 9/18/2006 18:42'!testFirstLastToken		| rbNode |	rbNode := (self defaultParser parseMethod: 'test []') body statements first.	self assert: (rbNode firstToken value = '[').	self assert: (rbNode lastToken value = ']').		rbNode := (self defaultParser parseMethod: 'test [:each :a]') body statements first.	self assert: (rbNode firstToken value = '[').	self assert: (rbNode lastToken value = ']').	rbNode := (self defaultParser parseMethod: 'test [:each :a | ^self]') body statements first.	self assert: (rbNode firstToken value = '[').	self assert: (rbNode lastToken value = ']').	rbNode := (self defaultParser parseMethod: 'test [^self]') body statements first.	self assert: (rbNode firstToken value = '[').	self assert: (rbNode lastToken value = ']').	rbNode := (self defaultParser parseMethod: 'test [| temp |]') body statements first.	self assert: (rbNode firstToken value = '[').	self assert: (rbNode lastToken value = ']').	rbNode := (self defaultParser parseMethod: 'test [:each || temp | ^self]') body statements first.	self assert: (rbNode firstToken value = '[').	self assert: (rbNode lastToken value = ']')! !!RBCascadeNodeTest methodsFor: 'testing' stamp: 'ms 9/17/2006 00:30'!testFirstLastToken		| rbNode |	rbNode := (self defaultParser parseMethod: 'test i factorial; add: aNum') body statements first.	self assert: (rbNode firstToken value = 'i').	self assert: (rbNode lastToken value = 'aNum')! !!RBFormatterTest methodsFor: 'testing' stamp: 'pmm 10/4/2006 14:01'!assertEqualFormattedAfterVerifyCode: aString	| methodNode |	self assert: (self class environment hasClassNamed: 'SqueakParser').	methodNode := self parse: aString.	self assert: (self class environment hasClassNamed: 'ASTChecker').	methodNode verifyIn: self class.	self assert: methodNode formattedCode = aString! !!RBFormatterTest methodsFor: 'testing' stamp: 'pmm 10/4/2006 14:01'!assertEqualFormattedCode: aString	| methodNode |	self assert: (self class environment hasClassNamed: 'SqueakParser').	methodNode := self parse: aString.	self assert: methodNode formattedCode = aString! !!RBFormatterTest methodsFor: 'fixtures' stamp: 'SR 9/3/2006 10:19'!parse: aString	^SqueakParser parseMethod: aString! !!RBFormatterTest methodsFor: 'strings' stamp: 'SR 9/3/2006 10:34'!pragmaAndPrimitiveMethodString	^'pragmaAndPrimitive	<primitive: 21>	<pragma: 21>	'! !!RBFormatterTest methodsFor: 'strings' stamp: 'SR 9/3/2006 10:30'!pragmaMethodString	^'pragma	<pragma: 21>	'! !!RBFormatterTest methodsFor: 'strings' stamp: 'SR 9/3/2006 10:29'!primitiveMethodString	^'primitive	<primitive: 21>	'! !!RBFormatterTest methodsFor: 'testing' stamp: 'pmm 10/4/2006 13:58'!testAll	#(		pragmaAndPrimitiveMethodString		pragmaMethodString		primitiveMethodString		threePragmaMethodString	) do: [ :stringSelector |		#(			assertEqualFormattedCode:			assertEqualFormattedAfterVerifyCode:		) do: [ :assertionSelector |			self perform: assertionSelector with: (self perform: stringSelector) ] ]! !!RBFormatterTest methodsFor: 'strings' stamp: 'pmm 10/4/2006 14:19'!testIsPritivePragma	| method primitive pragma |	method := self parse: self pragmaAndPrimitiveMethodString.	primitive := method pragmas detect: [ :each |		each pragma keyword = #primitive: ].	pragma := method pragmas detect: [ :each |		each pragma keyword = #pragma: ].	self assert: primitive isPrimitive.	self deny: pragma isPrimitive.	! !!RBFormatterTest methodsFor: 'strings' stamp: 'SR 9/3/2006 10:39'!threePragmaMethodString	^'threePragmas	<integer: 21>	<conference: ''ESUG'' year: 2006>	<yes>	'! !!RBLiteralNodeTest methodsFor: 'testing' stamp: 'ms 9/19/2006 12:57'!testFirstLastToken		| rbNode |	rbNode := (self defaultParser parseMethod: 'test true') body statements first.	self assert: (rbNode firstToken value = 'true').	self assert: (rbNode lastToken value = 'true').		rbNode := (self defaultParser parseMethod: 'test false') body statements first.	self assert: (rbNode firstToken value = 'false').	self assert: (rbNode lastToken value = 'false').		rbNode := (self defaultParser parseMethod: 'test nil') body statements first.	self assert: (rbNode firstToken value = 'nil').	self assert: (rbNode lastToken value = 'nil').		rbNode := (self defaultParser parseMethod: 'test 23') body statements first.	self assert: (rbNode firstToken value = '23').	self assert: (rbNode lastToken value = '23').		rbNode := (self defaultParser parseMethod: 'test -23') body statements first.	self assert: (rbNode firstToken value = '-23').	self assert: (rbNode lastToken value = '-23').		rbNode := (self defaultParser parseMethod: 'test $f') body statements first.	self assert: (rbNode firstToken value = '$f').	self assert: (rbNode lastToken value = '$f').		rbNode := (self defaultParser parseMethod: 'test ''bob''') body statements first.	self assert: (rbNode firstToken value = '''bob''').	self assert: (rbNode lastToken value = '''bob''').	rbNode := (self defaultParser parseMethod: 'test #''alice''') body statements first.	self assert: (rbNode firstToken value = '#').	self assert: (rbNode lastToken value = '''alice''').		rbNode := (self defaultParser parseMethod: 'test #alice') body statements first.	self assert: (rbNode firstToken value = '#').	self assert: (rbNode lastToken value = 'alice').		rbNode := (self defaultParser parseMethod: 'test #+') body statements first.	self assert: (rbNode firstToken value = '#').	self assert: (rbNode lastToken value = '+').		rbNode := (self defaultParser parseMethod: 'test #alice:') body statements first.	self assert: (rbNode firstToken value = '#').	self assert: (rbNode lastToken value = 'alice:').		rbNode := (self defaultParser parseMethod: 'test #alice:bob:') body statements first.	self assert: (rbNode firstToken value = '#').	self assert: (rbNode lastToken value = 'alice:bob:').		rbNode := (self defaultParser parseMethod: 'test #[3 4 0]') body statements first.	self assert: (rbNode firstToken value = '#').	self assert: (rbNode lastToken value = ']').	rbNode := (self defaultParser parseMethod: 'test #(alice black hat)') body statements first.	self assert: (rbNode firstToken value = '#').	self assert: (rbNode lastToken value = ')').		rbNode := (self defaultParser parseMethod: 'test #:indexOf:') body statements first.	self assert: (rbNode firstToken value = '#').	self assert: (rbNode lastToken value = ':indexOf:')								! !!RBMessageNodeTest methodsFor: 'testing' stamp: 'ms 9/17/2006 00:31'!testFirstLastToken		| rbNode |	rbNode := (self defaultParser parseMethod: 'test v factorial: w') body statements first.	self assert: (rbNode firstToken value = 'v').	self assert: (rbNode lastToken value = 'w').		rbNode := (self defaultParser parseMethod: 'test v factorial') body statements first.	self assert: (rbNode firstToken value = 'v').	self assert: (rbNode lastToken value = 'factorial')! !!RBMethodNodeTest methodsFor: 'testing' stamp: 'ms 9/16/2006 23:46'!testChildren		self assert: (self defaultParser parseMethod: 'bar: bob foo: alice ^self') children size = 3! !!RBMethodNodeTest methodsFor: 'testing' stamp: 'ms 9/16/2006 23:46'!testLastFirstToken		| aMethodNode |	aMethodNode := self defaultParser parseMethod: 'boo: ask tim whereIsBrian'.		self assert: (aMethodNode firstToken value = 'boo:').	self assert: (aMethodNode lastToken value = 'whereIsBrian')! !!RBMethodPatternNodeTest methodsFor: 'testing' stamp: 'ms 9/16/2006 22:41'!tesLastFirstToken	| rbMethod |	rbMethod := RBPatternMethodNode selectorParts: {RBKeywordToken value: 'bob:' start: 0} 									 arguments: {RBIdentifierToken value: 'arg' start: 0}.	self assert: (rbMethod firstToken value = 'bob:').	self assert: (rbMethod lastToken value = 'arg')! !!RBPragmaNodeTest methodsFor: 'testing' stamp: 'ms 9/18/2006 17:24'!testFirstLastToken	| aMethodNode |	aMethodNode := (self defaultParser parseMethod: 'test <hello: true>') pragmas first.		self assert: (aMethodNode firstToken value = '<').	self assert: (aMethodNode lastToken value = '>').		aMethodNode := (self defaultParser parseMethod: 'test <primitive: 4> <hello: true>') pragmas second.		self assert: (aMethodNode firstToken value = '<').	self assert: (aMethodNode lastToken value = '>')! !!RBReturnNodeTest methodsFor: 'testing' stamp: 'ms 9/18/2006 18:52'!testFirstLastToken	| aMethodNode |	aMethodNode := (self defaultParser parseMethod: 'test ^i owe: you') body statements first.		self assert: (aMethodNode firstToken value = '^').	self assert: (aMethodNode lastToken value = 'you').		aMethodNode := (self defaultParser parseMethod: 'test ^(i owe: you)') body statements first.		self assert: (aMethodNode firstToken value = '^').	self assert: (aMethodNode lastToken value = ')')! !!RBSequenceNodeTest methodsFor: 'testing' stamp: 'ms 9/18/2006 23:09'!testFirstLastToken		| rbNode |	rbNode := (self defaultParser parseMethod: 'test | a b |') body.	self assert: (rbNode firstToken value = '|').	self assert: (rbNode lastToken value = '|').		rbNode := (self defaultParser parseMethod: 'test []. u. []') body.	self assert: (rbNode firstToken value = '[').	self assert: (rbNode lastToken value = ']').		rbNode := (self defaultParser parseMethod: 'test | | []. {}') body.	self assert: (rbNode firstToken value = '|').	self assert: (rbNode lastToken value = '}').		rbNode := (self defaultParser parseMethod: 'test  | |') body.	self assert: (rbNode firstToken value  = '|').	self assert: (rbNode lastToken value = '|').		rbNode := (self defaultParser parseMethod: 'test  ||') body.	self assert: (rbNode firstToken value  = '||').	self assert: (rbNode lastToken value = '||').		rbNode := (self defaultParser parseMethod: 'test  || ^self') body.	self assert: (rbNode firstToken value  = '||').	self assert: (rbNode lastToken value = 'self').		rbNode := (self defaultParser parseMethod: 'test  [: each || tmp | ^3]') 					body statements first body.	self assert: (rbNode firstToken value  = '||').	self assert: (rbNode lastToken value = '3').		rbNode := (self defaultParser parseMethod: 'test ^self') body.	self assert: (rbNode firstToken value  = '^').	self assert: (rbNode lastToken value = 'self')! !!RBVariableNodeTest methodsFor: 'testing' stamp: 'ms 9/18/2006 17:26'!testFirstLastToken		| rbNode |	rbNode := RBVariableNode named: 'foo'.	self assert: (rbNode firstToken value = 'foo').	self assert: (rbNode lastToken value = 'foo').		rbNode := (self defaultParser parseMethod: 'test  (foo)') body statements first.	self assert: (rbNode firstToken value  = '(').	self assert: (rbNode lastToken value = ')').! !"AST"!'From Squeak3.8 of ''5 May 2005'' [latest update: #6665] on 2 September 2005 at 11:07:19 pm'!!MethodNode methodsFor: 'code generation' stamp: 'rw 9/2/2005 23:07' prior: 24453056!generate	^self generate: #(0 0 0 0)! !----End fileIn of a stream----!'From Squeak3.8 of ''5 May 2005'' [latest update: #6665] on 8 September 2005 at 1:18:43 am'!"Change Set:		RoelTyper-CoreDate:			8 September 2005Author:			Roel WuytsFast Type Reconstruction for Smalltalk. Load MethodNodeGenerate changeset before this one. See http://decomp.ulb.ac.be/roelwuyts/smalltalk/roeltyper/ for more info."!Object subclass: #AbstractType	instanceVariableNames: 'ivarClass ivarName'	classVariableNames: ''	poolDictionaries: ''	category: 'RoelTyper-Core'!Object subclass: #AbstractTypeComparison	instanceVariableNames: 'newResult existingResult'	classVariableNames: ''	poolDictionaries: ''	category: 'RoelTyper-Core'!AbstractType subclass: #EditedType	instanceVariableNames: 'editedTypes'	classVariableNames: ''	poolDictionaries: ''	category: 'RoelTyper-Core'!!EditedType commentStamp: '<historical>' prior: 0!I represent a TypingResult in which the user has made changes.!AbstractType subclass: #ExtractedType	instanceVariableNames: 'interface assignments extractedTypes'	classVariableNames: ''	poolDictionaries: ''	category: 'RoelTyper-Core'!InstructionClient subclass: #InstvarInterfaceExtractor	instanceVariableNames: 'stack copied initialStack method saveStacks input collector'	classVariableNames: ''	poolDictionaries: ''	category: 'RoelTyper-Core'!!InstvarInterfaceExtractor commentStamp: '<historical>' prior: 0!I am responsible for extracting the messages sent to an instance variable and the assignments done to an instance variable. I am supposed to work together with a TypeCollector.

Instance Variables:
	collector	<TypeCollector>	description of collector
	copied	<Array>	description of copied
	initialStack	<Collection | KeyBindingsList | MethodFilterAnd | MethodFilterOr>	description of initialStack
	input	<InstructionStream>	description of input
	method	<CompiledInitializer | CompiledMethod>	description of method
	saveStacks	<Dictionary>	description of saveStacks
	stack	<(OrderedCollection of: Object)>	description of stack

!AbstractTypeComparison subclass: #NoTypingConflict	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RoelTyper-Core'!InstvarInterfaceExtractor subclass: #SqueakInstvarInterfaceExtractor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RoelTyper-Core'!Object subclass: #TypeCollector	instanceVariableNames: 'theClass instVars typingResults'	classVariableNames: ''	poolDictionaries: ''	category: 'RoelTyper-Core'!!TypeCollector commentStamp: '<historical>' prior: 0!I collect and assemble the types sent to instance variables for a certain class (I use the InterfaceExtractor for that), And use them to create and return TypingResults.

Instance Variables:
	assignments	<Object>	description of assignments
	instVarOffset	<Object>	description of instVarOffset
	instVars	<(Palette of: (ExceptionSet | GenericException | SequenceableCollection | Signal)) | (SequenceableCollection of: (ExceptionSet | GenericException | SequenceableCollection | Signal))>	description of instVars
	sends	<Object>	description of sends
	theClass	<ClassDescription>	description of theClass

!TypeCollector subclass: #SqueakTypeCollector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RoelTyper-Core'!AbstractTypeComparison subclass: #TypingConflict	instanceVariableNames: 'conflictingSelectors conflictingAssignments'	classVariableNames: ''	poolDictionaries: ''	category: 'RoelTyper-Core'!Object subclass: #TypingResultKeeper	instanceVariableNames: 'timeTaken typeResults'	classVariableNames: ''	poolDictionaries: ''	category: 'RoelTyper-Core'!InstvarInterfaceExtractor subclass: #VWInstvarInterfaceExtractor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RoelTyper-Core'!TypeCollector subclass: #VWTypeCollector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RoelTyper-Core'!!AbstractType methodsFor: 'testing' stamp: ' 7/9/05 23:28'!isEditedResult

	^self subclassResponsibility! !!AbstractType methodsFor: 'testing' stamp: ' 7/9/05 23:28'!isExtractedResult

	^self subclassResponsibility! !!AbstractType methodsFor: 'testing' stamp: ' 7/9/05 23:28'!isObjectType

	^self isSingularType and: [self types includes: Object]! !!AbstractType methodsFor: 'testing' stamp: ' 7/9/05 23:28'!isSingularType

	^self types size = 1! !!AbstractType methodsFor: 'testing' stamp: ' 7/9/05 23:28'!is: aClass

	^self isSingularType and: [self types first = aClass]! !!AbstractType methodsFor: 'initialize-release' stamp: ' 7/9/05 23:28'!initialize
	"Do nothing, but give subclasses the chance to override."! !!AbstractType methodsFor: 'printing' stamp: ' 7/9/05 23:28'!printOn: aStream 

	self printTypesOn: aStream! !!AbstractType methodsFor: 'printing' stamp: ' 7/9/05 23:28'!printTypesOn: aStream 

	self types do: [:each | aStream print: each]
		separatedBy: [aStream nextPutAll: ' , ']! !!AbstractType methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!ivarClass

	^ivarClass! !!AbstractType methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!ivarClass: aClass

	ivarClass := aClass.
	self triggerEvent: #changed! !!AbstractType methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!ivarName

	^ivarName! !!AbstractType methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!ivarName: aSymbol

	ivarName := aSymbol.
	self triggerEvent: #changed! !!AbstractType methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!types

	^self subclassResponsibility! !!AbstractType methodsFor: 'comparing-private' stamp: ' 7/9/05 23:28'!sameAsEditedType: anEditedTypingResult
	"Return whether the receiver and the arguments are the same e.g. whether they have the same values for the interfaces, sends and extracted types."

	^self subclassResponsibility! !!AbstractType methodsFor: 'comparing-private' stamp: ' 7/9/05 23:28'!sameAsExtractedType: anExtractedTypingResult
	"Return whether the receiver and the arguments are the same e.g. whether they have the same values for the interfaces, sends and extracted types."

	^self subclassResponsibility! !!AbstractType methodsFor: 'private' stamp: ' 7/9/05 23:28'!conflictingAssignmentsWith: anExtractedType 
	| conflictingAssignments |
	conflictingAssignments := anExtractedType assignments 
				select: [:assignment | (self types includes: assignment) not].
	^conflictingAssignments! !!AbstractType methodsFor: 'private' stamp: ' 7/9/05 23:28'!conflictingSelectorsWith: anExtractedType 
	| conflictingSelectors |
	conflictingSelectors := Dictionary new.
	anExtractedType interface do: 
			[:selector | 
			self types do: 
					[:aType | 
					(aType canUnderstand: selector) 
						ifFalse: 
							[(conflictingSelectors at: selector ifAbsentPut: [OrderedCollection new]) 
								add: aType]]].
	^conflictingSelectors! !!AbstractType methodsFor: 'comparing' stamp: ' 7/9/05 23:28'!conformsTo: anExtractedType 
	"I am a type. Return whether my types conform to the interface and assignments from the argument."

	| conflictingSelectors conflictingAssignments |
	conflictingSelectors := self conflictingSelectorsWith: anExtractedType.
	conflictingAssignments := self conflictingAssignmentsWith: anExtractedType.
	^(conflictingSelectors isEmpty and: [conflictingAssignments isEmpty]) 
		ifTrue: [NoTypingConflict existingResult: self newResult: anExtractedType]
		ifFalse: 
			[TypingConflict 
				existingResult: self
				newResult: anExtractedType
				conflictingSelectors: conflictingSelectors
				conflictingAssignments: conflictingAssignments]! !!AbstractType methodsFor: 'comparing' stamp: ' 7/9/05 23:28'!isConformingTo: aType

	^(self conformsTo: aType) notConflict! !!AbstractType methodsFor: 'comparing' stamp: ' 7/9/05 23:28'!sameAs: aTypingResult 
	"Return whether the receiver and the arguments are the same e.g. whether they have the same values for the interfaces, sends and extracted types."

	^self subclassResponsibility! !!AbstractTypeComparison methodsFor: 'testing' stamp: ' 7/9/05 23:28'!isConflict

	^false! !!AbstractTypeComparison methodsFor: 'testing' stamp: ' 7/9/05 23:28'!notConflict

	^self isConflict not! !!AbstractTypeComparison methodsFor: 'printing' stamp: ' 7/9/05 23:28'!explanationString

	^self subclassResponsibility! !!AbstractTypeComparison methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!existingResult
	^existingResult! !!AbstractTypeComparison methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!existingResult: anObject
	existingResult := anObject! !!AbstractTypeComparison methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!ivarClass

	^self newResult ivarClass! !!AbstractTypeComparison methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!ivarName

	^self newResult ivarName! !!AbstractTypeComparison methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!newResult
	^newResult! !!AbstractTypeComparison methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!newResult: anObject
	newResult := anObject! !!Behavior methodsFor: 'enumerating' stamp: ' 7/9/05 23:28'!nonMetaSubclassesDo: aBlock 
	"Evaluate the argument, aBlock, for each of the receiver's immediate non-meta subclasses."

	subclasses == nil 
		ifFalse: [subclasses do: aBlock]! !!ClassDescription methodsFor: 'organization' stamp: ' 7/9/05 23:28'!categoryForSelector: aSelector 
	"Starting from the receiver, find the category for the given selector (if any). "
	"Works for Squeak as well,so do not use the fancy ifNil:ifNotNil: trick with arguments from VW, as Squeak does not digest it."

	| cat s |
	^(cat := self whichCategoryIncludesSelector: aSelector) ifNil: 
			[(s := self superclass) ifNil: [nil]
				ifNotNil: [s categoryForSelector: aSelector]]
		ifNotNil: [cat]! !!Class methodsFor: 'enumerating' stamp: ' 7/9/05 23:28'!nonMetaSubclassesDo: aBlock 
	"Evaluate the argument, aBlock, for each of the receiver's immediate non-meta subclasses."
	"This one is here for the sake of Squeak (where it is Class and not Behavior that keeps the subclasses instance variable)."

	subclasses == nil 
		ifFalse: [subclasses do: aBlock]! !!AbstractType class methodsFor: 'instance creation' stamp: ' 7/9/05 23:28'!forInstvar: iv inClass: aClass 

	^(self basicNew) initialize
		ivarName: iv;
		ivarClass: aClass;
		yourself! !!AbstractType class methodsFor: 'instance creation' stamp: ' 7/9/05 23:28'!new

	^self shouldNotImplement! !!AbstractTypeComparison class methodsFor: 'instance creation' stamp: ' 7/9/05 23:28'!existingResult: existingTypingResult newResult: newTypingResult

	^self basicNew
		newResult: newTypingResult;	
		existingResult: existingTypingResult;
		yourself! !!AbstractTypeComparison class methodsFor: 'instance creation' stamp: ' 7/9/05 23:28'!new

	^self shouldNotImplement! !!Collection methodsFor: 'testing' stamp: ' 7/9/05 23:28'!sameElements: aCollection 

	^(self allSatisfy: [:each | aCollection includes: each]) 
		and: [aCollection allSatisfy: [:each | self includes: each]]! !!EditedType methodsFor: 'testing' stamp: ' 7/9/05 23:28'!isEditedResult

	^true! !!EditedType methodsFor: 'testing' stamp: ' 7/9/05 23:28'!isExtractedResult

	^false! !!EditedType methodsFor: 'printing' stamp: ' 7/9/05 23:28'!printOn: aStream 

	aStream nextPutAll: 'EditedType: '.
	self printTypesOn: aStream! !!EditedType methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!types

	^editedTypes! !!EditedType methodsFor: 'private-accessing' stamp: ' 7/9/05 23:28'!editedTypes: aCollection

	editedTypes := aCollection.
	self triggerEvent: #changed! !!EditedType methodsFor: 'comparing-private' stamp: ' 7/9/05 23:28'!sameAsEditedType: anEditedTypingResult
	"Return whether the receiver and the arguments are the same e.g. whether they have the same values for the interfaces, sends and extracted types."

	^self types sameElements: anEditedTypingResult types! !!EditedType methodsFor: 'comparing-private' stamp: ' 7/9/05 23:28'!sameAsExtractedType: anExtractedTypingResult
	"Return whether the receiver and the arguments are the same e.g. whether they have the same values for the interfaces, sends and extracted types."

	^self types sameElements: anExtractedTypingResult types! !!EditedType methodsFor: 'comparing' stamp: ' 7/9/05 23:28'!sameAs: aTypingResult 
	"Return whether the receiver and the arguments are the same e.g. whether they have the same values for the interfaces, sends and extracted types."

	^aTypingResult sameAsEditedType: self! !!EditedType class methodsFor: 'instance creation' stamp: ' 7/9/05 23:28'!forInstvar: iv inClass: aClass types: aClassCollection

	^(self forInstvar: iv inClass: aClass) editedTypes: aClassCollection! !!ExtractedType methodsFor: 'testing' stamp: ' 7/9/05 23:28'!hasEmptyAssignments
	^self assignments isEmpty! !!ExtractedType methodsFor: 'testing' stamp: ' 7/9/05 23:28'!hasEmptyInterface
	^self interface isEmpty! !!ExtractedType methodsFor: 'testing' stamp: ' 7/9/05 23:28'!isEditedResult

	^false! !!ExtractedType methodsFor: 'testing' stamp: ' 7/9/05 23:28'!isEmpty
	^self hasEmptyAssignments and: [self hasEmptyInterface]! !!ExtractedType methodsFor: 'testing' stamp: ' 7/9/05 23:28'!isExtractedResult

	^true! !!ExtractedType methodsFor: 'initialize-release' stamp: ' 7/9/05 23:28'!initialize

	super initialize.
	self interface: IdentitySet new assignments: OrderedCollection new! !!ExtractedType methodsFor: 'printing' stamp: ' 7/9/05 23:28'!printInterfaceAndAssigmentsOn: aStream 
	aStream nextPutAll: 'Sends: {'.
	self interface do: [:symbol | aStream print: symbol]
		separatedBy: [aStream space].
	aStream
		nextPutAll: '}';
		cr;
		nextPutAll: 'Assignments: {'.
	self assignments do: [:symbol | aStream print: symbol]
		separatedBy: [aStream space].
	aStream
		nextPutAll: '}';
		cr! !!ExtractedType methodsFor: 'printing' stamp: ' 7/9/05 23:28'!printOn: aStream 

	aStream nextPutAll: 'ExtractedType: '.
	self basicExtractedTypes 
		ifNil: [self printInterfaceAndAssigmentsOn: aStream]
		ifNotNil: [self printTypesOn: aStream]! !!ExtractedType methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!types

	^extractedTypes ifNil: 
			[extractedTypes := self fold: (self rootsUnderstanding: self interface)
						with: self cleanedAssignments]
		ifNotNil: [extractedTypes]! !!ExtractedType methodsFor: 'private-accessing' stamp: ' 7/9/05 23:28'!addAssignment: anObject 

	(self assignments includes: anObject) ifFalse: [self assignments add: anObject]! !!ExtractedType methodsFor: 'private-accessing' stamp: ' 7/9/05 23:28'!addSend: anObject 
	self interface add: anObject! !!ExtractedType methodsFor: 'private-accessing' stamp: ' 7/9/05 23:28'!assignments
	^assignments! !!ExtractedType methodsFor: 'private-accessing' stamp: ' 7/9/05 23:28'!basicExtractedTypes

	^extractedTypes! !!ExtractedType methodsFor: 'private-accessing' stamp: ' 7/9/05 23:28'!interface
	^interface! !!ExtractedType methodsFor: 'private-accessing' stamp: ' 7/9/05 23:28'!interface: selectorCollection assignments: classCollection 
	interface := selectorCollection.
	assignments := classCollection! !!ExtractedType methodsFor: 'comparing-private' stamp: ' 7/9/05 23:28'!sameAsEditedType: anEditedTypingResult
	"Return whether the receiver and the arguments are the same e.g. whether they have the same values for the interfaces, sends and extracted types."

	^self types sameElements: anEditedTypingResult types! !!ExtractedType methodsFor: 'comparing-private' stamp: ' 7/9/05 23:28'!sameAsExtractedType: anExtractedTypingResult
	"Return whether the receiver and the arguments are the same e.g. whether they have the same values for the interfaces, sends and extracted types."

	^(self assignments sameElements: anExtractedTypingResult assignments) and: [
		(self interface sameElements: anExtractedTypingResult interface) and: [
				(self basicExtractedTypes isNil 
					and: [anExtractedTypingResult basicExtractedTypes isNil]) 
						or: [self types sameElements: anExtractedTypingResult types]]]! !!ExtractedType methodsFor: 'private' stamp: ' 7/9/05 23:28'!cleanedAssignments
	| assigns |
	assigns := self assignments copy.
	((assigns includes: True) and: [assigns includes: False]) 
		ifTrue: 
			[assigns
				remove: True;
				remove: False;
				add: Boolean].
	^assigns! !!ExtractedType methodsFor: 'private' stamp: ' 7/9/05 23:28'!fold: interfaceClasses with: assignmentClasses 

	| commonSuper |
	interfaceClasses remove: Object ifAbsent: [].	"breaks constraint that all classes found are most abstract useful types!!"
	assignmentClasses do: [:each |
		commonSuper := interfaceClasses detect: [:sendResultClass | each includesBehavior: sendResultClass] ifNone: [nil].
		commonSuper ifNotNil: [interfaceClasses remove: commonSuper; add: each ] ifNil: [
			interfaceClasses copy detect: [:cl | cl includesBehavior: each] ifNone: [interfaceClasses add: each]].
	].
	interfaceClasses isEmpty ifTrue: [interfaceClasses add: Object].	"Add again if nothing found"
	^interfaceClasses asSortedCollection: [:cl1 :cl2 | cl1 name < cl2 name].! !!ExtractedType methodsFor: 'private' stamp: ' 7/9/05 23:28'!rootsUnderstanding: selectors

	| initialClasses nextClasses traverseClassesStack next prototypeSet |
	prototypeSet := IdentitySet new: 20.
	nextClasses := prototypeSet copy add: Object; yourself.
	selectors do: 
			[:selector | 
			initialClasses := nextClasses.
			nextClasses := prototypeSet copy.
			initialClasses do: 
					[:initialClass | 
					(initialClass canUnderstand: selector) 
						ifTrue: [nextClasses add: initialClass]
						ifFalse: 
							[traverseClassesStack := OrderedCollection with: initialClass.
							[traverseClassesStack isEmpty] whileFalse: 
									[next := traverseClassesStack removeFirst.
									 next nonMetaSubclassesDo: [:subcl | 
											(subcl includesSelector: selector) 
												ifTrue: [nextClasses add: subcl]
												ifFalse: [traverseClassesStack add: subcl]]]]]].
	^nextClasses! !!ExtractedType methodsFor: 'comparing' stamp: ' 7/9/05 23:28'!sameAs: aTypingResult 
	"Return whether the receiver and the arguments are the same e.g. whether they have the same values for the interfaces, sends and extracted types."

	^aTypingResult sameAsExtractedType: self! !!ExtractedType class methodsFor: 'instance creation' stamp: ' 7/9/05 23:28'!forInstvar: iv inClass: aClass interface: selectorCollection assignments: classCollection 

	^(self forInstvar: iv inClass: aClass) interface: selectorCollection
		assignments: classCollection! !!InstvarInterfaceExtractor methodsFor: 'extracting' stamp: ' 7/9/05 23:28'!extractInterfacesFrom: m addTo: aTypeCollector

	method := m.
	saveStacks := Dictionary new.
	stack := OrderedCollection new.
	method numTemps timesRepeat: [stack add: #temp].
	initialStack := stack copy.
	collector := aTypeCollector.
	input := InstructionStream on: method.
	[input atEnd] whileFalse: [self reloadStack. input interpretNextInstructionFor: self]! !!InstvarInterfaceExtractor methodsFor: 'opcodes-data movement' stamp: ' 7/9/05 23:28'!dupFirst

	stack add: stack last.! !!InstvarInterfaceExtractor methodsFor: 'opcodes-data movement' stamp: ' 7/9/05 23:28'!pop

	stack removeLast.! !!InstvarInterfaceExtractor methodsFor: 'opcodes-data movement' stamp: ' 7/9/05 23:28'!pushConstant: value

	value class == BlockClosure
		ifTrue: [self readBlock: value method copied: 0]
		ifFalse: [stack addLast: value class]! !!InstvarInterfaceExtractor methodsFor: 'opcodes-data movement' stamp: ' 7/9/05 23:28'!pushContext

	stack add: #context.! !!InstvarInterfaceExtractor methodsFor: 'opcodes-data movement' stamp: ' 7/9/05 23:28'!pushInst: index

	stack add: index! !!InstvarInterfaceExtractor methodsFor: 'opcodes-data movement' stamp: ' 7/9/05 23:28'!pushReceiver

	stack addLast: #self.! !!InstvarInterfaceExtractor methodsFor: 'opcodes-data movement' stamp: ' 7/9/05 23:28'!pushStatic: assoc
	"assoc can be an association OR a variable binding. I just push the complete association, since it does not interest me for the moment."

	stack addLast: assoc! !!InstvarInterfaceExtractor methodsFor: 'opcodes-control' stamp: ' 7/9/05 23:28'!send: selector numArgs: na 

	| receiver args |
	args := stack removeLast: na.
	receiver := (stack removeLast: 1) first.
	receiver isInteger ifTrue: [collector addSend: selector to: receiver].
	stack add: (collector 
				pushSendOf: selector
				to: receiver
				args: args)! !!InstvarInterfaceExtractor methodsFor: 'private' stamp: ' 7/9/05 23:28'!copied: list

	copied := list! !!InstvarInterfaceExtractor methodsFor: 'private' stamp: ' 7/9/05 23:28'!input

	^input! !!InstvarInterfaceExtractor methodsFor: 'private' stamp: ' 7/9/05 23:28'!method: aMethod

	method := aMethod.
	copied := #()! !!InstvarInterfaceExtractor methodsFor: 'private' stamp: ' 7/9/05 23:28'!readBlock: block copied: count

	| newCopied |
	newCopied := stack removeLast: count.
	stack add: #block.
	^self class new
		copied: newCopied;
		extractInterfacesFrom: block addTo: collector! !!InstvarInterfaceExtractor methodsFor: 'private' stamp: ' 7/9/05 23:28'!reloadStack

	stack isNil
		ifTrue: [stack :=  self saveStacks at: self input pc ifAbsent: [initialStack copy]. ^self].
	stack := self saveStacks at: self input pc ifAbsent: [stack]! !!InstvarInterfaceExtractor methodsFor: 'private' stamp: ' 7/9/05 23:28'!saveStacks

	saveStacks ifNil: [saveStacks := Dictionary new].
	^saveStacks! !!NoTypingConflict methodsFor: 'printing' stamp: ' 7/9/05 23:28'!explanationString

	^'No conflict.'! !!NoTypingConflict methodsFor: 'printing' stamp: ' 7/9/05 23:28'!printOn: aStream

	aStream
		nextPutAll: 'Type OK for ';
		nextPutAll: self ivarClass shortName;
		nextPutAll: ' - ';
		nextPutAll: self ivarName! !!SqueakInstvarInterfaceExtractor methodsFor: 'opcodes-control' stamp: ' 7/9/05 23:28'!sendSuper: selector numArgs: na 

	stack removeLast: na + 1.
	stack add: #computed! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!blockReturnTop
	"Return Top Of Stack bytecode."

	^self pop! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!doDup
	"Duplicate Top Of Stack bytecode."

	self dupFirst! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!doPop
	"Remove Top Of Stack bytecode."

	^self pop! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!jump: delta

	| currentPC |
	currentPC := self input pc.
	delta > 0
		ifTrue: [self saveStacks at: currentPC+delta put: stack copy. stack := OrderedCollection new].! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!jump: delta if: condition

	self pop.		"receiver of ifTrue or ifFalse, according to condition"
	delta > 0
		ifTrue: [self saveStacks at: self input pc+delta put: (stack copy add: #computed; yourself)].! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!methodReturnConstant: value 
	"Return Constant bytecode."

	^self pushConstant: value; sqReturnTop! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!methodReturnReceiver
	"Return Self bytecode."

	^self pushReceiver; sqReturnTop! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!methodReturnTop
	"Return Top Of Stack bytecode."

	^self sqReturnTop! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!popIntoLiteralVariable: anAssociation 
	"Remove Top Of Stack And Store Into Literal Variable bytecode."

	^self pop! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!popIntoReceiverVariable: offset 
	"Remove Top Of Stack And Store Into Instance Variable bytecode."

	collector handleAssignment: stack removeLast for: offset! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!popIntoTemporaryVariable: offset 
	"Remove Top Of Stack And Store Into Temporary Variable bytecode."

	"Nothing to do,since I do not treat temporary variables for the moment."! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!pushActiveContext
	"Push Active Context On Top Of Its Own Stack bytecode."

	self pushContext! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!pushLiteralVariable: anAssociation
	"Push Contents Of anAssociation On Top Of Stack bytecode."

	self pushStatic: anAssociation! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!pushReceiverVariable: offset
	"Push Contents Of the Receiver's Instance Variable Whose Index 
	is the argument, offset, On Top Of Stack bytecode."

	self pushInst: offset! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!pushTemporaryVariable: offset
	"Push Contents Of Temporary Variable Whose Index Is the 
	argument, offset, On Top Of Stack bytecode."

	stack add: #tempVariable! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!send: selector super: supered numArgs: numberArguments
	"Send Message With Selector, selector, bytecode. The argument, 
	supered, indicates whether the receiver of the message is specified with 
	'super' in the source method. The arguments of the message are found in 
	the top numArguments locations on the stack and the receiver just 
	below them."

	^supered
		ifTrue: [self sendSuper: selector numArgs: numberArguments]
		ifFalse: [self send: selector numArgs: numberArguments]! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!storeIntoLiteralVariable: anAssociation 
	"Store Top Of Stack Into Literal Variable Of Method bytecode."

	"Nothing to do, since I do not do anything with literal variables. Just keep the right-hand side on the stack for further processing"! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!storeIntoReceiverVariable: offset 
	"Store Top Of Stack Into Instance Variable Of Method bytecode."

	| rvalue |
	collector handleAssignment: (rvalue := stack removeLast) for: offset.
	stack add: rvalue! !!SqueakInstvarInterfaceExtractor methodsFor: 'instruction decoding' stamp: ' 7/9/05 23:28'!storeIntoTemporaryVariable: offset 
	"Store Top Of Stack Into Temporary Variable Of Method bytecode."

	"Nothing to do,since I do not treat temporary variables for the moment."! !!SqueakInstvarInterfaceExtractor methodsFor: 'private' stamp: ' 7/9/05 23:28'!sqReturnTop
	"In VW, method returnTop is inherited from instructionClient and does nothing."! !!TypeCollector methodsFor: 'initialize-release' stamp: ' 7/9/05 23:28'!onClass: aClass

	theClass := aClass.
	instVars := aClass allInstVarNames collect: [:e | e asSymbol].
	typingResults :=  (instVars collect: [:ivar | ExtractedType forInstvar: ivar inClass: aClass]) asArray.! !!TypeCollector methodsFor: 'public-typing' stamp: ' 7/9/05 23:28'!typeInstvarsOfClass: aClass 
	| extractor |
	self onClass: aClass.
	extractor := self newExtractor.
	aClass 
		selectorsAndMethodsDo: [:sel :method | extractor extractInterfacesFrom: method addTo: self].
	^self packagedResults! !!TypeCollector methodsFor: 'adding' stamp: ' 7/9/05 23:28'!addAssignment: value to: index

	self withTranslatedIndex: index do: [:i | (self typingResults at: i) addAssignment: value]! !!TypeCollector methodsFor: 'adding' stamp: ' 7/9/05 23:28'!addSend: selector to: index 
	"Add a range check to filter out sends to instvars defined in superclasses, etc."

	self withTranslatedIndex: index do: [:i | (self typingResults at: i) addSend: selector]! !!TypeCollector methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!assignmentsTo: instVarName 

	^(self typingResultsFor: instVarName) assignments! !!TypeCollector methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!indexForVar: iVar
	"Note: works for Squeak and VisualWorks. If it would be only for VW, you could just use instVarIndexFor: instead."

	^instVars indexOf: iVar! !!TypeCollector methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!packagedResults

	| results |
	results := IdentityDictionary new: self typingResults size.

	instVars size - theClass instVarNames size + 1 to: instVars size do: [:index |
		results at: (instVars at: index) put: (self typingResults at: index)].
	^results! !!TypeCollector methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!sendsTo: instVarName 
	"	^self sends at: (self indexForVar: instVarName)"

	^(self typingResultsFor: instVarName) interface! !!TypeCollector methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!typingResults

	^typingResults! !!TypeCollector methodsFor: 'heuristics' stamp: ' 7/9/05 23:28'!assignmentTypeOf: val

	^self subclassResponsibility! !!TypeCollector methodsFor: 'heuristics' stamp: ' 7/9/05 23:28'!handleAssignment: val for: index 
	"Cannot use ifNotNil: with argument in Squeak, so use a temporary instead."

	| result |
	result := nil.
	val isInteger 
		ifTrue: [self withTranslatedIndex: val do: [:idx | result := self lastAssignmentForIndex: idx]]
		ifFalse: [result := self assignmentTypeOf: val].
	result ifNotNil: [self addAssignment: result to: index]! !!TypeCollector methodsFor: 'heuristics' stamp: ' 7/9/05 23:28'!langueSpecificPushSendOf: selector to: rec args: args

	^#computed! !!TypeCollector methodsFor: 'heuristics' stamp: ' 7/9/05 23:28'!pushSendOf: selector to: rec args: args
	"Needs to be optimized"

	| recValue index |
	(rec == #self) ifTrue: [
		((index := instVars indexOf: selector) > 0) ifTrue: [^index - 1].
		((selector last == $:) and: [(index := instVars indexOf: (selector copyFrom: 1 to: selector size - 1) asSymbol) > 0])
			ifTrue: [self handleAssignment: args first for: index - 1. ^#computed]].
	(#(#= #== #< #> #<= #>= #~=) includes: selector) ifTrue: [^Boolean].
	('is*' match: selector) ifTrue: [^Boolean].
	((rec isVariableBinding) and: [(recValue := rec value) isBehavior
		and: [(recValue class categoryForSelector: selector) == #'instance creation' ]])
			ifTrue: [^Association key: #instcreation value: recValue].
	^self langueSpecificPushSendOf: selector to: rec args: args! !!TypeCollector methodsFor: 'private' stamp: ' 7/9/05 23:28'!lastAssignmentForIndex: anIndex

	| assignments |
	assignments := (self typingResults at: anIndex) assignments.
	^assignments isEmpty ifTrue: [nil] ifFalse: [assignments last]! !!TypeCollector methodsFor: 'private' stamp: ' 7/9/05 23:28'!newExtractor
	"Return a new extractor class. This is typically Smalltalk dialect dependent, so subclasses have to override to choose the one they want."

	^self subclassResponsibility! !!TypeCollector methodsFor: 'private' stamp: ' 7/9/05 23:28'!typingResultsFor: instVarName 
	^self typingResults at: (self indexForVar: instVarName)! !!TypeCollector methodsFor: 'private' stamp: ' 7/9/05 23:28'!withTranslatedIndex: index do: aBlock

	aBlock value: index + 1! !!SqueakTypeCollector methodsFor: 'heuristics' stamp: ' 7/9/05 23:28'!assignmentTypeOf: val

	val isBehavior ifTrue: [^val].
	val isVariableBinding ifTrue: [
		(val key == #instcreation)
			ifTrue: [^val value]
			ifFalse: [^val value class]].
	^nil! !!SqueakTypeCollector methodsFor: 'heuristics' stamp: ' 7/9/05 23:28'!langueSpecificPushSendOf: selector to: rec args: args

	(selector == #blockCopy:) ifTrue: [^#block].
	(#(#// #quo: #rem: #\\ #ceiling #floor #rounded #roundTo: #truncated #truncateTo: #/ #+ #- #* #abs #negated #reciprocal) 
		includes: selector) ifTrue: [^Number].
	^#computed! !!SqueakTypeCollector methodsFor: 'private' stamp: ' 7/9/05 23:28'!newExtractor

	^SqueakInstvarInterfaceExtractor new! !!TypeCollector class methodsFor: 'instance creation' stamp: ' 7/9/05 23:28'!new
	"Override new to return either a VWTypeCollector or a SqueakTypeCollector"

	^self newForPlatform! !!TypeCollector class methodsFor: 'instance creation' stamp: ' 7/9/05 23:28'!newForPlatform
	"Return either a VWTypeCollector or a SqueakTypeCollector, depending on the platform used."

	| versionString |
	versionString := Smalltalk version.
	('*Squeak*' match: versionString)  ifTrue: [^SqueakTypeCollector basicNew].
	('*VisualWorks*' match: versionString)  ifTrue: [^VWTypeCollector basicNew].
	^self error: 'Unsupported Platform!!'! !!TypeCollector class methodsFor: 'instance creation' stamp: ' 7/9/05 23:28'!onClass: aClass

	^self new onClass: aClass! !!TypeCollector class methodsFor: 'instance creation' stamp: ' 7/9/05 23:28'!typeInstvarsOfClass: aClass

	^self new typeInstvarsOfClass: aClass! !!TypingConflict methodsFor: 'testing' stamp: ' 7/9/05 23:28'!isConflict

	^true! !!TypingConflict methodsFor: 'printing' stamp: ' 7/9/05 23:28'!explanationString
	| str |
	str := WriteStream on: String new.
	self printSelectorsNotUnderstoodOn: str.
	self printAssignmentConflictsOn: str.
	^str contents! !!TypingConflict methodsFor: 'printing' stamp: ' 7/9/05 23:28'!printAssignmentConflictsOn: str 
	self conflictingAssignments isEmpty 
		ifFalse: [str nextPutAll: 'There are conflicts between assignments.']! !!TypingConflict methodsFor: 'printing' stamp: ' 7/9/05 23:28'!printOn: aStream

	aStream
		nextPutAll: 'Type conflict for ';
		nextPutAll: self ivarClass shortName;
		nextPutAll: ' - ';
		nextPutAll: self ivarName! !!TypingConflict methodsFor: 'printing' stamp: ' 7/9/05 23:28'!printSelectorsNotUnderstoodOn: str 

	str nextPutAll: 'Following selector problems were found:'; crtab.
	self conflictingSelectors associations do: [:assoc |
		str print: assoc key; nextPutAll: ' not understood by: {'.
		assoc value do: [:cl | str print: cl] separatedBy: [str nextPut: $,].
		str nextPut: $}
	] separatedBy: [str nextPut: $,; crtab].

"	| selectorsNotUnderstood |
	selectorsNotUnderstood := self conflictingSelectors keys.
	selectorsNotUnderstood isEmpty 
		ifFalse: 
			[str 
				nextPutAll: 'Following selectors are not understood by existing type: '.
			selectorsNotUnderstood do: [:sel | str print: sel]
				separatedBy: [str nextPut: $,].
			str
				nextPut: $.;
				cr]"! !!TypingConflict methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!conflictingAssignments

	^conflictingAssignments! !!TypingConflict methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!conflictingSelectors

	^conflictingSelectors! !!TypingConflict methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!conflictingSelectors: selectorsCollection conflictingAssignments: classCollection

	conflictingSelectors := selectorsCollection.
	conflictingAssignments := classCollection! !!TypingConflict class methodsFor: 'instance creation' stamp: ' 7/9/05 23:28'!existingResult: existingTypingResult newResult: newTypingResult conflictingSelectors: selectorsCollection conflictingAssignments: classCollection 

	^(self existingResult: existingTypingResult newResult: newTypingResult) 
		conflictingSelectors: selectorsCollection conflictingAssignments: classCollection! !!TypingResultKeeper methodsFor: 'public' stamp: ' 7/9/05 23:28'!forImage

	| collector |
	collector := TypeCollector new.
	timeTaken := Time millisecondsToRun: [Object allSubclasses do: [:cl | cl isMeta ifFalse: [
		self addCollectorResult: ( collector typeInstvarsOfClass: cl)]]]! !!TypingResultKeeper methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!calculateTypesForClass: aClass 
	^TypeCollector typeInstvarsOfClass: aClass! !!TypingResultKeeper methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!nrObjectTypes

	| nr |
	nr := 0.
	self withAllInstvarResultsDo: [:cl :ivar :typeResult |
		(typeResult is: Object) ifTrue: [nr := nr + 1]].
	^nr! !!TypingResultKeeper methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!nrUniqueTypes

	| nr |
	nr := 0.
	self withAllInstvarResultsDo: [:cl :ivar :typeResult |
		typeResult isSingularType ifTrue: [nr := nr + 1]].
	^nr! !!TypingResultKeeper methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!resetTypesForClass: aClass

	^typeResults removeKey: aClass ifAbsent: []! !!TypingResultKeeper methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!timeTaken
	^timeTaken! !!TypingResultKeeper methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!typeResults
	^typeResults! !!TypingResultKeeper methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!typesForClass: aClass 

	^typeResults at: aClass ifAbsentPut: [self calculateTypesForClass: aClass]! !!TypingResultKeeper methodsFor: 'accessing' stamp: ' 7/9/05 23:28'!typesForClass: aClass instvar: instvar

	^(self typesForClass: aClass) at: instvar ifAbsent: [ExtractedType forInstvar: instvar inClass: aClass]! !!TypingResultKeeper methodsFor: 'initialize-release' stamp: ' 7/9/05 23:28'!initialize

	typeResults := IdentityDictionary new! !!TypingResultKeeper methodsFor: 'enumerating' stamp: ' 7/9/05 23:28'!withAllInstvarResultsDo: aBlock

	self typeResults keysAndValuesDo: [:cl :instvarDict |
		instvarDict keysAndValuesDo: [:ivar :typeResult |
			aBlock value: cl value: ivar value: typeResult]]! !!TypingResultKeeper methodsFor: 'private' stamp: ' 7/9/05 23:28'!addCollectorResult: collectorResult

	collectorResult isEmpty ifTrue: [^self].
	typeResults at: collectorResult values first ivarClass put: collectorResult! !!TypingResultKeeper methodsFor: 'private' stamp: ' 7/9/05 23:28'!addTypingResult: aTypeResult 

	| typeResultsForClass |
	typeResultsForClass := self typeResults at: aTypeResult ivarClass
				ifAbsentPut: [Dictionary new].
	typeResultsForClass at: aTypeResult ivarName put: aTypeResult! !!TypingResultKeeper methodsFor: 'private' stamp: ' 7/9/05 23:28'!resultsForClass: aClass instvar: instvar ifAbsent: absentBlock

	| ivars |
	ivars := typeResults at: aClass ifAbsent: absentBlock.
	^ivars at: instvar  ifAbsent: absentBlock! !!TypingResultKeeper class methodsFor: 'instance creation' stamp: ' 7/9/05 23:28'!forImage

	^self new forImage! !!TypingResultKeeper class methodsFor: 'instance creation' stamp: ' 7/9/05 23:28'!new

	^super new initialize! !!VWInstvarInterfaceExtractor methodsFor: 'opcodes-control' stamp: ' 7/9/05 23:28'!jump: delta

	| currentPC |
	currentPC := self input pc.
	delta > 0
		ifTrue: [self saveStacks at: currentPC+delta put: (self saveStacks at:currentPC). self saveStacks removeKey: currentPC].! !!VWInstvarInterfaceExtractor methodsFor: 'opcodes-control' stamp: ' 7/9/05 23:28'!jump: delta if: condition

	self pop.		"receiver of ifTrue or ifFalse, according to condition"
	delta > 0
		ifTrue: [self saveStacks at: self input pc+delta put: (stack copy add: #computed; yourself)].! !!VWInstvarInterfaceExtractor methodsFor: 'opcodes-control' stamp: ' 7/9/05 23:28'!makeCopyingBlock: meth count: count

	self readBlock: meth copied: count! !!VWInstvarInterfaceExtractor methodsFor: 'opcodes-control' stamp: ' 7/9/05 23:28'!makeFullBlock: meth

	self readBlock: meth copied: 0! !!VWInstvarInterfaceExtractor methodsFor: 'opcodes-control' stamp: ' 7/9/05 23:28'!makeFullCopyingBlock: meth count: count

	self readBlock: meth copied: count! !!VWInstvarInterfaceExtractor methodsFor: 'opcodes-control' stamp: ' 7/9/05 23:28'!methodPrimitive: index

	stack add: #errorCode.! !!VWInstvarInterfaceExtractor methodsFor: 'opcodes-control' stamp: ' 7/9/05 23:28'!sendNoCheck: selector numArgs: na

	self send: selector numArgs: na! !!VWInstvarInterfaceExtractor methodsFor: 'opcodes-control' stamp: ' 7/9/05 23:28'!sendNonImmediate: selector numArgs: na

	self send: selector numArgs: na! !!VWInstvarInterfaceExtractor methodsFor: 'opcodes-control' stamp: ' 7/9/05 23:28'!sendSuper: selector numArgs: na 
	stack removeLast: na + 2.
	stack add: #computed! !!VWInstvarInterfaceExtractor methodsFor: 'opcodes-data movement' stamp: ' 7/9/05 23:28'!dupLast

	stack removeLast.! !!VWInstvarInterfaceExtractor methodsFor: 'opcodes-data movement' stamp: ' 7/9/05 23:28'!dupNext

	stack removeLast; add: stack last.! !!VWInstvarInterfaceExtractor methodsFor: 'opcodes-data movement' stamp: ' 7/9/05 23:28'!pushCopiedValues: count

	copied size = count ifFalse: [self error: (#copiedMismatch << #dialogs >> 'copied mismatch')].
	stack addAll: copied.
	initialStack addAll: copied! !!VWInstvarInterfaceExtractor methodsFor: 'opcodes-data movement' stamp: ' 7/9/05 23:28'!pushLocalIndirect: majorIndex index: minorIndex 

	stack add: ((stack at: majorIndex + 1) == #self 
				ifTrue: [minorIndex]
				ifFalse: [#thing])! !!VWInstvarInterfaceExtractor methodsFor: 'opcodes-data movement' stamp: ' 7/9/05 23:28'!pushLocal: index

	stack add: (stack at: index+1).! !!VWInstvarInterfaceExtractor methodsFor: 'opcodes-data movement' stamp: ' 7/9/05 23:28'!pushNewArray: size

	stack add: #array.! !!VWInstvarInterfaceExtractor methodsFor: 'opcodes-data movement' stamp: ' 7/9/05 23:28'!storePopInst: index

	collector handleAssignment: stack removeLast for: index! !!VWInstvarInterfaceExtractor methodsFor: 'opcodes-data movement' stamp: ' 7/9/05 23:28'!storePopLocalIndirect: majorIndex index: minorIndex
	"Need to have a look at this, since an instance variable is being used (so I'd like to push its index on to the stack) bu I don't really know how. "

	self pop.
"	(stack at: majorIndex+1) == #self
		ifTrue: [instvarsInterface add: minorIndex]"! !!VWInstvarInterfaceExtractor methodsFor: 'opcodes-data movement' stamp: ' 7/9/05 23:28'!storePopLocal: index

	stack size = method numArgs
		ifTrue:
			[method primitiveNumber ifNil: [self error: (#BadMethod << #dialogs >> 'bad method')]]
		ifFalse: [self pop].! !!VWTypeCollector methodsFor: 'heuristics' stamp: ' 7/9/05 23:28'!assignmentTypeOf: val

	val isBehavior ifTrue: [^val].
	val isVariableBinding ifTrue: [^val value class].
	(val isKindOf: Association) ifTrue: [^val value].
	^nil! !!VWTypeCollector methodsFor: 'heuristics' stamp: ' 7/9/05 23:28'!langueSpecificPushSendOf: selector to: rec args: args
	"Needs to optimized, but since I need to go I'll publish it like this for the moment"

	(#(#/ #+ #- #* #abs #negated #reciprocal) includes: selector) 
		ifTrue: [^ArithmeticValue].
	(#(#// #quo: #rem: #\\ #ceiling #floor #rounded #roundTo: #truncated #truncateTo:) 
		includes: selector) ifTrue: [^Number].
	^#computed! !!VWTypeCollector methodsFor: 'private' stamp: ' 7/9/05 23:28'!newExtractor

	^VWInstvarInterfaceExtractor new! !----End fileIn of a stream----!'From Squeak3.8 of ''5 May 2005'' [latest update: #6665] on 8 September 2005 at 1:18:46 am'!"Change Set:		RoelTyperTestsDate:			8 September 2005Author:			Roel WuytsTests for Fast Type Reconstruction for Smalltalk. Load MethodNodeGenerate and RoelTyperCore changesets before this one. See http://decomp.ulb.ac.be/roelwuyts/smalltalk/roeltyper/ for more info."!TestCase subclass: #RoelTypingTestRoot	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RoelTyper-Tests'!RoelTypingTestRoot subclass: #InstvarInterfaceExtractorTest	instanceVariableNames: 'a b c u v w x y z'	classVariableNames: ''	poolDictionaries: ''	category: 'RoelTyper-Tests'!RoelTypingTestRoot subclass: #TypeCheckingTests	instanceVariableNames: 'typeResultKeeper ivarForTests'	classVariableNames: ''	poolDictionaries: ''	category: 'RoelTyper-Tests'!TestCase subclass: #TypeCollectorTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RoelTyper-Tests'!TestCase subclass: #TypingResultTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RoelTyper-Tests'!!RoelTypingTestRoot methodsFor: 'auxiliary' stamp: ' 7/9/05 23:28'!doForSource: src 

	| m |
	m := (Compiler new compile: ('gen ', src) in: self class notifying: nil ifFail: [self error: 'Error during compilation of generated method.']) generate.
	^self processMethod: m.! !!RoelTypingTestRoot methodsFor: 'auxiliary' stamp: ' 7/9/05 23:28'!processMethod: aCompiledMethod
	"Fail by default. Needs to be overridden by subclasses to trigger the base testing backbone."

	self assert: false! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests' stamp: ' 7/9/05 23:28'!testArithmetic
	"self run: #testArithmetic"

	| collector |
	collector := self doForSource: 'u := v \\ 3. a := b floor. b := c truncateTo: (x := 4 roundTo: 5)'.
	self assertSends:  #( #(v #(\\)) #(b #(floor)) #(c #(truncateTo:))) in: collector.
	self assertAssignments:  #(#(u #(Number)) #(a #(Number)) #(b #(Number)) #(x #(Number))) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests' stamp: ' 7/9/05 23:28'!testArrayAssignment

	| collector |
	collector := self doForSource: 'v := #(one two three)'.
	self assertAssignments:  #(#(v #(#Array))) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests' stamp: ' 7/9/05 23:28'!testComplicated1

	| collector |
	collector := self doForSource: '
		b := Set new: 3 * (c collect: [:s | s])'.
	self assertSends: #( #(c #(collect:)) ) in: collector.
	self assertAssignments:  #(#(b #(#Set))) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests' stamp: ' 7/9/05 23:28'!testEquality

	| collector |
	collector := self doForSource: 'u := v = 3'.
	self assertSends:  #(#(v #(#=))) in: collector.
	self assertAssignments:  #(#(u #(#Boolean))) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests' stamp: ' 7/9/05 23:28'!testIdentity

	| collector |
	collector := self doForSource: 'u := v == 3'.
	self assertSends:  #(#(v #(#==))) in: collector.
	self assertAssignments:  #(#(u #(#Boolean))) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests' stamp: ' 7/9/05 23:28'!testInstanceAssignment

	| collector |
	collector := self doForSource: 'w := TypeCollector new'.
	self assertAssignments:  #(#(w #(#TypeCollector))) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests' stamp: ' 7/9/05 23:28'!testInstanceAssignmentIndirect

	| collector |
	collector := self doForSource: 'self w: TypeCollector new'.
	self assertAssignments:  #(#(w #(#TypeCollector))) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests' stamp: ' 7/9/05 23:28'!testInstvarAssignment1

	| collector |
	collector := self doForSource: '
		| temp1 temp2 temp3 |
		a := 3.
		b := a'.
	self assertAssignments:  #(#(b #(#SmallInteger)) (a #(#SmallInteger))) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests' stamp: ' 7/9/05 23:28'!testInstvarAssignment2

	| collector |
	collector := self doForSource: '
		| temp1 temp2 temp3 |
		c := b := 3.'.
	self assertAssignments:  #(#(b #(#SmallInteger)) (c #(#SmallInteger))) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'assignment tests' stamp: ' 7/9/05 23:28'!testMetaClassAssignment

	| collector wAssignments wIndex |
	collector := self doForSource: 'w := TypeCollector'.
	wIndex := collector indexForVar: #w.
	wAssignments := collector assignmentsTo: #w.
	self assert: wAssignments size = 1.
	self assert: (wAssignments includes: TypeCollector class).
	self emptyAssigment: collector typingResults atIndexes: ((1 to: self class instVarNames size) asOrderedCollection remove: wIndex; yourself)! !!InstvarInterfaceExtractorTest methodsFor: 'send tests' stamp: ' 7/9/05 23:28'!testblockindirectxy

	| collector |
	collector := self doForSource: '^self testu ifTrue: [self x] ifFalse: [self y asString]'.
	self assertSends:  #(#(y #(#asString))) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests' stamp: ' 7/9/05 23:28'!testblockuwx

	| collector |
	collector := self doForSource: '^[u + w] on: Error do: [:exc | x printString]'.
	self assertSends:  #(#(u #(#+)) #(x #(#printString))) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests' stamp: ' 7/9/05 23:28'!testblockxy

	| collector |
	collector := self doForSource: '^self xyw ifTrue: [x] ifFalse: [y]'.
	self assertSends:  #() in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests' stamp: ' 7/9/05 23:28'!testblockyab
	" #'ifTrue:ifFalse: is sent to a, but is not Captured by the extractor"

	| collector |
	collector := self doForSource: '^self a ifTrue: [b] ifFalse: [y]'.
	self assertSends:  #() in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests' stamp: ' 7/9/05 23:28'!testCascaded1

	| collector |
	collector := self doForSource: 'x printString; size'.
	self assertSends:  #(#(x #(#printString #size))) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests' stamp: ' 7/9/05 23:28'!testCascaded2

	| collector |
	collector := self doForSource: 'x printString; size; yourself'.
	self assertSends:  #(#(x #(#printString #size #yourself))) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests' stamp: ' 7/9/05 23:28'!testIftrue

	| vSends collector |
	collector := self doForSource: 'u := v isNil ifTrue: [1] ifFalse: [2]'.
	vSends := collector sendsTo: #v.
	self assert: (vSends size = 1).
	self assert: (vSends includes: #isNil).! !!InstvarInterfaceExtractorTest methodsFor: 'send tests' stamp: ' 7/9/05 23:28'!testindirectx

	| collector |
	collector := self doForSource: '^self x printString'.
	self assertSends:  #(#(x #(#printString))) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests' stamp: ' 7/9/05 23:28'!testSuperivarAssignment

	| collector |
	collector := self doForSource: '^testSelector := testSelector'.
	self assertSends:  #() in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests' stamp: ' 7/9/05 23:28'!testSuperivarSend

	| collector |
	collector := self doForSource: '^testSelector printString'.
	self assertSends:  #(  #(testSelector #(#printString))  ) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests' stamp: ' 7/9/05 23:28'!testu

	| collector |
	collector := self doForSource: '^u'.
	self assertSends:  #() in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests' stamp: ' 7/9/05 23:28'!testuxyw

	| collector |
	collector := self doForSource: '	u := (x asString ~= y printString). ^u = w'.
	self assertSends:  #(#(y #(#printString)) #(x #(#asString)) #(u #(#=))) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests' stamp: ' 7/9/05 23:28'!testxyw

	| collector |
	collector := self doForSource: '
		| t |
		t := (x = y).
		^t = w'.
	self assertSends:  #(#(x #(#=))) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'send tests' stamp: ' 7/9/05 23:28'!testzuv

	| collector |
	collector := self doForSource: '^u ~= z or: [u = v]'.
	self assertSends:  #(#(u #(#= #~=))) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'auxiliary' stamp: ' 7/9/05 23:28'!assertAssignments: description in: collector

	| emptyIndexes ivarName ivarInterface extractedInterface ivarIndex anArray |
	anArray := collector typingResults.
	emptyIndexes := (1 to: self class instVarNames size) asOrderedCollection.
	description do: [:desc |
		ivarName := desc first.
		ivarInterface := desc at: 2.
		ivarIndex := collector indexForVar: ivarName.
		extractedInterface := collector assignmentsTo: ivarName.
		self assert: extractedInterface size = ivarInterface size.
		self assert: (extractedInterface allSatisfy: [:each | ivarInterface includes: each name]).
		emptyIndexes remove: ivarIndex].
	self emptyAssigment: anArray atIndexes: emptyIndexes.! !!InstvarInterfaceExtractorTest methodsFor: 'auxiliary' stamp: ' 7/9/05 23:28'!assertSends: description in: collector

	| emptyIndexes ivarName ivarInterface extractedInterface ivarIndex anArray |
	anArray := collector typingResults.
	emptyIndexes := (1 to: self class instVarNames size) asOrderedCollection.
	description do: [:desc |
		ivarName := desc first.
		ivarInterface := desc at: 2.
		ivarIndex :=  collector indexForVar: ivarName.
		extractedInterface := collector sendsTo: ivarName.
		self assert: extractedInterface size = ivarInterface size.
		self assert: (extractedInterface allSatisfy: [:each | ivarInterface includes: each]).
		emptyIndexes remove: ivarIndex].
	self emptyInterface: anArray atIndexes: emptyIndexes.! !!InstvarInterfaceExtractorTest methodsFor: 'auxiliary' stamp: ' 7/9/05 23:28'!denyAssignments: description in: collector

	| emptyIndexes ivarName ivarInterface extractedInterface ivarIndex anArray |
	anArray := collector typingResults.
	emptyIndexes := (1 to: self class instVarNames size) asOrderedCollection.
	description do: [:desc |
		ivarName := desc first.
		ivarInterface := desc at: 2.
		ivarIndex := collector indexForVar: ivarName.
		extractedInterface := collector assignmentsTo: ivarName.
		ivarInterface do: [:each | self deny: (extractedInterface includes: each)].
		emptyIndexes remove: ivarIndex].
	self emptyAssigment: anArray atIndexes: emptyIndexes.! !!InstvarInterfaceExtractorTest methodsFor: 'auxiliary' stamp: ' 7/9/05 23:28'!emptyAssigment: anArray atIndexes: indexCollection

	indexCollection do: [:index |
		self assert: (anArray at: index) hasEmptyAssignments]! !!InstvarInterfaceExtractorTest methodsFor: 'auxiliary' stamp: ' 7/9/05 23:28'!emptyInterface: anArray atIndexes: indexCollection

	indexCollection do: [:index |
		self assert: (anArray at: index) hasEmptyInterface]! !!InstvarInterfaceExtractorTest methodsFor: 'auxiliary' stamp: ' 7/9/05 23:28'!empty: anArray atIndexes: indexCollection

	indexCollection do: [:index |
		self assert: (anArray at: index) isEmpty]! !!InstvarInterfaceExtractorTest methodsFor: 'auxiliary' stamp: ' 7/9/05 23:28'!processMethod: aCompiledMethod
	"Fail by default. Needs to be overridden by subclasses to trigger the base testing backbone."

	| collector |
	collector := TypeCollector onClass: self class.
	TypeCollector new newExtractor extractInterfacesFrom: aCompiledMethod addTo: collector.
	^collector! !!InstvarInterfaceExtractorTest methodsFor: 'non supported' stamp: ' 7/9/05 23:28'!testComplicated2

	| collector |
	collector := self doForSource: '
		| temp1 temp2 |
		temp1 := b := temp2 := 3.'.
	self denyAssignments:  #(#(b #(#SmallInteger))) in: collector! !!InstvarInterfaceExtractorTest methodsFor: 'non supported' stamp: ' 7/9/05 23:28'!testComplicated3
	"self run: #testComplicated3"
	"selfdebug: #testComplicated3"

	| collector |
	collector := self doForSource: '
		| temp1 temp2 temp3 |
		temp2 := b := temp1 := 3.'.
	self denyAssignments:  #(#(b #(#SmallInteger))) in: collector! !!TypeCheckingTests methodsFor: 'auxiliary' stamp: ' 7/9/05 23:28'!processMethod: aCompiledMethod
	"Fail by default. Needs to be overridden by subclasses to trigger the base testing backbone."

	| collector invalidatedTypes existingTypeResult instvarUsed extractedInterface |
	instvarUsed := #ivarForTests.
	collector := TypeCollector onClass: self class.
	invalidatedTypes := Set new.
	TypeCollector new newExtractor extractInterfacesFrom: aCompiledMethod addTo: collector.
	extractedInterface := collector sendsTo: instvarUsed.
	existingTypeResult := (typeResultKeeper typesForClass: self class instvar: instvarUsed) types.
	extractedInterface do: [:selector |
		invalidatedTypes addAll:
		(existingTypeResult select: [:existingType | (existingType canUnderstand: selector) not])
	].
	^invalidatedTypes! !!TypeCheckingTests methodsFor: 'auxiliary' stamp: ' 7/9/05 23:28'!setMultipleTypeAs: existingClasses 
	"I am faking the typeResultKeeper to hold a given set of types for the ivarForText instance variable used in the tests."

	| collector index |
	typeResultKeeper := TypingResultKeeper new.
	collector := TypeCollector onClass: self class.
	index := collector indexForVar: #ivarForTests.
	existingClasses 
		do: [:existingClass | collector addAssignment: existingClass to: index-1].
	typeResultKeeper addCollectorResult: collector packagedResults! !!TypeCheckingTests methodsFor: 'auxiliary' stamp: ' 7/9/05 23:28'!setTypeAs: existingClass
	"I am faking the typeResultKeeper to hold a given set of types for the ivarForText instance variable used in the tests."

	self setMultipleTypeAs: (Array with: existingClass)! !!TypeCheckingTests methodsFor: 'testing' stamp: ' 7/9/05 23:28'!testSetadd

	| diffs |
	self setTypeAs: Set.
	diffs := self doForSource: 'ivarForTests add: 2'.
	self assert: diffs isEmpty! !!TypeCheckingTests methodsFor: 'testing' stamp: ' 7/9/05 23:28'!testSetfoo

	| diffs |
	self setTypeAs: Set.
	diffs := self doForSource: 'ivarForTests foo'.
	self assert: diffs size = 1! !!TypeCheckingTests methodsFor: 'testing' stamp: ' 7/9/05 23:28'!testSetTestCaseAdd

	| diffs |
	self setMultipleTypeAs: (Array with: Set with: TestCase).
	diffs := self doForSource: 'ivarForTests add: 4'.
	self assert: (diffs size = 1).
	self assert: (diffs includes: TestCase)! !!TypeCheckingTests methodsFor: 'testing' stamp: ' 7/9/05 23:28'!testSetTestCaseAssert

	| diffs |
	self setMultipleTypeAs: (Array with: Set with: TestCase).
	diffs := self doForSource: '^ivarForTests resources'.
	self assert: (diffs size = 1).
	self assert: (diffs includes: Set)! !!TypeCheckingTests methodsFor: 'testing' stamp: ' 7/9/05 23:28'!testSetTestCaseClass

	| diffs |
	self setMultipleTypeAs: (Array with: Set with: TestCase).
	diffs := self doForSource: 'ivarForTests class'.
	self assert: diffs isEmpty! !!TypeCheckingTests methodsFor: 'testing' stamp: ' 7/9/05 23:28'!testSetTestCaseFoo

	| diffs |
	self setMultipleTypeAs: (Array with: Set with: TestCase).
	diffs := self doForSource: 'ivarForTests foo'.
	self assert: (diffs size = 2).
	self assert: (diffs includes: Set).
	self assert: (diffs includes: TestCase)! !!TypeCollectorTests methodsFor: 'typing tests' stamp: ' 7/9/05 23:28'!testPoint

	| types xTypes yTypes |
	types := TypeCollector typeInstvarsOfClass: Point.
	xTypes := types at: #x.
	self assert: ((xTypes is: Number) or: [xTypes is: Integer]).
	yTypes := types at: #y.
	self assert: ((yTypes is: Number) or: [yTypes is: Integer])! !!TypingResultTests methodsFor: 'sameAs tests' stamp: ' 7/9/05 23:28'!testSame1

	| result1 result2 |
	result1 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #foo) assignments: IdentitySet new.
	result2 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #foo) assignments: IdentitySet new.
	self assert: (result1 sameAs: result2)! !!TypingResultTests methodsFor: 'sameAs tests' stamp: ' 7/9/05 23:28'!testSame2

	| result1 result2 |
	result1 := ExtractedType forInstvar: #testSelector inClass: self class interface: IdentitySet new assignments: (IdentitySet with: OrderedCollection).
	result2 := ExtractedType forInstvar: #testSelector inClass: self class interface: IdentitySet new assignments: (IdentitySet with: OrderedCollection).
	self assert: (result1 sameAs: result2)! !!TypingResultTests methodsFor: 'sameAs tests' stamp: ' 7/9/05 23:28'!testSame3

	| result1 result2 |
	result1 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #foo) assignments: (IdentitySet with: OrderedCollection).
	result2 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #foo) assignments: (IdentitySet with: OrderedCollection).
	self assert: (result1 sameAs: result2)! !!TypingResultTests methodsFor: 'sameAs tests' stamp: ' 7/9/05 23:28'!testSame4

	| result1 result2 |
	result1 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet new) assignments: (IdentitySet with: OrderedCollection).
	result2 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #foo) assignments: (IdentitySet with: OrderedCollection).
	self deny: (result1 sameAs: result2)! !!TypingResultTests methodsFor: 'sameAs tests' stamp: ' 7/9/05 23:28'!testSame5

	| result1 result2 |
	result1 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet new) assignments: (IdentitySet new).
	result2 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #foo) assignments: (IdentitySet with: OrderedCollection).
	self deny: (result1 sameAs: result2)! !!TypingResultTests methodsFor: 'sameAs tests' stamp: ' 7/9/05 23:28'!testSame6

	| result1 result2 |
	result1 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #foo) assignments: (IdentitySet new).
	result2 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #foo) assignments: (IdentitySet with: OrderedCollection).
	self deny: (result1 sameAs: result2)! !!TypingResultTests methodsFor: 'sameAs tests' stamp: ' 7/9/05 23:28'!testSame7

	| result1 result2 |
	result1 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #bar) assignments: (IdentitySet with: OrderedCollection).
	result2 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #foo) assignments: (IdentitySet with: OrderedCollection).
	self deny: (result1 sameAs: result2)! !!TypingResultTests methodsFor: 'sameAs tests' stamp: ' 7/9/05 23:28'!testSame8

	| result1 result2 |
	result1 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #bar) assignments: (IdentitySet with: Array).
	result2 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #foo) assignments: (IdentitySet with: OrderedCollection).
	self deny: (result1 sameAs: result2)! !!TypingResultTests methodsFor: 'sameAs tests' stamp: ' 7/9/05 23:28'!testSame9

	| result1 result2 |
	result1 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #foo) assignments: (IdentitySet with: Array).
	result2 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #foo) assignments: (IdentitySet with: OrderedCollection).
	self deny: (result1 sameAs: result2)! !!TypingResultTests methodsFor: 'indicatesSameTypes tests' stamp: ' 7/9/05 23:28'!testIndicatesSame1

	| result1 result2 |
	result1 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #findElementOrNil: with: #do:) assignments: IdentitySet new.
	result2 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #collect:) assignments: IdentitySet new.
	self deny: (result2 isConformingTo: result1).
	self assert: (result1 isConformingTo: result2).! !!TypingResultTests methodsFor: 'indicatesSameTypes tests' stamp: ' 7/9/05 23:28'!testIndicatesSame2

	| result1 result2 |
	result1 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #testIndicatesSame1 with: #testSame1) assignments: IdentitySet new.
	result2 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #do: with: #testIndicatesSame1 with: #testSame1) assignments: IdentitySet new.
	self deny: (result2 isConformingTo: result1)! !!TypingResultTests methodsFor: 'indicatesSameTypes tests' stamp: ' 7/9/05 23:28'!testIndicatesSame3

	| result1 result2 |
	result1 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #testIndicatesSame1 with: #testSame1) assignments: IdentitySet new.
	result2 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet with: #testSame2 with: #testIndicatesSame1 with: #testSame1) assignments: IdentitySet new.
	self assert: (result2 isConformingTo: result1)! !!TypingResultTests methodsFor: 'indicatesSameTypes tests' stamp: ' 7/9/05 23:28'!testIndicatesSame4

	| result1 result2 |
	result1 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet new) assignments: IdentitySet new.
	result2 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet new) assignments: IdentitySet new.
	self assert: (result2 isConformingTo: result1)! !!TypingResultTests methodsFor: 'indicatesSameTypes tests' stamp: ' 7/9/05 23:28'!testIndicatesSame5

	| result1 result2 |
	result1 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet new) assignments: (IdentitySet with: Array with: Set).
	result2 := ExtractedType forInstvar: #testSelector inClass: self class interface: (IdentitySet new) assignments: (IdentitySet with: Set).
	self deny: (result2 isConformingTo: result1)! !!TypingResultTests methodsFor: 'actions' stamp: ' 7/9/05 23:28'!testChecking! !!TypingResultTests methodsFor: 'folding tests' stamp: ' 7/9/05 23:28'!test1
	"Array is subclass of Collection
		-> folding keeps Array and loses Collection"


	| foldingResult |
	foldingResult := ExtractedType basicNew fold: (OrderedCollection with: Collection) with: (OrderedCollection with: Array).
	self assert: foldingResult size = 1.
	self assert: foldingResult first = Array.! !!TypingResultTests methodsFor: 'folding tests' stamp: ' 7/9/05 23:28'!test10
	"Dictionary and Array are in unrelated hierarchies -> keep both. Collection bites the dust because it is superclass of OrderedCollection"

	| foldingResult |
	foldingResult := ExtractedType basicNew fold: (OrderedCollection with: Dictionary) with: (OrderedCollection with: Array with: Collection).
	self assert: foldingResult size = 2.
	self assert: (foldingResult includes: Dictionary).
	self assert: (foldingResult includes: Array).! !!TypingResultTests methodsFor: 'folding tests' stamp: ' 7/9/05 23:28'!test11
	"Dictionary and Array are in unrelated hierarchies -> keep both. Collection bites the dust because it is superclass of OrderedCollection"

	| foldingResult |
	foldingResult := ExtractedType basicNew fold: (OrderedCollection with: Dictionary) with: (OrderedCollection with: Collection with: Array ).
	self assert: foldingResult size = 2.
	self assert: (foldingResult includes: Dictionary).
	self assert: (foldingResult includes: Array).! !!TypingResultTests methodsFor: 'folding tests' stamp: ' 7/9/05 23:28'!test12
	"Dictionary and Array are in unrelated hierarchies -> keep both. Collection bites the dust because it is superclass."

	| foldingResult |
	foldingResult := ExtractedType basicNew fold: (OrderedCollection with: Collection) with: (OrderedCollection with: Dictionary with: Array ).
	self assert: foldingResult size = 2.
	self assert: (foldingResult includes: Dictionary).
	self assert: (foldingResult includes: Array).! !!TypingResultTests methodsFor: 'folding tests' stamp: ' 7/9/05 23:28'!test13
	"Dictionary and Array are in unrelated hierarchies -> keep both. Collection bites the dust because it is superclass."

	| foldingResult |
	foldingResult := ExtractedType basicNew fold: (OrderedCollection with: Collection) with: (OrderedCollection with: Array with: Dictionary).
	self assert: foldingResult size = 2.
	self assert: (foldingResult includes: Dictionary).
	self assert: (foldingResult includes: Array).! !!TypingResultTests methodsFor: 'folding tests' stamp: ' 7/9/05 23:28'!test14

	| foldingResult |
	foldingResult := ExtractedType basicNew fold: (OrderedCollection with: SequenceableCollection with: Bag) with: (OrderedCollection with: Array).
	self assert: foldingResult size = 2.
	self assert: (foldingResult includes: Array).
	self assert: (foldingResult includes: Bag).! !!TypingResultTests methodsFor: 'folding tests' stamp: ' 7/9/05 23:28'!test2
	"Array is subclass of Collection
		-> folding keeps Array and loses Collection"

	| foldingResult |
	foldingResult := ExtractedType basicNew fold: (OrderedCollection with: Array) with: (OrderedCollection with: Collection).
	self assert: foldingResult size = 1.
	self assert: foldingResult first = Array.! !!TypingResultTests methodsFor: 'folding tests' stamp: ' 7/9/05 23:28'!test3

	| foldingResult |
	foldingResult := ExtractedType basicNew fold: (OrderedCollection new) with: (OrderedCollection new).
	self assert: foldingResult size = 1.
	self assert: foldingResult first = Object! !!TypingResultTests methodsFor: 'folding tests' stamp: ' 7/9/05 23:28'!test4

	| foldingResult |
	foldingResult := ExtractedType basicNew fold: (OrderedCollection with: Object) with: (OrderedCollection new).
	self assert: foldingResult size = 1.
	self assert: foldingResult first = Object! !!TypingResultTests methodsFor: 'folding tests' stamp: ' 7/9/05 23:28'!test5

	| foldingResult |
	foldingResult := ExtractedType basicNew fold: (OrderedCollection new) with: (OrderedCollection with: Object).
	self assert: foldingResult size = 1.
	self assert: foldingResult first = Object! !!TypingResultTests methodsFor: 'folding tests' stamp: ' 7/9/05 23:28'!test6
	"Dictionary and Array are in unrelated hierarchies -> keep both"


	| foldingResult |
	foldingResult := ExtractedType basicNew fold: (OrderedCollection with: Dictionary) with: (OrderedCollection with: Array).
	self assert: foldingResult size = 2.
	self assert: (foldingResult includes: Dictionary).
	self assert: (foldingResult includes: Array).! !!TypingResultTests methodsFor: 'folding tests' stamp: ' 7/9/05 23:28'!test7
	"Dictionary and Array are in unrelated hierarchies -> keep both"


	| foldingResult |
	foldingResult := ExtractedType basicNew fold: (OrderedCollection with: Dictionary with: Object) with: (OrderedCollection with: Array).
	self assert: foldingResult size = 2.
	self assert: (foldingResult includes: Dictionary).
	self assert: (foldingResult includes: Array).! !!TypingResultTests methodsFor: 'folding tests' stamp: ' 7/9/05 23:28'!test8
	"Dictionary and Array are in unrelated hierarchies -> keep both"


	| foldingResult |
	foldingResult := ExtractedType basicNew fold: (OrderedCollection with: Dictionary) with: (OrderedCollection with: Array with: Object).
	self assert: foldingResult size = 2.
	self assert: (foldingResult includes: Dictionary).
	self assert: (foldingResult includes: Array).! !!TypingResultTests methodsFor: 'folding tests' stamp: ' 7/9/05 23:28'!test9
	"Dictionary and Array are in unrelated hierarchies -> keep both"

	| foldingResult |
	foldingResult := ExtractedType basicNew fold: (OrderedCollection with: Dictionary with: Object) with: (OrderedCollection with: Array with: Object).
	self assert: foldingResult size = 2.
	self assert: (foldingResult includes: Dictionary).
	self assert: (foldingResult includes: Array).! !----End fileIn of a stream----!"Default preamble: loads all the change sets in order given."self ifNotNil: [self fileInMemberNamed: 'MethodNodeGenerate.1.cs'.
self fileInMemberNamed: 'RoelTyper-Core.1.cs'.
self fileInMemberNamed: 'RoelTyperTests.1.cs'.]!----End fileIn of a stream----!!MethodPragmaTest methodsFor: '*newcompiler-override' stamp: 'md 7/26/2006 14:59' prior: 33600941!testCompileInvalid	"Invalid pragmas should properly raise an error."	self should: [ self compile: '<>' selector: #zork ] raise: SmaCCParserError .	self should: [ self compile: '<1>' selector: #zork ] raise: SmaCCParserError.		self should: [ self compile: '<#123>' selector: #zork ] raise: SmaCCParserError.		self should: [ self compile: '<foo bar>' selector: #zork ] raise: SmaCCParserError.	self should: [ self compile: '<foo 1>' selector: #zork ] raise: SmaCCParserError.	self should: [ self compile: '<foo bar zork>' selector: #zork ] raise: SmaCCParserError.	self should: [ self compile: '<foo bar 1>' selector: #zork ] raise: SmaCCParserError.	self should: [ self compile: '<foo: bar:>' selector: #zork ] raise: SmaCCParserError.	self should: [ self compile: '<foo: #bar: zork:>' selector: #zork ] raise: SmaCCParserError.! !!CompiledMethod methodsFor: '*newcompiler' stamp: 'md 2/21/2006 13:57'!ast	"Return the node for self"	self isBlockMethod ifTrue: [^ self blockNode] ifFalse: [^ self methodNode].! !!CompiledMethod methodsFor: '*newcompiler' stamp: 'md 2/21/2006 13:52'!blockNode	"Return the block node for self"	| homeMethodNode |	homeMethodNode := self methodNode.	self isBlockMethod ifFalse: [^ homeMethodNode].	homeMethodNode ifNil: [^ self decompilerClass new decompileBlock: self].	homeMethodNode compiledMethod.  "generate method"	homeMethodNode nodesDo: [:node |		(node isBlock and:		 [node scope notNil "not-inlined" and:		  [node compiledMethod = self]])			ifTrue: [^ node]	].	"node not found, must have been compiled differently (compiler changed)"	^ self decompilerClass new decompileBlock: self! !!CompiledMethod methodsFor: '*newcompiler' stamp: 'ajh 3/2/2003 13:51'!ir	^ BytecodeDecompiler new decompile: self! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'ajh 6/28/2004 13:52'!compiledMethod	^ self ir compiledMethod! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'md 2/21/2006 14:42'!generate	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	^self generate: #(0 0 0 0)! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'ajh 3/10/2003 20:21'!generate: trailer	^ self generateIR compiledMethodWith: trailer! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'ajh 6/23/2004 19:52'!generateIR	^ ir _ ASTTranslator new		visitNode: self;		ir! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'pmm 8/16/2006 21:34'!generateWith: trailer using: aCompiledMethodClass	^ self generateIR compiledMethodWith: trailer using: aCompiledMethodClass! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'ajh 3/10/2003 20:20'!ir	^ ir ifNil: [self generateIR]! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'ajh 3/3/2003 12:07'!privIR: irMethod	ir _ irMethod! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'md 2/27/2006 17:50'!sourceText: aText	self flag: #fixme! !!RBMethodNode methodsFor: '*newcompiler' stamp: 'md 3/16/2006 18:48'!verifyIn: classOrScope	"Look up vars in classOrScope.  My tree will be annotated with bindings to LexicalScopes and ScopeVars."	ASTChecker new		scope: classOrScope parseScope;		visitNode: self.			Preferences compileBlocksAsClosures ifFalse: [ 		NonClosureScopeFixer new visitNode: self.	]! !!BytecodeDecompilerTest methodsFor: 'examples' stamp: 'md 2/24/2005 15:04'!exampleWhileTrue	"Override the superclass for performance reasons."	| index firstIndex lastIndex aBlock array |	index _ firstIndex.  	[index <= lastIndex]		whileTrue:			[aBlock value: (array at: index).			index _ index + 1]! !!BytecodeDecompilerTest methodsFor: 'tests' stamp: 'md 3/22/2005 15:01'!testDecompileObject	self shouldnt: [			Object methodDict values do: [:meth |					meth ir.			]	] raise: Error.! !!BytecodeDecompilerTest methodsFor: 'tests' stamp: 'md 2/24/2005 15:20'!testDecompilerOrderedCollectionDo	| cm decompiledIR  |	cm := OrderedCollection>>#do:.	decompiledIR := BytecodeDecompiler new decompile: cm.	self shouldnt: [decompiledIR compiledMethodWith: #(0)] raise: Error.! !!BytecodeDecompilerTest methodsFor: 'tests' stamp: 'md 3/22/2005 15:55'!testRecompileIRObject	self shouldnt: [			Object methodDict values do: [:meth |					(meth ir) compiledMethodWith: #(0).			] displayingProgress: 'recompiling'	] raise: Error.! !!BytecodeDecompilerTest methodsFor: 'tests' stamp: 'md 2/24/2005 15:26'!testWhileTrue	| cm decompiledIR aCompiledMethod |	cm := (self class)>>#testWhileTrue.	decompiledIR := BytecodeDecompiler new decompile: cm.		self shouldnt: [aCompiledMethod := decompiledIR compiledMethodWith: #(0)] raise: Error.! !!BytecodeGeneratorTest methodsFor: 'setup' stamp: 'md 10/13/2004 14:16'!setUp	a := 2! !!BytecodeGeneratorTest methodsFor: 'as yet unclassified' stamp: 'md 10/13/2004 14:20'!testExample	| cm |		cm := BytecodeGenerator new		numArgs: 1;		pushInstVar: 2;		pushTemp: 1;		send: #>;		if: false goto: #else;		pushLiteral: 'yes';		returnTop;		label: #else;		pushLiteral: 'no';		returnTop;		compiledMethod.	self assert: (cm isKindOf: CompiledMethod).	self assert: (cm valueWithReceiver: self arguments: #(1)) = 'yes' .	self assert: (cm valueWithReceiver: self arguments: #(3)) = 'no' .		^cm	! !!ClosureCompilerTest class methodsFor: 'as yet unclassified' stamp: 'md 10/19/2004 12:24'!Test	^Test! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 21:04'!exampleAndAnd1	^1 = 1 and: [ 2 = 2 ] and: [ 3 = 3 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 20:57'!exampleAndAnd2	^1 = 1 and: [ 2 = 2 ] and: [ 2 = 3 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 20:58'!exampleAndAnd3	^1 = 2 and: [ 2 = 2 ] and: [ 3 = 3 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 20:59'!exampleAndAnd4	^1 = 1 and: [ 2 = 3 ] and: [ 3 = 3 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 20:58'!exampleAndAnd5	^1 = 2 and: [ 2 = 3 ] and: [ 3 = 4 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/24/2006 20:17'!exampleAndAnd6	^1 = 2 and: [ 2 = 3 ] and: [ 3 = 4 ] and: [ 1 / 0 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 11:15'!exampleBlockExternal	| t |	t := 1.	^[t] value.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 15:39'!exampleBlockExternal2	| t1 t2 |	t1 :=  t2 := 1.	^[t1 + t2] value.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 15:38'!exampleBlockExternalArg	| t  |	t := 1.	^[:a | t + a] value: 1.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 15:40'!exampleBlockExternalNested	| t s |	t := s := 1.	^[[s] value +   t   ] value.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 15:42'!exampleBlockInternal		^[ | t | t := 1.    t] value.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/19/2006 13:30'!exampleIfNotNilDo	^1 even ifNotNilDo: [ :arg | arg not ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/19/2006 13:32'!exampleIfNotNilDoReturnNil	^nil ifNotNilDo: [ :arg | arg not ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 7/25/2006 15:24'!exampleIfNotNilReturnNil	^"nil ifNotNil: [ :arg | arg not ]"self! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 21:00'!exampleOrOr1	^1 = 1 or: [ 2 = 2 ] or: [ 3 = 3 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 21:00'!exampleOrOr2	^1 = 1 or: [ 2 = 2 ] or: [ 2 = 3 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 21:00'!exampleOrOr3	^1 = 2 or: [ 2 = 2 ] or: [ 3 = 3 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 21:00'!exampleOrOr4	^1 = 1 or: [ 2 = 3 ] or: [ 3 = 3 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/20/2006 21:00'!exampleOrOr5	^1 = 2 or: [ 2 = 3 ] or: [ 3 = 4 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'pmm 7/24/2006 20:17'!exampleOrOr6	^1 = 2 or: [ 2 = 3 ] or: [ 3 = 4 ] or: [ 4 = 4 ] or: [ 1 / 0 ]! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/14/2004 17:45'!exampleReturn1	^1! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 09:21'!exampleSimpleBlock	^[1].! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 11:08'!exampleSimpleBlockArgument1	^[:a | a ] value: 1.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 11:09'!exampleSimpleBlockArgument2	^[:a :b | a + b ] value: 1 value: 1.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 11:09'!exampleSimpleBlockArgument3	^[:a :b :c | a + b + c ] value: 1 value: 1 value: 1.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 11:09'!exampleSimpleBlockArgument4	^[:a :b :c :d | a + b + c  + d] value: 1 value: 1 value: 1 value: 1. ! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/15/2004 11:11'!exampleSimpleBlockArgument5	^[:a :b :c :d :e| a + b + c  + d + e] valueWithArguments: #(1 1 1 1 1). ! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 11/11/2004 14:22'!exampleSimpleBlockLocal	^[ :each | | t |  t:= each. t   ] value: 5.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 11/11/2004 14:42'!exampleSimpleBlockLocalIf	^true ifTrue: [ | hallo |  hallo := 1 . hallo].! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 11/11/2004 14:56'!exampleSimpleBlockLocalIfNested	^true ifTrue: [| hallo |  [  hallo := 1 . hallo] value] .! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 11/11/2004 15:47'!exampleSimpleBlockLocalWhile	|a|	a := true.	^[: b | [a] whileTrue: [ | hallo |  a := false. hallo := 1 . hallo]]value: 1.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 11/11/2004 17:37'!exampleSimpleBlockNested	| a match dict | 	a  := #(a b c d).	dict := Dictionary new.	a doWithIndex: [:each :index |		(match := a indexOf: each) > 0 ifTrue:			[dict at: index put: (a at: match)]].	^ dict.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/16/2004 21:26'!exampleSimpleBlockiVar	^[iVar] value.! !!ClosureCompilerTest methodsFor: 'examples' stamp: 'md 10/16/2004 20:20'!exampleiVar	iVar := 1.	^iVar.! !!ClosureCompilerTest methodsFor: 'as yet unclassified' stamp: 'md 10/16/2004 21:28'!setUp	iVar := 1.! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'pmm 7/24/2006 20:18'!testAndAnd	self assert: self exampleAndAnd1.	self deny: self exampleAndAnd2.	self deny: self exampleAndAnd3.	self deny: self exampleAndAnd4.	self deny: self exampleAndAnd5.	self shouldnt: [ self exampleAndAnd6 ] raise: ZeroDivide! !!ClosureCompilerTest methodsFor: 'tests - bugs' stamp: 'md 10/19/2004 12:32'!testBackJump	| src ast method |	src :=  JPEGReadWriter  sourceCodeAt: #idctBlockInt:qt:.		ast := ClosureCompiler new parseClosure: src in: JPEGReadWriter notifying: nil.	method := ast ir compiledMethod.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:18'!testBlockExternal	| src ast ir method |	src :=  self class sourceCodeAt: #exampleBlockExternal.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 1.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:18'!testBlockExternal2	| src ast ir method |	src :=  self class sourceCodeAt: #exampleBlockExternal2.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 2.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:18'!testBlockExternalArg	| src ast ir method |	src :=  self class sourceCodeAt: #exampleBlockExternalArg.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 2.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:18'!testBlockExternalNested	| src ast ir method |	src :=  self class sourceCodeAt: #exampleBlockExternalNested.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 2.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:18'!testBlockInternal	| src ast ir method |	src :=  self class sourceCodeAt: #exampleBlockInternal.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 1.! !!ClosureCompilerTest methodsFor: 'tests - bugs' stamp: 'md 10/19/2004 14:20'!testClassVar	| src ast method |	src :=  Float class sourceCodeAt: #nan.		ast := ClosureCompiler new parseClosure: src in: Float class notifying: nil.	self shouldnt: [ method := ast ir compiledMethod] raise: Error.	self assert: (method valueWithReceiver: nil arguments: #()) isNaN.! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'md 10/27/2004 17:02'!testCompile	| src ast ir method |	src :=  self class sourceCodeAt: #exampleReturn1.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: nil arguments: #()) = 1.! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'pmm 7/19/2006 13:31'!testIfNotNilDo	self assert: self exampleIfNotNilDo! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'pmm 7/19/2006 13:33'!testIfNotNilDoReturnNil	self assert: self exampleIfNotNilDoReturnNil isNil! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'pmm 7/19/2006 13:33'!testIfNotNilReturnNil	self assert: self exampleIfNotNilReturnNil isNil! !!ClosureCompilerTest methodsFor: 'tests - bugs' stamp: 'md 10/17/2004 16:25'!testMinusEndOfLine	| src  |	src :=  'test ^#-'.	self shouldnt: [ ClosureCompiler new parseClosure: src in: self class notifying: nil] raise: Error.	! !!ClosureCompilerTest methodsFor: 'tests' stamp: 'pmm 7/24/2006 20:19'!testOrOr	self assert: self exampleOrOr1.	self assert: self exampleOrOr2.	self assert: self exampleOrOr3.	self assert: self exampleOrOr4.	self deny: self exampleOrOr5.	self shouldnt: [ self exampleOrOr6 ] raise: ZeroDivide! !!ClosureCompilerTest methodsFor: 'tests - bugs' stamp: 'md 10/19/2004 14:57'!testParseSymbolColon	| src  |	src :=  'test ^#:'.	self shouldnt: [Compiler new parse: src in: self class notifying: nil] raise: Error.	self shouldnt: [ClosureCompiler new parseClosure: src in: self class notifying: nil] raise: Error.	! !!ClosureCompilerTest methodsFor: 'tests - bugs' stamp: 'md 10/17/2004 16:31'!testScannExponent	| src  |	src :=  'test ^1.0e-14'.	self shouldnt: [Compiler new parse: src in: self class notifying: nil] raise: Error.	self shouldnt: [ClosureCompiler new parseClosure: src in: self class notifying: nil] raise: Error.	! !!ClosureCompilerTest methodsFor: 'tests - bugs' stamp: 'md 10/17/2004 16:31'!testScannExponent2	| src  |	src :=  'test ^#(2r1e26 2r111e26)'.	self shouldnt: [Compiler new parse: src in: self class notifying: nil] raise: Error.	self shouldnt: [ClosureCompiler new parseClosure: src in: self class notifying: nil] raise: Error.	! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 11/11/2004 17:31'!testSimpleBloccNested	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockNested.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = ClosureCompilerTest new exampleSimpleBlockNested.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:18'!testSimpleBlock	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlock.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) value = 1.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:18'!testSimpleBlockArgument1	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockArgument1.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 1.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:17'!testSimpleBlockArgument2	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockArgument2.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 2.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:17'!testSimpleBlockArgument3	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockArgument3.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 3.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:17'!testSimpleBlockArgument4	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockArgument4.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 4.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/19/2004 11:17'!testSimpleBlockArgument5	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockArgument5.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 5.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 11/11/2004 14:21'!testSimpleBlockLocal	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockLocal.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 5.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 11/11/2004 14:42'!testSimpleBlockLocalIf	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockLocalIf.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 1.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 11/11/2004 14:53'!testSimpleBlockLocalIfNested	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockLocalIfNested.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 1.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 11/11/2004 15:55'!testSimpleBlockLocalWhile	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockLocalWhile.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = nil.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 10/16/2004 21:27'!testSimpleBlockiVar	| src ast ir method |	src :=  self class sourceCodeAt: #exampleSimpleBlockiVar.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.	self assert: (method valueWithReceiver: self arguments: #()) = 1.! !!ClosureCompilerTest methodsFor: 'testing - oldBlocks' stamp: 'md 11/10/2004 15:43'!testSimpleiVar	| src ast ir method |	src :=  self class sourceCodeAt: #exampleiVar.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	method := ir compiledMethod.		self assert: (method valueWithReceiver: self arguments: #()) = 1.! !!IRBuilderTest class methodsFor: 'as yet unclassified' stamp: 'ms 7/12/2006 18:43'!testToPush	^TestToPush! !!IRBuilderTest class methodsFor: 'as yet unclassified' stamp: 'ms 7/12/2006 18:43'!testToPush: anObject	TestToPush := anObject! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/13/2006 10:10'!expectedFailures	^ #(testPushThisEnv testStoreThisEnv)! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:50'!isThisEverCalled	"Redefinition for testing the #send:toSuperOf:"! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:32'!testDup	| iRMethod aCompiledMethod |	iRMethod _ IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteral: 3;		pushDup;				send: #=;				returnTop;		ir.	aCompiledMethod _ iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = true).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:32'!testInstVar	| iRMethod aCompiledMethod |	iRMethod _ IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushInstVar: 1;		pushInstVar: 2;		send: #+;				returnTop;		ir.	aCompiledMethod _ iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: (3@4) arguments: #() ) = 7).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:32'!testJumpAheadTo	| iRMethod aCompiledMethod |	iRMethod _ IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushTemp: #self	;					jumpAheadTo: #end;		pushLiteral: 3;		jumpAheadTarget: #end;					returnTop;		ir.	aCompiledMethod _ iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = nil).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:32'!testJumpAheadToIf	| iRMethod aCompiledMethod |	iRMethod _ IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushTemp: #self	;		pushLiteral: true;				"jumpAhaedTo pop the first element of thz stack"		jumpAheadTo: #end if: true;		pushLiteral: 3;		jumpAheadTarget: #end;					returnTop;		ir.	aCompiledMethod _ iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = nil).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:33'!testJumpBackTo	| iRMethod aCompiledMethod |	iRMethod _ IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushTemp: #self	;		pushLiteral: false;		jumpBackTarget: #begin;				"jumpAhaedTo pop the first element of the stack"		jumpAheadTo: #end if: true;		pushLiteral: true;		jumpBackTo: #begin;		jumpAheadTarget: #end;					returnTop;		ir.	aCompiledMethod _ iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = nil).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 17:52'!testLiteralArray	| iRMethod aCompiledMethod |	iRMethod _ IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteral: #(test 4 you); 			returnTop;		ir.	aCompiledMethod _ iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = #(test 4 you)).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 17:49'!testLiteralBoolean	| iRMethod aCompiledMethod |	iRMethod _ IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteral: true; 			returnTop;		ir.	aCompiledMethod _ iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = true).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 17:50'!testLiteralCharacter	| iRMethod aCompiledMethod |	iRMethod _ IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteral: $e; 			returnTop;		ir.	aCompiledMethod _ iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = $e).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 17:54'!testLiteralFloat	| iRMethod aCompiledMethod |	iRMethod _ IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteral: 2.0; 			returnTop;		ir.	aCompiledMethod _ iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = 2.0).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 17:54'!testLiteralInteger	| iRMethod aCompiledMethod |	iRMethod _ IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteral: 2; 			returnTop;		ir.	aCompiledMethod _ iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = 2).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 17:50'!testLiteralNil	| iRMethod aCompiledMethod |	iRMethod _ IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteral: nil; 			returnTop;		ir.	aCompiledMethod _ iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: 4 arguments: #() ) = nil).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 17:53'!testLiteralString	| iRMethod aCompiledMethod |	iRMethod _ IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteral: 'hello'; 			returnTop;		ir.	aCompiledMethod _ iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = 'hello').	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 17:56'!testLiteralSymbole	| iRMethod aCompiledMethod |	iRMethod _ IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteral: #you; 			returnTop;		ir.	aCompiledMethod _ iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = #you).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 17:28'!testLiteralVariableClass	| iRMethod aCompiledMethod |	iRMethod _ IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteralVariable: Object binding;			returnTop;		ir.	aCompiledMethod _ iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = Object).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 17:33'!testLiteralVariableClassVariable	| iRMethod aCompiledMethod |	iRMethod _ IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteralVariable: (DateAndTime bindingOf: #LocalTimeZone); 			returnTop;		ir.	aCompiledMethod _ iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = DateAndTime localTimeZone).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 17:27'!testLiteralVariableGlobale	| iRMethod aCompiledMethod |	iRMethod _ IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"					pushLiteralVariable: (Smalltalk associationAt: #Smalltalk);			returnTop;		ir.	aCompiledMethod _ iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = Smalltalk).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:33'!testPopTop	| iRMethod aCompiledMethod |	iRMethod _ IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushTemp: #self	;					pushLiteral: false;		popTop;				returnTop;		ir.	aCompiledMethod _ iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = nil).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:33'!testPushReceiver	| iRMethod aCompiledMethod receiver |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushReceiver;		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.		receiver :=  (5@8).	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: receiver arguments: #() ) == receiver).! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:33'!testPushTempArgument	| iRMethod aCompiledMethod  |	iRMethod := IRBuilder new		numRargs: 3;		addTemps: #(self a b);		"receiver and args declarations"		pushTemp: #a;		pushTemp: #b;		send: #+;		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #(2 8) ) = 10).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:33'!testPushTempSelf	| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushTemp: #self;		send: #class;		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) == UndefinedObject).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:33'!testPushTempTemp	| iRMethod aCompiledMethod  |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self a);		"receiver and args declarations"			pushTemp: #a;		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: 5 arguments: #() ) = nil).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:33'!testPushThisContext	| iRMethod aCompiledMethod  |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self a);		"receiver and args declarations"			pushThisContext;		send: #receiver;		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: 5 arguments: #() ) = 5).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:47'!testPushThisEnv	| iRMethod aCompiledMethod receiver |	self error: 'TODO I don''t know what it mean'.	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"			pushThisEnv;		send: #receiver;		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	receiver := Object new.		self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: receiver arguments: #()) == receiver)	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:41'!testSendSuper	| iRMethod aCompiledMethod  |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"			pushReceiver;		send: #isThisEverCalled toSuperOf: IRBuilderTest;		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self should: [(aCompiledMethod valueWithReceiver: (IRBuilderTest new) arguments: #())] raise: Halt.	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:34'!testStorIntoVariable	| iRMethod aCompiledMethod  |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"			pushLiteral: 4;		storeIntoLiteralVariable: (IRBuilderTest bindingOf: #TestToPush);		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     aCompiledMethod valueWithReceiver: nil arguments: #().	self assert: (IRBuilderTest testToPush = 4).	IRBuilderTest testToPush: nil.	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:48'!testStoreTemp	| iRMethod aCompiledMethod  |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self a);		"receiver and args declarations"			pushLiteral: 34;		storeTemp: #a;		popTop;		pushTemp: #a;		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = 34).	! !!IRBuilderTest methodsFor: 'testing' stamp: 'ms 7/12/2006 23:50'!testStoreThisEnv	| iRMethod aCompiledMethod  |	self error: 'TODO don''t know what it mean'.	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self a);		"receiver and args declarations"			pushLiteral: 34;		storeTemp: #a;		popTop;		pushTemp: #a;		returnTop;		ir.	aCompiledMethod := iRMethod compiledMethod.	self assert: (aCompiledMethod isKindOf: CompiledMethod).     self assert: ((aCompiledMethod valueWithReceiver: nil arguments: #() ) = 34).	! !!IRDecompilerTest commentStamp: '<historical>' prior: 0!This class tests decompilation if IR Nodes to RB Nodes (class IRDecompiler) !!IRDecompilerTest methodsFor: 'examples' stamp: 'md 11/15/2004 16:08'!exampleBlockParam	^[:a| a].! !!IRDecompilerTest methodsFor: 'examples' stamp: 'md 11/15/2004 17:10'!exampleBlockSelf	^[self].! !!IRDecompilerTest methodsFor: 'examples' stamp: 'md 3/9/2005 14:14'!exampleIf	^ true ifTrue: [1 + 3]. ! !!IRDecompilerTest methodsFor: 'examples' stamp: 'md 11/17/2004 13:55'!exampleParam: a	| ttttt |	[:t |  ^ttttt]   ! !!IRDecompilerTest methodsFor: 'examples' stamp: 'md 10/20/2004 17:49'!exampleSimpleBlock	^[1].! !!IRDecompilerTest methodsFor: 'as yet unclassified' stamp: 'md 7/13/2006 09:34'!expectedFailures	^#(testDecompileBlockParam)! !!IRDecompilerTest methodsFor: 'testing' stamp: 'md 11/15/2004 17:09'!testDecompileBlock	| ir ast src |	src :=  self class sourceCodeAt: #exampleSimpleBlock.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	ast := IRDecompiler new decompileIR: ir.	self assert: (ast compiledMethod valueWithReceiver: nil arguments: #()) value = 1. ! !!IRDecompilerTest methodsFor: 'testing' stamp: 'md 3/4/2005 15:48'!testDecompileBlockParam	| cm ir ast |	cm := (self class)>>#exampleBlockParam.	ir := BytecodeDecompiler new decompile: cm.		ast := IRDecompiler new decompileIR: ir.	self assert: ((ast compiledMethod valueWithReceiver: nil arguments: #()) value: 2) = 2. ! !!IRDecompilerTest methodsFor: 'testing' stamp: 'md 11/17/2004 12:31'!testDecompileBlockSelf	| ir ast src |	src :=  self class sourceCodeAt: #exampleBlockSelf.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.     	ir := ast ir.		ast := IRDecompiler new decompileIR: ir.	self assert: (ast compiledMethod valueWithReceiver: self arguments: #()) value = self. ! !!IRDecompilerTest methodsFor: 'testing' stamp: 'md 3/9/2005 18:42'!testDecompileIfTrue	| ir src ast |	"cm := self class>>#exampleIf.	ir := BytecodeDecompiler new decompile: cm."	src :=  self class sourceCodeAt: #exampleIf.		ast := ClosureCompiler new parseClosure: src in: self class notifying: nil.	ir := ast ir.	ast := IRDecompiler new decompileIR: ir.	! !!IRTransformTest methodsFor: 'testing' stamp: 'md 10/13/2004 14:09'!testAdd		| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushLiteral: 1;						returnTop;		ir.	(iRMethod allSequences last) last delete.	(iRMethod allSequences last) last delete.	(iRMethod allSequences last)			add: (IRInstruction pushLiteral: 2).	(iRMethod allSequences last)			add: (IRInstruction returnTop).	aCompiledMethod := iRMethod compiledMethod.	self should: [(aCompiledMethod valueWithReceiver: nil arguments: #() ) = 2].! !!IRTransformTest methodsFor: 'testing' stamp: 'md 10/13/2004 14:09'!testAddBefore		| iRMethod aCompiledMethod ret |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushLiteral: 1;						returnTop;		ir.	(iRMethod allSequences last) last delete.	(iRMethod allSequences last) last delete.	ret :=  (IRInstruction returnTop).	(iRMethod allSequences last)			add: ret.	(iRMethod allSequences last)			add: (IRInstruction pushLiteral: 2) before: ret.	aCompiledMethod := iRMethod compiledMethod.	self should: [(aCompiledMethod valueWithReceiver: nil arguments: #() ) = 2].! !!IRTransformTest methodsFor: 'testing' stamp: 'md 10/13/2004 14:09'!testAddIntructions		| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushLiteral: 1;						returnTop;		ir.	(iRMethod allSequences last) last delete.	(iRMethod allSequences last) last delete.	(iRMethod allSequences last)			addInstructions: {(IRInstruction pushLiteral: 2). (IRInstruction returnTop)}.	aCompiledMethod := iRMethod compiledMethod.	self should: [(aCompiledMethod valueWithReceiver: nil arguments: #() ) = 2].! !!IRTransformTest methodsFor: 'testing' stamp: 'md 10/12/2004 16:31'!testAddIntructionsBefore		| iRMethod aCompiledMethod push |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushLiteral: 1;						returnTop;		ir.	push := (iRMethod allSequences last) at: (iRMethod allSequences size - 1) .	(iRMethod allSequences last)			addInstructions: {(IRInstruction pushLiteral: 2). (IRInstruction returnTop)} before: push.	aCompiledMethod := iRMethod compiledMethod.	self should: [(aCompiledMethod valueWithReceiver: nil arguments: #() ) = 2].! !!IRTransformTest methodsFor: 'testing' stamp: 'md 10/13/2004 11:08'!testAddIntructionsBeforeFromLList		| iRMethod aCompiledMethod push llist col |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushLiteral: 1;						returnTop;		ir.	push := (iRMethod allSequences last) at: (iRMethod allSequences size - 1) .	llist := LinkedList new.	llist add: (IRInstruction pushLiteral: 2).	llist add: (IRInstruction returnTop).	col := llist asOrderedCollection.	(iRMethod allSequences last)			addInstructions:  col before: push.	aCompiledMethod := iRMethod compiledMethod.	self should: [(aCompiledMethod valueWithReceiver: nil arguments: #() ) = 2].! !!IRTransformTest methodsFor: 'testing' stamp: 'md 10/13/2004 14:09'!testDelete		| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushLiteral: 1;						pushLiteral: 2;			returnTop;		ir.	((iRMethod allSequences last) 		detect: [:each | each isConstant: [:c | c == 2]]) delete.				aCompiledMethod := iRMethod compiledMethod.	self should: [(aCompiledMethod valueWithReceiver: nil arguments: #() ) = 1].! !!IRTransformTest methodsFor: 'testing' stamp: 'ms 7/13/2006 10:13'!testReplace	| iRMethod aCompiledMethod |		iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushLiteral: 1;						returnTop;		ir.		(iRMethod allSequences last at: 1) 			replaceWith: (IRInstruction pushLiteral: 2).	aCompiledMethod := iRMethod compiledMethod.	self should: [(aCompiledMethod valueWithReceiver: nil arguments: #() ) = 2].! !!IRTransformTest methodsFor: 'testing' stamp: 'md 2/22/2005 11:58'!testReplaceInstr		| iRMethod aCompiledMethod |	iRMethod := IRBuilder new		numRargs: 1;		addTemps: #(self);		"receiver and args declarations"		pushLiteral: 1;						returnTop;		ir.		(iRMethod allSequences last at: 1) 			replaceWithInstructions: {(IRInstruction pushLiteral: 2)}.	aCompiledMethod := iRMethod compiledMethod.	self should: [(aCompiledMethod valueWithReceiver: nil arguments: #() ) = 2].! !!NonClosureScopeFixerTest methodsFor: 'example' stamp: 'md 3/16/2006 18:00'!exampleSimple	| a |	a := 1.	^[:b | a + b] value: 1.! !!NonClosureScopeFixerTest methodsFor: 'tests' stamp: 'md 3/17/2006 11:38'!testSimple	| text ast |		text := self class sourceCodeAt: #exampleSimple.	self assert: text isText.	ast := Parser2 new parse: text class: self class.	self assert: (ast isKindOf: RBMethodNode).		self assert: ast scope isMethodScope.	NonClosureScopeFixer new visitNode: ast.! !!PragmaTest methodsFor: 'accessing' stamp: 'ms 9/4/2006 00:25'!expectedFailures	Smalltalk at: #ExternalFunction ifAbsent:[^#(#testApicall #testCdecl #testCdeclNoModule)].	^#()! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/19/2006 00:12'!methodApicall	^'methodApicall: aHWND		<apicall: Win32HDC ''GetDC'' (Win32Window bool bool*) module: ''user32.dll''>		^self externalCallFailed'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/19/2006 00:15'!methodCdecl	^'XCloseDisplay: aDisplay		<cdecl: void ''XCloseDisplay'' (X11Display*) module:''X11''>		^self externalCallFailed'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/25/2006 08:36'!methodCdeclNoModule	^'ffiTestShort: c1 with: c2 with: c3 with: c4		"FFITester ffiTestShort: $A with: 65 with: 65.0 with: $A"		<cdecl: short ''ffiTestShorts'' (short short short short)>		^self externalCallFailed'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/16/2006 21:03'!methodDoublePragma	^'methodDoublePragma		<hello: 5>		<hello: 2>'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/16/2006 20:56'!methodDoublePrimitive	^'methodDoublePrimitive		<primitive: 5>		<primitive: 2>'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/26/2006 22:53'!methodNoPragma	^'methodNoPragma: aNum		^aNum'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/16/2006 21:04'!methodPragmaAfterBeforTemps	^'methodPragmaAfterBeforTemps		<hello: 5>		| aTemp |		<world: #ok>		<blue: true>'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/20/2006 20:49'!methodPragmaTwoParam	^'methodDoublePragma		<hello: 5 by: 2>'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/25/2006 07:56'!methodPragmaUnarayMessage	^'methodPragmaUnarayMessage		<hello>'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/16/2006 21:05'!methodPrimitive	^'methodPrimitive		<primitive: 4>'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/16/2006 21:05'!methodPrimitivePragma	^'methodPrimitivePragma		<hello: 1>		<primitive: 4>		<hello: 1>'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/22/2006 13:31'!methodPrimitiveString	^'methodPrimitiveString		<primitive: ''aFunctionName''>'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/22/2006 13:33'!methodPrimitiveStringModule	^'methodPrimitiveStringModule		<primitive: ''aFunctionName'' module: ''aModuleName''>'! !!PragmaTest methodsFor: 'method-tested' stamp: 'ms 7/16/2006 21:06'!methodSinglePragma	^'methodSinglePragma		<hello: 5>'! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/19/2006 00:10'!testApicall	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodApicall in: self class notifying: [nil].		self assert: ((aRBMethode compiledMethod literalAt: 1) isKindOf: ExternalLibraryFunction).	self assert: (aRBMethode compiledMethod primitive = 120)! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/19/2006 00:15'!testCdecl	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodCdecl in: self class notifying: [nil].		self assert: ((aRBMethode compiledMethod literalAt: 1) isKindOf: ExternalLibraryFunction).	self assert: (aRBMethode compiledMethod primitive = 120)! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/25/2006 08:37'!testCdeclNoModule	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodCdeclNoModule in: self class notifying: [nil].		self assert: ((aRBMethode compiledMethod literalAt: 1) isKindOf: ExternalLibraryFunction).	self assert: (aRBMethode compiledMethod primitive = 120)! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/16/2006 21:03'!testDoublePragma	| aRBMethode |	"self debug: #testDoublePragma"	aRBMethode := ClosureCompiler new parseClosure: self methodDoublePragma in: self class notifying: [nil].		self assert: (aRBMethode compiledMethod pragmas first keyword = #hello:).	self assert: (aRBMethode compiledMethod pragmas second keyword = #hello:)! !!PragmaTest methodsFor: 'testing' stamp: 'ms 9/4/2006 00:24'!testDoublePrimitive	"self debug: #testDoublePrimitive"	self should: [ClosureCompiler new parseClosure: self methodDoublePrimitive in: self class notifying: [^nil]] raise: Warning! !!PragmaTest methodsFor: 'testing' stamp: 'pmm 8/19/2006 22:18'!testIsPrimitve	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodPrimitive in: self class notifying: [nil].		self assert: aRBMethode isPrimitive! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/26/2006 22:54'!testNoPragma	"self debug: #testDoublePrimitive"	self shouldnt: [ClosureCompiler new parseClosure: self methodNoPragma in: self class notifying: nil] raise: Error! !!PragmaTest methodsFor: 'testing' stamp: 'ms 9/4/2006 00:51'!testPragmaAfterBeforTemp	"self debug: #testPragmaAfterBeforTemp"	| aRBMethode |	self halt.	aRBMethode := ClosureCompiler new parseClosure: self methodPragmaAfterBeforTemps in: self class notifying: nil.	self assert: (aRBMethode compiledMethod pragmas first keyword = #hello:).	self assert: (aRBMethode compiledMethod pragmas second keyword = #world:)	! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/20/2006 20:50'!testPragmaTwoParam	"self debug: #testPragmaAfterBeforTemp"	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodPragmaTwoParam in: self class notifying: nil.	self assert: (aRBMethode compiledMethod pragmas first keyword = #hello:by:)	! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/25/2006 07:57'!testPragmaUnarayMessage	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodPragmaUnarayMessage in: self class notifying: [nil].		self assert: (aRBMethode compiledMethod pragmas first keyword = #hello)! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/16/2006 21:05'!testPrimitiveNumber	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodPrimitive in: self class notifying: [nil].		self assert: (aRBMethode compiledMethod primitive = 4)! !!PragmaTest methodsFor: 'testing' stamp: 'ms 9/4/2006 00:33'!testPrimitivePragmaNumber	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodPrimitivePragma in: self class notifying: [^nil].		self assert: (aRBMethode compiledMethod primitive = 4)! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/22/2006 13:31'!testPrimitiveString	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodPrimitiveString in: self class notifying: [nil].		self assert: (aRBMethode compiledMethod primitive = 117)! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/22/2006 13:33'!testPrimitiveStringModule	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodPrimitiveStringModule in: self class notifying: [nil].		self assert: (aRBMethode compiledMethod primitive = 117)! !!PragmaTest methodsFor: 'testing' stamp: 'ms 7/16/2006 21:06'!testSinglePragma	| aRBMethode |	aRBMethode := ClosureCompiler new parseClosure: self methodSinglePragma in: self class notifying: [nil].	self assert: (aRBMethode compiledMethod pragmas first keyword = #hello:)	! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 7/15/2006 10:50'!keyword: anObject	"For test"	^anObject copy! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 8/4/2006 10:56'!testCommentOnArguments	| rbMethodNode |	rbMethodNode := SqueakParser parseMethod: 'zork 1 to: 2. "foo" ^self'.		self assert: rbMethodNode body statements first arguments first comments notEmpty.	self assert: rbMethodNode body statements first arguments first comments first = (15 to: 19).		rbMethodNode := SqueakParser parseMethod: 'zork 1 to: 2 "foo". ^self'.		self assert: rbMethodNode body statements first arguments first comments notEmpty.	self assert: rbMethodNode body statements first arguments first comments first = (14 to: 18)		! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 8/4/2006 11:09'!testCommentOnMethod	| rbMethodNode |	rbMethodNode := SqueakParser parseMethod: 'zork "hello" "world" ^self'.		self assert: rbMethodNode comments notEmpty.	self assert: rbMethodNode comments first = (6 to: 12).	self assert: rbMethodNode comments second = (14 to: 20).		rbMethodNode := SqueakParser parseMethod: 'zork 1 "foo" to: 2. ^self'.		self assert: rbMethodNode comments notEmpty.	self assert: rbMethodNode comments first = (8 to: 12)! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 8/4/2006 11:13'!testCommentOnReceiver	| rbMethodNode |	rbMethodNode := SqueakParser parseMethod: 'zork 1 to: "foo" 2. ^self'.		self assert: rbMethodNode body statements first receiver comments notEmpty.	self assert: rbMethodNode body statements first receiver comments first = (12 to: 16).		! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 8/4/2006 12:21'!testCommentOnTemp	| rbMethodNode |	rbMethodNode := SqueakParser parseMethod: 'zork | a b | "foo" ^self'.		self assert: rbMethodNode body temporaries last comments notEmpty.	self assert: rbMethodNode body temporaries last comments first = (14 to: 18).		rbMethodNode := SqueakParser parseMethod: 'zork | a "bob" b | ^self'.		self assert: rbMethodNode body temporaries first comments notEmpty.	self assert: rbMethodNode body temporaries first comments first = (10 to: 14)		! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 8/4/2006 10:56'!testCommentOnVariableNode	| rbMethodNode |	rbMethodNode := SqueakParser parseMethod: 'zork ^self "foo"'.		self assert: rbMethodNode body statements first value comments notEmpty.	self assert: rbMethodNode body statements first value comments first = (12 to: 16).		rbMethodNode := SqueakParser parseMethod: 'zork 1 to: 2.. "foo" ^self'.		self assert: rbMethodNode body statements second value comments notEmpty.	self assert: rbMethodNode body statements second value comments first = (16 to: 20).		rbMethodNode := SqueakParser parseMethod: 'zork 1 to: 2.. "foo". ^self'.		self assert: rbMethodNode body statements second value comments notEmpty.	self assert: rbMethodNode body statements second value comments first = (16 to: 20)! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 7/13/2006 15:33'!testEmptyStatement	"self debug: #testEmptyStatement"	self shouldnt: [SqueakParser parseDoIt: 'Object new..' ] raise: Error.	self shouldnt: [SqueakParser parseDoIt: '..Object new' ] raise: Error.	self shouldnt: [SqueakParser parseDoIt: 'Object new..Object new' ] raise: Error.		self assert: ((SqueakParser parseDoIt: 'Object new..') class = RBDoItNode).	self assert: ((SqueakParser parseDoIt: '..Object new') class = RBDoItNode).	self assert: ((SqueakParser parseDoIt: 'Object new..Object new') class = RBDoItNode)! !!SqueakParserTest methodsFor: 'testing' stamp: 'ms 7/15/2006 10:51'!testMethodPattern	"self debug: #testEmptyStatement"	self shouldnt: [SqueakParser parseMethodPattern: (self class>>#keyword:) getSource ] raise: Error.! !!ClosureCompiler class methodsFor: 'as yet unclassified' stamp: 'md 11/12/2004 11:44'!initialize		"self initialize"	Preferences		addPreference: #compileBlocksAsClosures		category: #compiler		default: false		balloonHelp: 'If true, blocks ([...]) will be compiled as BlockClosures instead of BlockContexts.  BlockClosures are independent of their home context but are a little slower (for now).  Only newly compiled methods will be affected by this preference. This requires the use of the new compiler, see Preference compileUsingNewCompiler'.! !!ClosureCompiler methodsFor: 'as yet unclassified' stamp: 'md 7/16/2003 16:01'!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock	"Compiles the sourceStream into a parse tree, then generates code into a 	method. This method is then installed in the receiver's class so that it 	can be invoked. In other words, if receiver is not nil, then the text can 	refer to instance variables of that receiver (the Inspector uses this). If 	aContext is not nil, the text can refer to temporaries in that context (the 	Debugger uses this). If aRequestor is not nil, then it will receive a 	notify:at: message before the attempt to evaluate is aborted. Finally, the 	compiled method is invoked from here as DoIt or (in the case of 	evaluation in aContext) DoItIn:. The method is subsequently removed 	from the class, but this will not get done if the invocation causes an 	error which is terminated. Such garbage can be removed by executing: 	Smalltalk allBehaviorsDo: [:cl | cl removeSelector: #DoIt; removeSelector: 	#DoItIn:]."			cacheDoItNode _ true.		^ self evaluate2: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock! !!ClosureCompiler methodsFor: 'as yet unclassified' stamp: 'md 10/14/2004 17:47'!exampleReturn1	^1! !!ClosureCompiler methodsFor: 'as yet unclassified' stamp: 'md 11/18/2003 16:18'!parseClosure: textOrStream in: aClass notifying: req        "Compile the argument, textOrStream, with respect to the class, aClass,         and answer the MethodNode that is the root of the resulting parse tree.         Notify the argument, req, if an error occurs. The failBlock is defaulted to         an empty block."        self from: textOrStream class: aClass context: nil notifying: req.        ^ Parser2 new                        parse: sourceStream                        class: class                        noPattern: false                        context: context                        notifying: requestor                        ifFail: []! !!ClosureCompiler methodsFor: 'as yet unclassified' stamp: 'md 7/15/2003 12:24'!parserClass	^Parser2! !!Compiler class methodsFor: '*newcompiler-override' stamp: 'md 3/5/2006 17:03' prior: 19133171!closureDecompilerClass	^FakeDecompiler! !!Compiler class methodsFor: '*newcompiler-override' stamp: 'md 3/5/2006 17:03' prior: 19133297!closureParserClass	^Parser2! !!Compiler class methodsFor: '*newcompiler-override' stamp: 'md 2/27/2006 16:58' prior: 19133660!decompilerClass	"Answer a decompiler class appropriate for this Compiler."	^ Preferences compileUseNewCompiler		ifTrue: [FakeDecompiler]		ifFalse: [Decompiler]! !!Compiler class methodsFor: '*newcompiler' stamp: 'md 2/27/2006 16:32'!initialize	Preferences		addPreference: #compileUseNewCompiler		category: #compiler		default: false		balloonHelp: 'If true, the new compiler is used for compiling methods. Only newly compiled methods will be affected by this preference.'! !!Compiler class methodsFor: '*newcompiler-override' stamp: 'ajh 1/20/2002 18:57' prior: 19133856!parserClass	"Return a parser class to use for parsing method headers."	^ Preferences compileUseNewCompiler		ifTrue: [Parser2]		ifFalse: [Parser]! !!Compiler methodsFor: '*newcompiler-override' stamp: 'md 2/28/2006 15:42' prior: 19125349!compile: textOrStream in: aClass classified: aCategory notifying: aRequestor ifFail: failBlock 	"Answer a MethodNode for the argument, textOrStream. If the 	MethodNode can not be created, notify the argument, aRequestor; if 	aRequestor is nil, evaluate failBlock instead. The MethodNode is the root 	of a parse tree. It can be told to generate a CompiledMethod to be 	installed in the method dictionary of the argument, aClass."		| methodNode |	self from: textOrStream		class: aClass		classified: aCategory 		context: nil		notifying: aRequestor.	methodNode := self translate: sourceStream noPattern: false ifFail: failBlock.	Preferences compileUseNewCompiler ifFalse: [		methodNode encoder requestor: requestor.	].	^methodNode.! !!Compiler methodsFor: '*newcompiler' stamp: 'md 6/22/2006 16:12'!compileDoIt: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock log: log	"Compiles the sourceStream into a parse tree, then generates code into a method.  This method is then wrapped in a block with the receiver or context as the sole free variable which the method refers to.  If requestor is not nil, then it will receive a notify:at: message if there is a compile error, followed by the failBlock being executed."	| scope parser blockNode method source |	source _ textOrStream readStream.	scope _ aContext		ifNotNil: [aContext doItScope]		ifNil: [receiver class parseScope instanceScope].	parser _ Parser2 new.	blockNode _ parser			parse: source			class: scope			noPattern: true			notifying: aRequestor			ifFail: [^ failBlock value].	method _ blockNode generate.	method selector: #DoIt.	log ifTrue: [		method putSource: source contents			fromParseNode: blockNode			inFile: 2 			withPreamble: [:file | file cr]].	^ BlockClosure new		env: (aContext ifNil: [receiver]);		method: method;		yourself! !!Compiler methodsFor: '*newcompiler' stamp: 'ajh 6/29/2004 14:31'!evaluate2: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	| string |	string _ textOrStream readStream upToEnd.	^ (self compileDoIt: string in: aContext to: receiver notifying: aRequestor ifFail: [^ failBlock value] log: logFlag) value! !!Compiler methodsFor: '*newcompiler-override' stamp: 'md 3/8/2006 14:42' prior: 33636074!evaluate: textOrStream in: aContext to: receiver notifying: aRequestor ifFail: failBlock logged: logFlag	"Compiles the sourceStream into a parse tree, then generates code into a method. In other words, if receiver is not nil, then the text can refer to instance variables of that receiver (the Inspector uses this). If aContext is not nil, the text can refer to temporaries in that context (the Debugger uses this). If aRequestor is not nil, then it will receive a notify:at: message before the attempt to evaluate is aborted. Finally, the compiled method is directly invoked without modifying the receiving-class."	| methodNode method value |	  	(Preferences compileUseNewCompiler or: 			[aContext ifNotNil: [aContext method isClosureCompiled] ifNil: [false]]) ifTrue: 				[^ self evaluate2: textOrStream 					    in: aContext 					    to: receiver 					    notifying: aRequestor 					    ifFail: failBlock 					    logged: logFlag].		class := (aContext isNil 		ifTrue: [ receiver ] 		ifFalse: [ aContext receiver ])			class.	self from: textOrStream class: class context: aContext notifying: aRequestor.	methodNode := self 		translate: sourceStream		noPattern: true 		ifFail: [ ^ failBlock value ].	method := methodNode generate.	self interactive		ifTrue: [ method := method copyWithTempNames: methodNode tempNames ].	value := receiver 		withArgs: (context isNil			ifTrue: [ #() ]			ifFalse: [ Array with: aContext ])		executeMethod: method.	logFlag 		ifTrue: [ SystemChangeNotifier uniqueInstance evaluated: sourceStream contents context: aContext ].	^ value.! !!BytecodeGenerator commentStamp: 'ajh 5/23/2003 10:59' prior: 0!I generate bytecodes in response to 'instructions' messages being sent to me.  I rewrite jumps at the end so their jump offsets are correct (see #bytecodes).  For example, to create a compiled method that compares first instVar to first arg and returns 'yes' or 'no' (same example as in IRBuilder), do:	BytecodeGenerator new		numArgs: 1;		pushInstVar: 1;		pushTemp: 1;		send: #>;		if: false goto: #else;		pushLiteral: 'yes';		returnTop;		label: #else;		pushLiteral: 'no';		returnTop;		compiledMethodYou can send #ir to the compiledMethod to decompile to its IRMethod, and you can send #methodNode to either to decompile to its parse tree.!!BytecodeGenerator class methodsFor: 'initialize' stamp: 'ajh 3/6/2003 22:44'!bytecodeTableFrom: specArray	"SpecArray is an array of either	(index selector) or	(index1 index2 selector)."	| contiguous |	Bytecodes _ IdentityDictionary new: 256.	BytecodeTable _ Array new: 256.	contiguous _ 0.	specArray do: [ :spec |		(spec at: 1) = contiguous ifFalse: [self error: 'Non-contiguous table entry'].		spec size = 2 ifTrue: [			Bytecodes at: (spec at: 2) put: (spec at: 1).			BytecodeTable at: (spec at: 1) + 1 put: (spec at: 2).			contiguous _ contiguous + 1.		] ifFalse: [			spec size = 3 ifFalse: [self error: 'bad spec size'].			Bytecodes at: (spec at: 3) put: ((spec at: 1) to: (spec at: 2)).			(spec at: 1) to: (spec at: 2) do: [ :i |				BytecodeTable at: i + 1 put: (spec at: 3).			].			contiguous _ contiguous + ((spec at: 2) - (spec at: 1)) + 1.		].	].	^ BytecodeTable! !!BytecodeGenerator class methodsFor: 'initialize' stamp: 'ajh 3/6/2003 22:40'!initialize	self initializeBytecodeTable.	self initializeSpecialSelectors.	self initializeSpecialConstants.! !!BytecodeGenerator class methodsFor: 'initialize' stamp: 'ajh 3/6/2003 22:42'!initializeBytecodeTable	"BytecodeWriteStream initialize"	"Defines all the bytecode instructions for the Compiler and the Interpreter.	The following bytecode tuple format is:	#(bytecode bytecodeSelector)	bytecodeSelector is the method in the Interpreter that gets executed for the given bytecode.	Common Send selector position within the specialSelectorsArray is hard code in the Interpreter, see senders of Interpreter specialSelector:."	^ self bytecodeTableFrom:	#(		(  0  15 pushReceiverVariableBytecode)		( 16  31 pushTemporaryVariableBytecode)		( 32  63 pushLiteralConstantBytecode)		( 64  95 pushLiteralVariableBytecode)		( 96 103 storeAndPopReceiverVariableBytecode)		(104 111 storeAndPopTemporaryVariableBytecode)		(112 pushReceiverBytecode)		(113 pushConstantTrueBytecode)		(114 pushConstantFalseBytecode)		(115 pushConstantNilBytecode)		(116 pushConstantMinusOneBytecode)		(117 pushConstantZeroBytecode)		(118 pushConstantOneBytecode)		(119 pushConstantTwoBytecode)		(120 returnReceiver)		(121 returnTrue)		(122 returnFalse)		(123 returnNil)		(124 returnTopFromMethod)		(125 returnTopFromBlock)		(126 unknownBytecode)		(127 unknownBytecode)		(128 extendedPushBytecode)		(129 extendedStoreBytecode)		(130 extendedStoreAndPopBytecode)		(131 singleExtendedSendBytecode)		(132 doubleExtendedDoAnythingBytecode)		(133 singleExtendedSuperBytecode)		(134 secondExtendedSendBytecode)		(135 popStackBytecode)		(136 duplicateTopBytecode)		(137 pushActiveContextBytecode)		(138 143 experimentalBytecode)		(144 151 shortUnconditionalJump)		(152 159 shortConditionalJump)		(160 167 longUnconditionalJump)		(168 171 longJumpIfTrue)		(172 175 longJumpIfFalse)		"176-191 were sendArithmeticSelectorBytecode"		(176 bytecodePrimAdd)		(177 bytecodePrimSubtract)		(178 bytecodePrimLessThan)		(179 bytecodePrimGreaterThan)		(180 bytecodePrimLessOrEqual)		(181 bytecodePrimGreaterOrEqual)		(182 bytecodePrimEqual)		(183 bytecodePrimNotEqual)		(184 bytecodePrimMultiply)		(185 bytecodePrimDivide)		(186 bytecodePrimMod)		(187 bytecodePrimMakePoint)		(188 bytecodePrimBitShift)		(189 bytecodePrimDiv)		(190 bytecodePrimBitAnd)		(191 bytecodePrimBitOr)			"192-207 were sendCommonSelectorBytecode"		(192 bytecodePrimAt)		(193 bytecodePrimAtPut)		(194 bytecodePrimSize)		(195 bytecodePrimNext)		(196 bytecodePrimNextPut)		(197 bytecodePrimAtEnd)		(198 bytecodePrimEquivalent)		(199 bytecodePrimClass)		(200 bytecodePrimBlockCopy)		(201 bytecodePrimValue)		(202 bytecodePrimValueWithArg)		(203 bytecodePrimDo)		(204 bytecodePrimNew)		(205 bytecodePrimNewWithArg)		(206 bytecodePrimPointX)		(207 bytecodePrimPointY)		(208 255 sendLiteralSelectorBytecode)	)! !!BytecodeGenerator class methodsFor: 'initialize' stamp: 'ajh 3/6/2003 22:45'!initializeSpecialConstants	SpecialConstants _ {true. false. nil. -1. 0. 1. 2}! !!BytecodeGenerator class methodsFor: 'initialize' stamp: 'ajh 3/6/2003 22:40'!initializeSpecialSelectors	"Create a map from specialSelector -> bytecode offset from sendAdd (the first one)"	| array |	SpecialSelectors _ IdentityDictionary new.	array _ self specialSelectorsArray.  "Smalltalk specialObjectsArray at: 24"	1 to: array size by: 2 "skip numArgs" do: [:i |		SpecialSelectors at: (array at: i) put: i - 1 / 2].! !!BytecodeGenerator class methodsFor: 'initialize' stamp: 'ajh 3/15/2003 15:43'!specialConstants	^ SpecialConstants! !!BytecodeGenerator class methodsFor: 'initialize' stamp: 'ajh 3/6/2003 22:45'!specialSelectorsArray	^ #(#+ 1 #- 1 #< 1 #> 1 #<= 1 #>= 1 #= 1 #~= 1 #* 1 #/ 1 #\\ 1 #@ 1 #bitShift: 1 #// 1 #bitAnd: 1 #bitOr: 1 #at: 1 #at:put: 2 #size 0 #next 0 #nextPut: 1 #atEnd 0 #== 1 #class 0 #blockCopy: 1 #value 0 #value: 1 #do: 1 #new 0 #new: 1 #x 0 #y 0)! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 3/6/2003 22:48'!addLastLiteral: object	lastLiteral ifNil: [^ lastLiteral _ object].	(lastLiteral literalEqual: object)		ifFalse: [self error: 'there can only be one last literal'].! !!BytecodeGenerator methodsFor: 'private' stamp: 'kwl 6/25/2006 20:06'!addLiteral: object	literals add: object.	^ literals identityIndexOf: object! !!BytecodeGenerator methodsFor: 'old style blocks' stamp: 'md 10/8/2004 16:01'!blockReturnTop	self saveLastJump: #return.	self nextPut: (Bytecodes at: #returnTopFromBlock).! !!BytecodeGenerator methodsFor: 'results' stamp: 'ajh 5/22/2003 13:06'!bytecodes	| stream |	[ orderSeq		inject: false		into: [:changed :seqId | (self updateJump: seqId) | changed]	] whileTrue.	stream _ (ByteArray new: 100) writeStream.	orderSeq do: [:seqId |		(instrMaps at: seqId) do: [:assoc |			assoc key "instr" bytecodeIndex: stream position + assoc value.		].		stream nextPutAll: (seqBytes at: seqId).	].	^ stream contents! !!BytecodeGenerator methodsFor: 'results' stamp: 'md 2/21/2006 14:14'!compiledMethod	^ self compiledMethodWith: #(0 0 0 0)! !!BytecodeGenerator methodsFor: 'results' stamp: 'pmm 8/16/2006 20:51'!compiledMethodWith: trailer	^self compiledMethodWith: trailer using: CompiledMethod! !!BytecodeGenerator methodsFor: 'results' stamp: 'pmm 8/16/2006 20:51'!compiledMethodWith: trailer using: aCompiledMethodClass	| cm |	cm := (aCompiledMethodClass		primitive: (self primNum > 0			ifTrue: [self primNum]			ifFalse: [self quickMethodPrim])		numArgs: self numArgs		numTemps: (self numTemps max: self numArgs)		stackSize: self stackSize		literals: self literals		bytecodes: self bytecodes		trailer: trailer).	cm isClosureCompiled: Preferences compileBlocksAsClosures.	cm properties: self properties.	^cm.! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 5/22/2003 13:00'!from: fromSeqId goto: toSeqId	| distance from to |	from _ seqOrder at: fromSeqId.	to _ seqOrder at: toSeqId ifAbsent: [^ self].	from + 1 = to ifTrue: [^ self].  "fall through, no jump needed"	from < to ifTrue: [ "jump forward"		distance _ (from + 1 to: to - 1) inject: 0 into: [:size :i | 				size + (seqBytes at: (orderSeq at: i)) size].		self jumpForward: distance.	] ifFalse: [ "jump backward"		distance _ ((to to: from - 1) inject: 0 into: [:size :i |				size + (seqBytes at: (orderSeq at: i)) size])			+ bytes size.		self jumpBackward: distance.	].! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 5/22/2003 13:22'!from: fromSeqId if: bool goto: toSeqId otherwise: otherwiseSeqId	| distance from to otherwise |	from _ seqOrder at: fromSeqId.	to _ seqOrder at: toSeqId ifAbsent: [^ self jump: 0 if: bool].  "not done yet"	otherwise _ seqOrder at: otherwiseSeqId ifAbsent: [^ self jump: 0 if: bool].  "not done yet"	from < to ifFalse: [self errorConditionalJumpBackwards].	from + 1 = otherwise ifFalse: [self errorFallThroughSequenceNotNext].	distance _ (from + 1 to: to - 1)		inject: 0		into: [:size :i | size + (seqBytes at: (orderSeq at: i)) size].	self jump: distance if: bool.! !!BytecodeGenerator methodsFor: 'old style blocks' stamp: 'md 10/8/2004 16:01'!fromBlock: curId goto: seqId	| distance from to |	from _ seqOrder at: curId.	to _ seqOrder at: seqId ifAbsent: [^ self].	distance _ (from + 1 to: to - 1) inject: 0 into: [:size :i | 				size + (seqBytes at: (orderSeq at: i)) size].	distance > 1023 ifTrue: [self error: 'forward jump too big'].	self nextPut: (Bytecodes at: #longUnconditionalJump) first + (distance // 256) + 4.	self nextPut: distance \\ 256.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 5/22/2003 12:22'!goto: seqId	stacks at: seqId put: (stack linkTo: (stacks at: seqId ifAbsentPut: [nil])).	self saveLastJump: (Message		selector: #from:goto:		arguments: {currentSeqId. seqId}).	self from: currentSeqId goto: seqId.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 5/22/2003 13:26'!if: bool goto: seqId	| otherwiseSeqId |	otherwiseSeqId _ self newDummySeqId.	self if: bool goto: seqId otherwise: otherwiseSeqId.	self label: otherwiseSeqId.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 5/22/2003 12:26'!if: bool goto: seqId1 otherwise: seqId2	stack pop.	stacks at: seqId1 put: (stack linkTo: (stacks at: seqId1 ifAbsentPut: [nil])).	stacks at: seqId2 put: (stack linkTo: (stacks at: seqId2 ifAbsentPut: [nil])).	self saveLastJump: (Message		selector: #from:if:goto:otherwise:		arguments: {currentSeqId. bool. seqId1. seqId2}).	self from: currentSeqId if: bool goto: seqId1 otherwise: seqId2.! !!BytecodeGenerator methodsFor: 'initialize' stamp: 'md 2/21/2006 14:27'!initialize	literals _ LiteralList new.	"The following dicts are keyed by sequence id given by client in label: (and gotos)."	seqOrder _ IdentityDictionary new.  "seqId -> seq order num"	seqBytes _ IdentityDictionary new.  "seqId -> seq bytecodes"	jumps _ IdentityDictionary new.  "seqId -> last jump instr"	instrMaps _ IdentityDictionary new.  "seqId -> (clientInstr -> bytecode pos)"	stacks _ IdentityDictionary new.  "seqId -> stackCount"	maxTemp _ 0.	primNum _ 0.	numArgs _ 0.	currentSeqNum _ 0.	orderSeq _ OrderedCollection new.  "reverse map of seqOrder"	"starting label in case one is not provided by client"	self label: self newDummySeqId.! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 3/24/2003 17:48'!jump: distance if: condition	| hi |	distance = 0 ifTrue: [		"jumps to fall through, no-op"		^ self nextPut: (Bytecodes at: #popStackBytecode)].	condition ifTrue: [		hi _ distance // 256.		hi < 8 ifFalse: [self error: 'true jump too big'].		self nextPut: (Bytecodes at: #longJumpIfTrue) first + hi.		self nextPut: distance \\ 256.	] ifFalse: [		distance <= 8 ifTrue: [			self nextPut: (Bytecodes at: #shortConditionalJump) first + distance - 1.		] ifFalse: [			hi _ distance // 256.			hi < 8 ifFalse: [self error: 'false jump too big'].			self nextPut: (Bytecodes at: #longJumpIfFalse) first + hi.			self nextPut: distance \\ 256.		].	]	! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 7/19/2004 12:12'!jumpBackward: distance	| dist |	distance = 0 ifTrue: [^ self].  "no-op"	dist _ 1024 - distance - 2.	dist < 0 ifTrue: [self error: 'back jump too big'].	self nextPut: (Bytecodes at: #longUnconditionalJump) first + (dist // 256).	self nextPut: dist \\ 256.! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 3/24/2003 17:46'!jumpForward: distance	distance = 0 ifTrue: [^ self].  "no-op"	distance <= 8 ifTrue: [		self nextPut: (Bytecodes at: #shortUnconditionalJump) first + distance - 1.	] ifFalse: [		distance > 1023 ifTrue: [self error: 'forward jump too big'].		self nextPut: (Bytecodes at: #longUnconditionalJump) first + (distance // 256) + 4.		self nextPut: distance \\ 256.	].! !!BytecodeGenerator methodsFor: 'old style blocks' stamp: 'md 10/8/2004 16:01'!jumpOverBlock: seqId	stacks at: seqId put: (stack linkTo: (stacks at: seqId ifAbsentPut: [nil])).			self saveLastJump: (Message		selector: #fromBlock:goto:		arguments: {currentSeqId. seqId}).		self fromBlock: currentSeqId goto: seqId.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'md 10/6/2005 16:51'!label: seqId	(currentSeqId notNil and: [(jumps at: currentSeqId) isNil]) ifTrue: [		"make previous implicit goto explicit"		self goto: seqId.	].	lastSpecialReturn := nil.	currentSeqId := seqId.	currentSeqNum := currentSeqNum + 1.	seqOrder at: seqId put: currentSeqNum.	orderSeq at: currentSeqNum ifAbsentPut: [seqId].	bytes := seqBytes at: seqId ifAbsentPut: [OrderedCollection new].	jumps at: seqId ifAbsentPut: [nil].	instrMap := instrMaps at: seqId ifAbsentPut: [OrderedCollection new].	stack := stacks at: seqId ifAbsentPut: [StackCount new].! !!BytecodeGenerator methodsFor: 'results' stamp: 'md 2/21/2006 14:14'!literals	literals := literals asArray copyWith: MethodProperties new.	^ lastLiteral 		ifNil: [literals copyWith: nil ] 		ifNotNil: [literals copyWith: lastLiteral]! !!BytecodeGenerator methodsFor: 'mapping' stamp: 'ajh 3/13/2003 13:00'!mapBytesTo: instr	"Associate next byte with instr"	instrMap add: instr -> (bytes size + 1)! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 5/22/2003 13:28'!newDummySeqId	^ Object new! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 3/13/2003 13:00'!nextPut: byte	bytes add: byte! !!BytecodeGenerator methodsFor: 'results' stamp: 'ajh 3/13/2003 18:27'!numArgs	^ numArgs! !!BytecodeGenerator methodsFor: 'initialize' stamp: 'ajh 3/13/2003 18:21'!numArgs: n	numArgs _ n! !!BytecodeGenerator methodsFor: 'results' stamp: 'ajh 3/13/2003 18:03'!numTemps	^ maxTemp! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/13/2003 17:48'!popTop	stack pop.	self nextPut: (Bytecodes at: #popStackBytecode).! !!BytecodeGenerator methodsFor: 'results' stamp: 'ajh 3/13/2003 18:27'!primNum	^ primNum! !!BytecodeGenerator methodsFor: 'initialize' stamp: 'ajh 3/13/2003 18:21'!primitiveNode: aPrimitiveNode	literals isEmpty ifFalse: [self error: 'init prim before adding instructions'].	aPrimitiveNode spec ifNotNil: [literals add: aPrimitiveNode spec].	primNum _ aPrimitiveNode num.! !!BytecodeGenerator methodsFor: 'accessing' stamp: 'md 7/12/2006 16:40'!properties	^ properties ifNil: [ properties := MethodProperties new ].! !!BytecodeGenerator methodsFor: 'accessing' stamp: 'md 7/10/2005 22:21'!properties: propDict	properties := propDict.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/13/2003 17:48'!pushDup	stack push.	self nextPut: (Bytecodes at: #duplicateTopBytecode).! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/13/2003 17:49'!pushInstVar: instVarIndex	| interval |	stack push.	interval _ Bytecodes at: #pushReceiverVariableBytecode.	instVarIndex <= interval size ifTrue: [		^ self nextPut: (interval at: instVarIndex).	].	instVarIndex <= 64 ifTrue: [		self nextPut: (Bytecodes at: #extendedPushBytecode).		^ self nextPut: (0 "instVar" << 6) + instVarIndex - 1.	].	instVarIndex <= 256 ifFalse: [self error: 'can''t reference more than 256 inst vars'].	self nextPut: (Bytecodes at: #doubleExtendedDoAnythingBytecode).	self nextPut: 2 "pushInstVar" << 5.	self nextPut: instVarIndex - 1.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'kwl 6/25/2006 19:56'!pushLiteral: object	| index interval |	stack push.	(index _ SpecialConstants identityIndexOf: object ifAbsent: 0) > 0 ifTrue: [		^ self nextPut: (Bytecodes at: #pushConstantTrueBytecode) + index - 1].	(index _ literals literalIndexOf: object ifAbsent: 0) > 0 ifFalse: [		index _ self addLiteral: object].	interval _ Bytecodes at: #pushLiteralConstantBytecode.	(index <= interval size) ifTrue: [		^ self nextPut: (interval at: index)	].	index <= 64 ifTrue: [		self nextPut: (Bytecodes at: #extendedPushBytecode).		^ self nextPut: 2 "lit constant" << 6 + index - 1	].	index > 256 ifTrue: [self error: 'too many literals (>256)'].	self nextPut: (Bytecodes at: #doubleExtendedDoAnythingBytecode).	self nextPut: 3 "lit constant" << 5.	self nextPut: index - 1.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'kwl 6/25/2006 19:58'!pushLiteralVariable: object	| index interval |	stack push.	object isVariableBinding		ifFalse: [self error: 'not a literal variable'].	(index _ literals literalIndexOf: object ifAbsent: 0) > 0 ifFalse: [		index _ self addLiteral: object].	interval _ Bytecodes at: #pushLiteralVariableBytecode.	(index <= interval size) ifTrue: [		^ self nextPut: (interval at: index)	].	index <= 64 ifTrue: [		self nextPut: (Bytecodes at: #extendedPushBytecode).		^ self nextPut: 3 "literal variable" << 6 + index - 1	].	index > 256 ifTrue: [self error: 'too many literals (>256)'].	self nextPut: (Bytecodes at: #doubleExtendedDoAnythingBytecode).	self nextPut: 1 "lit variable" << 7.	self nextPut: index - 1.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/13/2003 17:50'!pushReceiver	stack push.	self nextPut: (Bytecodes at: #pushReceiverBytecode)! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/13/2003 17:51'!pushTemp: index	| interval |	stack push.	maxTemp _ index max: maxTemp.	interval _ Bytecodes at: #pushTemporaryVariableBytecode.	index <= interval size ifTrue: [		^ self nextPut: (interval at: index).	].	index <= 64 ifFalse: [self error: 'too many temp vars (>64)'].	self nextPut: (Bytecodes at: #extendedPushBytecode).	self nextPut: (1 "temp" << 6) + index - 1.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/13/2003 17:51'!pushThisContext	stack push.	self nextPut: (Bytecodes at: #pushActiveContextBytecode).! !!BytecodeGenerator methodsFor: 'results' stamp: 'md 10/6/2005 16:50'!quickMethodPrim	| i |	self numArgs = 0 ifFalse: [^ 0].	lastSpecialReturn ifNil: [^ 0].	(seqBytes  size <= 2) ifFalse: [^ 0].	"seqBytes  size = 1 ifFalse: [^ 0]."	^ lastSpecialReturn selector caseOf: {		[#returnReceiver] -> [256].		[#returnConstant:] -> [			(i := SpecialConstants indexOf: lastSpecialReturn argument) > 0				ifTrue: [256 + i] ifFalse: [0]].		[#returnInstVar:] -> [263 + lastSpecialReturn argument]	  }! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 7/2/2004 13:44'!remoteReturn	self saveLastJump: #return.	self send: #privRemoteReturnTo:.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'md 7/19/2005 23:11'!returnConstant: obj	self saveLastJump: #return.		bytes size = 0 ifTrue: [		lastSpecialReturn := Message selector: #returnConstant: argument: obj]. 		obj caseOf: {		[true] -> [self nextPut: (Bytecodes at: #returnTrue)].		[false] -> [self nextPut: (Bytecodes at: #returnFalse)].		[nil] -> [self nextPut: (Bytecodes at: #returnNil)]	} otherwise: [		self pushLiteral: obj.		self returnTop.	]! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'md 7/19/2005 23:29'!returnInstVar: index	self saveLastJump: #return.		bytes size = 0 ifTrue: [		lastSpecialReturn := Message selector: #returnInstVar: argument: index].	self pushInstVar: index.	self returnTop.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 5/22/2003 14:02'!returnReceiver	self saveLastJump: #return.	bytes size = 0 ifTrue: [		lastSpecialReturn _ Message selector: #returnReceiver].	self nextPut: (Bytecodes at: #returnReceiver).! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 5/22/2003 14:02'!returnTop	self saveLastJump: #return.	self nextPut: (Bytecodes at: #returnTopFromMethod).! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 5/22/2003 12:23'!saveLastJump: message	jumps at: currentSeqId put: {bytes size. message}.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/16/2003 14:43'!send: selector	| index nArgs |	nArgs _ selector numArgs.	stack pop: nArgs.	SpecialSelectors at: selector ifPresent: [:i |		^ self nextPut: (Bytecodes at: #bytecodePrimAdd) + i].	index _ self addLiteral: selector.	(index <= 16 and: [nArgs <= 2]) ifTrue: [		"short send"		^ self nextPut: (Bytecodes at: #sendLiteralSelectorBytecode) first + (nArgs * 16) + index - 1	].	(index <= 32 and: [nArgs <= 7]) ifTrue: [		"extended (2-byte) send"		self nextPut: (Bytecodes at: #singleExtendedSendBytecode).		^ self nextPut: nArgs * 32 + index - 1	].	(index <= 64 and: [nArgs <= 3]) ifTrue: [		"new extended (2-byte)"		self nextPut: (Bytecodes at: #secondExtendedSendBytecode).		^ self nextPut: nArgs * 64 + index - 1	].	"long (3-byte) send"	self nextPut: (Bytecodes at: #doubleExtendedDoAnythingBytecode).	self nextPut: nArgs.	self nextPut: index - 1.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'md 2/27/2006 17:03'!send: selector toSuperOf: behavior	| index nArgs |	nArgs := selector numArgs.	stack pop: nArgs.	self addLastLiteral: behavior binding.  	index := self addLiteral: selector.	(index <= 32 and: [nArgs <= 7]) ifTrue: [		"extended (2-byte) send"		self nextPut: (Bytecodes at: #singleExtendedSuperBytecode).		^ self nextPut: nArgs * 32 + index - 1	].	"long (3-byte) send"	self nextPut: (Bytecodes at: #doubleExtendedDoAnythingBytecode).	self nextPut: 1 << 5 "super" + nArgs.	self nextPut: index - 1.! !!BytecodeGenerator methodsFor: 'results' stamp: 'ajh 3/13/2003 18:03'!stackSize	^ (stacks collect: [:s | s length]) max! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/9/2003 20:36'!storeInstVar: index	index <= 64 ifTrue: [		self nextPut: (Bytecodes at: #extendedStoreBytecode).		^ self nextPut: (0 "instVar" << 6) + index - 1.	].	index <= 256 ifFalse: [self error: 'can''t reference more than 256 inst vars'].	self nextPut: (Bytecodes at: #doubleExtendedDoAnythingBytecode).	self nextPut: 5 "storeInstVar" << 5.	self nextPut: index - 1.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'md 10/4/2005 17:42'!storeIntoLiteralVariable: object	| index |		index := self addLiteral: object.   	index <= 64 ifTrue: [		self nextPut: (Bytecodes at: #extendedStoreBytecode).		^ self nextPut: (3 "instVar" << 6) + index - 1.	].	index <= 256 ifFalse: [self error: 'can''t reference more than 256 inst vars'].	self nextPut: (Bytecodes at: #doubleExtendedDoAnythingBytecode).	self nextPut: 7 "storeLiteralVar" << 5.	self nextPut: index - 1.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/13/2003 18:00'!storePopInstVar: index	| interval |	stack pop.	interval _ Bytecodes at: #storeAndPopReceiverVariableBytecode.	index <= interval size ifTrue: [		^ self nextPut: (interval at: index)	].	index <= 64 ifTrue: [		self nextPut: (Bytecodes at: #extendedStoreAndPopBytecode).		^ self nextPut: (0 "instVar" << 6) + index - 1.	].	index <= 256 ifFalse: [		self error: 'can''t reference more than 256 inst vars'].	self nextPut: (Bytecodes at: #doubleExtendedDoAnythingBytecode).	self nextPut: 6 "storePopInstVar" << 5.	self nextPut: index - 1.! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/13/2003 18:01'!storePopTemp: index	| interval |	stack pop.	maxTemp _ index max: maxTemp.	interval _ Bytecodes at: #storeAndPopTemporaryVariableBytecode.	index <= interval size ifTrue: [		^ self nextPut: (interval at: index)	].	index <= 64 ifTrue: [		self nextPut: (Bytecodes at: #extendedStoreAndPopBytecode).		^ self nextPut: (1 "temp" << 6) + index - 1.	].	self error: 'too many temps (>64)'! !!BytecodeGenerator methodsFor: 'instructions' stamp: 'ajh 3/13/2003 18:01'!storeTemp: index	maxTemp _ index max: maxTemp.	index <= 64 ifFalse: [self error: 'too many temps (>64)'].	self nextPut: (Bytecodes at: #extendedStoreBytecode).	self nextPut: (1 "temp" << 6) + index - 1.! !!BytecodeGenerator methodsFor: 'private' stamp: 'ajh 6/22/2003 14:41'!updateJump: seqId	"Recalculate final jump bytecodes.  Return true if jump bytecodes SIZE has changed, otherwise return false"	| pair s1 |	pair _ jumps at: seqId.	pair last == #return ifTrue: [^ false].  "no jump, a return"	bytes _ seqBytes at: seqId.	s1 _ bytes size.	bytes removeLast: (bytes size - pair first).	pair last sendTo: self.	^ s1 ~= bytes size! !!ClosureCompiledObject class methodsFor: 'as yet unclassified' stamp: 'md 11/23/2005 11:49'!compile: code classified: cat notifying: requestor trailer: bytes ifFail: failBlock	"Compile code without logging the source in the changes file"	| methodNode |	methodNode  := self compilerClass new				compile: code				in: self				classified: category 				notifying: requestor				ifFail: failBlock.	^ CompiledMethodWithNode generateMethodFromNode: methodNode trailer: bytes.! !!ClosureCompiledObject class methodsFor: 'as yet unclassified' stamp: 'md 7/16/2003 15:57'!compilerClass	^ClosureCompiler! !!ClosureRuntimeStats commentStamp: 'ajh 5/21/2004 17:39' prior: 0!Count the number of closure creations and calls while executing a given block. ClosureRuntimeStats on. ClosureRuntimeStats off inspect. (Closure measure: [...]) inspect. ClosureRuntimeStats testResults asArray. (ClosureRuntimeStats testResults allButFirst	inject: ClosureRuntimeStats testResults first	into: [:agg :stat | agg + stat])	testName: 'Aggregate'!!ClosureRuntimeStats class methodsFor: 'tracing methods' stamp: 'ajh 7/1/2004 17:32'!blockClosureNew	ClosureCreationCount _ ClosureCreationCount + 1.	^ self basicNew! !!ClosureRuntimeStats class methodsFor: 'tracing methods' stamp: 'ajh 7/1/2004 17:32'!envNew: size	| array n |	array _ EnvCreationCount.	n _ size + 1.	array at: n put: (array at: n) + 1.	^ self basicNew: size! !!ClosureRuntimeStats class methodsFor: 'initialize' stamp: 'ajh 7/1/2004 15:28'!initCounters	Smalltalk at: #ClosureCreationCount put: 0.		"indexed by number of free vars"	Smalltalk at: #EnvCreationCount put: (Array new: 100 withAll: 0).	Smalltalk at: #ClosureCallCount put: (Array new: 100 withAll: 0).		Smalltalk at: #NewObjectCount put: 0.	StartTime _ Time millisecondClockValue.! !!ClosureRuntimeStats class methodsFor: 'initialize' stamp: 'ajh 5/21/2004 13:43'!initialize	Tests _ OrderedCollection new.	self initCounters.! !!ClosureRuntimeStats class methodsFor: 'initialize' stamp: 'ajh 5/21/2004 16:06'!installCountObjectMethods	{{Behavior. #primBasicNew. #primBasicNew}.	 {Behavior. #primBasicNew:. #primBasicNew:}.	 {Behavior. #basicNew. #traceBasicNew}.	 {Behavior. #basicNew:. #traceBasicNew:}	} do: [:triple |		triple first			addSelectorSilently: triple second			withMethod: (self class compiledMethodAt: triple third)].	self installTracingMethods.! !!ClosureRuntimeStats class methodsFor: 'initialize' stamp: 'ajh 7/1/2004 15:20'!installOriginalMethods	{{BlockClosure. #valueWithArguments:. #primValueWithArguments:}.	} do: [:triple |		triple first			addSelectorSilently: triple second			withMethod: (self class compiledMethodAt: triple third)].	{{ClosureEnvironment class. #new:}.	 {BlockClosure class. #new}.	 {BlockClosure. #primValueWithArguments:}.	} do: [:pair |		pair first removeSelectorSimply: pair second].! !!ClosureRuntimeStats class methodsFor: 'initialize' stamp: 'ajh 5/21/2004 16:06'!installOriginalObjectMethods	{{Behavior. #basicNew. #primBasicNew}.	 {Behavior. #basicNew:. #primBasicNew:}	} do: [:triple |		triple first			addSelectorSilently: triple second			withMethod: (self class compiledMethodAt: triple third)].	{{Behavior. #primBasicNew}.	 {Behavior. #primBasicNew:}	} do: [:pair |		pair first removeSelectorSimply: pair second].	self installOriginalMethods.! !!ClosureRuntimeStats class methodsFor: 'initialize' stamp: 'ajh 7/1/2004 15:06'!installTracingMethods	{{BlockClosure class. #new. #blockClosureNew}.	 {BlockClosure. #primValueWithArguments:. #primValueWithArguments:}.	 {BlockClosure. #valueWithArguments:. #valueWithArguments:}.	 {ClosureEnvironment class. #new:. #envNew:}.	} do: [:triple |		triple first			addSelectorSilently: triple second			withMethod: (self class compiledMethodAt: triple third)].	self initCounters.! !!ClosureRuntimeStats class methodsFor: 'run' stamp: 'ajh 5/21/2004 00:05'!measure: block	self on.	block value.	^ self off! !!ClosureRuntimeStats class methodsFor: 'run' stamp: 'ajh 5/21/2004 16:07'!off	| stats |	stats _ self new copyResults.	self installOriginalObjectMethods.	stats sendsPerSecond: 0 tinyBenchmarks.	^ stats! !!ClosureRuntimeStats class methodsFor: 'run' stamp: 'ajh 5/21/2004 16:06'!on	self installCountObjectMethods.! !!ClosureRuntimeStats class methodsFor: 'original methods' stamp: 'ajh 5/21/2004 15:48'!primBasicNew	"Primitive. Answer an instance of the receiver (which is a class) with no 	indexable variables. Fail if the class is indexable. Essential. See Object 	documentation whatIsAPrimitive."	<primitive: 70>	self isVariable ifTrue: [ ^ self basicNew: 0 ].	"space must be low"	self environment signalLowSpace.	^ self basicNew  "retry if user proceeds"! !!ClosureRuntimeStats class methodsFor: 'original methods' stamp: 'ajh 5/21/2004 15:49'!primBasicNew: sizeRequested 	"Primitive. Answer an instance of this class with the number	of indexable variables specified by the argument, sizeRequested.	Fail if this class is not indexable or if the argument is not a	positive Integer, or if there is not enough memory available. 	Essential. See Object documentation whatIsAPrimitive."	<primitive: 71>	self isVariable ifFalse:		[self error: self printString, ' cannot have variable sized instances'].	(sizeRequested isInteger and: [sizeRequested >= 0]) ifTrue:		["arg okay; space must be low."		self environment signalLowSpace.		^ self basicNew: sizeRequested  "retry if user proceeds"].	self primitiveFailed! !!ClosureRuntimeStats class methodsFor: 'original methods' stamp: 'ajh 7/1/2004 17:19'!primValueWithArguments: anArray 	"Primitive. Evaluate the block represented by the receiver. The argument 	is an Array whose elements are the arguments for the block. Fail if the 	length of the Array is not the same as the the number of arguments that 	the block was expecting. Fail if the block is already being executed. 	Essential. See Object documentation whatIsAPrimitive."	"<primitive: 187>"	^ self env withArgs: anArray executeMethod: self method! !!ClosureRuntimeStats class methodsFor: 'tests' stamp: 'ajh 5/21/2004 13:57'!testResults	"Collection of previously run test results"	^ Tests! !!ClosureRuntimeStats class methodsFor: 'tracing methods' stamp: 'ajh 5/21/2004 15:49'!traceBasicNew	NewObjectCount _ NewObjectCount + 1.	^ self primBasicNew! !!ClosureRuntimeStats class methodsFor: 'tracing methods' stamp: 'ajh 5/21/2004 15:49'!traceBasicNew: size	NewObjectCount _ NewObjectCount + 1.	^ self primBasicNew: size! !!ClosureRuntimeStats class methodsFor: 'tracing methods' stamp: 'ajh 7/1/2004 18:00'!valueWithArguments: args	| n array e |	e _ self env.	n _ e class == ClosureEnvironment		ifTrue: [e size]		ifFalse: [1].	n _ n + 1.	(array _ ClosureCallCount) at: n put: (array at: n) + 1.	^ self primValueWithArguments: args! !!ClosureRuntimeStats methodsFor: 'as yet unclassified' stamp: 'ajh 7/1/2004 15:33'!+ stat	| agg |	(stat isKindOf: self class) ifFalse: [self error: 'can''t add stats'].	agg _ self class basicNew.	#(envCreationCount closureCreationCount closureCallCount milliseconds) do: [:var |		agg instVarNamed: var put:			(self instVarNamed: var) + (stat instVarNamed: var)].	^ agg! !!ClosureRuntimeStats methodsFor: 'as yet unclassified' stamp: 'ajh 5/21/2004 15:00'!closureCallsPerSecond	^ ((closureCallCount first: 6) / (milliseconds / 1000)) truncated! !!ClosureRuntimeStats methodsFor: 'as yet unclassified' stamp: 'ajh 7/1/2004 15:35'!closureCreationPerSecond	^ (closureCreationCount / (milliseconds / 1000)) truncated! !!ClosureRuntimeStats methodsFor: 'as yet unclassified' stamp: 'ajh 7/1/2004 15:33'!copyResults	milliseconds _ Time millisecondClockValue - StartTime.	envCreationCount _ EnvCreationCount.	closureCreationCount _ ClosureCreationCount.	closureCallCount _ ClosureCallCount.	newObjectCount _ NewObjectCount.! !!ClosureRuntimeStats methodsFor: 'as yet unclassified' stamp: 'ajh 7/1/2004 15:34'!envCreationPerSecond	^ ((envCreationCount first: 6) / (milliseconds / 1000)) truncated! !!ClosureRuntimeStats methodsFor: 'printing' stamp: 'ajh 7/1/2004 18:03'!longPrintOn: stream	stream print: testName; cr; cr.	stream nextPutAll: 'New objects per sec: '.	stream print: self newObjectsPerSecond; cr; cr.	stream nextPutAll: 'New envs per sec: '.	stream print: self envCreationPerSecond sum; cr.	stream nextPutAll: 'by num free vars: '.	stream print: self envCreationPerSecond; cr; cr.	stream nextPutAll: 'New closures per sec: '.	stream print: self closureCreationPerSecond; cr; cr.	stream nextPutAll: 'Closure calls per sec: '.	stream print: self closureCallsPerSecond sum; cr.	stream nextPutAll: 'by num free vars: '.	stream print: self closureCallsPerSecond; cr; cr.	stream nextPutAll: self sendsPerSecond; cr.! !!ClosureRuntimeStats methodsFor: 'as yet unclassified' stamp: 'ajh 5/21/2004 16:09'!newObjectsPerSecond	^ (newObjectCount / (milliseconds / 1000)) truncated! !!ClosureRuntimeStats methodsFor: 'printing' stamp: 'ajh 5/21/2004 13:45'!printOn: stream	stream print: self class; space.	stream print: testName.! !!ClosureRuntimeStats methodsFor: 'as yet unclassified' stamp: 'ajh 5/21/2004 13:54'!sendsPerSecond	^ sendsPerSecond ifNil: [sendsPerSecond _ 0 tinyBenchmarks]! !!ClosureRuntimeStats methodsFor: 'as yet unclassified' stamp: 'ajh 5/21/2004 14:03'!sendsPerSecond: string	sendsPerSecond _ string! !!ClosureRuntimeStats methodsFor: 'printing' stamp: 'ajh 5/21/2004 13:58'!testName	"Just for documentation to distinguish multiple instances"	^ testName! !!ClosureRuntimeStats methodsFor: 'printing' stamp: 'ajh 5/21/2004 11:45'!testName: name	"Just to document for when you have multiple instances"	testName _ name! !!ClosureStaticStats commentStamp: 'ajh 5/21/2004 14:52' prior: 0!After recompiling the image under the new closure compiler (using Recompiler), use this to find distribution of:number of closures per method,number of free vars per closure.number of indirect free vars per closure.number of indirect temp vars per method with closure(s).number of indirect temp vars per method. ClosureStaticStats new run inspect. ClosureStaticStats lastStats.!!ClosureStaticStats class methodsFor: 'as yet unclassified' stamp: 'ajh 5/20/2004 02:20'!lastStats	^ LastStats! !!ClosureStaticStats methodsFor: 'as yet unclassified' stamp: 'ajh 5/20/2004 02:18'!allMethodsDo: methodBlock	| count |	count _ 0.	Smalltalk allClassesDo: [:class | count _ count +		({class. class class} collect: [:behavior |			behavior methodDictionary size]) sum].		'Checking ', count printString, ' methods'		displayProgressAt: Sensor cursorPoint from: 0 to: count		during: [:bar | | m | m _ 0.			Smalltalk allClassesDo: [:class |				{class. class class} do: [:behavior |					behavior methodDictionary do: [:meth |						methodBlock value: meth.						bar value: (m _ m + 1)]]]].! !!ClosureStaticStats methodsFor: 'as yet unclassified' stamp: 'ajh 7/1/2004 10:47'!initBags	methodsByEmbeddedBlocks _ Bag new.	blocksByFreeVars _ Bag new.	homeFunctionsByEscapingEnvs _ Bag new.	problemMethods _ OrderedCollection new.! !!ClosureStaticStats methodsFor: 'as yet unclassified' stamp: 'ajh 7/1/2004 10:47'!longPrintOn: stream	| list |	list _ [:bag | (0 to: 9) collect: [:i | bag valuesAndCounts at: i ifAbsent: [0]]].	stream nextPutAll: 'Methods: '.	stream print: methodsByEmbeddedBlocks size; cr.	stream nextPutAll: 'by num closures: '.	stream print: (list value: methodsByEmbeddedBlocks); cr; cr.	stream nextPutAll: 'Home methods/blocks: '.	stream print: homeFunctionsByEscapingEnvs size; cr.	stream nextPutAll: 'by having own env: '.	stream print: (list value: homeFunctionsByEscapingEnvs); cr; cr.	stream nextPutAll: 'Closures: '.	stream print: blocksByFreeVars size; cr.	stream nextPutAll: 'by num free vars: '.	stream print: (list value: blocksByFreeVars); cr.! !!ClosureStaticStats methodsFor: 'as yet unclassified' stamp: 'ajh 7/8/2004 19:19'!run	"scan all methods collecting stats"	self initBags.	self allMethodsDo: [:meth |		| blockMeths |		blockMeths _ meth allEmbeddedBlockMethods.		methodsByEmbeddedBlocks add: blockMeths size.		blockMeths size > 0 ifTrue: [			homeFunctionsByEscapingEnvs add: meth ast scope hasEscapingEnv asBit].		[blockMeths do: [:bm | | ast |			ast _ bm ast.			bm containsBlockClosures ifTrue: [				homeFunctionsByEscapingEnvs add: ast scope hasEscapingEnv asBit].			blocksByFreeVars add: ast freeVars size.		]] on: Error do: [problemMethods add: meth].	].	LastStats _ self.! !!CompilerTODO methodsFor: 'as yet unclassified' stamp: 'md 7/30/2005 19:53'!todo' - Support for popIntoLiteralVariable - Decompiler variable store - Fix MethodFinder for new Compiler - Annotation support fuer new Parser - IRInterpreter rename: IRVisitor - Fix Compiler IR-->RBNode decompile - Make a better parser for primitives - Better error messages parser - fix BUG: In the debugger, the selection is wrong - fix quickPrimitive generation'! !!Decompiler2 commentStamp: 'ajh 3/25/2003 00:28' prior: 0!This mirrors the old Decompiler interface delegating the real work to BytecodeDecompiler then IRDecompiler.!!Decompiler2 methodsFor: 'as yet unclassified' stamp: 'ajh 3/13/2003 21:09'!decompile: aMethod	"Answer a MethodNode that is the root of the parse tree for the argument, aMethod.  Selector will be 'unknown' and inst vars will be 'instVarN'.  selector and class can be placed in resulting MethodNode later"	^self		decompile: nil		in: nil		method: aMethod! !!Decompiler2 methodsFor: 'as yet unclassified' stamp: 'ajh 3/13/2003 21:09'!decompile: aSelector in: aClass 	"See Decompiler|decompile:in:method:. The method is found by looking up 	the message, aSelector, in the method dictionary of the class, aClass."	^self		decompile: aSelector		in: aClass		method: (aClass compiledMethodAt: aSelector)! !!Decompiler2 methodsFor: 'as yet unclassified' stamp: 'md 4/26/2005 12:23'!decompile: selector in: aClass method: aMethod	"Answer a MethodNode that is the root of the parse tree for the 	argument, aMethod, which is the CompiledMethod associated with the 	message, aSelector. Variables are determined with respect to the 	argument, aClass."	| ird methodNode |	ird _ IRDecompiler new.	ird scope: aClass parseScope newMethodScope.	methodNode _ ird decompileIR: aMethod ir.	selector ifNotNil: [[methodNode selector: selector] on: Error do: []].	^ methodNode! !!Decompiler2 methodsFor: 'as yet unclassified' stamp: 'md 2/27/2006 12:33'!decompileBlock: aBlock	"Answer a BlockNode, not done yet... return nil."	^nil.			"ird _ IRDecompiler new.	ird scope: nil parseScope newBlockScope.	^ (ird decompileIR: aBlock ir) asBlock"! !!Decompiler2 methodsFor: 'as yet unclassified' stamp: 'ajh 3/15/2003 15:57'!withTempNames: tempNameArray! !!FakeDecompiler methodsFor: 'as yet unclassified' stamp: 'md 2/28/2006 21:36'!decompile: aMethod	"Answer a MethodNode that is the root of the parse tree for the argument, aMethod.  Selector will be 'unknown' and inst vars will be 'instVarN'.  selector and class can be placed in resulting MethodNode later"	^self		decompile: aMethod selector  		in:  aMethod methodClass		method: aMethod! !!FakeDecompiler methodsFor: 'as yet unclassified' stamp: 'md 2/27/2006 16:35'!decompile: aSelector in: aClass 	"See Decompiler|decompile:in:method:. The method is found by looking up 	the message, aSelector, in the method dictionary of the class, aClass."	^self		decompile: aSelector		in: aClass		method: (aClass compiledMethodAt: aSelector)! !!FakeDecompiler methodsFor: 'as yet unclassified' stamp: 'md 2/28/2006 21:35'!decompile: selector in: aClass method: aMethod	"Answer a MethodNode that is the root of the parse tree for the 	argument, aMethod, which is the CompiledMethod associated with the 	message, aSelector. Variables are determined with respect to the 	argument, aClass."	| source |	^ (source := aMethod getSourceFromFile)		ifNil: [Decompiler new decompile: selector in: aClass method: aMethod ]		ifNotNil: [aMethod parserClass new parse: source class: aMethod methodClass]! !!FakeDecompiler methodsFor: 'as yet unclassified' stamp: 'md 2/27/2006 16:35'!decompileBlock: aBlock	"Answer a BlockNode, not done yet... return nil."	^nil.			"ird _ IRDecompiler new.	ird scope: nil parseScope newBlockScope.	^ (ird decompileIR: aBlock ir) asBlock"! !!FakeDecompiler methodsFor: 'as yet unclassified' stamp: 'md 2/27/2006 16:37'!withTempNames: tempNameArray	"ignored... fake decompiler has corrent temp names by default"! !!IRBuilder commentStamp: 'kwl 5/12/2006 18:29' prior: 0!I provide a simple interface for constructing an IRMethod.  For example, to create an ir method that compares first instVar to first arg and returns 'yes' or 'no' (same example as in BytecodeGenerator), do:	IRBuilder new		numRargs: 2;		addTemps: #(self a z);		"rcvr, arg, & extra temp (not used here)"		pushTemp: #self;		pushInstVar: 1;		pushTemp: #a;		send: #>;		jumpAheadTo: #else if: false;		pushLiteral: 'yes';		returnTop;		jumpAheadTarget: #else;		pushLiteral: 'no';		returnTop;		irSending #compiledMethod to an ir method will generate its compiledMethod.  Sending #methodNode to it will decompile to its parse tree.!!IRBuilder methodsFor: 'private' stamp: 'ajh 3/13/2003 13:20'!add: instr	"Associate instr with current parse node or byte range"	instr sourceNode: self sourceNode.	instr bytecodeIndex: self sourceByteIndex.	^ currentSequence add: instr! !!IRBuilder methodsFor: 'decompiling' stamp: 'ajh 6/22/2003 14:44'!addJumpBackTarget: label to: sequence	(jumpBackTargetStacks at: label ifAbsentPut: [OrderedCollection new])		addLast: sequence! !!IRBuilder methodsFor: 'private' stamp: 'md 7/11/2005 22:20'!addLiteral: aSymbol	ir addLiteral: aSymbol! !!IRBuilder methodsFor: 'private' stamp: 'md 7/12/2005 00:21'!addLiterals: aSymbol	ir addLiterals: aSymbol! !!IRBuilder methodsFor: 'initialize' stamp: 'md 11/16/2004 15:18'!addTemp: tempKey	self addTemps: {tempKey}! !!IRBuilder methodsFor: 'initialize' stamp: 'md 7/11/2005 23:53'!addTemps: newKeys	| keys i new |	keys := ir tempKeys.	i := keys size - 1. "zero-based (index 0 equals receiver)"	new := OrderedCollection new.	newKeys do: [:key |		tempMap at: key ifAbsentPut: [			new add: key.			i := i + 1]	].	ir tempKeys: keys, new.! !!IRBuilder methodsFor: 'instr - old blocks' stamp: 'md 9/26/2005 13:09'!blockReturnTop	| retInst newSequence |	retInst _ IRInstruction blockReturnTop.	self  add:retInst.	newSequence _ IRSequence new  orderNumber:currentSequence orderNumber  +1.	newSequence  method:ir.	currentSequence last isJumpOrReturn 		 ifFalse:[self  add:(IRJump new  destination:newSequence)].	currentSequence _ newSequence.	retInst  successor:currentSequence! !!IRBuilder methodsFor: 'accessing' stamp: 'md 10/11/2004 15:19'!currentSequence	^currentSequence! !!IRBuilder methodsFor: 'private' stamp: 'md 9/26/2005 13:09'!initialize	ir _ IRMethod new.	tempMap _ Dictionary new.	jumpAheadStacks _ IdentityDictionary new.	jumpBackTargetStacks _ IdentityDictionary new.	sourceMapNodes _ OrderedCollection new.	"stack"	"Leave an empty sequence up front (guaranteed not to be in loop)"	ir  startSequence:((IRSequence new  orderNumber:0)  method:ir).	currentSequence _ (IRSequence new  orderNumber:1)  method:ir.	ir startSequence  add:(IRJump new  destination:currentSequence)! !!IRBuilder methodsFor: 'results' stamp: 'ajh 3/10/2003 15:51'!ir	^ ir! !!IRBuilder methodsFor: 'instructions' stamp: 'md 2/27/2005 17:19'!jumpAheadTarget: labelSymbol	"Pop latest jumpAheadTo: with this labelSymbol and have it point to this new instruction sequence"	| jumpInstr |	self startNewSequence.	jumpInstr := (jumpAheadStacks at: labelSymbol ifAbsent: [			self error: 'Missing jumpAheadTo: ', labelSymbol printString]) removeLast.	jumpInstr destination: currentSequence.! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 6/22/2003 14:44'!jumpAheadTo: labelSymbol	"Jump to the sequence that will be created when jumpAheadTarget: labelSymbol is sent to self.  This is and its corresponding target is only good for one use.  Other jumpAheadTo: with the same label will be put on a stack and superceed existing ones until its jumpAheadTarget: is called."	"jumpAheadTarget: label will pop this and replace destination with its basic block"	(jumpAheadStacks at: labelSymbol ifAbsentPut: [OrderedCollection new])		addLast: (self add: IRJump new).	self startNewSequence.! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 6/22/2003 14:44'!jumpAheadTo: labelSymbol if: boolean	"Conditional jump to the sequence that will be created when jumpAheadTarget: labelSymbol is sent to self.  This and its corresponding target is only good for one use.  Other jumpAheadTo:... with the same label will be put on a stack and superceed existing ones until its jumpAheadTarget: is called."	| instr |	"jumpAheadTarget: label will pop this and replace destination with its basic block"	(jumpAheadStacks at: labelSymbol ifAbsentPut: [OrderedCollection new])		addLast: (instr _ self add: (IRJumpIf new boolean: boolean)).	self startNewSequence.	instr otherwise: currentSequence.! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 6/22/2003 14:44'!jumpBackTarget: labelSymbol	"Remember this basic block for a future jumpBackTo: labelSymbol.  Stack up remembered targets with same name and remove them from stack for each jumpBackTo: called with same name."	self startNewSequence.	(jumpBackTargetStacks at: labelSymbol ifAbsentPut: [OrderedCollection new])		addLast: currentSequence.! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 6/22/2003 14:25'!jumpBackTo: labelSymbol	"Pop last remembered position with this label and write an unconditional jump to it"	| sequence |	sequence _ (jumpBackTargetStacks at: labelSymbol ifAbsent: [self error: 'Missing jumpBackTarget: ', labelSymbol printString]) removeLast.	self add: (IRJump new destination: sequence).	self startNewSequence.! !!IRBuilder methodsFor: 'instr - old blocks' stamp: 'md 10/8/2004 15:59'!jumpOverBlockTo: labelSymbol	"Conditional jump to the sequence that will be created when jumpAheadTarget: labelSymbol is sent to self.  This and its corresponding target is only good for one use.  Other jumpAheadTo:... with the same label will be put on a stack and superceed existing ones until its jumpAheadTarget: is called."	| instr |	"jumpAheadTarget: label will pop this and replace destination with its basic block"	(jumpAheadStacks at: labelSymbol ifAbsentPut: [OrderedCollection new])		addLast: (instr _ self add: (IRJumpOverBlock new)).	self startNewSequence.	instr blockSequence: currentSequence.! !!IRBuilder methodsFor: 'mapping' stamp: 'ajh 3/13/2003 13:17'!mapToByteIndex: index	"decompiling"	sourceMapByteIndex _ index! !!IRBuilder methodsFor: 'mapping' stamp: 'ajh 6/22/2003 14:45'!mapToNode: object	"new instructions will be associated with object"	sourceMapNodes addLast: object! !!IRBuilder methodsFor: 'initialize' stamp: 'ajh 6/25/2004 11:24'!numRargs: n	ir numRargs: n.! !!IRBuilder methodsFor: 'mapping' stamp: 'ajh 6/22/2003 14:25'!popMap	sourceMapNodes removeLast! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 3/10/2003 01:09'!popTop	self add: IRInstruction popTop! !!IRBuilder methodsFor: 'initialize' stamp: 'ajh 3/10/2003 14:10'!primitiveNode: primNode	ir primitiveNode: primNode! !!IRBuilder methodsFor: 'accessing' stamp: 'md 7/10/2005 22:37'!properties: aDict	ir properties: aDict! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 6/27/2004 21:38'!pushBlock: irMethod	self add: (IRInstruction pushBlock: irMethod)! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 6/27/2004 21:38'!pushBlockMethod: irMethod	self add: (IRInstruction pushBlockMethod: irMethod)! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 3/10/2003 01:09'!pushDup	self add: IRInstruction pushDup! !!IRBuilder methodsFor: 'instructions' stamp: 'md 6/13/2005 13:59'!pushInstVar: instVarIndex	"Receiver must be on top"	self add: (IRInstruction pushInstVar: instVarIndex)."	self pushLiteral: instVarIndex.	self send: #privGetField:."! !!IRBuilder methodsFor: 'instructions' stamp: 'md 7/5/2005 15:52'!pushLiteral: object		self add: (IRInstruction pushLiteral: object)! !!IRBuilder methodsFor: 'instructions' stamp: 'md 7/5/2005 15:52'!pushLiteralVariable: object		self add: (IRInstruction pushLiteralVariable: object)! !!IRBuilder methodsFor: 'instructions' stamp: 'md 4/21/2005 11:38'!pushReceiver	self add: (IRInstruction pushReceiver)! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 3/17/2003 11:06'!pushTemp: key	| index |	index _ tempMap at: key.	self add: (IRInstruction pushTemp: index)! !!IRBuilder methodsFor: 'instructions' stamp: 'md 4/21/2005 12:06'!pushThisContext	self add: (IRInstruction pushThisContext)! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 6/26/2004 13:47'!pushThisEnv	self add: (IRInstruction pushTemp: -1)! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 3/15/2003 01:55'!remoteReturn	self add: IRInstruction remoteReturn.	self startNewSequence.! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 3/15/2003 01:55'!returnTop	self add: IRInstruction returnTop.	self startNewSequence.! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 3/10/2003 01:09'!send: selector	self add: (IRInstruction send: selector)! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 3/10/2003 01:09'!send: selector toSuperOf: behavior	self add: (IRInstruction send: selector toSuperOf: behavior)! !!IRBuilder methodsFor: 'mapping' stamp: 'ajh 3/13/2003 13:19'!sourceByteIndex	"decompiling"	^ sourceMapByteIndex! !!IRBuilder methodsFor: 'mapping' stamp: 'ajh 6/22/2003 21:03'!sourceNode	^ sourceMapNodes isEmpty		ifTrue: [nil]		ifFalse: [sourceMapNodes last]! !!IRBuilder methodsFor: 'private' stamp: 'md 9/26/2005 13:09'!startNewSequence	"End current instruction sequence and start a new sequence to add instructions to.  If ending block just falls through to new block then add an explicit jump to it so they stay linked"	| newSequence |	currentSequence isEmpty  ifTrue:[^ self].	"block is still empty, continue using it"	newSequence _ IRSequence new  orderNumber:currentSequence orderNumber  +1.	newSequence  method:ir.	currentSequence last isJumpOrReturn 		 ifFalse:[self  add:(IRJump new  destination:newSequence)].	currentSequence _ newSequence! !!IRBuilder methodsFor: 'instructions' stamp: 'md 6/13/2005 14:02'!storeInstVar: instVarIndex	"receiver must be on top with new field value underneath"	self add: (IRInstruction storeInstVar: instVarIndex).	"self pushLiteral: instVarIndex.	self send: #privStoreIn:field:."! !!IRBuilder methodsFor: 'instructions' stamp: 'md 7/5/2005 15:52'!storeIntoLiteralVariable: object		self add: (IRInstruction storeIntoLiteralVariable: object)! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 3/17/2003 11:06'!storeTemp: key	| index |	index _ tempMap at: key.	self add: (IRInstruction storeTemp: index)! !!IRBuilder methodsFor: 'instructions' stamp: 'ajh 6/26/2004 13:48'!storeThisEnv	self add: (IRInstruction storeTemp: -1)! !!IRBuilder methodsFor: 'decompiling' stamp: 'ajh 3/21/2003 01:48'!testJumpAheadTarget: label	jumpAheadStacks at: label ifPresent: [:stack |		[stack isEmpty] whileFalse: [self jumpAheadTarget: label]	]! !!IRInterpreter commentStamp: 'ajh 3/24/2003 23:55' prior: 0!I visit each IRInstruction in an IRMethod in order.  Each instruction sends its instruction message to me upon being visited.  See my 'instructions' method category for complete list of instructions.  Subclasses should override them.!!IRDecompiler commentStamp: 'ajh 3/25/2003 00:37' prior: 0!I interpret IRMethod instructions and generate a Smalltalk abstract syntax tree rooted at a RBMethodNode.This is implemented like a shift-reduce parser.  Each instruction either causes a node to be pushed on the stack (shift), or causes one or more nodes to be popped and combined into a single node which is push back on the stack (reduce).  Most reduction is done at the "label: labelNum" instruction where it tries to reduce jump structures into control messages like #ifTrue:, whileFalse:, etc.Several pseudo nodes (RBPseudoNode and subclasses) are used to represent basic instructions that have not been reduced to real AST nodes yet.!!IRDecompiler class methodsFor: 'as yet unclassified' stamp: 'ajh 6/5/2003 12:34'!dummySelector: numArgs	"Answer a dummy selector with number of args"	| sel |	sel _ 'unknown'.	1 to: numArgs do: [:i |		sel _ sel, 'with:'].	^ sel asSymbol! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 3/22/2003 17:03'!Assignment	| node |	(node _ self stackDown) isAssignment ifTrue: [^ node].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'md 11/12/2004 14:06'!Block	| node |	(node := self stackDown) isBlock ifTrue: [^ node].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 3/23/2003 22:34'!Dup	| node |	(node _ self stackDown) isDup ifTrue: [^ node].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 3/22/2003 16:33'!Goto	| node |	(node _ self stackDown) isGoto ifTrue: [^ node].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 3/23/2003 12:57'!Goto: seqNum	| goto |	(goto _ self Goto) destination = seqNum ifTrue: [^ goto].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 3/23/2003 23:17'!GotoOrReturn: seqNum	| goto |	goto _ self Goto.	(goto destination = seqNum or: [goto isRet]) ifTrue: [^ goto].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 3/22/2003 16:33'!If	| node |	(node _ self stackDown) isIf ifTrue: [^ node].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 3/22/2003 17:07'!IfGoto: seqNum otherwise: seqNum2	| if |	((if _ self If) destination = seqNum and: [if otherwise = seqNum2])		ifTrue: [^ if].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 3/22/2003 16:33'!Label	| node |	(node _ self stackDown) isLabel ifTrue: [^ node].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 3/22/2003 16:34'!Label: seqNum	| label |	(label _ self Label) destination = seqNum ifTrue: [^ label].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 3/22/2003 17:36'!Pop	| node |	(node _ self stackDown) isPop ifTrue: [^ node].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 3/23/2003 22:32'!Send	| node |	(node _ self stackDown) isPseudoSend ifTrue: [^ node].	self abort! !!IRDecompiler methodsFor: 'stack' stamp: 'md 11/15/2004 13:56'!Sequence	| node seq i goto |	seq := RBSequenceNode statements: #().	i := sp ifNil: [sp := stack size].	[	node := stack at: i. 		node isSequence ifTrue: [			seq addNodesFirst: node statements.			node := stack at: (i := i - 1).			self halt.		].		"include sequences before fall-through gotos"		(node isLabel and: [i > 1 "not first"]) ifFalse: [			sp := i.			^ seq].		goto := stack at: (i := i - 1).		goto isGoto and: [goto destination = node destination]	] whileTrue: [i := i - 1].	sp := i + 1.  "points to label"	^ seq! !!IRDecompiler methodsFor: 'stack' stamp: 'md 11/15/2004 15:45'!Sequence2	| node seq i |	seq := RBSequenceNode statements: #().	i := sp ifNil: [sp := stack size].	node := stack at: i. 	[(node isLabel not and: [i > 1 "not first"])] whileTrue: [		seq addNodeFirst: node.		i := i - 1.		node := stack at: i. 	].	sp := i.  "points to label"	^ seq! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 3/24/2003 01:08'!SequenceBackTo: labelNum	"Return previous sequence stopping at non-sequence or label: num, whichever comes first"	| node seq i goto |	seq _ RBSequenceNode statements: #().	i _ sp ifNil: [sp _ stack size].	[	node _ stack at: i.		node isSequence ifTrue: [			seq addNodesFirst: node statements.			node _ stack at: (i _ i - 1).		].		"includes sequences back to labelNum"		(node isLabel and: [i > 1 "not first"]) ifFalse: [			sp _ i.			^ seq].		node destination = labelNum ifTrue: [			sp _ i.			^ seq].		goto _ stack at: (i _ i - 1).		goto isGoto and: [goto destination = node destination]	] whileTrue: [i _ i - 1].	sp _ i + 1.  "points to label"	^ seq! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 3/23/2003 21:44'!Value	| node |	node _ self ValueOrNone.	node ifNil: [self abort].	^ node! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 3/23/2003 21:43'!ValueOrNone	| node i label |	i _ sp ifNil: [sp _ stack size].	[	node _ stack at: i.		node isValue ifTrue: [			label ifNotNil: [valueLabelMap at: node put: label].			sp _ i - 1.			^ node].		"test for value before fall-through goto"		(node isLabel and: [i > 1 "not first"]) ifFalse: [^ nil].		label _ node.		node _ stack at: (i _ i - 1).		node isGoto and: [node destination = label destination]	] whileTrue: [i _ i - 1].	^ nil! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 3/24/2003 00:59'!abort	| spWas |	spWas _ sp.	sp _ nil.	Abort signal! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ajh 3/21/2003 00:47'!block: method capturedVars: varNodes	| vars |	vars _ varNodes collect: [:v |		v isVariable ifTrue: [v binding]		  ifFalse: [			(v isMessage and: [v selector = #contextTag and: [v receiver isVariable]])				ifFalse: [self patternError].			v receiver binding]	].	self stackPush: (IRDecompiler new		scope: (scope newBlockScope capturedVars: vars);		decompileIR: method ir)		asBlock! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'md 11/15/2004 17:03'!block: method env: envRefNode	envRefNode ifNotNil: [		envRefNode isVariable ifTrue: [envRefNode binding]		  ifFalse: [			(envRefNode isMessage and: [envRefNode selector = #myEnv and: [envRefNode receiver isVariable]])				ifFalse: [self patternError].			envRefNode receiver binding].	].	self stackPush: (IRDecompiler new		scope: (scope newBlockScope "capturedVars: vars");		decompileIR: method ir)		asBlock! !!IRDecompiler methodsFor: 'old blocks' stamp: 'md 11/15/2004 15:38'!blockReturnTop	self goto: #return.! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ajh 3/24/2003 01:54'!cascade	| messages selector args rcvr |	messages _ OrderedCollection new.	[	"last message"		selector _ self Send selector.		args _ OrderedCollection new.		selector numArgs timesRepeat: [args addFirst: self Value].		messages addFirst: selector -> args.		"rest of messages"		[(rcvr _ self ValueOrNone) isNil] whileTrue: [			self Pop.			selector _ self Send selector.			args _ OrderedCollection new.			selector numArgs timesRepeat: [args addFirst: self Value].			self Dup.			messages addFirst: selector -> args.		].	] on: Abort do: [^ false].	messages _ messages collect: [:assoc |		RBMessageNode			receiver: rcvr			selector: assoc key			arguments: assoc value].	self stackPush: (RBCascadeNode messages: messages).! !!IRDecompiler methodsFor: 'init' stamp: 'md 11/17/2004 14:01'!decompileIR: ir	| sequenceNode temps args goto seq value |	0 to: ir numRargs -1 do: [:i | scope tempVarAt: i].	self interpret: ir.	self label: #return.  "final label to return"	self Label: #return.	goto := self Goto.	value := self ValueOrNone.	seq := self Sequence.	sp = 1 ifFalse: [self error: 'error'].	value ifNotNil: [seq addNode: value].	sequenceNode := (self newBlock: seq return: goto) body.	temps := scope tempVars asArray.	ir tempKeys: temps.	args := (temps first: ir numRargs) allButFirst.	args := args collect: [:var | self newVar: var].	temps := temps allButFirst: ir numRargs.	sequenceNode temporaries: (temps collect: [:var | self newVar: var]).	^ RBMethodNode new		selectorParts: (self newSelectorParts: (self class dummySelector: args size));		arguments: args;		body: sequenceNode;		privIR: ir;		primitiveNode: ir primitiveNode;		scope: scope! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ajh 6/22/2003 14:46'!endAndOr2: seqNum	| goto seq p if2 test else o if1 seqValue elseTest |	[		goto _ self Goto.		seqValue _ self ValueOrNone.		seq _ self Sequence.		p _ self Label destination.		if2 _ self IfGoto: seqNum otherwise: p.		elseTest _ self Value.		else _ self SequenceBackTo: goto destination.		o _ self Label destination.		o = goto destination ifTrue: [self abort].		if1 _ self IfGoto: seqNum otherwise: o.		test _ self Value.	] on: Abort do: [^ false].	if1 boolean = if2 boolean ifFalse: [		test _ RBMessageNode			receiver: test selector: #not arguments: #().	].	self stackPush: (RBMessageNode		receiver: test		selector: (if2 boolean ifTrue: [#or:] ifFalse: [#and:])		arguments: {self newBlock: (else addNode: elseTest) return: nil}).	stack addLast: if2.	self label: p.	stack addLast: seq.	seqValue ifNotNil: [stack addLast: seqValue].	stack addLast: goto.	^ true! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ajh 6/22/2003 14:46'!endAndOr: seqNum	| o test branches if body block sel1 sel2 if2 |	branches _ OrderedCollection new.	[		(if2 _ self If) otherwise = seqNum ifFalse: [self abort].		[	test _ self Value.			body _ self Sequence.			branches add: {body. test}.			o _ self Label destination.			(if _ self If) otherwise = o ifFalse: [self abort].			if destination = seqNum		] whileFalse: [			if boolean = if2 boolean ifFalse: [self abort].			if destination = if2 destination ifFalse: [self abort].		].		if boolean = if2 boolean ifTrue: [self abort].		test _ self Value.	] on: Abort do: [^ false].	if boolean		ifTrue: [sel1 _ #or:. sel2 _ #and:]		ifFalse: [sel1 _ #and:. sel2 _ #or:].	block _ self newBlock: (branches first first addNode: branches first second).	branches allButFirstDo: [:pair |		block _ self newBlock: (pair first addNode: (RBMessageNode				receiver: pair second				selector: sel2				arguments: {block})).	].	self stackPush: (RBMessageNode		receiver: test		selector: sel1		arguments: {block}).	stack addLast: if2.	^ true! !!IRDecompiler methodsFor: 'old blocks' stamp: 'md 11/17/2004 14:09'!endBlock: seqNum		| blockSeq block |	[		self GotoOrReturn: seqNum.		sp = 0 ifTrue: [self abort].		blockSeq := self Sequence2.		self Label.		block := self Block.		self Send.	] on: Abort do: [^ false].	self stackPush: (self newBlock: blockSeq).		stack last arguments: block arguments.	scope := scope outerScope.	self goto: block successor.	^ true! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ajh 3/24/2003 00:07'!endCase: seqNum	| otherwiseGoto goto node otherwiseValue otherwiseSeq n branchValue branchSeq f caseValue caseSeq rcvr branches message |	branches _ OrderedCollection new.	[	"otherwise"		otherwiseGoto _ self GotoOrReturn: seqNum.		node _ self stackDown.		(node isPop or: [node isPseudoSend]) ifTrue: [			node isPop ifTrue: [node _ self Send].			node selector == #caseError ifFalse: [self abort].		] ifFalse: [			sp _ sp + 1.  "stackUp"			otherwiseValue _ self ValueOrNone.			otherwiseSeq _ self Sequence.		].		n _ self Label destination.		"last case branch"		goto _ self GotoOrReturn: seqNum.		branchValue _ self ValueOrNone.		branchSeq _ self Sequence.		f _ self Label destination.		"last case"		self IfGoto: n otherwise: f.		self Send selector == #= ifFalse: [self abort].		caseValue _ self Value.		caseSeq _ self Sequence.		otherwiseSeq ifNil: [self Dup].		branches addFirst: ({caseSeq. caseValue} -> {branchSeq. branchValue. goto}).		[(rcvr _ self ValueOrNone) isNil] whileTrue: [			"case branch"			n _ self Label destination.			goto _ self GotoOrReturn: seqNum.			branchValue _ self ValueOrNone.			branchSeq _ self Sequence.			self Pop.			f _ self Label destination.			"case"			self IfGoto: n otherwise: f.			self Send selector == #= ifFalse: [self abort].			caseValue _ self Value.			caseSeq _ self Sequence.			self Dup.			branches addFirst: ({caseSeq. caseValue} -> {branchSeq. branchValue. goto}).		].	] on: Abort do: [^ false].	branches _ branches collect: [:assoc |		assoc key second			ifNotNil: [assoc key first addNode: assoc key second].		assoc value second			ifNotNil: [assoc value first addNode: assoc value second].		RBMessageNode			receiver: (self newBlock: assoc key first return: nil)			selector: #->			arguments:				{self newBlock: assoc value first return: assoc value third}	].	message _ otherwiseSeq		ifNil: [			RBMessageNode				receiver: rcvr				selector: #caseOf:				arguments: {RBArrayNode statements: branches}]		ifNotNil: [			otherwiseValue				ifNotNil: [otherwiseSeq addNode: otherwiseValue].			RBMessageNode				receiver: rcvr				selector: #caseOf:otherwise:				arguments: 					{RBArrayNode statements: branches.					self newBlock: otherwiseSeq return: otherwiseGoto}.		].	self stackPush: message.	branchValue ifNil: [self popTop].	self goto: seqNum.	^ true! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ajh 3/24/2003 02:39'!endIfNil: seqNum	| goto branch o if rcvr value |	[		goto _ self GotoOrReturn: seqNum.		value _ self Value.		branch _ self Sequence.		self Pop.		o _ self Label destination.		if _ self IfGoto: seqNum otherwise: o.		self Send selector == #== ifFalse: [self abort].		(self Value isLiteral: [:v | v isNil]) ifFalse: [self abort].		self Dup.		rcvr _ self Value.	] on: Abort do: [^ false].	branch addNode: value.	self stackPush: (RBMessageNode		receiver: rcvr		selector: (if boolean ifTrue: [#ifNotNil:] ifFalse: [#ifNil:])		arguments: {self newBlock: branch return: goto}).	self goto: seqNum.	^ true! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'md 11/12/2004 14:59'!endIfThen: seqNum	| goto branch o if test value |	[				goto := self Goto.		(goto destination == seqNum or: [self isExplicitReturn: goto]) ifFalse: [self abort].		goto isRet ifTrue: [value := self Value].		branch := self Sequence.		o := self Label destination.		if := self IfGoto: seqNum otherwise: o.		test := self Value.	] on: Abort do: [^ false].		self halt.		value ifNotNil: [branch addNode: value].	self stackPush: (self simplify: (RBMessageNode		receiver: test		selector: (if boolean ifTrue: [#ifFalse:] ifFalse: [#ifTrue:])		arguments: {self newBlock: branch return: goto})).	self popTop.	self goto: seqNum.	^ true! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'md 11/12/2004 18:16'!endIfThenElse: seqNum	| goto2 else d goto1 then o if test value2 value1 |	[		goto2 := self Goto.		value2 := self ValueOrNone.		else := self Sequence.		d := self Label destination.		goto1 := self Goto.		((self isExplicitReturn: goto2) or: [goto2 destination == goto1 destination]) ifFalse: [self abort].		value1 := self ValueOrNone.		then := self Sequence.		o := self Label destination.		if := self IfGoto: d otherwise: o.		test := self Value.	] on: Abort do: [^ false].	value2 ifNotNil: [else addNode: value2].	value1 ifNotNil: [then addNode: value1].	self stackPush: (self simplify: (else statements isEmpty		ifTrue: [RBMessageNode			receiver: test			selector: (if boolean ifTrue: [#ifFalse:] ifFalse: [#ifTrue:])			arguments: {self newBlock: then return: goto1}]		ifFalse: [RBMessageNode			receiver: test			selector: (if boolean				ifTrue: [#ifFalse:ifTrue:]				ifFalse: [#ifTrue:ifFalse:])			arguments: {				self newBlock: then return: goto1.				self newBlock: else return: goto2}])).	value1 ifNil: [self popTop].	self goto: goto1 destination.	(else statements isEmpty and:	 [stack anySatisfy: [:n | n isIf and: [n destination = d]]]	) ifTrue: [		self label: d.		self goto: goto2 destination.	].	^ true! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ajh 3/24/2003 02:04'!endToDo: seqNum	| start limit incr iter step loopBlock o if test limitExpr init |	[		start _ self Goto destination.		limit _ self Value.		incr _ self Assignment.		iter _ incr variable.		(incr value isMessage and:		 [incr value selector == #+ and:		  [incr value receiver isVariable and: 		   [incr value receiver binding == iter binding]]]		) ifFalse: [self abort].		step _ incr value arguments first.		loopBlock _ self Sequence.		o _ self Label destination.		if _ self IfGoto: seqNum otherwise: o.		test _ self Value.		(test isMessage and:		 [(test selector == #<= or: [test selector == #>=]) and:		  [(valueLabelMap at: test arguments first ifAbsent: [self abort]) destination = start]]		) ifFalse: [self abort].		limitExpr _ test arguments first.		limitExpr isAssignment ifTrue: [			limitExpr variable binding == limit binding ifFalse: [self abort].			limitExpr _ limitExpr value.		].		init _ test receiver.		(init isAssignment and: [init variable binding == iter binding])			ifFalse: [self abort].	] on: Abort do: [^ false].	loopBlock _ self newBlock: loopBlock return: nil.	loopBlock arguments: {iter}.	self stackPush: ((step isLiteral: [:c | c = 1])		ifTrue: [RBMessageNode				receiver: init value				selector: #to:do:				arguments: {limitExpr. loopBlock}]		ifFalse: [RBMessageNode				receiver: init value				selector: #to:by:do:				arguments: {limitExpr. step. loopBlock}]).	self popTop.	self goto: seqNum.	^ true! !!IRDecompiler methodsFor: 'priv instructions' stamp: 'ajh 3/24/2003 02:18'!endWhile: seqNum	| start loopBlock if test sequence o |	[		start _ self Goto destination.		loopBlock _ self Sequence.		o _ self Label destination.		if _ self IfGoto: seqNum otherwise: o.		test _ self Value.		sequence _ self SequenceBackTo: start.		self Label: start.		sp _ sp + 1.  "stackUp"	] on: Abort do: [^ false].	self stackPush: (self simplify: (RBMessageNode		receiver: (self newBlock: (sequence addNode: test) return: nil)		selector: (if boolean ifTrue: [#whileFalse:] ifFalse: [#whileTrue:])		arguments: {self newBlock: loopBlock return: nil})).	self popTop.	self goto: seqNum.	^ true! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 6/22/2003 14:41'!fixStack	sp ifNotNil: [stack removeLast: (stack size - sp)].	sp _ nil.! !!IRDecompiler methodsFor: 'instructions' stamp: 'ajh 3/23/2003 12:47'!goto: seqNum	self stackPush: (RBPseudoGotoNode new destination: seqNum).! !!IRDecompiler methodsFor: 'instructions' stamp: 'ajh 3/20/2003 17:21'!if: bool goto: seqNum1 otherwise: seqNum2	self stackPush: (RBPseudoIfNode new		boolean: bool;		destination: seqNum1;		otherwise: seqNum2)! !!IRDecompiler methodsFor: 'private' stamp: 'ajh 3/23/2003 21:17'!initialize	stack _ OrderedCollection new.	scope _ nil parseScope newMethodScope.  "in case never set"	valueLabelMap _ IdentityDictionary new.! !!IRDecompiler methodsFor: 'interpret' stamp: 'ajh 3/13/2003 13:48'!interpretInstruction: irInstruction	currentInstr _ irInstruction.	super interpretInstruction: irInstruction.! !!IRDecompiler methodsFor: 'interpret' stamp: 'ajh 3/20/2003 23:37'!interpretSequence: instructionSequence	super interpretSequence: instructionSequence.	currentInstr _ nil.! !!IRDecompiler methodsFor: 'private' stamp: 'ajh 3/22/2003 11:03'!isExplicitReturn: goto	^ goto isRet and:	  [goto mapInstr notNil and:	   [goto mapInstr isRemote or: [scope isBlockScope not]]]! !!IRDecompiler methodsFor: 'old blocks' stamp: 'md 11/17/2004 14:30'!jumpOverBlock: seqNum1  to: seqNum2	| numArgs args oldscope |	oldscope := scope.	self scope: (scope newBlockScope).	args := OrderedCollection new.	numArgs := stack last arguments first value.	numArgs timesRepeat: [ | var instr |		instr :=  currentInstr blockSequence removeFirst. 		var := oldscope tempVarAt: instr number.		args add: (self newVar: var).		currentInstr blockSequence removeFirst.		oldscope removeTemp: var.		scope addTemp: var.	].		self stackPush: (RBPseudoBlockNode new		block: seqNum1;		successor: seqNum2;		arguments: args).		! !!IRDecompiler methodsFor: 'instructions' stamp: 'md 11/12/2004 15:16'!label: seqNum	stack isEmpty ifTrue: [  "start"		^ stack addLast: (RBPseudoLabelNode new destination: seqNum)].	"Reduce jump structures to one of the following if possible"	[	(self endIfNil: seqNum) or: [		 (self endAndOr: seqNum) or: [		  (self endAndOr2: seqNum) or: [		   (self endIfThen: seqNum) or: [		    (self endIfThenElse: seqNum) or: [		     (self endCase: seqNum) or: [		      (self endToDo: seqNum) or: [		       (self endWhile: seqNum) or: [			   (self endBlock: seqNum)]]]]]]]]	] whileTrue.	stack addLast: (RBPseudoLabelNode new destination: seqNum).! !!IRDecompiler methodsFor: 'private' stamp: 'ajh 3/20/2003 23:21'!mapNode: node	currentInstr ifNil: [^ self].	node isPseudo		ifTrue: [node mapInstr: currentInstr]		ifFalse: [currentInstr sourceNode: node]! !!IRDecompiler methodsFor: 'private' stamp: 'ajh 3/24/2003 12:07'!newBlock: sequence	^ self newBlock: sequence return: nil! !!IRDecompiler methodsFor: 'private' stamp: 'ajh 3/24/2003 01:24'!newBlock: sequence return: goto	| statements ret |	statements _ sequence statements.	(goto notNil and: [self isExplicitReturn: goto]) ifTrue: [		ret _ RBReturnNode value: statements last.		goto mapInstr sourceNode: ret.		statements atLast: 1 put: ret.	].	sequence statements: statements.	^ RBBlockNode body: sequence! !!IRDecompiler methodsFor: 'private' stamp: 'ajh 3/13/2003 14:10'!newSelectorParts: selector	^ selector keywords collect: [:word |		SmaCCToken value: word]! !!IRDecompiler methodsFor: 'private' stamp: 'md 11/16/2004 15:24'!newVar: semVar	^ RBVariableNode new		identifierToken: (SmaCCToken value: semVar name);		binding: semVar! !!IRDecompiler methodsFor: 'instructions' stamp: 'ajh 6/22/2003 21:05'!popTop	| value |	stack last ifNil: [^ stack removeLast].  "pop no-op from #simplifyTempAssign:"	stack last isValue ifTrue: [		(stack atLast: 2) isSequence ifTrue: [			value _ stack removeLast.			^ stack last addNode: value.		] ifFalse: [(stack atLast: 2) isPseudo ifTrue: [			value _ stack removeLast.			^ stack addLast: (RBSequenceNode statements: {value}).		]].	].	stack addLast: RBPseudoPopNode new! !!IRDecompiler methodsFor: 'instructions' stamp: 'ajh 6/27/2004 21:35'!pushBlock: irMethod	self block: irMethod env: nil! !!IRDecompiler methodsFor: 'instructions' stamp: 'ajh 6/27/2004 21:37'!pushBlockMethod: irMethod	"block will recognized when send: #createBlock:"	self pushLiteral: irMethod! !!IRDecompiler methodsFor: 'instructions' stamp: 'ajh 6/22/2003 14:51'!pushDup	stack addLast: RBPseudoDupNode new! !!IRDecompiler methodsFor: 'instructions' stamp: 'ajh 6/27/2004 21:36'!pushLiteral: object	self stackPush: (RBLiteralNode		literalToken: (SmaCCToken value: object name)		value: object).! !!IRDecompiler methodsFor: 'instructions' stamp: 'md 11/16/2004 13:55'!pushTemp: tempIndex	| var |	var := scope tempVarAt: tempIndex.	self stackPush: (self newVar: var).! !!IRDecompiler methodsFor: 'instructions' stamp: 'ajh 6/22/2003 14:27'!remoteReturn	stack removeLast.  "pop home context free var"	self goto: #return.! !!IRDecompiler methodsFor: 'instructions' stamp: 'md 11/12/2004 18:00'!returnTop	self goto: #return.! !!IRDecompiler methodsFor: 'init' stamp: 'ajh 6/27/2004 15:14'!scope: aLexicalScope	scope _ aLexicalScope! !!IRDecompiler methodsFor: 'instructions' stamp: 'md 11/15/2004 18:05'!send: selector	| args rcvr |	args := OrderedCollection new.	[	selector numArgs timesRepeat: [args addFirst: self Value].		rcvr := self Value.	] on: Abort do: [		self stackPush: (RBPseudoSendNode new selector: selector).		^ self cascade	].	Preferences compileBlocksAsClosures 			ifTrue: [ (rcvr isLiteral and: [selector = #createBlock:]) ifTrue: [					 ^ self block: rcvr value env: args first]]			ifFalse: [ (selector = #blockCopy:) ifTrue: [					 ^ self stackPush: (RBPseudoSendNode new selector: selector; arguments: args)]].	self stackPush: (self simplify: (RBMessageNode new		receiver: rcvr		selectorParts: (self newSelectorParts: selector)		arguments: args)).! !!IRDecompiler methodsFor: 'instructions' stamp: 'ajh 3/24/2003 00:45'!send: selector toSuperOf: behavior	| args rcvr |	args _ OrderedCollection new.	selector numArgs timesRepeat: [args addFirst: self Value].	rcvr _ self Value.	(rcvr isVariable and: [rcvr name = 'self']) ifFalse: [self patternError].	rcvr identifierToken: (SmaCCToken value: 'super').	self stackPush: (RBMessageNode new		receiver: rcvr		selectorParts: (self newSelectorParts: selector)		arguments: args).! !!IRDecompiler methodsFor: 'private' stamp: 'md 6/14/2005 15:03'!simplify: mess	"mess is a messageNode.  If it is a message created by the compiler convert it back to its normal form"	| rcvr sc |	(mess selector == #value and: [mess receiver isLiteral]) ifTrue: [		^ self newVar: (GlobalVar new assoc: mess receiver value; scope: scope)	].	(mess selector = #privSetInHolder: and: [mess arguments first isLiteral]) ifTrue: [		^ RBAssignmentNode			variable: (self newVar: (GlobalVar new assoc: mess arguments first value; scope: scope))			value: mess receiver	].	(mess selector = #privGetInstVar: and:	 [mess arguments first isLiteral and:	  [mess receiver isVariable]]) ifTrue: [		rcvr _ mess receiver binding.		rcvr == scope receiverVar ifTrue: [			^ self newVar: (scope receiverVarAt: mess arguments first value)].		(rcvr isFieldVar and: [rcvr originalTempVar notNil]) ifTrue: [			sc _ rcvr originalTempVar scope.			rcvr = scope receiverVar ifTrue: [				^ self newVar: (sc receiverVarAt: mess arguments first value)]].	].	(mess selector = #privStoreIn:instVar: and:	 [mess arguments last isLiteral and:	  [mess arguments first isVariable]]) ifTrue: [		rcvr _ mess arguments first binding.		rcvr == scope receiverVar ifTrue: [			^ RBAssignmentNode				variable: (self newVar: (scope receiverVarAt: mess arguments last value))				value: mess receiver		].		(rcvr isFieldVar and: [rcvr originalTempVar notNil]) ifTrue: [			sc _ rcvr originalTempVar scope.			rcvr = scope receiverVar ifTrue: [				^ RBAssignmentNode					variable: (self newVar: (sc receiverVarAt: mess arguments last value))					value: mess receiver]		].	].	(mess selector = #tempHolderValue and: [mess receiver isVariable]) ifTrue: [		^ mess receiver	].	(mess selector = #storeInTempHolder: and: [mess arguments first isVariable]) ifTrue: [		^ RBAssignmentNode			variable: mess arguments first			value: mess receiver	].	^ mess! !!IRDecompiler methodsFor: 'private' stamp: 'ajh 3/24/2003 16:01'!simplifyTempAssign: assignment	"If it is a assignment created by the compiler convert it back to its normal form"	| mess |	((mess _ assignment value) isMessage and: 	 [mess selector = #wrapInTempHolder and:	  [mess receiver isLiteral: [:v | v isNil]]]	) ifTrue: [		^ nil  "no-op"	].	^ assignment! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 3/22/2003 19:24'!stackDown	| node |	sp ifNil: [sp _ stack size].	sp = 0 ifTrue: [self abort].	node _ stack at: sp.	sp _ sp - 1.	^ node! !!IRDecompiler methodsFor: 'stack' stamp: 'ajh 6/22/2003 14:51'!stackPush: node	self fixStack.	stack addLast: node.	node ifNil: [^ self].  "no op"	self mapNode: node.! !!IRDecompiler methodsFor: 'instructions' stamp: 'ajh 3/24/2003 15:55'!storeTemp: tempIndex	| var |	var _ scope tempVarAt: tempIndex.	self stackPush: (self simplifyTempAssign:		(RBAssignmentNode variable: (self newVar: var) value: self Value)).! !!IRInterpreter methodsFor: 'instructions' stamp: 'md 8/12/2005 13:30'!blockReturnTop! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 13:26'!goto: seqNum! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 13:26'!if: bool goto: seqNum1 otherwise: seqNum2! !!IRInterpreter methodsFor: 'interpret' stamp: 'ajh 3/9/2003 12:33'!interpret: ir	self interpretAll: ir allSequences! !!IRInterpreter methodsFor: 'interpret' stamp: 'ajh 3/10/2003 23:30'!interpretAll: irSequences	irSequences do: [:seq | self interpretSequence: seq]! !!IRInterpreter methodsFor: 'interpret' stamp: 'ajh 3/6/2003 15:31'!interpretInstruction: irInstruction	irInstruction executeOn: self! !!IRInterpreter methodsFor: 'interpret' stamp: 'ajh 3/9/2003 13:20'!interpretSequence: instructionSequence	self label: instructionSequence orderNumber.	instructionSequence do: [:instr | self interpretInstruction: instr].! !!IRInterpreter methodsFor: 'instructions' stamp: 'md 7/29/2005 10:44'!jumpOverBlock: blockSeq to: dest! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 13:25'!label: seqNum! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 14:11'!popTop! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 6/27/2004 21:34'!pushBlock: irMethod! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 6/27/2004 21:26'!pushBlockMethod: irMethod! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 14:12'!pushDup! !!IRInterpreter methodsFor: 'instructions' stamp: 'md 10/10/2005 17:38'!pushInstVar: aSmallInteger ! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/2/2003 16:08'!pushLiteral: object! !!IRInterpreter methodsFor: 'instructions' stamp: 'md 7/7/2005 14:17'!pushLiteralVariable: object! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/2/2003 16:09'!pushTemp: index! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/2/2003 16:10'!remoteReturn! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/2/2003 16:08'!returnTop! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/2/2003 16:11'!send: selector! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/2/2003 16:11'!send: selector toSuperOf: behavior! !!IRInterpreter methodsFor: 'instructions' stamp: 'md 7/7/2005 14:17'!storeLiteralVariable: index! !!IRInterpreter methodsFor: 'instructions' stamp: 'ajh 3/2/2003 16:11'!storeTemp: index! !!IRPrinter commentStamp: 'ajh 3/25/2003 00:22' prior: 0!I interpret IRMethod instructions and write them out to a print stream.!!IRPrinter methodsFor: 'instructions' stamp: 'md 8/9/2005 17:08'!blockReturnTop	stream nextPutAll: 'blockReturnTop'.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 15:41'!goto: seqNum	stream nextPutAll: 'goto: '.	seqNum printOn: stream.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 15:42'!if: bool goto: seqNum1 otherwise: seqNum2	stream nextPutAll: 'if: '.	bool printOn: stream.	stream nextPutAll: ' goto: '.	seqNum1 printOn: stream.	stream nextPutAll: ' else: '.	seqNum2 printOn: stream.! !!IRPrinter methodsFor: 'initialize' stamp: 'ajh 3/9/2003 15:49'!indent: tabs	indent _ tabs! !!IRPrinter methodsFor: 'interpret' stamp: 'ajh 3/9/2003 15:48'!interpretInstruction: irInstruction	indent timesRepeat: [stream tab].	super interpretInstruction: irInstruction.	stream cr.! !!IRPrinter methodsFor: 'instructions' stamp: 'md 8/10/2005 11:23'!jumpOverBlock: blockSeq to: dest	stream nextPutAll: 'jumpOverBlock: '.	stream nextPutAll: ' block '.	blockSeq  printOn: stream.	stream nextPutAll: ' cont: '.	dest  printOn: stream.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/11/2003 00:36'!label: seqNum	"add tab and cr since this does not get called within interpretInstruction:"	stream cr.  "extra cr just to space out sequences"	indent timesRepeat: [stream tab].	stream nextPutAll: 'label: '.	seqNum printOn: stream.	stream cr.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 15:42'!popTop	stream nextPutAll: 'popTop'! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 6/27/2004 21:44'!pushBlock: irMethod	stream nextPutAll: 'pushBlock:'.	IRPrinter new		indent: indent + 1;		stream: stream;		interpret: irMethod removeEmptyStart.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 6/27/2004 21:44'!pushBlockMethod: irMethod	stream nextPutAll: 'pushBlockMethod:'.	IRPrinter new		indent: indent + 1;		stream: stream;		interpret: irMethod removeEmptyStart.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 15:42'!pushDup	stream nextPutAll: 'pushDup'! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/21/2003 01:49'!pushLiteral: object	stream nextPutAll: 'pushLiteral: '.	object isVariableBinding ifTrue: [^ stream nextPutAll: object key].	object printOn: stream.	((object isKindOf: BlockClosure) or: [object isKindOf: CompiledMethod])		ifTrue: [			IRPrinter new				indent: indent + 1;				stream: stream;				interpret: object method ir removeEmptyStart].! !!IRPrinter methodsFor: 'instructions' stamp: 'md 8/10/2005 11:28'!pushLiteralVariable: object	stream nextPutAll: 'pushLiteralVariable: '.	object isVariableBinding ifTrue: [^ stream nextPutAll: object key].	object printOn: stream.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 6/26/2004 18:37'!pushTemp: index	stream nextPutAll: 'pushTemp: '.	index printOn: stream.	index = 0 ifTrue: [stream nextPutAll: ' "receiver"'].	index = -1 ifTrue: [stream nextPutAll: ' "thisEnv"'].	index = -2 ifTrue: [stream nextPutAll: ' "thisContext"'].! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 15:43'!remoteReturn	stream nextPutAll: 'remoteReturn'.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 15:43'!returnTop	stream nextPutAll: 'returnTop'.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 15:44'!send: selector	stream nextPutAll: 'send: '.	selector printOn: stream.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 3/9/2003 15:44'!send: selector toSuperOf: behavior	stream nextPutAll: 'send: '.	selector printOn: stream.	stream nextPutAll: ' toSuperOf: '.	behavior printOn: stream.! !!IRPrinter methodsFor: 'instructions' stamp: 'ajh 6/26/2004 23:15'!storeTemp: index	stream nextPutAll: 'storeTemp: '.	index printOn: stream.	index = -1 ifTrue: [stream nextPutAll: ' "thisEnv"'].! !!IRPrinter methodsFor: 'initialize' stamp: 'ajh 3/9/2003 15:50'!stream: stringWriteStream	stream _ stringWriteStream! !!IRTranslator commentStamp: 'ajh 3/25/2003 00:26' prior: 0!I interpret IRMethod instructions, sending the appropriate bytecode messages to my BytecodeGenerator (gen).  I hold some messages back in pending awaiting certain sequences of them that can be consolidated into single bytecode instructions, otherwise the pending messages are executed in order as if they were executed when they first appeared.!!IRTranslator methodsFor: 'instructions' stamp: 'md 4/23/2005 17:15'!addLiteral: literal	gen addLiteral: literal.! !!IRTranslator methodsFor: 'priv pending' stamp: 'ajh 6/22/2003 14:54'!addPending: message	pending addLast: currentInstr -> message! !!IRTranslator methodsFor: 'instructions' stamp: 'md 10/8/2004 16:07'!blockReturnTop	self doPending.	gen blockReturnTop.! !!IRTranslator methodsFor: 'results' stamp: 'ajh 6/28/2004 11:23'!compiledMethod	^ gen compiledMethodWith: trailerBytes! !!IRTranslator methodsFor: 'results' stamp: 'pmm 8/16/2006 20:55'!compiledMethodUsing: aCompiledMethodClass	^ gen compiledMethodWith: trailerBytes using: aCompiledMethodClass! !!IRTranslator methodsFor: 'results' stamp: 'ajh 3/13/2003 18:28'!compiledMethodWith: trailer	^ gen compiledMethodWith: trailer! !!IRTranslator methodsFor: 'results' stamp: 'pmm 8/16/2006 20:52'!compiledMethodWith: trailer using: aCompiledMethodClass	^ gen compiledMethodWith: trailer using: aCompiledMethodClass! !!IRTranslator methodsFor: 'priv pending' stamp: 'ajh 3/13/2003 04:49'!doPending	"execute pending instructions"	| assoc |	[pending isEmpty] whileFalse: [		assoc _ pending removeFirst.		gen mapBytesTo: assoc key "instr".		assoc value "message" sendTo: gen.	].	gen mapBytesTo: currentInstr.! !!IRTranslator methodsFor: 'instructions' stamp: 'ajh 3/9/2003 22:09'!goto: seqNum	self doPending.	gen goto: seqNum.! !!IRTranslator methodsFor: 'instructions' stamp: 'ajh 3/9/2003 22:09'!if: bool goto: seqNum1 otherwise: seqNum2	self doPending.	gen if: bool goto: seqNum1 otherwise: seqNum2.! !!IRTranslator methodsFor: 'initialize' stamp: 'ajh 6/28/2004 11:27'!initialize	gen _ BytecodeGenerator new.	trailerBytes _ #(0).! !!IRTranslator methodsFor: 'interpret' stamp: 'md 7/11/2005 22:23'!interpret: ir	ir optimize.	gen primitiveNode: ir primitiveNode.	gen numArgs: ir numArgs.	gen properties: ir properties.	ir additionalLiterals do: [:lit | gen addLiteral: lit].	super interpret: ir.! !!IRTranslator methodsFor: 'interpret' stamp: 'ajh 3/13/2003 18:07'!interpretAll: irSequences	irSequences withIndexDo: [:seq :i | seq orderNumber: i].	super interpretAll: irSequences.! !!IRTranslator methodsFor: 'interpret' stamp: 'ajh 3/13/2003 04:50'!interpretInstruction: irInstruction	currentInstr _ irInstruction.	super interpretInstruction: irInstruction.! !!IRTranslator methodsFor: 'instructions' stamp: 'md 10/27/2004 17:00'!jumpOverBlock:  blockNum to: seqNum	self doPending.	gen jumpOverBlock: seqNum.! !!IRTranslator methodsFor: 'instructions' stamp: 'ajh 3/9/2003 22:10'!label: seqNum	pending _ OrderedCollection new.	gen label: seqNum.! !!IRTranslator methodsFor: 'priv pending' stamp: 'ajh 6/5/2003 12:41'!pendingMatches: blocks	"Return true if each message at end of pending list satisfies its corresponding block.  The number of elements tested equals the number of blocks.  If not enough elements return false"	| messages i |	messages _ pending collect: [:assoc | assoc value].	blocks size > messages size ifTrue: [^ false].	i _ messages size - blocks size.	blocks do: [:b |		(b value: (messages at: (i _ i + 1))) ifFalse: [^ false].	].	^ true! !!IRTranslator methodsFor: 'priv pending' stamp: 'ajh 6/22/2003 21:06'!pendingSelector	pending isEmpty ifTrue: [^ nil].	^ pending last value "message" selector! !!IRTranslator methodsFor: 'priv pending' stamp: 'ajh 6/22/2003 21:06'!pendingSelector: selector	pending last value "message" setSelector: selector! !!IRTranslator methodsFor: 'priv pending' stamp: 'ajh 6/22/2003 14:27'!popPending	^ pending removeLast value "message"! !!IRTranslator methodsFor: 'instructions' stamp: 'ajh 3/9/2003 22:35'!popTop	"if last was storeTemp or storeInstVar then convert to storePopTemp or storePopInstVar"	#storeTemp: == self pendingSelector ifTrue: [		^ self pendingSelector: #storePopTemp:].	#storeInstVar: == self pendingSelector ifTrue: [		^ self pendingSelector: #storePopInstVar:].	"otherwise do normal pop"	self doPending.	gen popTop.! !!IRTranslator methodsFor: 'instructions' stamp: 'ajh 6/28/2004 11:20'!pushBlock: irMethod	| meth block |	meth _ irMethod compiledMethodWith: trailerBytes.	meth isBlockMethod: true.	block _ meth createBlock: nil.	self addPending: (Message selector: #pushLiteral: argument: block)! !!IRTranslator methodsFor: 'instructions' stamp: 'ajh 6/28/2004 11:20'!pushBlockMethod: irMethod	| meth |	meth _ irMethod compiledMethodWith: trailerBytes.	meth isBlockMethod: true.	self addPending: (Message selector: #pushLiteral: argument: meth)! !!IRTranslator methodsFor: 'instructions' stamp: 'ajh 3/9/2003 22:10'!pushDup	self doPending.	gen pushDup.! !!IRTranslator methodsFor: 'instructions' stamp: 'md 7/19/2005 23:21'!pushInstVar: index	"self doPending.	gen pushInstVar: index."	self addPending: (Message selector: #pushInstVar: argument: index)! !!IRTranslator methodsFor: 'instructions' stamp: 'md 7/5/2005 16:10'!pushLiteral: object	self addPending: (Message selector: #pushLiteral: argument: object)! !!IRTranslator methodsFor: 'instructions' stamp: 'md 7/5/2005 16:10'!pushLiteralVariable: object	self addPending: (Message selector: #pushLiteralVariable: argument: object)! !!IRTranslator methodsFor: 'instructions' stamp: 'md 6/14/2005 15:02'!pushTemp: index	index = 0 ifTrue: [^ self addPending: (Message selector: #pushReceiver)].	(self pendingMatches: {		[:m | m selector == #storePopTemp: and: [m argument = index]]}		) ifTrue: [^ self pendingSelector: #storeTemp:].	self doPending.	index = -2 ifTrue: [^ gen pushThisContext].	index = -1 ifTrue: [		^ gen pushThisContext;			pushLiteral: MethodContext myEnvFieldIndex;			send: #privGetInstVar:].	gen pushTemp: index.! !!IRTranslator methodsFor: 'instructions' stamp: 'ajh 3/9/2003 22:12'!remoteReturn	self doPending.	gen remoteReturn.! !!IRTranslator methodsFor: 'instructions' stamp: 'md 7/19/2005 23:30'!returnTop	#pushReceiver == self pendingSelector ifTrue: [		self pendingSelector: #returnReceiver.		^ self doPending	].	#pushLiteral: == self pendingSelector ifTrue: [		self pendingSelector: #returnConstant:.		^ self doPending	].	#pushInstVar: == self pendingSelector ifTrue: [		self pendingSelector: #returnInstVar:.		^ self doPending	].	self doPending.	gen returnTop.! !!IRTranslator methodsFor: 'instructions' stamp: 'md 6/14/2005 15:04'!send: selector	"If get/set inst var, access it directly"	| index |		((#(privGetInstVar: #privStoreIn:instVar:) identityIncludes: selector) and:	 [self pendingMatches: {		[:m | m selector == #pushReceiver].		[:m | m selector == #pushLiteral: and: [m argument isInteger]]}]	) ifTrue: [		index _ self popPending argument.		self popPending.  "pop pushReceiver"		self addPending: (Message			selector: (selector == #privGetInstVar:				ifTrue: [#pushInstVar:] ifFalse: [#storeInstVar:])			argument: index).		(self pendingMatches: {			[:m | m selector == #storePopInstVar: and: [m argument = index]].			[:m | m selector == #pushInstVar: and: [m argument = index]]}		) ifTrue: [			self popPending.			self pendingSelector: #storeInstVar:.		].		^ self	].	"otherwise do normal send"	self doPending.	gen send: selector.! !!IRTranslator methodsFor: 'instructions' stamp: 'ajh 3/9/2003 22:14'!send: selector toSuperOf: behavior	self doPending.	gen send: selector toSuperOf: behavior.! !!IRTranslator methodsFor: 'instructions' stamp: 'md 11/10/2004 15:43'!storeInstVar: index	self doPending.	gen storeInstVar: index.! !!IRTranslator methodsFor: 'instructions' stamp: 'md 7/7/2005 14:16'!storeIntoLiteralVariable: assoc	self doPending.	gen storeIntoLiteralVariable: assoc.! !!IRTranslator methodsFor: 'instructions' stamp: 'md 6/14/2005 15:04'!storeTemp: index	index = -1 "thisEnv" ifTrue: [		self doPending.		^ gen pushThisContext;			pushLiteral: MethodContext myEnvFieldIndex;			send: #privStoreIn:instVar:].	self addPending: (Message selector: #storeTemp: argument: index)! !!IRTranslator methodsFor: 'initialize' stamp: 'ajh 6/28/2004 11:23'!trailer: bytes	trailerBytes _ bytes! !!IRMethod commentStamp: 'ajh 5/23/2003 11:08' prior: 0!I am a method in the IR (intermediate representation) language consisting of IRInstructions grouped by IRSequence (basic block).  The IRSequences form a control graph (therefore I only have to hold onto the starting sequence).  #compiledMethod will convert me to a CompiledMethod.  #methodNode will convert me back to a parse tree.!!IRMethod methodsFor: 'optimizing' stamp: 'ajh 3/10/2003 15:45'!absorbConstantConditionalJumps	startSequence absorbConstantConditionalJumps: IdentitySet new! !!IRMethod methodsFor: 'optimizing' stamp: 'ajh 3/10/2003 15:45'!absorbJumpsToSingleInstrs	startSequence absorbJumpToSingleInstr: IdentitySet new! !!IRMethod methodsFor: 'inlining' stamp: 'md 9/11/2005 18:52'!addInstructionsAfter: aCollection	| returningSeqs  lastInstr |	aCollection ifEmpty: [^self].	returningSeqs := self allSequences select: [:each | each last isReturn].	lastInstr := returningSeqs last last.	lastInstr addInstructionsBefore: aCollection.	! !!IRMethod methodsFor: 'inlining' stamp: 'md 7/14/2005 12:31'!addInstructionsBefore: aCollection	(self startSequence nextSequence first) addInstructionsBefore: aCollection.	! !!IRMethod methodsFor: 'accessing' stamp: 'md 7/11/2005 22:19'!addLiteral: aSymbol		additionalLiterals add: aSymbol.! !!IRMethod methodsFor: 'accessing' stamp: 'md 7/12/2005 00:21'!addLiterals: anArray		additionalLiterals addAll: anArray.! !!IRMethod methodsFor: 'accessing' stamp: 'md 7/10/2005 15:41'!addTemps: newKeys		tempKeys addAll: newKeys.! !!IRMethod methodsFor: 'accessing' stamp: 'md 7/11/2005 22:19'!additionalLiterals	^additionalLiterals.! !!IRMethod methodsFor: 'accessing' stamp: 'md 6/10/2005 16:07'!allInstructions	" return irNodes as a flat collection "	| irInstructions |	irInstructions := OrderedCollection new.	startSequence withAllSuccessorsDo: [:seq | seq do: [:bc | irInstructions add: bc]].	^irInstructions! !!IRMethod methodsFor: 'accessing' stamp: 'md 6/13/2005 10:41'!allInstructionsMatching: aBlock	" return irNodes as a flat collection "	| irInstructions |	irInstructions := OrderedCollection new.	startSequence withAllSuccessorsDo: [:seq | seq do: [:bc | (aBlock value: bc) ifTrue: [irInstructions add: bc]]].	^irInstructions! !!IRMethod methodsFor: 'accessing' stamp: 'md 6/13/2005 10:40'!allSendInstructions	^self allInstructionsMatching: [:bc | bc isSend].! !!IRMethod methodsFor: 'accessing' stamp: 'ajh 3/9/2003 15:35'!allSequences	^ startSequence withAllSuccessors! !!IRMethod methodsFor: 'accessing' stamp: 'md 6/13/2005 11:06'!allTempAccessInstructions	^self allInstructionsMatching: [:bc | bc isTempAccess].! !!IRMethod methodsFor: 'accessing' stamp: 'md 6/13/2005 10:39'!allTempReadInstructions	^self allInstructionsMatching: [:bc | bc isTempRead].! !!IRMethod methodsFor: 'accessing' stamp: 'md 6/13/2005 10:40'!allTempWriteInstructions	^self allInstructionsMatching: [:bc | bc isTempStore].! !!IRMethod methodsFor: 'decompiling' stamp: 'ajh 6/28/2004 13:44'!ast	^ IRDecompiler new decompileIR: self! !!IRMethod methodsFor: 'translating' stamp: 'pmm 8/25/2006 15:02'!compiledMethod	^ compiledMethod ifNil: [self compiledMethodWith: #(0 0 0 0)]! !!IRMethod methodsFor: 'translating' stamp: 'pmm 8/16/2006 20:56'!compiledMethodWith: trailer	^self compiledMethodWith: trailer using: CompiledMethod! !!IRMethod methodsFor: 'translating' stamp: 'pmm 8/16/2006 20:55'!compiledMethodWith: trailer using: aCompiledMethodClass	^ compiledMethod _ IRTranslator new		trailer: trailer;		interpret: self;		compiledMethodUsing: aCompiledMethodClass! !!IRMethod methodsFor: 'initialize' stamp: 'md 11/22/2005 17:59'!initialize	primitiveNode _ PrimitiveNode null.	tempKeys _ OrderedCollection new.	properties _ MethodProperties new. 	additionalLiterals _ OrderedCollection new.! !!IRMethod methodsFor: 'accessing' stamp: 'md 11/15/2004 17:08'!ir	^self.! !!IRMethod methodsFor: 'testing' stamp: 'md 6/21/2005 13:56'!isSend	^false.! !!IRMethod methodsFor: 'printing' stamp: 'ajh 3/9/2003 15:53'!longPrintOn: stream	IRPrinter new		indent: 0;		stream: stream;		interpret: self! !!IRMethod methodsFor: 'optimizing' stamp: 'md 8/10/2005 11:45'!maxOrderNumber	maxOrderNumber ifNil: [		maxOrderNumber := self startSequence orderNumber.		self startSequence withAllSuccessorsDo: [:seq | maxOrderNumber := maxOrderNumber max: seq orderNumber].				].	^ maxOrderNumber.! !!IRMethod methodsFor: 'accessing' stamp: 'md 6/16/2005 15:02'!method	^self.! !!IRMethod methodsFor: 'inlining' stamp: 'md 8/2/2005 15:07'!methodForInlining	^self removeReturnSelf removeEmptyStart.! !!IRMethod methodsFor: 'optimizing' stamp: 'md 9/26/2005 13:09'!newSeq	maxOrderNumber _ self maxOrderNumber  +1.	^ IRSequence new  orderNumber:maxOrderNumber! !!IRMethod methodsFor: 'accessing' stamp: 'ajh 6/25/2004 10:53'!numArgs	^ self numRargs - 1! !!IRMethod methodsFor: 'accessing' stamp: 'ajh 6/25/2004 10:53'!numRargs	^ numRargs! !!IRMethod methodsFor: 'initialize' stamp: 'ajh 6/25/2004 10:53'!numRargs: n	numRargs _ n! !!IRMethod methodsFor: 'optimizing' stamp: 'ajh 3/18/2003 19:05'!optimize	self removeEmptyStart.	self absorbJumpsToSingleInstrs.  "do before next to get in right form"	self absorbConstantConditionalJumps.	self absorbJumpsToSingleInstrs.  "do again since new opportunities may have arised after last step" ! !!IRMethod methodsFor: 'accessing' stamp: 'ajh 3/10/2003 18:10'!primitiveNode	^ primitiveNode! !!IRMethod methodsFor: 'initialize' stamp: 'ajh 3/10/2003 23:08'!primitiveNode: aPrimitiveNode	primitiveNode _ aPrimitiveNode! !!IRMethod methodsFor: 'translating' stamp: 'ajh 3/10/2003 15:54'!privCompiledMethod: aCompiledMethod	compiledMethod _ aCompiledMethod! !!IRMethod methodsFor: 'accessing' stamp: 'md 7/10/2005 22:06'!properties	^properties! !!IRMethod methodsFor: 'accessing' stamp: 'md 7/10/2005 22:06'!properties: propDict	properties := propDict.! !!IRMethod methodsFor: 'optimizing' stamp: 'ajh 3/18/2003 19:25'!removeEmptyStart	startSequence size = 1 ifTrue: [		"startSeq is just unconditional jump, forget it"		startSequence _ startSequence last destination].! !!IRMethod methodsFor: 'inlining' stamp: 'md 9/12/2005 12:00'!removeReturn	self allSequences last removeLast.! !!IRMethod methodsFor: 'inlining' stamp: 'md 7/1/2005 17:34'!removeReturnSelf	self removeReturn.	self allSequences last removeLast.! !!IRMethod methodsFor: 'mapping' stamp: 'ajh 3/19/2003 13:38'!sourceMap	"Return a mapping from bytecode pcs to source code ranges"	| start map |	"Besides getting start position, make sure bytecodeIndices are filled in"	start _ self compiledMethod initialPC - 1.  	map _ OrderedCollection new.	self allSequences do: [:seq |		seq do: [:instr |  | node |			((node _ instr sourceNode) notNil and: 			 [node debugHighlightStart notNil and:			  [node debugHighlightStop notNil and:			   [instr bytecodeIndex notNil]]]) ifTrue: [				map add:					instr bytecodeIndex + start						-> (node debugHighlightStart to: node debugHighlightStop)]		]	].	^ map! !!IRMethod methodsFor: 'accessing' stamp: 'ajh 3/10/2003 17:53'!startSequence	^ startSequence! !!IRMethod methodsFor: 'initialize' stamp: 'md 7/9/2005 22:36'!startSequence: irSequence	startSequence _ irSequence.	irSequence method: self.! !!IRMethod methodsFor: 'accessing' stamp: 'ajh 6/25/2004 10:49'!tempKeys	^ tempKeys! !!IRMethod methodsFor: 'initialize' stamp: 'ajh 6/25/2004 11:19'!tempKeys: objects	tempKeys _ objects! !!IRMethod methodsFor: 'accessing' stamp: 'ajh 6/25/2004 10:52'!tempNames	"All temp names in context order"	| varNames |	varNames _ OrderedCollection new.	self tempKeys do: [:var | | name |		name _ var asString.		"vars are unique but inlined to:do: loop vars may have the same name, so munge the names to make them different"		[varNames includes: name] whileTrue: [name _ name, 'X'].		varNames add: name.	].	^ varNames asArray! !!IRSequence methodsFor: 'as yet unclassified' stamp: 'dr 9/10/2005 20:59'!, otherCollection 	^sequence, otherCollection! !!IRSequence methodsFor: 'comparing' stamp: 'md 7/14/2005 11:08'!= other	"Override collection equal with identity equal"	^ self == other! !!IRSequence methodsFor: 'optimizing' stamp: 'md 7/14/2005 11:56'!absorbConstantConditionalJumps: alreadySeen	"Collapse sequences that look like:			[if] goto s1			...		 s1:	pushConst: true/false			goto s2		 s2:	if true/false goto s3 else s4	into:			[if] goto s3/s4	These sequences are produced by and:/or: messages"	| seq bool if |	(alreadySeen includes: self) ifTrue: [^ self].	alreadySeen add: self.	[(seq := self successorSequences) size > 0  "not return"	  and: [(seq := seq first "destination") size = 2	   and: [(seq first isConstant: [:obj | (bool := obj) isKindOf: Boolean])	    and: [seq last isGoto	     and: [(if := seq last destination first) isIf]]]]	] whileTrue: [ "absorb"		self last destination: (bool == if boolean			ifTrue: [if destination]			ifFalse: [if otherwise]).	].	self successorSequences do: [:instrs | instrs absorbConstantConditionalJumps: alreadySeen].! !!IRSequence methodsFor: 'optimizing' stamp: 'md 7/14/2005 11:56'!absorbJumpToSingleInstr: alreadySeen	"Collapse jumps to single return instructions into caller"	| seqs seq |	(alreadySeen includes: self) ifTrue: [^ self].	alreadySeen add: self.	[ (seqs := self successorSequences) size = 1  "unconditional jump..." 	   and: [(seq := seqs first) size = 1  "...to single instruction..."	    and: [seq successorSequences size < 2]		and: [self last isBlockReturnTop not]] "...but don't collapse conditional jumps so their otherwiseSequences can stay right after them"	] whileTrue: [ "replace goto with single instruction"		self removeLast.		seq do: [:instr | self add: instr copy].	].	seqs do: [:instrs | instrs absorbJumpToSingleInstr: alreadySeen].! !!IRSequence methodsFor: 'adding' stamp: 'md 7/14/2005 11:57'!add: anInstruction	sequence add: anInstruction.	anInstruction sequence: self.	^anInstruction.! !!IRSequence methodsFor: 'adding' stamp: 'md 7/14/2005 11:57'!add: instr after: another	sequence add: instr after: another.	instr sequence: self.	^instr.! !!IRSequence methodsFor: 'adding' stamp: 'md 7/14/2005 11:58'!add: instr before: another	sequence add: instr before: another.	instr sequence: self.	^instr.! !!IRSequence methodsFor: 'adding' stamp: 'dr 9/11/2005 15:35'!addAll: aCollection	^sequence addAll: aCollection! !!IRSequence methodsFor: 'adding' stamp: 'md 9/28/2005 17:55'!addAllFirst: aCollection	^sequence addAllFirst: aCollection.! !!IRSequence methodsFor: 'adding' stamp: 'md 7/14/2005 11:58'!addInstructions: aCollection		^aCollection do: [:instr | self add: instr].! !!IRSequence methodsFor: 'adding' stamp: 'md 7/14/2005 11:57'!addInstructions: aCollection after: anInstruction		^aCollection reverseDo: [:instr | self add: instr after: anInstruction].! !!IRSequence methodsFor: 'adding' stamp: 'md 7/14/2005 12:29'!addInstructions: aCollection before: anInstruction	aCollection do: [:instr | self add: instr before: anInstruction].! !!IRSequence methodsFor: 'adding' stamp: 'dr 9/10/2005 20:57'!addLast: anInstruction	^self add: anInstruction.! !!IRSequence methodsFor: 'as yet unclassified' stamp: 'md 9/29/2005 11:25'!after: o	^sequence after: o! !!IRSequence methodsFor: 'as yet unclassified' stamp: 'dr 9/10/2005 21:01'!at: index	^sequence at: index! !!IRSequence methodsFor: 'as yet unclassified' stamp: 'dr 9/10/2005 21:02'!detect: aBlock	^sequence detect: aBlock! !!IRSequence methodsFor: 'as yet unclassified' stamp: 'md 7/14/2005 12:24'!do: aBlock	^sequence do: aBlock.! !!IRSequence methodsFor: 'as yet unclassified' stamp: 'md 7/14/2005 12:31'!first	^sequence first! !!IRSequence methodsFor: 'comparing' stamp: 'md 7/14/2005 11:08'!hash	^ self identityHash! !!IRSequence methodsFor: 'as yet unclassified' stamp: 'md 7/14/2005 12:30'!ifEmpty: aBlock	^sequence ifEmpty: aBlock! !!IRSequence methodsFor: 'as yet unclassified' stamp: 'md 7/14/2005 12:30'!ifNotEmpty: aBlock	^sequence ifNotEmpty: aBlock! !!IRSequence methodsFor: 'initialize-release' stamp: 'md 7/14/2005 11:56'!initialize	sequence := OrderedCollection new.! !!IRSequence methodsFor: 'successor sequences' stamp: 'md 7/14/2005 11:58'!instructionsDo: aBlock	^self withAllSuccessorsDo: [:seq | seq do: aBlock].! !!IRSequence methodsFor: 'as yet unclassified' stamp: 'md 7/14/2005 12:23'!isEmpty	^sequence isEmpty! !!IRSequence methodsFor: 'as yet unclassified' stamp: 'md 7/14/2005 12:23'!last	^sequence last! !!IRSequence methodsFor: 'printing' stamp: 'md 7/14/2005 11:59'!longPrintOn: stream	[IRPrinter new		indent: 0;		stream: stream;		interpretSequence: self	] onDNU: #orderNumber do: [:ex | ex resume: ex receiver]! !!IRSequence methodsFor: 'accessing' stamp: 'md 7/14/2005 12:00'!method	^method! !!IRSequence methodsFor: 'accessing' stamp: 'md 7/14/2005 12:00'!method: aIRMethod	method := aIRMethod! !!IRSequence methodsFor: 'successor sequences' stamp: 'md 7/14/2005 11:58'!nextSequence	| sequences i |	sequences := self withAllSuccessors.	i := sequences findFirst: [:seq | seq orderNumber = self orderNumber].	(i = 0 or: [i = sequences size]) ifTrue: [^ nil].	^ sequences at: i + 1! !!IRSequence methodsFor: 'as yet unclassified' stamp: 'dr 9/10/2005 20:55'!notEmpty	^sequence notEmpty! !!IRSequence methodsFor: 'accessing' stamp: 'md 7/14/2005 12:00'!orderNumber	"Sequences are sorted by this number"	^ orderNumber! !!IRSequence methodsFor: 'accessing' stamp: 'md 7/14/2005 12:00'!orderNumber: num	"Sequences are sorted by this number"	orderNumber := num.! !!IRSequence methodsFor: 'printing' stamp: 'md 7/14/2005 12:00'!printOn: stream	stream nextPutAll: 'an '.	self class printOn: stream.	stream space.	stream nextPut: $(.	self orderNumber printOn: stream.	stream nextPut: $).! !!IRSequence methodsFor: 'replacing' stamp: 'md 7/14/2005 12:00'!remove: aNode	aNode sequence: nil.	sequence remove: aNode ifAbsent: [self error].! !!IRSequence methodsFor: 'as yet unclassified' stamp: 'dr 9/10/2005 21:03'!removeFirst	^sequence removeFirst.! !!IRSequence methodsFor: 'as yet unclassified' stamp: 'md 7/14/2005 12:25'!removeLast	^sequence removeLast.! !!IRSequence methodsFor: 'replacing' stamp: 'md 7/14/2005 12:01'!replaceNode: aNode withNode: anotherNode 	self add: anotherNode before: aNode.	sequence remove: aNode ifAbsent: [self error].! !!IRSequence methodsFor: 'replacing' stamp: 'md 7/14/2005 12:01'!replaceNode: aNode withNodes: aCollection 	self addInstructions: aCollection before: aNode.	sequence remove: aNode ifAbsent: [self error].! !!IRSequence methodsFor: 'as yet unclassified' stamp: 'md 7/14/2005 12:28'!reverseDo: aBlock	^sequence reverseDo: aBlock.! !!IRSequence methodsFor: 'as yet unclassified' stamp: 'md 7/14/2005 12:28'!select: aBlock	^sequence select: aBlock.! !!IRSequence methodsFor: 'as yet unclassified' stamp: 'md 7/14/2005 12:32'!sequence	^sequence! !!IRSequence methodsFor: 'manipulating' stamp: 'dr 9/10/2005 20:58'!setSuccessor: suc	"find the blockReturnTops, set successor "	self withAllSuccessorsDo: [:succ | succ notEmpty ifTrue: [		| last |		last := succ last.		last isBlockReturnTop ifTrue: [ 			last successor: suc.		]	]].! !!IRSequence methodsFor: 'as yet unclassified' stamp: 'md 7/14/2005 12:25'!size	^sequence size.! !!IRSequence methodsFor: 'manipulating' stamp: 'md 7/14/2005 13:22'!splitAfter: instruction	| newSeq index next |	next := self nextSequence.	next := next		ifNil: [self orderNumber + 1]		ifNotNil: [(next orderNumber + self orderNumber) / 2].	newSeq := self class new orderNumber: next.	newSeq method: self method.	"Split after instruction"	index := sequence indexOf: instruction.	(sequence last: sequence size - index) do: [:instr | newSeq add: instr].	sequence := sequence first: index.	sequence add: (IRJump new destination: newSeq).	^ newSeq! !!IRSequence methodsFor: 'manipulating' stamp: 'md 7/14/2005 13:22'!splitAfterNoJump: instruction	| newSeq next index |	next := self nextSequence.	next := next		ifNil: [self orderNumber + 1]		ifNotNil: [(next orderNumber + self orderNumber) / 2].	newSeq := self class new orderNumber: next.	newSeq method: self method.		"Split after instruction"	index := sequence indexOf: instruction.	(sequence last: sequence size - index) do: [:instr | newSeq add: instr].	sequence := sequence first: index.	^ newSeq! !!IRSequence methodsFor: 'successor sequences' stamp: 'md 7/14/2005 11:59'!successorSequences	sequence isEmpty ifTrue: [^ #()].	^ sequence last successorSequences! !!IRSequence methodsFor: 'manipulating' stamp: 'md 9/23/2005 14:42'!tranformToBlockSequence	| last |	" fix: if last jump --> follow jumps, remove returns and add blockReturnTop on leafs."	self withAllSuccessorsDo: [:succ | 		succ notEmpty ifTrue: [			last := succ last.			last isJump ifFalse: [ 				last isReturn ifTrue: [succ removeLast].				succ addLast: IRInstruction blockReturnTop.			]		].		succ ifEmpty: [succ addLast: IRInstruction blockReturnTop].	].! !!IRSequence methodsFor: 'successor sequences' stamp: 'md 7/14/2005 11:59'!withAllSuccessors	"Return me and all my successors sorted by sequence orderNumber"	| list |	list := OrderedCollection new: 20.	self withAllSuccessorsDo: [:seq | list add: seq].	^ list asSortedCollection: [:x :y | x orderNumber <= y orderNumber]! !!IRSequence methodsFor: 'successor sequences' stamp: 'md 7/14/2005 11:59'!withAllSuccessorsDo: block	"Iterate over me and all my successors only once"	self withAllSuccessorsDo: block alreadySeen: IdentitySet new! !!IRSequence methodsFor: 'successor sequences' stamp: 'md 7/14/2005 11:59'!withAllSuccessorsDo: block alreadySeen: set	"Iterate over me and all my successors only once"	(set includes: self) ifTrue: [^ self].	set add: self.	block value: self.	self successorSequences do: [:seq |		seq ifNotNil: [seq withAllSuccessorsDo: block alreadySeen: set]].! !!LexicalScope commentStamp: 'ajh 3/24/2003 21:53' prior: 0!I am a symbol table where variable names are associated with SemVars.  Each context (method/closure) get a fresh scope that inherits from its outer scope.!!ClassScope commentStamp: 'ajh 3/24/2003 21:44' prior: 0!I include all variable enries for class, pool and global vars.!!ClassScope methodsFor: 'initializing' stamp: 'ajh 2/25/2003 20:10'!class: aBehavior	class _ aBehavior! !!ClassScope methodsFor: 'lookup' stamp: 'ajh 2/25/2003 20:10'!classEncoding	^ class! !!ClassScope methodsFor: 'levels' stamp: 'ajh 6/24/2004 04:03'!instanceScope	^ InstanceScope new		vars: class allInstVarNames;		outerScope: self! !!ClassScope methodsFor: 'lookup' stamp: 'md 2/21/2006 14:10'!lookupVar: name	"Return a SemVar for my pool var with this name.  Return nil if none found"	(class bindingOf: name asSymbol) ifNotNilDo: [:assoc | 		^ GlobalVar new assoc: assoc; scope: self].	^ nil! !!ClassScope methodsFor: 'levels' stamp: 'ajh 6/26/2004 17:56'!newFunctionScope	^ self instanceScope newFunctionScope! !!ClassScope methodsFor: 'lookup' stamp: 'ajh 3/18/2003 15:42'!possibleVarsFor: name continued: listOrNil	"Return my pool var names that are close to name"	name first isUppercase ifFalse: [^ listOrNil].	^ class possibleVariablesFor: name continuedFrom: listOrNil! !!ClassScope methodsFor: 'printing' stamp: 'ajh 2/25/2003 20:10'!printOn: stream	class printOn: stream.	stream nextPutAll: ' parseScope'.! !!ClassScope methodsFor: 'lookup' stamp: 'md 2/21/2006 14:10'!rawVar: name	"Return a SemVar for my pool var with this name.  Return nil if none found"	(class bindingOf: name asSymbol) ifNotNilDo: [:assoc | 		^ GlobalVar new assoc: assoc; scope: self].	^ nil! !!FunctionScope commentStamp: 'ajh 7/8/2004 18:33' prior: 0!I am the symbol table (for declared temp vars) for methods and blocks (non-inlined closures). Scopes nest mirroring the block nesting (skipping inlined blocks like ifTrue: blocks). Variable references are looked up in the closest scope first then if not found searches the outer scope and so on. Temp variables found in an outer scope become captured in that outer scope. The emitPrologue: checks if any temp were captured and if so generates code that creates a ClosureEnvironment for those captured vars and copies any captured rargs (receiver and arguments) into it. This way MethodContexts are LIFO. Even a non-local (remote) return does not hold onto its home context, but rather holds onto its home context's environment. Upon return the caller stack is searched for the context that points to that home environment and returns to it. This allows stacks to be copied and blocks to still return to the correct context within the current thread.!!ContextDoItScope methodsFor: 'lookup' stamp: 'ajh 7/8/2004 17:06'!captureVar: name	"Don't convert temps to captured"	^ self lookupVar: name! !!ContextDoItScope methodsFor: 'parent env' stamp: 'ajh 7/8/2004 17:56'!closestEnvScope	"my temps are like inst vars, hence my own environment"	^ self! !!ContextDoItScope methodsFor: 'emitting' stamp: 'md 6/13/2005 13:58'!emitEnvParentEnv: methodBuilder	methodBuilder pushInstVar: (MethodContext allInstVarNames indexOf: #receiver).	"return which scope my receiver points to"	^ self outerEnvScope! !!ContextDoItScope methodsFor: 'emitting' stamp: 'md 3/10/2006 15:55'!emitLocalParentEnv: methodBuilder	"local parent is held in receiver"	"return which scope my receiver points to"	^ self outerEnvScope! !!ContextDoItScope methodsFor: 'emitting' stamp: 'md 6/13/2005 13:58'!emitMyEnv: methodBuilder	self flag: #myEnv.	methodBuilder pushInstVar: MethodContext myEnvFieldIndex.! !!ContextDoItScope methodsFor: 'emitting' stamp: 'md 3/10/2006 15:55'!emitPrologue: methodBuilder	self hasEscapingEnv ifFalse: [^ self].	self emitCreateEnv: methodBuilder.	self emitMoveCapturedRargs: methodBuilder.! !!ContextDoItScope methodsFor: 'initializing' stamp: 'ajh 7/8/2004 19:53'!hideOuterTemps	"Hide outer temps so they don't get captured (becuase they weren't captured and their values are not in the do-it env chain)"	self outerScope tempsAreNoLongerAvailable! !!ContextDoItScope methodsFor: 'scope' stamp: 'ajh 7/8/2004 17:15'!isDoItScope	^ true! !!FunctionScope methodsFor: 'captured vars' stamp: 'ajh 7/8/2004 14:36'!addCaptured: name	self forceThisEnv.	^ capturedVars add: (CapturedVar new			name: name;			index: capturedVars size + 1;			scope: self)! !!FunctionScope methodsFor: 'parent env' stamp: 'ajh 7/8/2004 16:01'!addSlotForCapturedParentEnv	| receiver |	self hasInnerFreeVars ifFalse: [^ false].	receiver _ self receiverVar.	capturedVars do: [:var | var sourceTemp = receiver ifTrue: [^ false]].	^ true! !!FunctionScope methodsFor: 'temp vars' stamp: 'ajh 6/26/2004 17:46'!addTemp: name	^ tempVars add: (TempVar new			name: name;			index: tempVars size; "zero-based; receiver is at 0"			scope: self)! !!FunctionScope methodsFor: 'initializing' stamp: 'ajh 7/8/2004 20:23'!asDoItScope	^ (self primitiveChangeClassTo: ContextDoItScope basicNew) hideOuterTemps! !!FunctionScope methodsFor: 'lookup' stamp: 'md 10/16/2004 20:56'!captureVar: name	"Return the ScopeVar with this name. If a temp move to captured."	| var |	capturedVars at: name ifPresent: [:v | ^ v].	self hideTemps ifFalse: [		tempVars at: name ifPresent: [:v | ^ self moveToCaptured: v]].	(name = 'top env' and: [self isHome]) ifTrue: [^ self forceThisEnv].	var _ self outerScope captureVar: name.	(var notNil and: [var isGlobal not]) ifTrue: [self hasInnerFreeVars: true].	^ var! !!FunctionScope methodsFor: 'parent env' stamp: 'ajh 7/8/2004 16:00'!capturedParentEnv	| receiver |	self hasInnerFreeVars ifFalse: [^ nil].	receiver _ self receiverVar.	capturedVars do: [:var | var sourceTemp = receiver ifTrue: [^ var]].	"not added to captured list, but slot is created for it in emitCreateEnv.	 It's not added since it was not captured directly by a variable reference in the code (only indirectly)"	^ CapturedVar new		name: 'env parent';		index: capturedVars size + 1;		scope: self! !!FunctionScope methodsFor: 'captured vars' stamp: 'ajh 6/25/2004 22:24'!capturedVars	^ capturedVars asSortedCollection: [:x :y | x index <= y index]! !!FunctionScope methodsFor: 'parent env' stamp: 'ajh 7/8/2004 14:26'!closestEnvScope	"If self has its own env return self, otherwise return first outer scope with its own env"	self hasEscapingEnv ifTrue: [^ self].	^ self outerScope closestEnvScope! !!FunctionScope methodsFor: 'emitting' stamp: 'ajh 7/8/2004 16:02'!emitCreateEnv: methodBuilder	"Create a heap environment for my captured vars"	methodBuilder		pushLiteral: ClosureEnvironment;		pushLiteral: capturedVars size + self addSlotForCapturedParentEnv asBit;		send: #new:.	self thisEnvVar emitLocalStore: methodBuilder.	methodBuilder popTop.! !!FunctionScope methodsFor: 'emitting' stamp: 'md 3/9/2006 12:04'!emitEnvParentEnv: methodBuilder	Preferences compileBlocksAsClosures ifTrue:  [		methodBuilder pushInstVar: self capturedParentEnv index.	].	"return which scope my parent env points to"	^ self outerEnvScope! !!FunctionScope methodsFor: 'emitting' stamp: 'md 3/9/2006 12:03'!emitLocalParentEnv: methodBuilder	"local parent is held in receiver"	Preferences compileBlocksAsClosures ifTrue:  [		self receiverVar emitLocalValue: methodBuilder.	].	"return which scope my receiver points to"	^ self outerEnvScope! !!FunctionScope methodsFor: 'emitting' stamp: 'md 6/13/2005 14:01'!emitMoveCapturedRargs: methodBuilder	self capturedVars do: [:var |		| sourceTemp |		sourceTemp _ var sourceTemp.		sourceTemp ifNotNil: [			sourceTemp emitLocalValue: methodBuilder.			self thisEnvVar emitLocalValue: methodBuilder.			methodBuilder storeInstVar: var index; popTop]].	self addSlotForCapturedParentEnv ifTrue: [		self receiverVar emitLocalValue: methodBuilder.		self thisEnvVar emitLocalValue: methodBuilder.		methodBuilder storeInstVar: capturedVars size + 1; popTop].! !!FunctionScope methodsFor: 'emitting' stamp: 'ajh 7/8/2004 17:12'!emitMyEnv: methodBuilder	thisEnvVar emitLocalValue: methodBuilder! !!FunctionScope methodsFor: 'emitting' stamp: 'md 10/17/2004 14:14'!emitPrologue: methodBuilder	Preferences compileBlocksAsClosures ifTrue: [			self hasEscapingEnv ifFalse: [^ self].		self emitCreateEnv: methodBuilder.		self emitMoveCapturedRargs: methodBuilder.	]! !!FunctionScope methodsFor: 'env' stamp: 'ajh 7/8/2004 14:37'!forceThisEnv	"create local env (if not already)"	thisEnvVar ifNotNil: [^ thisEnvVar].	^ thisEnvVar _ ThisEnvVar new			name: 'thisEnv';			index: -1;			scope: self! !!FunctionScope methodsFor: 'env' stamp: 'ajh 7/8/2004 14:30'!hasEscapingEnv	"has own env?"	^ thisEnvVar notNil! !!FunctionScope methodsFor: 'parent env' stamp: 'ajh 7/8/2004 15:38'!hasInnerFreeVars	"True if has inner scope that references to outer scope (non-global) variables. Indicates whether or not to add parent ref to local env"	^ hasInnerFreeVars = true! !!FunctionScope methodsFor: 'parent env' stamp: 'ajh 7/8/2004 15:37'!hasInnerFreeVars: bool	"True if has inner scope that references to outer scope (non-global) variables. Indicates whether or not to add parent ref to local env"	hasInnerFreeVars _ bool! !!FunctionScope methodsFor: 'temp vars' stamp: 'ajh 7/8/2004 19:50'!hideTemps	"If true do not allow inner scopes to capture my temps. Used by do-it scopes, which are fetching from an existing context env which no longer has its temps"	^ hideTemps = true! !!FunctionScope methodsFor: 'initializing' stamp: 'ajh 7/8/2004 14:24'!initialize	tempVars _ KeyedSet keyBlock: [:var | var name].	capturedVars _ KeyedSet keyBlock: [:var | var name].	thisContextVar _ ThisContextVar new		name: 'thisContext';		index: -2;		scope: self.! !!FunctionScope methodsFor: 'scope' stamp: 'ajh 6/26/2004 13:57'!isBlockScope	^ self isMethodScope not! !!FunctionScope methodsFor: 'scope' stamp: 'ajh 6/25/2004 15:18'!isFunctionScope	^ true! !!FunctionScope methodsFor: 'scope' stamp: 'ajh 6/29/2004 16:38'!isHome	"the home scope is the one that returns (^) return from"	^ isHome = true! !!FunctionScope methodsFor: 'scope' stamp: 'ajh 6/29/2004 16:38'!isHome: bool	"the home scope is the one that returns (^) return from"	isHome _ bool! !!FunctionScope methodsFor: 'scope' stamp: 'ajh 6/29/2004 16:38'!isMethodScope	^ self isHome! !!FunctionScope methodsFor: 'lookup' stamp: 'md 3/10/2006 15:53'!lookupVar: name	"Return the ScopeVar with this name. If found in outer scope then move it to captured."	capturedVars at: name ifPresent: [:v | ^ v].	tempVars at: name ifPresent: [:v | ^ v].	name = 'thisEnv' ifTrue: [^ self forceThisEnv].	name = 'thisContext' ifTrue: [^ thisContextVar].	(name = 'top env' and: [self isHome]) ifTrue: [^ nil]. "'top env' used by return node"		Preferences compileBlocksAsClosures ifFalse: [				^ self outerScope rawVar: name.	].		^ self outerScope captureVar: name! !!FunctionScope methodsFor: 'captured vars' stamp: 'ajh 10/28/2004 23:41'!moveToCaptured: tempVar	"tempVar has been captured by an inner scope, move it from temps to captured. If tempVar is an arg, keep a temp version of it and link them via sourceTemp. tempVar 'becomes' a captured var so parse tree var nodes will keep pointer to its var."	| newTempVar |	self forceThisEnv.	tempVar isArg ifTrue: [		newTempVar _ tempVar copy.		tempVars remove: tempVar.		tempVars add: newTempVar.		tempVar becomeCaptured.		capturedVars add: tempVar.		tempVar index: capturedVars size.		tempVar sourceTemp: newTempVar.	] ifFalse: [		self removeTemp: tempVar.		tempVar becomeCaptured.		capturedVars add: tempVar.		tempVar index: capturedVars size.	].	^ tempVar! !!FunctionScope methodsFor: 'parent env' stamp: 'ajh 7/8/2004 14:26'!outerEnvScope	^ outerScope closestEnvScope! !!FunctionScope methodsFor: 'scope' stamp: 'ajh 7/8/2004 14:19'!popScope	"Propogate free var usages to their outer vars, then return outer scope"	^ self outerScope! !!FunctionScope methodsFor: 'lookup' stamp: 'ajh 7/8/2004 16:10'!possibleVarsFor: name continued: listOrNil	"Return my var names that are close in spelling to name"	| list |	list _ listOrNil.	name first isLowercase ifTrue: [		{tempVars. capturedVars} do: [:vars |			list _ name correctAgainstDictionary: vars continuedFrom: list]	].	^ self outerScope possibleVarsFor: name continued: list! !!FunctionScope methodsFor: 'printing' stamp: 'ajh 3/20/2003 11:29'!printOn: stream	super printOn: stream.	stream space.	self scopeLevel printOn: stream.! !!FunctionScope methodsFor: 'lookup' stamp: 'ajh 10/28/2004 23:26'!rawVar: name	"Return the var with this name without capturing temps"	capturedVars at: name ifPresent: [:v | ^ v].	tempVars at: name ifPresent: [:v | ^ v].	name = 'thisEnv' ifTrue: [^ self forceThisEnv].	name = 'thisContext' ifTrue: [^ thisContextVar].	^ self outerScope rawVar: name! !!FunctionScope methodsFor: 'temp vars' stamp: 'ajh 6/25/2004 17:12'!receiverVar	^ self tempVars first! !!FunctionScope methodsFor: 'decompiling' stamp: 'md 10/10/2004 15:02'!receiverVarAt: instVarIndex	^ self tempVars detect: [:var | var index = instVarIndex] ifNone: [		| name |		name _ 'f', instVarIndex asString.		self tempVars at: name put: 			(ScopeVar new				name: name;				receiverVar: self receiverVar;				index: instVarIndex)	  ]! !!FunctionScope methodsFor: 'temp vars' stamp: 'ajh 6/25/2004 22:05'!removeTemp: tempVar	tempVars remove: tempVar.	tempVars do: [:var |		var index > tempVar index ifTrue: [			var index: var index - 1]].! !!FunctionScope methodsFor: 'decompiling' stamp: 'ajh 6/27/2004 15:33'!tempVarAt: tempIndex	tempIndex = -2 ifTrue: [^ self thisContextVar].	tempIndex = -1 ifTrue: [^ self thisEnvVar].	^ tempVars detect: [:var | var index = tempIndex] ifNone: [		| name |		name _ String streamContents: [:str |			self scopeLevel timesRepeat: [str nextPut: $t].			tempIndex printOn: str].		tempVars add: 			(TempVar new				name: name;				index: tempIndex;				scope: self)	  ]! !!FunctionScope methodsFor: 'temp vars' stamp: 'ajh 6/25/2004 22:23'!tempVars	^ tempVars asSortedCollection: [:x :y | x index <= y index]! !!FunctionScope methodsFor: 'temp vars' stamp: 'ajh 7/8/2004 19:52'!tempsAreNoLongerAvailable	"Hide my temps and outer temps so they don't get captured (becuase they weren't captured and their values are not in the do-it env chain)"	hideTemps _ true.	self outerScope tempsAreNoLongerAvailable.! !!FunctionScope methodsFor: 'env' stamp: 'ajh 6/25/2004 17:11'!thisContextVar	^ thisContextVar! !!FunctionScope methodsFor: 'env' stamp: 'ajh 6/25/2004 17:56'!thisEnvVar	^ thisEnvVar! !!GlobalScope commentStamp: 'ajh 3/24/2003 21:52' prior: 0!When the class is not known, use me to at least find global vars.!!GlobalScope methodsFor: 'lookup' stamp: 'ajh 2/26/2003 13:42'!classEncoding	"subclass responsibility, default is nil"	^ nil! !!GlobalScope methodsFor: 'lookup' stamp: 'md 2/21/2006 14:11'!lookupVar: name	"subclass responsibility, default is to look up global vars"	(ProtoObject bindingOf: name asSymbol) ifNotNilDo: [:assoc | 		^ GlobalVar new assoc: assoc; scope: self].	^ nil! !!GlobalScope methodsFor: 'lookup' stamp: 'ajh 3/12/2003 12:10'!possibleVarsFor: name continued: listOrNil	"subclass responsibility, default is to look up global vars"	name first isLowercase ifTrue: [^ listOrNil].	^ ProtoObject possibleVariablesFor: name continuedFrom: listOrNil! !!GlobalScope methodsFor: 'lookup' stamp: 'md 2/21/2006 14:11'!rawVar: name	"subclass responsibility, default is to look up global vars"	(ProtoObject bindingOf: name asSymbol) ifNotNilDo: [:assoc | 		^ GlobalVar new assoc: assoc; scope: self].	^ nil! !!InstanceScope methodsFor: 'lookup' stamp: 'ajh 7/8/2004 14:55'!closestEnvScope	"If self has its own env return self, otherwise return first outer scope with its own env"	^ self! !!InstanceScope methodsFor: 'accessing' stamp: 'md 3/10/2006 12:17'!emitEnvParentEnv: anIRBuilder 	^self.! !!InstanceScope methodsFor: 'lookup' stamp: 'ajh 6/28/2004 16:36'!hasEscapingEnv	^ true! !!InstanceScope methodsFor: 'initializing' stamp: 'ajh 7/8/2004 20:26'!isInstanceScope	^ true! !!InstanceScope methodsFor: 'lookup' stamp: 'ajh 6/24/2004 03:02'!lookupVar: name	"Return a SemVar for my pool var with this name.  Return nil if none found"	^ vars at: name ifAbsent: [self outerScope lookupVar: name]! !!InstanceScope methodsFor: 'lookup' stamp: 'ajh 6/24/2004 03:03'!possibleVarsFor: name continued: listOrNil	"Return my var names that are close in spelling to name"	| list |	list _ name first isLowercase		ifTrue: [name correctAgainstDictionary: vars continuedFrom: listOrNil]		ifFalse: [listOrNil].	^ self outerScope possibleVarsFor: name continued: list! !!InstanceScope methodsFor: 'lookup' stamp: 'ajh 6/24/2004 03:04'!rawVar: name	"Return a ScopeVar for my inst var with this name.  Return nil if none found"	^ vars at: name ifAbsent: [self outerScope rawVar: name]! !!InstanceScope methodsFor: 'initializing' stamp: 'ajh 7/8/2004 18:16'!tempsAreNoLongerAvailable	"done"! !!InstanceScope methodsFor: 'initializing' stamp: 'ajh 6/24/2004 04:10'!vars: names	self vars: names offset: 0! !!InstanceScope methodsFor: 'initializing' stamp: 'ajh 7/8/2004 16:22'!vars: names offset: k	vars _ Dictionary new.	names withIndexDo: [:name :index |		vars at: name put:			(CapturedVar new				name: name;				index: k + index;				scope: self)				markGiven].! !!LexicalScope methodsFor: 'adding' stamp: 'ajh 2/25/2003 22:44'!addSelector: string	^ string asSymbol! !!LexicalScope methodsFor: 'lookup' stamp: 'ajh 6/25/2004 22:00'!captureVar: name	^ self lookupVar: name! !!LexicalScope methodsFor: 'lookup' stamp: 'ajh 2/27/2003 00:40'!classEncoding	^ self outerScope classEncoding! !!LexicalScope methodsFor: 'levels' stamp: 'ajh 7/8/2004 20:02'!hasOuter: scope	outerScope ifNil: [^ false].	^ outerScope = scope or: [outerScope hasOuter: scope]! !!LexicalScope methodsFor: 'initializing' stamp: 'ajh 2/25/2003 21:27'!initialize! !!LexicalScope methodsFor: 'scope' stamp: 'ajh 7/8/2004 18:39'!isDoItScope	^ false! !!LexicalScope methodsFor: 'scope' stamp: 'ajh 6/25/2004 15:20'!isFunctionScope	^ false! !!LexicalScope methodsFor: 'scope' stamp: 'ajh 7/8/2004 20:26'!isInstanceScope	^ false! !!LexicalScope methodsFor: 'lookup' stamp: 'ajh 2/25/2003 22:41'!lookupSelector: name	Symbol hasInterned: name ifTrue: [ :sym | ^ sym].	^ nil! !!LexicalScope methodsFor: 'lookup' stamp: 'ajh 3/11/2003 20:19'!lookupVar: name	"subclass responsibility"	^ self outerScope lookupVar: name! !!LexicalScope methodsFor: 'levels' stamp: 'ajh 6/25/2004 17:27'!newBlockScope	^ self newFunctionScope! !!LexicalScope methodsFor: 'levels' stamp: 'ajh 6/25/2004 17:26'!newFunctionScope	^ FunctionScope new outerScope: self! !!LexicalScope methodsFor: 'levels' stamp: 'ajh 6/29/2004 16:37'!newMethodScope	^ self newFunctionScope isHome: true! !!LexicalScope methodsFor: 'levels' stamp: 'ajh 2/26/2003 13:44'!outerScope	^ outerScope! !!LexicalScope methodsFor: 'initializing' stamp: 'ajh 2/26/2003 13:43'!outerScope: aSemScope	outerScope _ aSemScope! !!LexicalScope methodsFor: 'initializing' stamp: 'ajh 2/26/2003 20:01'!parseScope	^ self! !!LexicalScope methodsFor: 'lookup' stamp: 'ajh 2/25/2003 22:40'!possibleSelectorsFor: string	^ Symbol possibleSelectorsFor: string! !!LexicalScope methodsFor: 'lookup' stamp: 'ajh 2/25/2003 22:39'!possibleVarsFor: string	| list |	list _ self possibleVarsFor: string continued: nil.	^ string correctAgainst: nil continuedFrom: list! !!LexicalScope methodsFor: 'lookup' stamp: 'ajh 3/11/2003 20:17'!possibleVarsFor: name continued: listOrNil	"subclass responsibility"	^ self outerScope possibleVarsFor: name continued: listOrNil! !!LexicalScope methodsFor: 'lookup' stamp: 'ajh 3/25/2003 23:38'!rawVar: name	"subclass responsibility"	^ self outerScope rawVar: name! !!LexicalScope methodsFor: 'old protocol' stamp: 'ajh 2/25/2003 20:09'!requestor: editor	"Old protocol, do nothing"! !!LexicalScope methodsFor: 'levels' stamp: 'ajh 3/20/2003 11:27'!scopeLevel	outerScope ifNil: [^ 0].	^ outerScope scopeLevel + 1! !!NewCompilerDocumentation commentStamp: 'md 7/23/2005 09:21' prior: 0!This class is used for collection documentation... e.g. for classes outside of NewCompiler(e.g. Compiler). This will go away at some point.!!NewCompilerDocumentation methodsFor: 'as yet unclassified' stamp: 'md 6/8/2006 15:57'!compiler'Comment for class Compiler:Closure Compilerby Anthony Hannan 3/13/2003The Compiler class (like before) serves as the interface to the compiler.  If Preferences compileUseNewCompiler is true it will run the new closure compiler.  The closure compiler classes reside in their own system category called "Compiler", which is broken down into four minor categories: "Compiler-Syntax", "Compiler-Semantics", "Compiler-IR", and "Compiler-Bytecodes".  The closure compiler also uses classes in "SmaCC-Runtime".Like most compilers, the closure compiler translates source text into bytecodes in a sequence of phases or transformations.Phase 1 - Scan and parse text into abstract syntax tree (AST)SqueakScanner and SqueakParser in "Compiler-Syntax" transform a method or do-it text into a Refactory abstract syntax tree.  SqueakScanner and SqueakParser classes were automatically generated using the SmaCC parser generator from a token and grammar specification derived from the StScanner and StParser specifications that comes with SmaCC.Phase 2 - Verify and annotate AST (semantic analysis)SemanticChecker in "Compiler-Semantics" binds RBVariableNodes in the AST to temp, instance, or pool (class, pool, or global) SemVars, raising a notifier if no match is found.  The lookup is performed on a chain of SemScopes, one for the class, method and each nested closure.  Var usage (read/write/capture-in-closure) is tracked using a FiniteAutomaton.  The final usage state is used to determine unused temps and escaping temps (temps whose storage need to reside independent of the context since a block may assign to it after the context is gone).Phase 3 - Translate AST to intermediate representation (IR)SemanticTranslator in "Compiler-Semantics" visits each node in the AST and invokes the appropriate instruction message on IRBuilder in "Compiler-IR" resulting in an IRMethod.  An IRMethod consists of IRInstructions grouped by IRSequence (basic block).  Each IRInstruction represents a simple stack instruction like pushTemp: or send:.Phase 4 - Optimize IRTwo simple optimization are applied to the IRMethod: absorbJumpsToSingleInstrs and absorbConstantConditionalJumps. The first eliminates jumps to returns and returns directly.  The second converts chained constant jumps created by and:/or: to single jumps directly to the target code.Phase 5 - Translate IR to bytecodes (CompiledMethod)IRTranslator in "Compiler-IR" visits each IR instruction and invokes the appropriate bytecode message on BytecodeGenerator in "Compiler-Bytecodes".  Certain combinations of IR instructions (like storeTemp: and popTop) are mapped to a single bytecode instructions.'! !!Object methodsFor: '*newcompiler' stamp: 'ajh 6/29/2004 14:40'!doItScope	^ self class parseScope instanceScope! !!Parser2 commentStamp: 'ajh 3/24/2003 21:36' prior: 0!This mirrors the old Parser protocol but delegates to the real parser which is SqueakParser.!!Parser2 class methodsFor: 'as yet unclassified' stamp: 'ajh 7/7/2004 13:49'!initialize	Smalltalk at: #ParseError put: SmaCCParserError.! !!Parser2 methodsFor: 'accessing' stamp: 'ajh 3/11/2003 12:16'!classEncoding	^ scope classEncoding! !!Parser2 methodsFor: 'error correction' stamp: 'ajh 3/13/2003 04:22'!correctSelector: messageNode	"Correct the proposed selector in messageNode, correcting the original text if such action is indicated.  Fail if the proposedKeyword couldn't be converted into a valid selector.  Spots is an ordered collection of intervals within the test stream of the for each of the keyword parts."	| alternatives aStream choice userSelection lines firstLine sel spots newSel |	sel _ messageNode selectorString.	"If we can't ask the user, assume that the keyword will be defined later"	self interactive ifFalse: [^ sel asSymbol].	spots _ messageNode selectorParts collect: [:token | token sourceInterval].	userSelection _ requestor selectionInterval.	requestor selectFrom: spots first first to: spots last last.	requestor select.	alternatives _ messageNode owningScope possibleSelectorsFor: sel.	aStream _ WriteStream on: (String new: 200).	aStream nextPutAll: (sel contractTo: 35); cr.	firstLine _ 1. 	alternatives do: [:s | aStream nextPutAll: s; cr].	aStream nextPutAll: 'cancel'.	lines _ Array with: firstLine with: (alternatives size + firstLine).		choice _ (PopUpMenu labels: aStream contents lines: lines)		startUpWithCaption: 'Unknown selector, please confirm, correct, or cancel'.	(choice = 0) | (choice > (lines at: 2)) ifTrue: [^ self fail].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	choice = 1 ifTrue: [^ sel asSymbol].	newSel _ alternatives at: choice - 1.	self substituteSelector: newSel in: messageNode.	((sel last ~~ $:) and: [newSel last == $:]) ifTrue: [^ self fail].	^ (messageNode owningScope lookupSelector: newSel)		ifNil: [self halt: 'chosen selector expected to exist']! !!Parser2 methodsFor: 'error correction' stamp: 'ajh 6/30/2004 14:20'!correctVariable: variableNode	"Correct the variableNode to a known variable, or declare it as a new	variable if such action is requested.  We support declaring lowercase	variables as temps, and uppercase variables as Globals or ClassVars,	depending on whether the context is nil (class=UndefinedObject)."	| varName spot alternatives aStream choice userSelection temp binding declareSize |	varName _ variableNode name.	"If we can't ask the user for correction, make it undeclared"	self interactive ifFalse: [		Transcript show: ' (' , varName , ' is Undeclared) '.		varName _ varName asSymbol.		Undeclared at: varName put: nil.		^ GlobalVar new assoc: (Undeclared associationAt: varName); scope: scope	].	spot _ variableNode sourceInterval.	temp _ varName first isLowercase.	"First check to see if the requestor knows anything about the variable"	(temp and: [(binding _ requestor bindingOf: varName) notNil])		ifTrue: [^ GlobalVar new assoc: binding; scope: scope].	userSelection _ requestor selectionInterval.	requestor selectFrom: spot first to: spot last.	requestor select.	alternatives _ variableNode owningScope possibleVarsFor: varName.	aStream _ WriteStream on: (String new: 200).	temp ifTrue: [		declareSize _ 1.		aStream nextPutAll: 'declare temp'; cr.	] ifFalse: [		declareSize _ 1.		self classEncoding ifNotNil: [			declareSize _ declareSize + 1.  			aStream nextPutAll: 'declare class variable'; cr].		aStream nextPutAll: 'declare global'; cr.	].	alternatives do: [:name | aStream nextPutAll: name; cr].	aStream nextPutAll: 'cancel'.	choice _ (PopUpMenu labels: aStream contents				lines: {declareSize. declareSize + alternatives size})		startUpWithCaption:(('Unknown variable: ', varName, 'please correct, or cancel:') asText makeBoldFrom: 19 to: 19 + varName size).	(choice = 0 or: [choice > (declareSize + alternatives size)]) ifTrue: [^ self fail].	requestor deselect.	requestor selectInvisiblyFrom: userSelection first to: userSelection last.	temp ifTrue: [		choice = 1 ifTrue: [^ self declareTempAndPaste: variableNode]	] ifFalse: [		declareSize = 1 ifTrue: [			choice = 1 ifTrue: [^ self declareGlobal: variableNode].		] ifFalse: [ "declareSize = 2"			choice = 1 ifTrue: [^ self declareClassVar: variableNode].			choice = 2 ifTrue: [^ self declareGlobal: variableNode].		].	].	"Spelling correction"	varName _ alternatives at: choice - declareSize.	variableNode changeToken: (SmaCCToken value: varName start: spot first).	self substituteWord: varName wordInterval: spot offset: 0.	^ (variableNode owningScope lookupVar: varName)		ifNil: [self halt: 'var should have been found']! !!Parser2 methodsFor: 'error correction' stamp: 'ajh 3/20/2003 01:30'!declareClassVar: variableNode	self classEncoding theNonMetaClass		addClassVarName: variableNode name asSymbol.	^ (variableNode owningScope lookupVar: variableNode name)		ifNil: [self halt: 'should be found']! !!Parser2 methodsFor: 'error correction' stamp: 'ajh 3/20/2003 01:30'!declareGlobal: variableNode	Smalltalk at: variableNode name asSymbol put: nil.	^ (variableNode owningScope lookupVar: variableNode name)		ifNil: [self halt: 'should be found']! !!Parser2 methodsFor: 'error correction' stamp: 'ajh 3/20/2003 01:31'!declareTempAndPaste: variableNode	| name insertion theTextString methodBody pos start c var tempNode prev |	name _ variableNode name.	theTextString _ requestor text string.	methodBody _ variableNode root body.	methodBody temporaries notEmpty ifTrue: [  		"Paste it after last temp"		prev _ pos _ methodBody temporaries last stop + 1.		(theTextString at: pos) isSeparator ifTrue: [			insertion _ name, ' '.			pos _ pos + 1.  start _ pos.		] ifFalse: [			insertion _ ' ', name.			start _ pos + 1.		].		self substituteWord: insertion			wordInterval: (pos to: pos - 1) offset: 0.	] ifFalse: [		"No bars - insert some with CR & tab"		insertion _ '| ', name, ' |', String cr.		prev _ pos _ methodBody statements first start - 1.		start _ 0.		[pos = 0 or: [(c _ theTextString at: pos) = Character cr]] whileFalse: [			c isSeparator ifTrue: [				insertion _ c asString, insertion.				start _ start + 1.			].			pos _ pos - 1.		].		pos _ pos + 1.		self substituteWord: insertion			wordInterval: (pos to: pos - 1) offset: 0.		start _ pos + 2 + start.	].	var _ methodBody owningScope addTemp: name.	tempNode _ RBVariableNode new		identifierToken: (SmaCCToken value: name start: start);		binding: var.	methodBody root adjustPositionsAfter: prev by: insertion size.	methodBody temporaries: (methodBody temporaries copyWith: tempNode).	^ (variableNode owningScope lookupVar: name)		ifNil: [self halt: 'should have been found']! !!Parser2 methodsFor: 'accessing' stamp: 'ajh 3/25/2003 23:45'!encoder	^ self! !!Parser2 methodsFor: 'old protocol' stamp: 'ajh 3/11/2003 20:01'!endOfLastToken	^ endOfMethodPattern! !!Parser2 methodsFor: 'error handling' stamp: 'ajh 3/6/2003 01:03'!fail	^ failBlock value! !!Parser2 methodsFor: 'error handling' stamp: 'ajh 5/19/2004 17:31'!interactive	requestor == nil ifTrue: [^ false].	(requestor isKindOf: SyntaxError) ifTrue: [^ false].	(requestor respondsTo: #interactive) ifTrue: [^ requestor interactive].	^ true! !!Parser2 methodsFor: 'error handling' stamp: 'ajh 9/12/2002 01:10'!notify: string at: location	requestor isNil		ifTrue: [SyntaxError 					errorInClass: (self classEncoding ifNil: [FakeClassPool])					withCode: 						(source contents							copyReplaceFrom: location							to: location - 1							with: string , ' ->')					doitFlag: doitFlag]		ifFalse: [requestor					notify: string , ' ->'					at: location					in: source].	^self fail! !!Parser2 methodsFor: 'public access' stamp: 'ajh 3/11/2003 14:35'!parse: sourceStreamOrString class: behavior	^ self parse: sourceStreamOrString readStream class: behavior		noPattern: false notifying: nil ifFail: [nil]! !!Parser2 methodsFor: 'public access' stamp: 'md 11/22/2005 18:08'!parse: sourceStream class: class category: aCategory noPattern: noPattern context: ctxt notifying: req ifFail: aBlock         "Answer a MethodNode for the argument, sourceStream, that is the root of         a parse tree. Parsing is done with respect to the argument, class, to find         instance, class, and pool variables; and with respect to the argument,         ctxt, to find temporary variables. Errors in parsing are reported to the         argument, req, if not nil; otherwise aBlock is evaluated. The argument         noPattern is a Boolean that is true if the the sourceStream does not         contain a method header (i.e., for DoIts)."         	^ self parse: sourceStream class: class  noPattern: noPattern context: ctxt notifying: req ifFail: aBlock ! !!Parser2 methodsFor: 'public access' stamp: 'ajh 9/14/2002 09:28'!parse: sourceStream class: behavior noPattern: noPattern context: context notifying: req ifFail: aBlock	"Backwards compatibilty"	context ifNotNil: [self error: 'Use Compiler-evaluate... instead'].	^ self parse: sourceStream class: behavior noPattern: noPattern notifying: req ifFail: aBlock! !!Parser2 methodsFor: 'public access' stamp: 'ms 7/27/2006 17:15'!parse: sourceStream class: parseScope noPattern: doitBool notifying: req ifFail: aBlock	"Parse sourceStream into a embedded BlockNode if doitFlag is true (no method header) or a MethodNode if doitFlag is false.  Parsing is done with respect to parseScope to find non-local variables.  Errors in parsing are reported to req if not nil followed by executing the fail block."	| parser |	source := sourceStream.	requestor := req.	doitFlag := doitBool.	scope := parseScope parseScope.	failBlock := [^ aBlock value].	parser := self realParserClass.	^ [	| tree |		tree := doitFlag 			ifTrue: [parser parseDoIt: source]			ifFalse: [parser parseMethod: source].		[tree verifyIn: scope] on: SemanticWarning do: [:ex | ex correctIn: self]	 ] on: UnhandledError do: [:uEx | | ex |		ex := uEx exception.		(SmaCCParserError handles: ex)			ifTrue: [self notify: ex description at: ex tag position]			ifFalse: [uEx pass]	 ]! !!Parser2 methodsFor: 'public access' stamp: 'ajh 3/6/2003 00:42'!parseArgsAndTemps: aString notifying: req 	"No initialization required.  Parse the argument, aString, notifying req if an error occurs. Otherwise, answer a two-element Array containing Arrays of strings (the argument names and temporary variable names)."	aString == nil ifTrue: [^ #()].	^ (self parse: aString readStream class: nil noPattern: false notifying: req ifFail: [^ nil]) tempNames! !!Parser2 methodsFor: 'public access' stamp: 'ms 7/15/2006 15:35'!parseMethodComment: aString setPattern: aBlock	"Answer the method comment for the argument, aString. Evaluate aBlock with the methodNode containing the selector and arguments"	| methodNode comments |	methodNode := self realParserClass parseMethod: aString.	endOfMethodPattern := methodNode methodPatternStop.	aBlock value: methodNode.	comments := methodNode comments.	comments isEmpty ifTrue: [^ nil].	^ comments first! !!Parser2 methodsFor: 'public access' stamp: 'pmm 5/28/2006 16:05'!parseSelector: aString 	"Answer the message selector for the argument, aString, which should parse successfully up to the temporary declaration or the end of the method header."	| methodNode |	methodNode := self realParserClass parseMethodPattern: aString.	endOfMethodPattern := methodNode methodPatternStop.	^ methodNode selector! !!Parser2 methodsFor: 'error correction' stamp: 'ajh 3/12/2003 14:34'!queryUninitializedTemp: variableNode	| varStart varName |	self interactive ifFalse: [^ self].	varName _ variableNode name.	varStart _ variableNode start.	requestor selectFrom: varStart to: varStart + varName size - 1; select.	((PopUpMenu labels:'yesno') startUpWithCaption:		((varName , ' appears to beundefined at this point.Proceed anyway?') asText makeBoldFrom: 1 to: varName size))		= 1 ifFalse: [^ self fail]! !!Parser2 methodsFor: 'accessing' stamp: 'pmm 5/28/2006 16:03'!realParserClass	^ SqueakParser! !!Parser2 methodsFor: 'error correction' stamp: 'ajh 3/15/2003 13:27'!removeUnusedTemp: variableNode	"Removing unused temp, variableNode, if verified by the user"	| varName interval |	self interactive ifFalse: [^ self].  "don't remove and continue"	varName _ variableNode name.	((PopUpMenu labels: 'yes\no' withCRs) startUpWithCaption:		((varName , ' appears to beunused in this method.OK to remove it?') asText makeBoldFrom: 1 to: varName size))			= 1 ifFalse: [^ self].  "don't remove and continue"	"Remove temp then continue"	interval _ variableNode sourceInterval.	(requestor text at: interval last + 1) isSeparator ifTrue: [		interval _ interval first to: interval last + 1].	self substituteWord: '' wordInterval: interval offset: 0.	variableNode root adjustPositionsAfter: interval first by: 0 - interval size.	variableNode parent removeTemporaryNamed: varName.	^ self! !!Parser2 methodsFor: 'accessing' stamp: 'ajh 3/10/2003 22:17'!requestor	"Return the source code editor"	^ requestor! !!Parser2 methodsFor: 'accessing' stamp: 'ajh 6/9/2002 19:47'!requestor: editor	"set the source code editor"	requestor _ editor! !!Parser2 methodsFor: 'error correction' stamp: 'ajh 3/17/2003 13:07'!substituteSelector: newSel in: messageNode	"Substitute the correctSelector into the (presuamed interactive) receiver."	| offset newParts |	newParts _ OrderedCollection new.	offset _ 0.	newSel keywords	  with: (messageNode selectorParts collect: [:tok | tok sourceInterval])	  do: [:word :interval |		newParts add: (SmaCCToken value: word start: interval first + offset).		offset _ self substituteWord: word wordInterval: interval offset: offset.	  ].	messageNode changeSelectorParts: newParts asArray.! !!Parser2 methodsFor: 'error correction' stamp: 'ajh 3/11/2003 23:22'!substituteWord: correctWord wordInterval: spot offset: o	"Substitute the correctSelector into the (presuamed interactive) receiver."	requestor		correctFrom: (spot first + o)		to: (spot last + o)		with: correctWord.	^ o + correctWord size - spot size! !!Parser2 methodsFor: 'error correction' stamp: 'ajh 3/19/2003 16:43'!variable: varNode shadows: semVar	self interactive ifFalse: [		^ Transcript show: '(', varNode name, ' is shadowed)'].	self notify: 'Name already defined' at: varNode start.! !!Recompiler commentStamp: 'ajh 7/8/2004 21:18' prior: 0![Recompiler new inspect; recompileImage] forkAt: 30!!Recompiler methodsFor: 'problem methods' stamp: 'ajh 5/19/2004 18:16'!initialize	problemMethods _ OrderedCollection new.! !!Recompiler methodsFor: 'requestor interface' stamp: 'ajh 5/19/2004 17:32'!interactive	"Batch compiling, not interactive"	^ false! !!Recompiler methodsFor: 'requestor interface' stamp: 'ajh 5/19/2004 17:32'!notify: aString at: anInteger in: aStream	"Called from Parser2 on syntax error. Do nothing and let fail block handle it"! !!Recompiler methodsFor: 'problem methods' stamp: 'ajh 5/19/2004 18:16'!problem: reason sel: selector in: class	problemMethods add: {class. selector. reason}! !!Recompiler methodsFor: 'recompile' stamp: 'ajh 7/8/2004 20:42'!recompile: selector in: class	"Recompile method in class. If method can't be recompiled (because of compile error) add it to problemMethods with general reason"	| source oldMethod trailer methodNode newMethod |	oldMethod _ class compiledMethodAt: selector.	"oldMethod isClosureCompiled ifTrue: [^ self]."	source _ class sourceCodeAt: selector.	source ifNil: [^ self problem: 'no source' sel: selector in: class].	trailer _ oldMethod trailer.	methodNode _ Compiler new		compile: source in: class notifying: self		ifFail: [^ self problem: 'syntax error' sel: selector in: class].	selector == methodNode selector ifFalse: [		^ self problem: 'selector changed' sel: selector in: class].	newMethod _ methodNode generate: trailer.	class addSelectorSilently: selector withMethod: newMethod.! !!Recompiler methodsFor: 'recompile' stamp: 'ajh 5/19/2004 23:29'!recompileClass: class	{class. class class} do: [:behavior |		behavior selectorsDo: [:selector |			[self recompile: selector in: behavior]				on: Error				do: [:ex | self problem: ex description sel: selector in: behavior]]]! !!Recompiler methodsFor: 'recompile' stamp: 'md 7/19/2006 15:25'!recompileImage	"Recomiles all class/instance methods in image. Methods that can't be recompiled (because of compile error) are added to problemMethods and are not recompiled"	"ProtoObject allSubclasses includes metaclasses"	| m |	m _ 0.	Smalltalk allClassesAndTraitsDo: [:class | m _ m + 1].	'Recompiling ', m printString, ' classes and traits'		displayProgressAt: Sensor cursorPoint from: 0 to: m		during: [:bar | | n |			n _ 0.			Smalltalk allClassesDo: [:class |				self recompileClass: class.				bar value: (n _ n + 1)].			self recompileClass: ProtoObject.		].! !!ScopeVar commentStamp: 'ajh 3/24/2003 22:38' prior: 0!I am an entry in a SemScope that gets associated with variable nodes of the same name.  There a three different subclasses of vars: temp vars, field vars, and pool/global vars.!!GlobalVar commentStamp: 'ajh 3/24/2003 21:53' prior: 0!I am a global, pool, or class variable.!!GlobalVar methodsFor: 'initializing' stamp: 'ajh 2/26/2003 17:31'!assoc: anAssociation	assoc _ anAssociation! !!GlobalVar methodsFor: 'emitting' stamp: 'md 10/4/2005 17:23'!emitStore: methodBuilder from: refScope	self flag: #fixme.	methodBuilder storeIntoLiteralVariable: assoc.	"methodBuilder pushLiteral: assoc.	methodBuilder send: #privSetInHolder:."! !!GlobalVar methodsFor: 'emitting' stamp: 'md 7/9/2005 22:15'!emitValue: methodBuilder from: refScope	methodBuilder pushLiteralVariable: assoc.! !!GlobalVar methodsFor: 'accessing' stamp: 'ajh 7/8/2004 16:25'!isGlobal	^ true! !!GlobalVar methodsFor: 'accessing' stamp: 'ajh 7/2/2004 14:15'!name	^ assoc name! !!GlobalVar methodsFor: 'accessing' stamp: 'ms 8/5/2006 14:35'!value	^assoc value! !!LocalVar commentStamp: 'ajh 3/24/2003 21:54' prior: 0!I am an argument or temporary variable of a method or block.!!CapturedVar commentStamp: 'ajh 3/24/2003 21:52' prior: 0!I'm a field var of some receiverVar.  if receiverVar is 'self' than I am an instance variable.  If receiverVar is a closure than I am a free variable (outer temp reference) and my outerVar is the outer reference var.!!CapturedVar methodsFor: 'emitting' stamp: 'md 6/13/2005 14:01'!emitEnvStore: methodBuilder	self scope isDoItScope ifTrue: [self scope emitMyEnv: methodBuilder].	methodBuilder storeInstVar: self index! !!CapturedVar methodsFor: 'emitting' stamp: 'md 6/13/2005 13:58'!emitEnvValue: methodBuilder	self scope isDoItScope ifTrue: [self scope emitMyEnv: methodBuilder].	methodBuilder pushInstVar: self index.! !!CapturedVar methodsFor: 'emitting' stamp: 'md 3/10/2006 16:31'!emitLocalStore: methodBuilder	Preferences compileBlocksAsClosures ifTrue: [			self scope emitMyEnv: methodBuilder.		].	methodBuilder storeInstVar: self index.			! !!CapturedVar methodsFor: 'emitting' stamp: 'md 3/10/2006 16:31'!emitLocalValue: methodBuilder	Preferences compileBlocksAsClosures ifTrue: [			self scope emitMyEnv: methodBuilder.	].	methodBuilder pushInstVar: self index.! !!CapturedVar methodsFor: 'accessing' stamp: 'ajh 6/24/2004 15:15'!isCaptured	^ true! !!CapturedVar methodsFor: 'accessing' stamp: 'ajh 6/25/2004 22:18'!sourceTemp	^ sourceTemp! !!CapturedVar methodsFor: 'initializing' stamp: 'ajh 6/25/2004 22:18'!sourceTemp: tempVarOrNil	sourceTemp _ tempVarOrNil! !!LocalVar methodsFor: 'emitting' stamp: 'md 8/24/2006 12:11'!emitEnvStore: methodBuilder from: refScope	| nextParent |	refScope = self scope ifTrue: [^ self emitEnvStore: methodBuilder].	refScope isInstanceScope ifTrue: [^ self emitEnvStore: methodBuilder].	"self is being referenced from an inner scope (refScope), emit its parent env and recurse"	nextParent _ refScope emitEnvParentEnv: methodBuilder.	self emitEnvStore: methodBuilder from: nextParent.! !!LocalVar methodsFor: 'emitting' stamp: 'md 8/24/2006 12:11'!emitEnvValue: methodBuilder from: refScope	| nextParent |	refScope = self scope ifTrue: [^ self emitEnvValue: methodBuilder].	refScope isInstanceScope ifTrue: [^ self emitEnvValue: methodBuilder].	"self is being referenced from an inner scope (refScope), emit its parent env and recurse"	nextParent _ refScope emitEnvParentEnv: methodBuilder.	self emitEnvValue: methodBuilder from: nextParent.! !!LocalVar methodsFor: 'emitting' stamp: 'md 3/10/2006 16:23'!emitStore: methodBuilder from: refScope	| nextParent |		refScope = self scope ifTrue: [^ self emitLocalStore: methodBuilder].		"self is being referenced from an inner scope (refScope), emit its parent env and recurse"	nextParent _ refScope emitLocalParentEnv: methodBuilder.	self emitEnvStore: methodBuilder from: nextParent.! !!LocalVar methodsFor: 'emitting' stamp: 'md 3/10/2006 16:17'!emitValue: methodBuilder from: refScope	| nextParent |	refScope = self scope ifTrue: [^ self emitLocalValue: methodBuilder].	"self is being referenced from an inner scope (refScope), emit its parent env and recurse"	nextParent _ refScope emitLocalParentEnv: methodBuilder.	self emitEnvValue: methodBuilder from: nextParent. 	! !!LocalVar methodsFor: 'accessing' stamp: 'ajh 3/18/2003 11:30'!index	^ index! !!LocalVar methodsFor: 'initializing' stamp: 'ajh 6/23/2004 22:43'!index: n	index _ n! !!LocalVar methodsFor: 'read/write usage' stamp: 'ajh 7/8/2004 16:21'!isUndefined	^ usage isNil! !!LocalVar methodsFor: 'read/write usage' stamp: 'ajh 6/28/2004 10:10'!markArg	"mark given"	usage _ #arg! !!LocalVar methodsFor: 'accessing' stamp: 'ajh 6/23/2004 22:51'!name	^ name! !!LocalVar methodsFor: 'initializing' stamp: 'ajh 6/23/2004 22:47'!name: string	name _ string! !!TempVar methodsFor: 'initializing' stamp: 'ajh 6/29/2004 17:05'!becomeCaptured	"TempVar has to become a captured var so parse tree var nodes will point to the captured var. Use change-class instead of become for speed. In order to do this both TempVar and CapturedVar has to have the same number of inst vars"	isArg "sourceTemp" _ nil.	self primitiveChangeClassTo: CapturedVar basicNew.! !!TempVar methodsFor: 'emitting' stamp: 'md 3/10/2006 16:27'!emitEnvStore: methodBuilder	(Preferences compileBlocksAsClosures or: [self scope isDoItScope])		ifTrue: [ self scope isDoItScope ifFalse: [self error: 'should have been captured'].				  methodBuilder storeInstVar: (MethodContext instSize + self index).]		ifFalse: [ self emitLocalStore: methodBuilder].! !!TempVar methodsFor: 'emitting' stamp: 'md 3/10/2006 16:19'!emitEnvValue: methodBuilder	(Preferences compileBlocksAsClosures or: [self scope isDoItScope]) ifTrue: [	self scope isDoItScope ifFalse: [self error: 'should have been captured'].	methodBuilder pushInstVar: (MethodContext instSize + self index).	] ifFalse: [self emitLocalValue: methodBuilder].! !!TempVar methodsFor: 'emitting' stamp: 'ajh 7/8/2004 14:10'!emitLocalStore: methodBuilder	methodBuilder storeTemp: self.! !!TempVar methodsFor: 'emitting' stamp: 'ajh 7/8/2004 14:10'!emitLocalValue: methodBuilder	methodBuilder pushTemp: self.! !!TempVar methodsFor: 'read/write usage' stamp: 'ajh 6/25/2004 22:11'!isArg	^ isArg = true! !!TempVar methodsFor: 'accessing' stamp: 'ajh 6/23/2004 23:18'!isTemp	^ true! !!TempVar methodsFor: 'read/write usage' stamp: 'ajh 6/25/2004 22:11'!markArg	isArg _ true.	usage _ #arg! !!ThisContextVar methodsFor: 'emitting' stamp: 'ajh 7/8/2004 14:12'!emitLocalValue: methodBuilder	methodBuilder pushThisContext.! !!ThisContextVar methodsFor: 'accessing' stamp: 'ajh 6/25/2004 16:52'!isUndefined	^ false! !!ThisEnvVar methodsFor: 'emitting' stamp: 'ajh 7/8/2004 14:13'!emitEnvValue: methodBuilder	"do nothing, env is on top"! !!ThisEnvVar methodsFor: 'emitting' stamp: 'ajh 7/8/2004 14:14'!emitLocalStore: methodBuilder	methodBuilder storeThisEnv.! !!ThisEnvVar methodsFor: 'emitting' stamp: 'ajh 7/8/2004 14:14'!emitLocalValue: methodBuilder	methodBuilder pushThisEnv.! !!ThisEnvVar methodsFor: 'accessing' stamp: 'ajh 6/25/2004 17:54'!isUndefined	^ false! !!ScopeVar class methodsFor: 'as yet unclassified' stamp: 'md 7/5/2005 15:29'!new	^super basicNew! !!ScopeVar methodsFor: 'accessing' stamp: 'ajh 3/16/2003 20:08'!asString	^ self name! !!ScopeVar methodsFor: 'emitting' stamp: 'ajh 7/8/2004 10:47'!emitStore: methodBuilder from: refScope	self subclassResponsibility! !!ScopeVar methodsFor: 'emitting' stamp: 'ajh 7/8/2004 10:47'!emitValue: methodBuilder from: refScope	self subclassResponsibility! !!ScopeVar methodsFor: 'accessing' stamp: 'ajh 6/23/2004 22:44'!isCaptured	^ false! !!ScopeVar methodsFor: 'accessing' stamp: 'ajh 7/8/2004 16:25'!isGlobal	^ false! !!ScopeVar methodsFor: 'accessing' stamp: 'md 11/22/2005 16:29'!isInstance	^self scope isInstanceScope! !!ScopeVar methodsFor: 'accessing' stamp: 'md 11/22/2005 16:29'!isRead	^usage = #read! !!ScopeVar methodsFor: 'accessing' stamp: 'ajh 3/18/2003 11:13'!isTemp	^ false! !!ScopeVar methodsFor: 'read/write usage' stamp: 'ajh 6/25/2004 11:58'!isUndefined	^ false! !!ScopeVar methodsFor: 'read/write usage' stamp: 'ajh 7/8/2004 16:18'!isUnused	^ usage isNil! !!ScopeVar methodsFor: 'accessing' stamp: 'md 11/22/2005 16:29'!isWrite	^usage = #write! !!ScopeVar methodsFor: 'read/write usage' stamp: 'ajh 7/8/2004 16:18'!markGiven	usage ifNil: [usage _ #arg].! !!ScopeVar methodsFor: 'read/write usage' stamp: 'ajh 7/8/2004 16:19'!markRead	(usage isNil or: [usage = #arg]) ifTrue: [usage _ #read]! !!ScopeVar methodsFor: 'read/write usage' stamp: 'ajh 7/8/2004 16:19'!markWrite	usage _ #write! !!ScopeVar methodsFor: 'accessing' stamp: 'ajh 6/23/2004 22:47'!name	^ self subclassResponsibility! !!ScopeVar methodsFor: 'accessing' stamp: 'ajh 2/27/2003 00:38'!printOn: stream	stream nextPutAll: self name! !!ScopeVar methodsFor: 'read/write usage' stamp: 'ajh 6/28/2004 10:13'!privUsage	^ usage! !!ScopeVar methodsFor: 'read/write usage' stamp: 'ajh 6/28/2004 10:13'!privUsage: usageSymbol	usage _ usageSymbol! !!ScopeVar methodsFor: 'accessing' stamp: 'ajh 6/23/2004 22:52'!scope	^ scope! !!ScopeVar methodsFor: 'initializing' stamp: 'ajh 7/8/2004 16:17'!scope: aLexicalScope	scope _ aLexicalScope! !!StackCount commentStamp: 'ajh 3/25/2003 00:34' prior: 0!This keeps track of the stack count for the BytecodeGenerator.!!StackCount class methodsFor: 'as yet unclassified' stamp: 'ajh 3/13/2003 01:49'!new	^ super new startAt: 0! !!StackCount class methodsFor: 'as yet unclassified' stamp: 'ajh 3/13/2003 01:49'!startAt: pos	^ super new startAt: pos! !!StackCount methodsFor: 'comparing' stamp: 'ajh 3/13/2003 01:39'!= other	^ self class == other class 	  and: [start = other start	  and: [position = other position	  and: [length = other size]]]! !!StackCount methodsFor: 'error handling' stamp: 'md 7/18/2005 09:59'!errorStackOutOfSync: aStackCount 	self error: 'stack not in sync!!'.! !!StackCount methodsFor: 'comparing' stamp: 'ajh 3/13/2003 01:51'!hash	^ position hash bitXor: (length hash bitXor: start hash)! !!StackCount methodsFor: 'results' stamp: 'ajh 3/13/2003 01:32'!length	^length! !!StackCount methodsFor: 'results' stamp: 'ajh 3/13/2003 18:37'!linkTo: stackOrNil	stackOrNil ifNil: [^ self class startAt: self position].	^ self position = stackOrNil start		ifTrue: [stackOrNil]		ifFalse: [self errorStackOutOfSync: stackOrNil]! !!StackCount methodsFor: 'affecting' stamp: 'ajh 3/13/2003 01:32'!pop	^ self pop: 1! !!StackCount methodsFor: 'affecting' stamp: 'ajh 3/13/2003 01:32'!pop: n	(position _ position - n) "< 0 		ifTrue: [self error: 'Parse stack underflow']"! !!StackCount methodsFor: 'results' stamp: 'ajh 3/13/2003 01:32'!position	^position! !!StackCount methodsFor: 'printing' stamp: 'ajh 3/13/2003 01:38'!printOn: aStream		super printOn: aStream.	aStream		nextPutAll: ' start '; print: start;		nextPutAll: ' stop '; print: position;		nextPutAll: ' max '; print: length.! !!StackCount methodsFor: 'affecting' stamp: 'ajh 3/13/2003 01:32'!push	^ self push: 1! !!StackCount methodsFor: 'affecting' stamp: 'ajh 3/13/2003 01:32'!push: n	(position _ position + n) > length 		ifTrue: [length _ position]! !!StackCount methodsFor: 'results' stamp: 'ajh 3/13/2003 01:32'!size	^length! !!StackCount methodsFor: 'results' stamp: 'ajh 3/13/2003 01:36'!start	^ start! !!StackCount methodsFor: 'initialize' stamp: 'ajh 3/13/2003 01:48'!startAt: pos	start _ position _ length _ pos! !!UndefinedObject methodsFor: '*newcompiler' stamp: 'ajh 6/23/2004 20:40'!parseScope	^ GlobalScope new! !!IRInstruction commentStamp: 'ajh 6/27/2004 23:02' prior: 0!I am an instruction in the IR (intermediate representation) language.  The IR serves as the intermediary between the Smalltalk language and the bytecode language.  It is easier to optimize and translate to/from this language than it is to optimize/translate directly from Smalltalk to bytecodes.  The IR is generic and simple consisting of just twelve instructions.  They are:	goto: labelNum	if: boolean goto: labelNum1 otherwise: labelNum2	label: labelNum	popTop	pushDup	pushLiteral: object	pushBlock: irMethod	pushBlockMethod: irMethod	pushTemp: tempIndex	remoteReturn	returnTop	send: selector	send: selector toSuperOf: behavior	storeTemp: tempIndexEach instruction is reified as an instance of one of my eight subclasses and grouped by basic block (IRSequence) into an IRMethod.  IRInterpreter visits each instruction in a IRMethod responding to the above instruction messages sent to it.!!IRAccess methodsFor: 'testing' stamp: 'md 6/13/2005 12:01'!isRead	^self isStore not! !!IRAccess methodsFor: 'accessing' stamp: 'md 6/12/2005 17:56'!number	^ number! !!IRAccess methodsFor: 'accessing' stamp: 'md 6/12/2005 17:57'!number: num	number _ num! !!IRInstVarAccess commentStamp: 'md 11/10/2004 16:07' prior: 0!when closures disabled, Field describes an instVar. With closures, it describes a fieldaccess with receiver to be accessed pushed first.!!IRInstVarAccess methodsFor: 'testing' stamp: 'md 6/13/2005 11:10'!isInstVarAccess	^true.! !!IRInstVarAccess methodsFor: 'testing' stamp: 'md 3/6/2006 09:14'!varname	name ifNil: [name := self method compiledMethod methodClass allInstVarNames at: self offset].	^name.! !!IRInstVarRead methodsFor: 'interpret' stamp: 'md 6/14/2005 15:02'!executeOn: interpreter	Preferences compileBlocksAsClosures 		ifFalse: [ interpreter pushInstVar: number] 		ifTrue: [  interpreter pushLiteral: number.				  interpreter send: #privGetInstVar:. ]! !!IRInstVarRead methodsFor: 'testing' stamp: 'md 6/13/2005 11:24'!isRead	^true.! !!IRInstVarRead methodsFor: 'testing' stamp: 'md 6/13/2005 11:24'!isStore	^false.! !!IRInstVarStore methodsFor: 'interpret' stamp: 'md 6/14/2005 15:04'!executeOn: interpreter	Preferences compileBlocksAsClosures 		ifFalse: [interpreter storeInstVar: number] 		ifTrue: [interpreter pushLiteral: number.				interpreter send: #privStoreIn:instVar:].		! !!IRInstVarStore methodsFor: 'testing' stamp: 'md 6/13/2005 11:25'!isRead	^false! !!IRInstVarStore methodsFor: 'testing' stamp: 'md 6/13/2005 11:25'!isStore	^true! !!IRLiteralVariableAccess methodsFor: 'accessing' stamp: 'md 7/9/2005 21:14'!association: anAssociation	association := anAssociation! !!IRLiteralVariableAccess methodsFor: 'accessing' stamp: 'md 10/4/2005 16:45'!isLiteralVariable	^true! !!IRLiteralVariableAccess methodsFor: 'accessing' stamp: 'md 10/4/2005 16:45'!isLiteralVariableAccess	^true! !!IRLiteralVariableAccess methodsFor: 'accessing' stamp: 'md 10/4/2005 16:53'!isLiteralVariableRead	^self isLiteralVariableAccess and: [self isRead].! !!IRLiteralVariableAccess methodsFor: 'accessing' stamp: 'md 10/4/2005 16:53'!isLiteralVariableStore	^self isLiteralVariableAccess and: [self isStore].! !!IRLiteralVariableRead methodsFor: 'interpret' stamp: 'md 7/9/2005 21:18'!executeOn: interpreter	interpreter pushLiteralVariable: association! !!IRLiteralVariableRead methodsFor: 'testing' stamp: 'md 7/9/2005 21:17'!isRead	^true! !!IRLiteralVariableRead methodsFor: 'testing' stamp: 'md 7/9/2005 21:17'!isStore	^false! !!IRLiteralVariableStore methodsFor: 'interpret' stamp: 'md 7/9/2005 21:18'!executeOn: interpreter	interpreter storeIntoLiteralVariable: association! !!IRLiteralVariableStore methodsFor: 'testing' stamp: 'md 7/9/2005 21:18'!isRead	^false! !!IRLiteralVariableStore methodsFor: 'testing' stamp: 'md 7/9/2005 21:18'!isStore	^true! !!IRTempAccess methodsFor: 'testing' stamp: 'md 2/26/2005 16:22'!isSelf	^self number = 0.! !!IRTempAccess methodsFor: 'testing' stamp: 'md 2/22/2005 11:28'!isTemp	^true.! !!IRTempAccess methodsFor: 'testing' stamp: 'md 6/12/2005 18:42'!isTempAccess	^true.! !!IRTempAccess methodsFor: 'testing' stamp: 'md 6/13/2005 11:08'!isTempRead	^self isTempAccess and: [self isRead].! !!IRTempAccess methodsFor: 'testing' stamp: 'md 6/13/2005 12:01'!isTempStore	^self isTempAccess and: [self isStore].! !!IRTempRead methodsFor: 'interpret' stamp: 'md 6/12/2005 18:19'!executeOn: interpreter	interpreter pushTemp: number.! !!IRTempRead methodsFor: 'as yet unclassified' stamp: 'md 6/12/2005 18:21'!isRead	^true! !!IRTempRead methodsFor: 'as yet unclassified' stamp: 'md 6/13/2005 12:03'!isStore	^false! !!IRTempStore methodsFor: 'interpret' stamp: 'md 6/12/2005 18:20'!executeOn: interpreter	interpreter storeTemp: number.		! !!IRTempStore methodsFor: 'testing' stamp: 'md 6/12/2005 18:22'!isRead	^false! !!IRTempStore methodsFor: 'testing' stamp: 'md 6/13/2005 12:03'!isStore	^true! !!IRConstant commentStamp: 'ajh 3/24/2003 23:56' prior: 0!Instruction "pushLiteral: object"!!IRConstant methodsFor: 'accessing' stamp: 'ajh 3/10/2003 00:43'!constant	^ constant! !!IRConstant methodsFor: 'accessing' stamp: 'ajh 3/10/2003 00:43'!constant: object	constant _ object! !!IRConstant methodsFor: 'interpret' stamp: 'ajh 6/27/2004 21:41'!executeOn: interpreter	^ type caseOf: {		[nil] -> [interpreter pushLiteral: constant].		[#block] -> [interpreter pushBlock: constant].		[#blockMethod] -> [interpreter pushBlockMethod: constant]	 }! !!IRConstant methodsFor: 'testing' stamp: 'md 11/26/2004 15:35'!isConstant	^ true! !!IRConstant methodsFor: 'testing' stamp: 'ajh 3/10/2003 16:12'!isConstant: valueTest	^ valueTest value: constant! !!IRConstant methodsFor: 'accessing' stamp: 'ajh 6/27/2004 21:39'!type	"type is nil, #block, or #blockMethod"	^ type! !!IRConstant methodsFor: 'accessing' stamp: 'ajh 6/27/2004 21:39'!type: symbol	"symbol is nil, #block, or #blockMethod"	type _ symbol! !!IRDup commentStamp: 'ajh 3/24/2003 23:56' prior: 0!Instruction "pushDup"!!IRDup methodsFor: 'interpret' stamp: 'ajh 3/10/2003 00:46'!executeOn: interpreter	^ interpreter pushDup! !!IRInstruction class methodsFor: 'instance creation - old style blocks' stamp: 'md 10/8/2004 16:05'!blockReturnTop	^ IRBlockReturnTop new		! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 3/10/2003 01:07'!goto: seq	^ IRJump new		destination: seq! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 3/10/2003 01:07'!if: bool goto: seq1 otherwise: seq2	^ IRJumpIf new		boolean: bool;		destination: seq1;		otherwise: seq2! !!IRInstruction class methodsFor: 'instance creation - old style blocks' stamp: 'md 8/10/2005 11:03'!jumpOverBlock: block to: cont	^ (IRJumpOverBlock new)				blockSequence: block;				destination: cont.! !!IRInstruction class methodsFor: 'instance creation' stamp: 'md 6/29/2005 16:47'!new	^super basicNew.! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 3/10/2003 01:07'!popTop	^ IRPop new! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 6/27/2004 22:58'!pushBlock: irMethod	^ IRConstant new		constant: irMethod;		type: #block! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 6/27/2004 21:40'!pushBlockMethod: irMethod	^ IRConstant new		constant: irMethod;		type: #blockMethod! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 3/10/2003 01:08'!pushDup	^ IRDup new! !!IRInstruction class methodsFor: 'instance creation' stamp: 'md 6/13/2005 13:58'!pushInstVar: index	^ IRInstVarRead new number: index.! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 3/10/2003 01:08'!pushLiteral: object	^ IRConstant new		constant: object! !!IRInstruction class methodsFor: 'instance creation' stamp: 'md 7/9/2005 21:20'!pushLiteralVariable: object	^ IRLiteralVariableRead new		association: object.	 ! !!IRInstruction class methodsFor: 'instance creation' stamp: 'md 4/21/2005 11:38'!pushReceiver	^IRInstruction pushTemp: 0! !!IRInstruction class methodsFor: 'instance creation' stamp: 'md 6/12/2005 18:22'!pushTemp: index	^ IRTempRead new		number: index.! !!IRInstruction class methodsFor: 'instance creation' stamp: 'md 4/21/2005 12:06'!pushThisContext	^IRInstruction pushTemp: -2! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 3/10/2003 01:08'!remoteReturn	^ IRReturn new		isRemote: true! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 3/10/2003 01:08'!returnTop	^ IRReturn new		isRemote: false! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 3/10/2003 01:08'!send: selector	^ IRSend new		selector: selector! !!IRInstruction class methodsFor: 'instance creation' stamp: 'ajh 7/3/2004 19:10'!send: selector toSuperOf: behavior	behavior ifNil: [self error: 'super of nil does not exist'].	^ IRSend new		selector: selector;		superOf: behavior! !!IRInstruction class methodsFor: 'instance creation' stamp: 'md 6/13/2005 13:57'!storeInstVar: index	^ IRInstVarStore new number: index.	! !!IRInstruction class methodsFor: 'instance creation' stamp: 'md 7/9/2005 21:20'!storeIntoLiteralVariable: object	^ IRLiteralVariableStore new		association: object! !!IRInstruction class methodsFor: 'instance creation' stamp: 'md 6/13/2005 11:50'!storeTemp: index	^ IRTempStore new		number: index.! !!IRInstruction methodsFor: 'adding' stamp: 'md 7/9/2005 22:41'!addInstructionsAfter: aCollection	sequence addInstructions: aCollection after: self.! !!IRInstruction methodsFor: 'adding' stamp: 'md 7/9/2005 22:41'!addInstructionsBefore: aCollection	sequence addInstructions: aCollection before: self.! !!IRInstruction methodsFor: 'mapping' stamp: 'ajh 3/13/2003 13:07'!bytecodeIndex	^ bytecodeIndex! !!IRInstruction methodsFor: 'mapping' stamp: 'ajh 3/13/2003 13:14'!bytecodeIndex: index	bytecodeIndex _ index! !!IRInstruction methodsFor: 'mapping' stamp: 'md 9/1/2005 21:18'!bytecodeOffset	| startpc |	startpc := self method compiledMethod initialPC.	self bytecodeIndex ifNil: [^startpc].	^self bytecodeIndex + startpc - 1.! !!IRInstruction methodsFor: 'replacing' stamp: 'md 7/9/2005 22:41'!delete	sequence isNil ifTrue: [self error: 'This node doesn''t have a sequence'].	sequence remove: self.! !!IRInstruction methodsFor: 'interpret' stamp: 'ajh 3/6/2003 14:32'!executeOn: interpreter	"Send approriate message to interpreter"	self subclassResponsibility! !!IRInstruction methodsFor: 'testing' stamp: 'md 10/9/2004 20:14'!isBlockReturnTop	^false! !!IRInstruction methodsFor: 'testing' stamp: 'md 11/26/2004 15:35'!isConstant	^ false! !!IRInstruction methodsFor: 'testing' stamp: 'ajh 3/10/2003 16:12'!isConstant: valueTest	^ false! !!IRInstruction methodsFor: 'testing' stamp: 'ajh 3/11/2003 00:19'!isGoto	"is unconditional jump"	^ false! !!IRInstruction methodsFor: 'testing' stamp: 'ajh 3/11/2003 00:21'!isIf	^ false! !!IRInstruction methodsFor: 'testing' stamp: 'abc 1/2/2006 15:41'!isInBlock	| irs |	irs := self method allInstructionsMatching: [:each | each isJumpOverBlock ].	irs detect: [:each | each blockSequence == self sequence ] ifNone: [^false].	^true! !!IRInstruction methodsFor: 'testing' stamp: 'md 6/13/2005 11:10'!isInstVarAccess	^false.! !!IRInstruction methodsFor: 'testing' stamp: 'md 6/13/2005 13:54'!isInstVarRead	^self isInstVarAccess and: [self isRead].! !!IRInstruction methodsFor: 'testing' stamp: 'md 6/13/2005 13:54'!isInstVarStore	^self isInstVarAccess and: [self isStore].! !!IRInstruction methodsFor: 'testing' stamp: 'ajh 3/11/2003 00:22'!isJump	"goto or if"	^ false! !!IRInstruction methodsFor: 'testing' stamp: 'ajh 3/10/2003 16:13'!isJumpOrReturn	^ self isJump or: [self isReturn]! !!IRInstruction methodsFor: 'testing' stamp: 'abc 1/2/2006 15:14'!isJumpOverBlock	^false! !!IRInstruction methodsFor: 'testing' stamp: 'md 10/4/2005 16:52'!isLiteralVariable	^false! !!IRInstruction methodsFor: 'testing' stamp: 'md 10/4/2005 16:53'!isLiteralVariableAccess	^false! !!IRInstruction methodsFor: 'testing' stamp: 'md 10/4/2005 16:53'!isLiteralVariableRead	^false! !!IRInstruction methodsFor: 'testing' stamp: 'md 10/4/2005 16:53'!isLiteralVariableStore	^false! !!IRInstruction methodsFor: 'testing' stamp: 'ajh 3/10/2003 16:09'!isReturn	^ false! !!IRInstruction methodsFor: 'testing' stamp: 'md 2/26/2005 16:22'!isSelf	^false! !!IRInstruction methodsFor: 'testing' stamp: 'md 11/12/2004 15:57'!isSend	^false.! !!IRInstruction methodsFor: 'testing' stamp: 'md 2/22/2005 11:28'!isTemp	^false! !!IRInstruction methodsFor: 'testing' stamp: 'md 6/13/2005 11:05'!isTempAccess	^false! !!IRInstruction methodsFor: 'testing' stamp: 'md 4/28/2005 14:26'!isTempRead	^false! !!IRInstruction methodsFor: 'testing' stamp: 'md 4/28/2005 14:26'!isTempStore	^false! !!IRInstruction methodsFor: 'accessing' stamp: 'md 7/9/2005 22:42'!method	^sequence method.! !!IRInstruction methodsFor: 'replacing' stamp: 'md 10/11/2004 15:56'!replaceNode: aNode withNode: anotherNode 	self error: 'I don''t store other nodes'! !!IRInstruction methodsFor: 'replacing' stamp: 'md 7/9/2005 22:41'!replaceWith: aNode	sequence isNil ifTrue: [self error: 'This node doesn''t have a sequence'].	sequence replaceNode: self withNode: aNode! !!IRInstruction methodsFor: 'replacing' stamp: 'md 7/9/2005 22:41'!replaceWithInstructions: aCollection 	sequence isNil ifTrue: [self error: 'This node doesn''t have a sequence'].	sequence replaceNode: self withNodes: aCollection! !!IRInstruction methodsFor: 'accessing' stamp: 'md 7/9/2005 22:38'!sequence	^sequence! !!IRInstruction methodsFor: 'accessing' stamp: 'md 7/9/2005 22:39'!sequence: aSeq	sequence := aSeq! !!IRInstruction methodsFor: 'mapping' stamp: 'ajh 3/6/2003 14:32'!sourceNode	^ sourceNode	! !!IRInstruction methodsFor: 'mapping' stamp: 'ajh 3/6/2003 14:32'!sourceNode: parseNode	sourceNode _ parseNode	! !!IRInstruction methodsFor: 'accessing' stamp: 'ajh 3/6/2003 14:32'!successorSequences	"sent to last instruction in sequence which is expected to be a jump and return instruction"	^ #()! !!IRJump commentStamp: 'ajh 3/24/2003 23:56' prior: 0!Instruction "goto: labelNum"!!IRJump methodsFor: 'accessing' stamp: 'ajh 3/10/2003 23:08'!destination	^ destination! !!IRJump methodsFor: 'accessing' stamp: 'ajh 3/10/2003 23:08'!destination: sequence	destination _ sequence! !!IRJump methodsFor: 'interpret' stamp: 'ajh 3/10/2003 00:47'!executeOn: interpreter	^ interpreter goto: destination orderNumber! !!IRJump methodsFor: 'testing' stamp: 'ajh 3/11/2003 00:19'!isGoto	"is unconditional jump"	^ true! !!IRJump methodsFor: 'testing' stamp: 'ajh 3/11/2003 00:22'!isJump	"goto or if"	^ true! !!IRJump methodsFor: 'accessing' stamp: 'ajh 3/11/2003 00:02'!successorSequences	^ {destination}! !!IRJumpIf commentStamp: 'ajh 3/24/2003 23:56' prior: 0!Instruction "if: boolean goto: labelNum1 otherwise: labelNum2"!!IRJumpIf methodsFor: 'acessing' stamp: 'ajh 3/10/2003 00:43'!boolean	^ boolean! !!IRJumpIf methodsFor: 'acessing' stamp: 'ajh 3/10/2003 00:43'!boolean: bool	boolean _ bool! !!IRJumpIf methodsFor: 'interpret' stamp: 'ajh 3/10/2003 00:47'!executeOn: interpreter	^ interpreter if: boolean goto: destination orderNumber otherwise: otherwise orderNumber! !!IRJumpIf methodsFor: 'testing' stamp: 'ajh 3/11/2003 00:19'!isGoto	"is unconditional jump"	^ false! !!IRJumpIf methodsFor: 'testing' stamp: 'ajh 3/11/2003 00:21'!isIf	^ true! !!IRJumpIf methodsFor: 'acessing' stamp: 'ajh 3/10/2003 00:43'!otherwise	^ otherwise! !!IRJumpIf methodsFor: 'acessing' stamp: 'ajh 3/10/2003 00:44'!otherwise: sequence	otherwise _ sequence! !!IRJumpIf methodsFor: 'acessing' stamp: 'ajh 3/11/2003 00:02'!successorSequences	^ {destination. otherwise}! !!IRJumpOverBlock methodsFor: 'accessing' stamp: 'md 10/8/2004 15:18'!blockSequence	^blockSequence! !!IRJumpOverBlock methodsFor: 'accessing' stamp: 'md 10/8/2004 15:18'!blockSequence: instr	blockSequence := instr.! !!IRJumpOverBlock methodsFor: 'interpret' stamp: 'md 10/20/2004 20:44'!executeOn: interpreter	^ interpreter jumpOverBlock:  blockSequence orderNumber to: destination orderNumber! !!IRJumpOverBlock methodsFor: 'testing' stamp: 'md 10/8/2004 15:19'!isJumpOverBlock	^true.! !!IRJumpOverBlock methodsFor: 'accessing' stamp: 'md 10/8/2004 15:18'!successorSequences	^ {destination. blockSequence} ! !!IRPop commentStamp: 'ajh 3/24/2003 23:57' prior: 0!Instruction "popTop"!!IRPop methodsFor: 'interpret' stamp: 'ajh 3/10/2003 00:47'!executeOn: interpreter	^ interpreter popTop! !!IRReturn commentStamp: 'ajh 3/24/2003 23:57' prior: 0!Instruction "returnTop" or "remoteReturn"!!IRBlockReturnTop methodsFor: 'interpret' stamp: 'md 10/8/2004 16:04'!executeOn: interpreter	interpreter blockReturnTop.! !!IRBlockReturnTop methodsFor: 'testing' stamp: 'md 10/8/2004 16:04'!isBlockReturnTop	^true.! !!IRBlockReturnTop methodsFor: 'testing' stamp: 'md 10/21/2004 18:38'!isRemote	^false.! !!IRBlockReturnTop methodsFor: 'accessing' stamp: 'md 10/8/2004 16:04'!successor: anObject	successor := anObject. ! !!IRBlockReturnTop methodsFor: 'accessing' stamp: 'md 10/8/2004 16:04'!successorSequences	"sent to last instruction in sequence which is expected to be a jump and return instruction"	^  { successor }! !!IRReturn methodsFor: 'interpret' stamp: 'ajh 3/10/2003 00:48'!executeOn: interpreter	^ isRemote		ifTrue: [interpreter remoteReturn]		ifFalse: [interpreter returnTop]! !!IRReturn methodsFor: 'accessing' stamp: 'ajh 3/10/2003 00:44'!isRemote	^ isRemote! !!IRReturn methodsFor: 'accessing' stamp: 'ajh 3/10/2003 00:44'!isRemote: boolean	isRemote _ boolean! !!IRReturn methodsFor: 'testing' stamp: 'ajh 3/10/2003 16:10'!isReturn	^ true! !!IRSend commentStamp: 'ajh 3/24/2003 23:57' prior: 0!Instruction "send: selector" or "send: selector toSuperOf: behavior"!!IRSend methodsFor: 'interpret' stamp: 'ajh 3/10/2003 00:48'!executeOn: interpreter	^ superOf		ifNil: [interpreter send: selector]		ifNotNil: [interpreter send: selector toSuperOf: superOf]! !!IRSend methodsFor: 'testing' stamp: 'md 11/12/2004 15:56'!isMessageSend	^true.! !!IRSend methodsFor: 'testing' stamp: 'md 11/12/2004 15:57'!isSend	^true.! !!IRSend methodsFor: 'testing' stamp: 'md 10/10/2005 17:37'!isSuperSend    ^superOf notNil! !!IRSend methodsFor: 'accessing' stamp: 'md 6/23/2005 13:45'!selector	^selector! !!IRSend methodsFor: 'accessing' stamp: 'ajh 3/10/2003 00:44'!selector: symbol	selector _ symbol! !!IRSend methodsFor: 'accessing' stamp: 'md 6/23/2005 13:49'!senderselector	^self method selector! !!IRSend methodsFor: 'accessing' stamp: 'ajh 3/10/2003 00:45'!superOf	^ superOf! !!IRSend methodsFor: 'accessing' stamp: 'ajh 3/10/2003 00:45'!superOf: behavior	superOf _ behavior! !!ClosureEnvInspector methodsFor: 'selecting' stamp: 'ajh 7/7/2004 16:50'!accept: aString	| result |	selectionIndex <= 2 ifTrue: [^ false].	context ifNil: [^ super accept: aString].	self eval: self selectedSlotName , ' _ ' , aString ifFail: [^ false].	self update.	^ true! !!ClosureEnvInspector methodsFor: 'accessing' stamp: 'ajh 7/7/2004 16:13'!doItContext	"Use my context. May be nil, in which case doItReceiver will be the context"	^ context! !!ClosureEnvInspector methodsFor: 'accessing' stamp: 'ajh 7/7/2004 16:12'!doItReceiver	"My doItContext will take precedence"	^ object! !!ClosureEnvInspector methodsFor: 'selecting' stamp: 'ajh 7/7/2004 16:57'!eval: string ifFail: block	^ self doItReceiver class evaluatorClass new		evaluate2: (ReadStream on: string)		in: self doItContext		to: self doItReceiver		notifying: nil	"fix this"		ifFail:  block		logged: false! !!ClosureEnvInspector methodsFor: 'accessing' stamp: 'ajh 7/7/2004 16:05'!fieldList 	"Refer to the comment in Inspector|fieldList."	object == nil ifTrue: [^ #('thisEnv')].	^ #('thisEnv' 'all free vars'), self freeNames! !!ClosureEnvInspector methodsFor: 'accessing' stamp: 'ajh 7/7/2004 16:35'!freeNames	context ifNil: [^ (1 to: object size) collect: [:i | i printString]].	^ context freeNames! !!ClosureEnvInspector methodsFor: 'accessing' stamp: 'ajh 7/7/2004 16:34'!freeNamesAndValues	context ifNil: [		| stream |		stream _ '' writeStream.		1 to: object size do: [:i |			stream print: i; nextPut: $:; space; tab.			(object at: i) printOn: stream.			stream cr].		^ stream contents	].	^ context freeNamesAndValues! !!ClosureEnvInspector methodsFor: 'accessing' stamp: 'ajh 7/8/2004 20:12'!object: anObject 	"Same as super, except always update fields even if the object is the same, because the same closureEnvironment (object) can have different free vars depending on the context."	| oldIndex |	oldIndex _ selectionIndex <= 2 ifTrue: [selectionIndex] ifFalse: [0].	self inspect: anObject.	oldIndex _ oldIndex min: self fieldList size.	self changed: #inspectObject.	oldIndex > 0		ifTrue: [self toggleIndex: oldIndex].	self changed: #fieldList.	self changed: #contents.! !!ClosureEnvInspector methodsFor: 'selecting' stamp: 'ajh 7/7/2004 16:46'!replaceSelectionValue: anObject 	"Refer to the comment in Inspector|replaceSelectionValue:."	object at: selectionIndex - 2 put: anObject! !!ClosureEnvInspector methodsFor: 'selecting' stamp: 'ajh 7/7/2004 17:41'!selection 	"Refer to the comment in Inspector|selection."	selectionIndex = 0 ifTrue:[^ ''].	selectionIndex = 1 ifTrue: [^ object].	selectionIndex = 2 ifTrue: [^ self freeNamesAndValues].	context ifNil: [^ object at: selectionIndex - 2].	^ self eval: (self freeNames at: selectionIndex - 2)		ifFail: [self error: 'bug']! !!SemanticWarning commentStamp: 'ajh 7/7/2004 17:36' prior: 0!If a variable is not found or some other problem occurs during checking (ASTChecker) than a particular subclass instance of me is signal, usually causing a notification to the user. If not handled, the default handling is done, and compiling continues.!!SemanticWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/12/2003 14:28'!correctIn: compiler	self subclassResponsibility! !!SemanticWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/11/2003 14:54'!isResumable	^ true! !!ShadowVariableWarning commentStamp: 'ajh 3/24/2003 22:21' prior: 0!I get signalled when a variable in a block or method scope shadows a variable of the same name in an outer scope.  The default action is to allow it.!!ShadowVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/19/2003 16:42'!correctIn: compiler	self resume: (compiler variable: self variableNode shadows: self shadowedVar)! !!ShadowVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/19/2003 13:34'!defaultAction	"allow variable to shadow previous/inst var of the same name"	^ nil! !!ShadowVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/19/2003 13:32'!shadowedVar	^ shadowedVar! !!ShadowVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/19/2003 13:32'!shadowedVar: semVar	shadowedVar _ semVar! !!ShadowVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/19/2003 13:19'!variableNode	^ variableNode! !!ShadowVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/19/2003 13:24'!variableNode: aVariableNode	variableNode _ aVariableNode.	messageText _ 'Temp shadows: ', aVariableNode name.! !!UndeclaredSelectorWarning commentStamp: 'ajh 3/24/2003 22:23' prior: 0!I get signalled when no selector is defined for a message send, indicating a possible mispelling.  My default action is to create a new selector.!!UndeclaredSelectorWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/12/2003 14:28'!correctIn: compiler	self resume: (compiler correctSelector: self messageNode)! !!UndeclaredSelectorWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/24/2003 22:30'!defaultAction	"create new selector"	^ messageNode selectorString asSymbol! !!UndeclaredSelectorWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/11/2003 22:43'!messageNode	^ messageNode! !!UndeclaredSelectorWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/11/2003 23:37'!messageNode: aMessageNode	messageNode _ aMessageNode.	messageText _ 'Unknown selector: ', aMessageNode selectorString.! !!UndeclaredVariableWarning commentStamp: 'ajh 3/24/2003 22:33' prior: 0!I get signalled when an unknown variable it references.  My default action is to raise an warning.!!UndeclaredVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/12/2003 14:28'!correctIn: compiler	self resume: (compiler correctVariable: self variableNode)! !!UndeclaredVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/11/2003 12:05'!variableNode	^ variableNode! !!UndeclaredVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/11/2003 23:37'!variableNode: aVariableNode	variableNode _ aVariableNode.	messageText _ 'Undeclared variable: ', aVariableNode name.! !!UninitializedVariableWarning commentStamp: 'ajh 3/24/2003 22:34' prior: 0!I get signalled when a temporary variable is used before it is assigned to.  My default action is to allow it since all temps get initialized to nil.!!UninitializedVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/12/2003 14:28'!correctIn: compiler	self resume: (compiler queryUninitializedTemp: self variableNode)! !!UninitializedVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/12/2003 13:37'!defaultAction	"unitialized temp will be initialized to nil, so ignore this warning if not handled"	^ nil! !!UninitializedVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/12/2003 13:25'!variableNode	^ variableNode! !!UninitializedVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/12/2003 14:08'!variableNode: aVariableNode	variableNode _ aVariableNode.	messageText _ 'Uninitialized temp: ', aVariableNode name.! !!UnusedVariableWarning commentStamp: 'ajh 3/24/2003 22:35' prior: 0!I get signalled when a temporary variable is declared but never used.  My default action is to allow it since it is benign.!!UnusedVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/12/2003 14:28'!correctIn: compiler	self resume: (compiler removeUnusedTemp: self variableNode)! !!UnusedVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/12/2003 14:07'!defaultAction	"unused temp will be ignored, so ignore this warning if not handled"	^ nil! !!UnusedVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/12/2003 14:06'!variableNode	^ variableNode! !!UnusedVariableWarning methodsFor: 'as yet unclassified' stamp: 'ajh 3/12/2003 14:07'!variableNode: aVariableNode	variableNode _ aVariableNode.	messageText _ 'Unused temp: ', aVariableNode name.! !!SqueakParser commentStamp: 'ajh 3/24/2003 18:24' prior: 0!I parse Smalltalk text into a Refactory abstract syntax tree, whose root is RBMethodNode or RBDoItNode.  Methods under 'generated-*' categories were automatically generated using SmaCC.!!SqueakParser class methodsFor: 'parsing' stamp: 'ajh 2/27/2003 16:40'!parseDoIt: stringOrStream	| sequence |	sequence _ self		parseStream: stringOrStream readStream		startingAt: self startingStateForSequence.	^ (RBDoItNode body: sequence)		source: stringOrStream contents! !!SqueakParser class methodsFor: 'parsing' stamp: 'ajh 2/27/2003 16:40'!parseMethod: stringOrStream	^ (self		parseStream: stringOrStream readStream		startingAt: self startingStateForMethod)		source: stringOrStream contents! !!SqueakParser class methodsFor: 'parsing' stamp: 'ms 7/15/2006 19:20'!parseMethodPattern: stringOrStream	"to be remove: instead use #parseMethodPattern: "		^self parseMethod: stringOrStream	"| array comments |	array :=		[self			parseStream: stringOrStream readStream			startingAt: self startingStateForMethodPattern		] on: SmaCCParserError do: [:ex | | parser |			parser := ex tag.			comments := parser scanner comments.			parser nodeStack size = 1 ifFalse: [ex pass].			parser nodeStack last		].	^RBMethodNode new		selectorParts: array first arguments: array last;		comments: comments"! !!SqueakParser class methodsFor: 'generated-comments' stamp: 'ms 8/5/2006 14:11'!parserDefinitionComment	"%id <name> <number> <negativeNumber> <binarySymbol> <period>;%start Sequence MethodPattern;Method:	MethodPattern Sequence						{#method:}|	MethodPattern Pragmas Sequence			{#methodPragma:}|	MethodPattern Pragmas Temporaries Pragmas Statements {#methodPragmaTempsPragma:}|	MethodPattern Temporaries Pragmas Statements {#methodTempsPragma:};MethodPattern:	<name>										{#unaryMessage:}|	<binarySymbol> Variable						{#messagePart:}|	KeywordMethodPattern						{#first:};KeywordMethodPattern:	<keyword> Variable							{#messagePart:}|	KeywordMethodPattern <keyword> Variable	{#addMessagePart:};Pragmas:	""<"" PragmaMessage "">""						{#pragma:}|	Pragmas ""<"" PragmaMessage "">""				{#pragmas:};Sequence:	Statements									{#sequence:}|	Temporaries Statements						{#sequenceWithTemps:};Temporaries:	""||""											{#array}|	""|"" TemporaryVariables ""|""					{#second:};TemporaryVariables:												{#array}|	TemporaryVariables Variable				{#add:};Statements:												{#array}|	StatementList <period>?						{#first:}|	StatementList <period> ""^"" Expression <period>?	{#returnAdd:}|	""^"" Expression <period>?						{#return:};StatementList:	Expression									{#firstIn:}|	StatementList <period> Expression				{#add3:};Block:	""["" BlockArgs ""|"" Sequence ""]""					{#blockWithArgs:}|	""["" Sequence ""]""								{#blockNoArgs:}|	""["" BlockArgs ""]""								{#blockArgs:}|	""["" BlockArgs ""||"" TemporaryVariables ""|"" Statements ""]"" {#blockWithTemps:};BlockArgs:	"":"" Variable									{#secondIn:}|	BlockArgs "":"" Variable						{#add3:};Expression:	Assignment									{#first:}|	Cascade										{#first:}|	Primary									{#first:};Primary:	""("" Expression "")""								{#second:}|	Array										{#first:}|	Block										{#first:}|	Literal										{#first:}|	Variable									{#first:};Assignment:	Variable <assignment> Expression				{#assignment:};Cascade:	MessageSend								{#first:}|	Cascade "";"" Message							{#cascade:};MessageSend:	KeywordMessageSend						{#first:}|	BinaryMessageSend							{#first:}|	UnaryMessageSend							{#first:};Message:	UnaryMessage								{#first:}|	BinaryMessage								{#first:}|	KeywordMessage							{#first:};KeywordMessageSend:	BinaryMessageSend KeywordMessage			{#messageSend:}|	UnaryMessageSend KeywordMessage			{#messageSend:}|	Primary KeywordMessage					{#messageSend:};KeywordMessage:	<keyword> KeywordArgument				{#messagePart:}|	KeywordMessage <keyword> KeywordArgument {#addMessagePart:};KeywordArgument:	BinaryMessageSend							{#first:}|	UnaryMessageSend							{#first:}|	Primary									{#first:};BinaryMessageSend:	BinaryMessageSend BinaryMessage			{#messageSend:}|	UnaryMessageSend BinaryMessage			{#messageSend:}|	Primary BinaryMessage						{#messageSend:};BinaryMessage :	<binarySymbol> BinaryArgument				{#messagePart:};BinaryArgument:	UnaryMessageSend							{#first:}|	Primary									{#first:};UnaryMessageSend :	UnaryMessageSend UnaryMessage			{#messageSend:}|	Primary UnaryMessage						{#messageSend:};UnaryMessage :	<name>										{#unaryMessage:};Array:	""{"" Statements ""}""								{#array:};Variable:	<name>										{#variable:};Literal:	""true""										{#litTrue:}|	""false""										{#litFalse:}|	""nil""										{#litNil:}|	<number>									{#litNumber:}|	<negativeNumber>							{#litNumber:} |	<character>									{#litChar:}|	<string>										{#litString:}|	""#"" <string>									{#litStringSymbol:}|	""#"" <name>									{#litSymbol:}|	""#"" <binarySymbol>							{#litSymbol:}|	""#"" <keyword>								{#litSymbol:}|	""#"" <multikeyword>							{#litSymbol:}|	""#"" <alternateKeyword>						{#litSymbol:}|	""#"" ""["" ByteArray ""]""							{#litArray:}|	""#"" ""("" LiteralArray "")""						{#litArray:}|	""#:""								{#litString:};ByteArray:												{#byteStream}|	ByteArray <number>							{#byteStreamPut:};LiteralArray:												{#stream}|	LiteralArray ArrayLiteral					{#streamPut:};ArrayLiteral:	Literal										{#value:}|	<name>										{#valueSymbol:}|	<binarySymbol>								{#valueSymbol:}|	<keyword>									{#valueSymbol:}|	<multikeyword>								{#valueSymbol:}|	<alternateKeyword>							{#valueSymbol:}|	""("" LiteralArray "")""							{#contents2:}|	""["" ByteArray ""]""							{#contents2:}|	<anyChar>									{#valueSymbol:};PragmaMessage:	Apicall										{#messagePragma:}| 	Primitive 									{#messagePragma:} |	MessagePragma 								{#messagePragma:};MessagePragma:	KeyWordMessagePragma						{#pragmaKeyWordMessage:}|	UnaryMessage 								{#pragmaUnaryMessage:};										KeyWordMessagePragma:	<keyword> PrimaryPragma					{#messagePart:}|	KeywordMessage <keyword> PrimaryPragma	{#addMessagePart:};PrimaryPragma:	Array										{#first:}|	Block										{#first:}|	Literal										{#first:}|	Variable									{#first:};Apicall:	TypeCall ExternalType IndexName ""("" ParameterApicall "")""					{#externalCall:}|	TypeCall ExternalType IndexName ""("" ParameterApicall "")"" ""module:"" <string>	{#externalModuleCall:};IndexName:	<string>										{#externalFunction:}|	<number>									{#externalIndex:};TypeCall:	""apicall:""									{#callConvention:}|	""cdecl:""										{#callConvention:};ParameterApicall:	ExternalType 								{#parameterExtCall:}|	ParameterApicall ExternalType 				{#parametersExtCall:};ExternalType:	<name>										{#externalType:}	|	<name> ""*""									{#externalTypePointer:};Primitive:	""primitive:"" <string>							{#primitiveString:}|	""primitive:"" <number>						{#primitiveNumber:}|	""primitive:"" <string> ""module:"" <string>		{#primitiveModule:};"! !!SqueakParser class methodsFor: 'generated-accessing' stamp: 'ms 8/5/2006 14:11'!scannerClass	^SqueakScanner! !!SqueakParser class methodsFor: 'generated-starting states' stamp: 'ms 8/5/2006 14:11'!startingStateForMethod	^1! !!SqueakParser class methodsFor: 'generated-starting states' stamp: 'ms 8/5/2006 14:11'!startingStateForMethodPattern	^3! !!SqueakParser class methodsFor: 'generated-starting states' stamp: 'ms 8/5/2006 14:11'!startingStateForSequence	^2! !!SqueakParser methodsFor: 'private' stamp: 'ms 7/13/2006 10:02'!actionForCurrentToken	| ids action |	ids := currentToken id.	1 to: ids size do: [:i | 		action := self actionFor: (ids at: i).		(action bitAnd: self actionMask) = self errorAction ifFalse: [^ action].		"Convert negative number to binarySymbol"		(self isNegativeNumberId:(ids at: i)) ifTrue: [			^self negativeNumberToBinaryString].		"Ignore repeating periods"		(self isEmptyStatementId: (ids at: i)) ifTrue: [			^ self ignoreEmptyStatement].	].	^ self errorAction! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:01'!add3: nodes	^ nodes first copyWith: nodes third! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:59'!add: nodes	^ nodes first copyWith: nodes second! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:54'!addMessagePart: nodes	^ {nodes first first copyWith: nodes second.	   nodes first second copyWith: nodes third}! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:58'!array	^ #()! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:30'!array: nodes	^ RBArrayNode		leftBrace: nodes first start		rightBrace: nodes third stop		statements: nodes second! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:07'!assignment: nodes	^ RBAssignmentNode		variable: nodes first		value: nodes third! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:04'!blockArgs: nodes	^ (RBBlockNode		arguments: nodes second		body: (RBSequenceNode statements: #()))		left: nodes first start;		right: nodes third stop! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:03'!blockNoArgs: nodes	^ (RBBlockNode		body: nodes second)		left: nodes first start;		right: nodes third stop! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:02'!blockWithArgs: nodes	^ (RBBlockNode		arguments: nodes second		body: nodes fourth)		left: nodes first start;		right: nodes fifth stop! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:06'!blockWithTemps: nodes	^ (RBBlockNode		arguments: nodes second		body: (RBSequenceNode			temporaries: nodes fourth			statements: nodes sixth))		left: nodes first start;		right: nodes seventh stop! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:23'!byteStream	^ ByteArray new writeStream! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:25'!byteStreamPut: nodes	^ nodes first		nextPut: nodes second value asNumber;		yourself! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/4/2006 00:18'!callConvention: nodes	| descriptorClass |	descriptorClass := Smalltalk at: #ExternalFunction ifAbsent:[^nil].	^descriptorClass callingConventionFor: nodes first value.! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:12'!cascade: nodes	^ (nodes first isKindOf: RBMessageNode)		ifTrue: [RBCascadeNode messages:			{nodes first.			 RBMessageNode new				receiver: nodes first receiver				selectorParts: nodes third first				arguments: nodes third last}]		ifFalse: [RBCascadeNode messages:			(nodes first messages copyWith:				(RBMessageNode new					receiver: nodes first messages first receiver					selectorParts: nodes third first					arguments: nodes third last))]! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:27'!contents2: nodes	^ nodes second contents! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 7/26/2006 22:18'!externalCall: nodes	| fn |	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|		fn := xfn name: nodes third				module: nil 				callType: nodes first				returnType: nodes second				argumentTypes: nodes fifth contents.	].	^ OrderedCollection with: (Pragma keyword: #primitive: arguments: #(120)) with: fn with: 120! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 7/25/2006 13:37'!externalFunction: nodes	^nodes first value withoutQuoting asSymbol.! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 7/25/2006 13:37'!externalIndex: nodes	^nodes first value.! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 7/26/2006 22:18'!externalModuleCall: nodes	| fn |	Smalltalk at: #ExternalLibraryFunction ifPresent:[:xfn|		fn := xfn name: nodes third 				module: nodes last value withoutQuoting asSymbol				callType: nodes first				returnType: nodes second				argumentTypes: nodes fifth contents.	].	^ OrderedCollection with: (Pragma keyword: #primitive: arguments: #(120)) with: fn with: 120! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 7/20/2006 01:02'!externalType: nodes	^self externalTypeOn: nodes	! !!SqueakParser methodsFor: 'private' stamp: 'ms 9/4/2006 00:20'!externalTypeOn: aNode	| xType descriptorClass |	descriptorClass := Smalltalk at: #ExternalFunction ifAbsent:[^nil].	xType := descriptorClass atomicTypeNamed: aNode first value.	xType == nil ifTrue:["Look up from class scope"		Symbol hasInterned: aNode first value ifTrue:[:sym|			xType := descriptorClass structTypeNamed: sym]].	xType == nil ifTrue:[		"Raise an error if user is there"		self interactive ifTrue:[^nil].		"otherwise go over it silently"		xType := descriptorClass forceTypeNamed: aNode first value].	^xType.! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/4/2006 00:27'!externalTypePointer: nodes	| xType |	xType := self externalTypeOn: nodes.	xType ifNil:[^nodes].	^xType asPointerType! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:53'!first: nodes	^ nodes first! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:01'!firstIn: nodes	^ {nodes first}! !!SqueakParser methodsFor: 'private' stamp: 'ms 7/13/2006 09:48'!ignoreEmptyStatement		currentToken _ nil.	self getNextToken.	^ self actionForCurrentToken! !!SqueakParser methodsFor: 'private' stamp: 'ms 7/13/2006 09:59'!isEmptyStatementId: id	^ ((id = scanner periodId) and: [nodeStack isEmpty]) 		or: [(id = scanner periodId) and: [(nodeStack last isKindOf: SmaCCToken) and: [nodeStack last id first = scanner periodId]]] ! !!SqueakParser methodsFor: 'private' stamp: 'ms 7/13/2006 09:58'!isNegativeNumberId: id	^ scanner negativeNumberId = id! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/17/2003 12:10'!litArray: nodes	^ RBLiteralNode		literalToken: (SmaCCToken			value: (String new: (nodes fourth stop - nodes second start + 1))			start: nodes second start)		value: nodes third contents! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:16'!litChar: nodes	^ RBLiteralNode		literalToken: nodes first		value: (nodes first value at: 2)! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:14'!litFalse: nodes	^ RBLiteralNode		literalToken: nodes first		value: false! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:14'!litNil: nodes	^ RBLiteralNode		literalToken: nodes first		value: nil! !!SqueakParser methodsFor: 'reduction actions' stamp: 'md 10/18/2004 17:23'!litNumber: nodes	| str num |	str _ nodes first value readStream.	num _ Number readFrom: str.	str atEnd ifFalse: [		currentToken _ nil.		scanner position: scanner position - (str originalContents size - str position) + 1.		self reportErrorMessage: 'Digit out of range'].	^ RBLiteralNode		literalToken: nodes first		value: num! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:18'!litString: nodes	| s |	s _ nodes first value.	^ RBLiteralNode		literalToken: nodes first		value: ((s copyFrom: 2 to: s size - 1)				copyReplaceAll: '''''' with: '''')! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:19'!litStringSymbol: nodes	| s |	s _ nodes second value.	^ RBLiteralNode		literalToken: nodes second		value: ((s copyFrom: 2 to: s size - 1)				copyReplaceAll: '''''' with: '''') asSymbol! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:20'!litSymbol: nodes	^ RBLiteralNode		literalToken: nodes second		value: nodes second value asSymbol! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:14'!litTrue: nodes	^ RBLiteralNode		literalToken: nodes first		value: true! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:52'!messagePart: nodes	^ {{nodes first}. {nodes second}}! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 7/22/2006 14:39'!messagePragma: nodes	"self haltIf: [(nodes first first isKindOf: Pragma) not]."	^nodes first! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:13'!messageSend: nodes	^ RBMessageNode new		receiver: nodes first		selectorParts: nodes second first		arguments: nodes second last! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:48'!method: nodes	^ RBMethodNode new		selectorParts: nodes first first		arguments: nodes first last;		body: nodes second! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 7/15/2006 19:07'!methodPragma: nodes	^RBMethodNode new		selectorParts: nodes first first		arguments: nodes first last;		body: nodes third;		pragmas:nodes second! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/3/2006 23:53'!methodPragmaTempsPragma: nodes	^ RBMethodNode new 		selectorParts: nodes first first		arguments: nodes first last;		body: (RBSequenceNode			temporaries: nodes third			statements: nodes fifth);		pragmas: (nodes second addAll: nodes fourth; yourself)! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 7/15/2006 19:07'!methodTempsPragma: nodes	^ RBMethodNode new		selectorParts: nodes first first		arguments: nodes first last;		body: (RBSequenceNode			temporaries: nodes second			statements: nodes fourth);		pragmas: nodes third! !!SqueakParser methodsFor: 'private' stamp: 'ms 7/13/2006 10:01'!negativeNumberToBinaryString		currentToken := SmaCCToken 		value: '-'		start: currentToken startPosition		id: (Array with: scanner binarySymbolId).	scanner position: currentToken stopPosition.	^ self actionForCurrentToken! !!SqueakParser methodsFor: 'private' stamp: 'ajh 3/6/2003 00:02'!nodeStack	^ nodeStack! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 7/20/2006 18:01'!parameterExtCall: nodes	| args |	args := WriteStream on: Array new.	args nextPut: nodes first.	^args! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 7/20/2006 17:59'!parametersExtCall: nodes	^nodes first nextPut: (nodes second); yourself! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/3/2006 23:26'!pragma: nodes	"self haltIf: [nodes second first isKindOf: Pragma]."	"| pragmaNode |	pragmaNode := RBPragmasNode withPragma: nodes second first spec: nodes second second.	nodes second third ifNotNil: [pragmaNode primitiveNumber: nodes second third].	^pragmaNode"		| rbPragma |	rbPragma := RBPragmaNode pragma: nodes second first spec: nodes second second start: nodes first start stop: nodes third stop.	nodes second third ifNotNil: [rbPragma primitiveNumber: nodes second third].	^OrderedCollection with: rbPragma! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 8/5/2006 14:03'!pragmaKeyWordMessage: nodes	| arguments keyword |	keyword := String new.	arguments := (nodes first second collect: [:each | each value]).	nodes first first do: [:each | keyword := keyword, each value].	^OrderedCollection with:(Pragma keyword: keyword asSymbol arguments: arguments)					  with: nil					  with: nil			! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 7/26/2006 22:17'!pragmaUnaryMessage: nodes	^OrderedCollection with:(Pragma keyword: nodes first first first value asSymbol arguments: nodes first second)					  with: nil					  with: nil			! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 9/3/2006 23:48'!pragmas: nodes	"nodes first addPragma: nodes third first withSpec: nodes third second.	nodes third third ifNotNil: [nodes first primitiveNumber: nodes third third].	^nodes first"		| rbPragma |	rbPragma := RBPragmaNode pragma: nodes third first spec: nodes third second start: nodes second start stop: nodes fourth stop.	nodes third third ifNotNil: [rbPragma primitiveNumber: nodes third third].	nodes first add: rbPragma.	^nodes first	! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 7/26/2006 22:16'!primitiveModule: nodes	^OrderedCollection with: (Pragma keyword: #primitive:module: 									 arguments: (Array with: nodes second value withoutQuoting asSymbol														with: nodes fourth value withoutQuoting asSymbol)) 					  with: (Array with: nodes fourth value withoutQuoting asSymbol 								    with: nodes second value withoutQuoting asSymbol 								    with: 0 with: 0)					  with: 117	! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 7/26/2006 22:32'!primitiveNumber: nodes	^OrderedCollection with: (Pragma keyword: #primitive: arguments: (Array with: nodes second value asInteger)) 					  with: nil					  with: nodes second value asInteger	! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ms 7/26/2006 22:33'!primitiveString: nodes	^OrderedCollection with: (Pragma keyword: #primitive: 									 arguments: (Array with: nodes second value withoutQuoting asSymbol)) 					   with: (Array with: nil 									with: nodes second value withoutQuoting asSymbol 									with: 0 with: 0)					   with: 117! !!SqueakParser methodsFor: 'generated-reduction actions' stamp: 'ms 8/5/2006 14:11'!reduceActionForOptionalXXXperiodX1: nodes 	^ nil! !!SqueakParser methodsFor: 'generated-reduction actions' stamp: 'ms 8/5/2006 14:11'!reduceActionForOptionalXXXperiodX2: nodes 	^ nodes at: 1! !!SqueakParser methodsFor: 'generated-tables' stamp: 'ms 8/5/2006 14:11'!reduceTable	^#(#(39 1 #messagePragma:)#(39 1 #messagePragma:)#(39 1 #messagePragma:)#(40 0 #array)#(40 2 #add:)#(41 1 #firstIn:)#(41 3 #add3:)#(42 0 #array)#(42 2 #first:)#(42 5 #returnAdd:)#(42 3 #return:)#(43 1 #first:)#(43 1 #first:)#(43 1 #first:)#(44 2 #secondIn:)#(44 3 #add3:)#(45 5 #blockWithArgs:)#(45 3 #blockNoArgs:)#(45 3 #blockArgs:)#(45 7 #blockWithTemps:)#(46 3 #assignment:)#(47 1 #first:)#(47 3 #cascade:)#(48 3 #second:)#(48 1 #first:)#(48 1 #first:)#(48 1 #first:)#(48 1 #first:)#(49 3 #array:)#(50 1 #litTrue:)#(50 1 #litFalse:)#(50 1 #litNil:)#(50 1 #litNumber:)#(50 1 #litNumber:)#(50 1 #litChar:)#(50 1 #litString:)#(50 2 #litStringSymbol:)#(50 2 #litSymbol:)#(50 2 #litSymbol:)#(50 2 #litSymbol:)#(50 2 #litSymbol:)#(50 2 #litSymbol:)#(50 4 #litArray:)#(50 4 #litArray:)#(50 1 #litString:)#(51 1 #array)#(51 3 #second:)#(52 1 #first:)#(52 1 #first:)#(52 1 #first:)#(53 1 #first:)#(53 1 #first:)#(53 1 #first:)#(54 2 #messageSend:)#(54 2 #messageSend:)#(54 2 #messageSend:)#(55 2 #messageSend:)#(55 2 #messageSend:)#(55 2 #messageSend:)#(56 2 #messageSend:)#(56 2 #messageSend:)#(57 1 #unaryMessage:)#(58 2 #messagePart:)#(58 3 #addMessagePart:)#(59 2 #messagePart:)#(59 3 #addMessagePart:)#(60 1 #first:)#(60 1 #first:)#(60 1 #first:)#(61 1 #first:)#(61 1 #first:)#(62 1 #variable:)#(63 3 #pragma:)#(63 4 #pragmas:)#(64 1 #unaryMessage:)#(64 2 #messagePart:)#(64 1 #first:)#(65 1 #sequence:)#(65 2 #sequenceWithTemps:)#(66 0 #byteStream)#(66 2 #byteStreamPut:)#(67 0 #stream)#(67 2 #streamPut:)#(68 1 #value:)#(68 1 #valueSymbol:)#(68 1 #valueSymbol:)#(68 1 #valueSymbol:)#(68 1 #valueSymbol:)#(68 1 #valueSymbol:)#(68 3 #contents2:)#(68 3 #contents2:)#(68 1 #valueSymbol:)#(69 2 #method:)#(69 3 #methodPragma:)#(69 5 #methodPragmaTempsPragma:)#(69 4 #methodTempsPragma:)#(70 6 #externalCall:)#(70 8 #externalModuleCall:)#(71 2 #primitiveString:)#(71 2 #primitiveNumber:)#(71 4 #primitiveModule:)#(72 1 #pragmaKeyWordMessage:)#(72 1 #pragmaUnaryMessage:)#(73 2 #messagePart:)#(73 3 #addMessagePart:)#(74 1 #first:)#(74 1 #first:)#(74 1 #first:)#(74 1 #first:)#(75 1 #callConvention:)#(75 1 #callConvention:)#(76 1 #externalType:)#(76 2 #externalTypePointer:)#(77 1 #externalFunction:)#(77 1 #externalIndex:)#(78 1 #parameterExtCall:)#(78 2 #parametersExtCall:)#(81 2 #messagePart:)#(82 1 #reduceFor:)#(83 0 #reduceActionForOptionalXXXperiodX1:)#(83 1 #reduceActionForOptionalXXXperiodX2:))! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/19/2003 13:49'!return: nodes	^ {RBReturnNode		return: nodes first start		value: nodes second}! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/19/2003 13:49'!returnAdd: nodes	^ nodes first copyWith: (RBReturnNode		return: nodes third start		value: nodes fourth)! !!SqueakParser methodsFor: 'private' stamp: 'ajh 3/6/2003 00:19'!scanner	^ scanner! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:58'!second: nodes	^ nodes second! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:06'!secondIn: nodes	^ {nodes second}! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:57'!sequence: nodes	^ RBSequenceNode		statements: nodes first! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:58'!sequenceWithTemps: nodes	^ RBSequenceNode		temporaries: nodes first		statements: nodes second! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:23'!stream	^ Array new writeStream! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:26'!streamPut: nodes	^ nodes first		nextPut: nodes second;		yourself! !!SqueakParser methodsFor: 'generated-tables' stamp: 'ms 8/5/2006 14:11'!transitionTable	^#(#(3 17 27 21 28 25 30 29 58 33 64 37 69)#(3 41 3 45 5 49 6 53 9 57 10 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 105 41 109 42 113 43 117 45 121 46 125 47 129 48 133 49 137 50 141 51 145 52 149 54 153 55 157 56 161 62 165 65 34 79)#(3 17 27 21 28 25 30 29 58 169 64)#(2 302 3 5 6 7 9 10 16 18 20 21 22 23 24 25 26 27 35 79)#(3 97 27 173 62)#(3 97 27 177 62)#(3 310 3 310 5 310 6 310 7 310 9 310 10 310 16 310 18 310 20 310 21 310 22 310 23 310 24 310 25 310 26 310 27 181 28 310 35 310 79)#(3 41 3 45 5 49 6 185 7 53 9 57 10 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 105 41 109 42 113 43 117 45 121 46 125 47 129 48 133 49 137 50 189 51 145 52 149 54 153 55 157 56 161 62 193 63 197 65 34 79)#(2 0 79)#(3 41 3 49 6 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 201 43 117 45 121 46 125 47 129 48 133 49 137 50 145 52 149 54 153 55 157 56 161 62)#(3 41 3 49 6 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 205 43 117 45 121 46 125 47 129 48 133 49 137 50 145 52 149 54 153 55 157 56 161 62)#(3 209 2 41 3 45 5 49 6 53 9 57 10 34 12 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 105 41 109 42 113 43 213 44 117 45 121 46 125 47 129 48 133 49 137 50 141 51 145 52 149 54 153 55 157 56 161 62 217 65)#(2 186 3 5 6 7 12 16 18 20 21 22 23 24 25 26 27 35 79)#(3 18 10 18 27 221 40)#(3 41 3 45 5 49 6 61 16 65 18 34 19 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 105 41 225 42 113 43 117 45 121 46 125 47 129 48 133 49 137 50 145 52 149 54 153 55 157 56 161 62)#(2 182 3 4 6 8 11 12 18 19 20 21 22 23 24 25 26 27 28 29 30 32 35 36 38 79)#(3 229 3 233 6 237 26 241 27 245 28 249 29 253 30 257 32)#(2 122 3 4 6 8 11 12 18 19 20 21 22 23 24 25 26 27 28 29 30 32 35 36 38 79)#(2 130 3 4 6 8 11 12 18 19 20 21 22 23 24 25 26 27 28 29 30 32 35 36 38 79)#(2 126 3 4 6 8 11 12 18 19 20 21 22 23 24 25 26 27 28 29 30 32 35 36 38 79)#(2 134 3 4 6 8 11 12 18 19 20 21 22 23 24 25 26 27 28 29 30 32 35 36 38 79)#(2 138 3 4 6 8 11 12 18 19 20 21 22 23 24 25 26 27 28 29 30 32 35 36 38 79)#(2 146 3 4 6 8 11 12 18 19 20 21 22 23 24 25 26 27 28 29 30 32 35 36 38 79)#(2 290 2 3 4 5 6 7 8 9 10 11 12 16 18 19 20 21 22 23 24 25 26 27 28 30 31 35 36 79)#(2 142 3 4 6 8 11 12 18 19 20 21 22 23 24 25 26 27 28 29 30 32 35 36 38 79)#(3 482 12 482 19 261 36 482 79 265 83)#(2 314 12 79)#(2 26 12 19 36 79)#(2 106 4 11 12 19 27 28 30 36 79)#(2 50 4 12 19 36 79)#(3 54 4 269 11 54 12 54 19 54 36 54 79)#(3 58 4 58 12 58 19 273 27 277 28 281 30 58 36 285 57 289 59 58 79 293 81)#(2 102 4 11 12 19 27 28 30 36 79)#(2 110 4 11 12 19 27 28 30 36 79)#(3 41 3 45 5 49 6 34 12 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 105 41 297 42 113 43 117 45 121 46 125 47 129 48 133 49 137 50 145 52 149 54 153 55 157 56 161 62 34 79)#(2 90 4 11 12 19 36 79)#(2 194 4 11 12 19 36 79)#(3 198 4 198 11 198 12 198 19 277 28 281 30 198 36 301 59 198 79 305 81)#(3 202 4 202 11 202 12 202 19 273 27 277 28 281 30 202 36 309 57 313 59 202 79 317 81)#(3 114 4 114 12 114 19 114 27 114 28 114 30 321 31 114 36 114 79)#(2 0 79)#(2 0 79)#(2 254 3 5 6 7 9 10 16 18 20 21 22 23 24 25 26 27 28 35 79)#(2 306 3 5 6 7 9 10 16 18 20 21 22 23 24 25 26 27 35 79)#(3 97 27 325 62)#(3 329 1 333 14 337 15 273 27 341 28 345 39 349 57 353 59 357 70 361 71 365 72 369 73 373 75)#(3 41 3 45 5 49 6 185 7 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 105 41 297 42 113 43 117 45 121 46 125 47 129 48 133 49 137 50 145 52 149 54 153 55 157 56 161 62 377 63 34 79)#(3 41 3 45 5 49 6 381 7 53 9 57 10 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 105 41 109 42 113 43 117 45 121 46 125 47 129 48 133 49 137 50 385 51 145 52 149 54 153 55 157 56 161 62 389 65 34 79)#(2 374 79)#(2 393 4)#(3 482 12 482 19 397 36 482 79 401 83)#(3 97 27 405 62)#(3 409 2 413 9 417 10 421 12)#(2 425 12)#(3 429 10 97 27 433 62)#(2 437 19)#(3 330 3 330 4 330 6 330 18 330 20 330 21 330 22 330 23 330 24 330 25 330 26 330 27 330 28 330 29 330 30 330 32 330 35 330 38 441 67)#(3 322 12 322 24 445 66)#(2 150 3 4 6 8 11 12 18 19 20 21 22 23 24 25 26 27 28 29 30 32 35 36 38 79)#(2 154 3 4 6 8 11 12 18 19 20 21 22 23 24 25 26 27 28 29 30 32 35 36 38 79)#(2 162 3 4 6 8 11 12 18 19 20 21 22 23 24 25 26 27 28 29 30 32 35 36 38 79)#(2 166 3 4 6 8 11 12 18 19 20 21 22 23 24 25 26 27 28 29 30 32 35 36 38 79)#(2 158 3 4 6 8 11 12 18 19 20 21 22 23 24 25 26 27 28 29 30 32 35 36 38 79)#(2 170 3 4 6 8 11 12 18 19 20 21 22 23 24 25 26 27 28 29 30 32 35 36 38 79)#(3 41 3 449 5 49 6 486 12 61 16 65 18 486 19 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 453 43 117 45 121 46 125 47 129 48 133 49 137 50 145 52 149 54 153 55 157 56 161 62 486 79)#(2 38 12 19 79)#(3 273 27 277 28 281 30 457 53 461 57 465 59 469 81)#(2 250 4 8 11 12 19 27 28 30 36 79)#(3 41 3 49 6 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 117 45 473 48 133 49 137 50 477 55 481 56 485 60 489 62)#(3 41 3 49 6 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 117 45 493 48 133 49 137 50 497 56 501 61 489 62)#(2 246 4 11 12 19 27 28 30 36 79)#(3 226 4 226 11 226 12 226 19 505 28 226 36 226 79)#(2 238 4 11 12 19 28 30 36 79)#(2 318 12 79)#(3 218 4 218 11 218 12 218 19 505 28 218 36 218 79)#(2 230 4 11 12 19 28 30 36 79)#(2 242 4 11 12 19 27 28 30 36 79)#(3 222 4 222 11 222 12 222 19 505 28 222 36 222 79)#(2 234 4 11 12 19 28 30 36 79)#(3 41 3 49 6 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 509 43 117 45 121 46 125 47 129 48 133 49 137 50 145 52 149 54 153 55 157 56 161 62)#(2 258 3 5 6 7 9 10 16 18 20 21 22 23 24 25 26 27 28 35 79)#(3 513 24 517 26)#(2 442 27)#(2 446 27)#(3 41 3 49 6 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 521 45 473 48 525 49 529 50 477 55 481 56 485 60 533 62 537 74)#(2 541 8)#(2 414 8)#(2 545 28)#(2 6 8)#(2 10 8)#(2 14 8)#(2 410 8)#(3 549 27 553 76)#(3 41 3 45 5 49 6 381 7 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 105 41 557 42 113 43 117 45 121 46 125 47 129 48 133 49 137 50 145 52 149 54 153 55 157 56 161 62 34 79)#(3 329 1 333 14 337 15 273 27 341 28 561 39 349 57 353 59 357 70 361 71 365 72 369 73 373 75)#(3 41 3 45 5 49 6 185 7 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 105 41 297 42 113 43 117 45 121 46 125 47 129 48 133 49 137 50 145 52 149 54 153 55 157 56 161 62 565 63 34 79)#(2 378 79)#(2 98 4 11 12 19 27 28 30 36 79)#(2 486 12 19 79)#(2 46 12 19 79)#(2 62 2 9 10 12)#(3 97 27 569 62)#(3 18 10 18 27 573 40)#(3 41 3 45 5 49 6 53 9 57 10 34 12 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 105 41 109 42 113 43 117 45 121 46 125 47 129 48 133 49 137 50 141 51 145 52 149 54 153 55 157 56 161 62 577 65)#(2 78 4 8 11 12 19 27 28 30 36 79)#(2 74 4 8 11 12 19 27 28 30 36 79)#(2 190 3 5 6 7 12 16 18 20 21 22 23 24 25 26 27 35 79)#(2 22 10 27)#(2 118 4 8 11 12 19 27 28 30 36 79)#(3 581 3 585 4 589 6 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 593 27 597 28 601 29 605 30 609 32 101 35 613 38 617 50 621 68)#(3 625 12 629 24)#(3 41 3 49 6 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 633 43 117 45 121 46 125 47 129 48 133 49 137 50 145 52 149 54 153 55 157 56 161 62)#(2 30 12 19 36 79)#(2 94 4 11 12 19 36 79)#(2 206 4 11 12 19 36 79)#(3 214 4 214 11 214 12 214 19 505 28 214 36 214 79)#(2 210 4 11 12 19 36 79)#(3 278 4 278 11 278 12 278 19 273 27 278 28 281 30 278 36 285 57 278 79 293 81)#(3 270 4 270 11 270 12 270 19 270 28 281 30 270 36 270 79 305 81)#(3 274 4 274 11 274 12 274 19 273 27 274 28 281 30 274 36 309 57 274 79 317 81)#(2 262 4 11 12 19 28 36 79)#(2 114 4 11 12 19 27 28 30 36 79)#(3 286 4 286 11 286 12 286 19 273 27 286 28 286 30 286 36 285 57 286 79)#(3 282 4 282 11 282 12 282 19 273 27 282 28 282 30 282 36 309 57 282 79)#(2 474 4 11 12 19 28 30 36 79)#(3 41 3 49 6 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 117 45 473 48 133 49 137 50 477 55 481 56 637 60 489 62)#(2 86 4 12 19 36 79)#(2 402 8)#(3 398 8 641 13)#(3 430 8 106 27 106 28 106 30)#(3 426 8 102 27 102 28 102 30)#(3 434 8 110 27 110 28 110 30)#(3 438 8 114 27 114 28 114 30)#(2 418 8)#(2 294 3 5 6 7 9 10 16 18 20 21 22 23 24 25 26 27 35 79)#(3 41 3 49 6 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 521 45 473 48 525 49 529 50 477 55 481 56 637 60 533 62 645 74)#(3 450 4 649 17 450 24 450 26 450 27)#(3 653 24 657 26 661 77)#(2 386 79)#(2 665 8)#(3 41 3 45 5 49 6 381 7 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 105 41 669 42 113 43 117 45 121 46 125 47 129 48 133 49 137 50 145 52 149 54 153 55 157 56 161 62 34 79)#(2 66 2 9 10 12)#(3 673 10 97 27 433 62)#(2 677 12)#(3 330 3 330 4 330 6 330 18 330 20 330 21 330 22 330 23 330 24 330 25 330 26 330 27 330 28 330 29 330 30 330 32 330 35 330 38 681 67)#(2 178 3 4 6 8 11 12 18 19 20 21 22 23 24 25 26 27 28 29 30 32 35 36 38 79)#(3 322 12 322 24 685 66)#(2 342 3 4 6 18 20 21 22 23 24 25 26 27 28 29 30 32 35 38)#(2 350 3 4 6 18 20 21 22 23 24 25 26 27 28 29 30 32 35 38)#(2 354 3 4 6 18 20 21 22 23 24 25 26 27 28 29 30 32 35 38)#(2 346 3 4 6 18 20 21 22 23 24 25 26 27 28 29 30 32 35 38)#(2 358 3 4 6 18 20 21 22 23 24 25 26 27 28 29 30 32 35 38)#(2 370 3 4 6 18 20 21 22 23 24 25 26 27 28 29 30 32 35 38)#(2 338 3 4 6 18 20 21 22 23 24 25 26 27 28 29 30 32 35 38)#(2 334 3 4 6 18 20 21 22 23 24 25 26 27 28 29 30 32 35 38)#(2 174 3 4 6 8 11 12 18 19 20 21 22 23 24 25 26 27 28 29 30 32 35 36 38 79)#(2 326 12 24)#(3 482 12 482 19 397 36 482 79 689 83)#(2 266 4 11 12 19 28 36 79)#(2 693 26)#(2 422 8)#(2 454 4 24 26 27)#(2 462 3)#(2 458 3)#(2 697 3)#(2 298 3 5 6 7 9 10 16 18 20 21 22 23 24 25 26 27 35 79)#(2 382 79)#(3 41 3 45 5 49 6 34 12 61 16 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 97 27 101 35 105 41 701 42 113 43 117 45 121 46 125 47 129 48 133 49 137 50 145 52 149 54 153 55 157 56 161 62)#(2 70 4 8 11 12 19 27 28 30 36 79)#(3 581 3 705 4 589 6 65 18 69 20 73 21 77 22 81 23 85 24 89 25 93 26 593 27 597 28 601 29 605 30 609 32 101 35 613 38 617 50 621 68)#(3 709 12 629 24)#(2 42 12 19 79)#(2 406 8)#(3 549 27 713 76 717 78)#(2 721 12)#(2 362 3 4 6 18 20 21 22 23 24 25 26 27 28 29 30 32 35 38)#(2 366 3 4 6 18 20 21 22 23 24 25 26 27 28 29 30 32 35 38)#(2 466 4 27)#(3 725 4 549 27 729 76)#(2 82 4 8 11 12 19 27 28 30 36 79)#(3 390 8 733 13)#(2 470 4 27)#(2 737 26)#(2 394 8))! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/14/2003 23:52'!unaryMessage: nodes	^ {{nodes first}. #()}! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:27'!value: nodes	^ nodes first value! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:27'!valueSymbol: nodes	^ nodes first value asSymbol! !!SqueakParser methodsFor: 'reduction actions' stamp: 'ajh 3/15/2003 00:13'!variable: nodes	^ RBVariableNode new		identifierToken: nodes first! !!LiteralSet commentStamp: 'ajh 3/25/2003 00:33' prior: 0!Holds a unique set of literals.  Literal objects are equal if they are #= plus they are the same class.  This set uses this rule for finding elements.Example:	Set new add: 'anthony'; add: #anthony; size  "= 1"	LiteralSet new add: 'anthony'; add: #anthony; size  "= 2"!!LiteralSet methodsFor: 'as yet unclassified' stamp: 'ajh 12/9/2001 16:03'!add: newObject	"Include newObject as one of the receiver's elements.  If equivalent is already present don't add and return equivalent object"	| index |	newObject ifNil: [self error: 'Sets cannot meaningfully contain nil as an element'].	index _ self findElementOrNil: newObject.	^ (array at: index) 		ifNil: [self atNewIndex: index put: newObject. newObject]		ifNotNil: [array at: index]! !!LiteralSet methodsFor: 'as yet unclassified' stamp: 'ajh 2/2/2002 19:16'!scanFor: anObject	"Scan the key array for the first slot containing either a nil (indicating an empty slot) or an element that matches anObject. Answer the index of that slot or zero if no slot is found. This method will be overridden in various subclasses that have different interpretations for matching elements."	| element start finish |	start _ (anObject hash \\ array size) + 1.	finish _ array size.	"Search from (hash mod size) to the end."	start to: finish do:		[:index | ((element _ array at: index) == nil					or: [element literalEqual: anObject])					ifTrue: [^ index ]].	"Search from 1 to where we started."	1 to: start-1 do:		[:index | ((element _ array at: index) == nil					or: [element literalEqual: anObject])					ifTrue: [^ index ]].	^ 0  "No match AND no empty slot"! !!ClosureEnvironment methodsFor: '*newcompiler' stamp: 'ajh 7/7/2004 16:53'!inspectorClass	^ ClosureEnvInspector! !!RBBlockNode methodsFor: '*newcompiler' stamp: 'ajh 6/28/2004 13:52'!compiledMethod	^ self ir compiledMethod! !!RBBlockNode methodsFor: '*newcompiler' stamp: 'md 2/21/2006 14:41'!generate	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	^self generate: #(0 0 0 0)! !!RBBlockNode methodsFor: '*newcompiler' stamp: 'ajh 3/10/2003 20:23'!generate: trailer	^ self generateIR compiledMethodWith: trailer! !!RBBlockNode methodsFor: '*newcompiler' stamp: 'ajh 6/23/2004 19:51'!generateIR	^ ir _ ASTTranslator new		translateBlockNode: self;		ir! !!RBBlockNode methodsFor: '*newcompiler' stamp: 'pmm 8/16/2006 21:34'!generateWith: trailer using: aCompiledMethodClass	^ self generateIR compiledMethodWith: trailer using: aCompiledMethodClass! !!RBBlockNode methodsFor: '*newcompiler' stamp: 'ajh 3/10/2003 20:24'!ir	^ ir ifNil: [self generateIR]! !!RBBlockNode methodsFor: '*newcompiler' stamp: 'md 2/27/2006 18:13'!methodNodeFormattedAndDecorated: decorate	"Answer a method node made from pretty-printed (and colorized, if decorate is true) 	 source text."	^ self method methodNodeFormattedAndDecorated: decorate.! !!RBBlockNode methodsFor: '*newcompiler' stamp: 'ajh 3/3/2003 15:31'!privIR: irMethod	ir _ irMethod! !!SqueakScanner commentStamp: 'ajh 3/24/2003 21:31' prior: 0!I parse Smalltalk text into tokens which are used by the SqueakParser.  Methods under 'generated-*' categories were automatically generated using SmaCC.!!SqueakScanner class methodsFor: 'generated-initialization' stamp: 'ms 8/5/2006 14:11'!initializeKeywordMap	keywordMap := Dictionary new.	#(#(27 'false' 23 ) #(27 'nil' 22 ) #(27 'true' 21 ) ) do: 				[:each | 				(keywordMap at: each first ifAbsentPut: [Dictionary new]) at: (each at: 2)					put: each last].	^ keywordMap! !!SqueakScanner class methodsFor: 'generated-comments' stamp: 'ms 8/5/2006 14:11'!scannerDefinitionComment	"<decimalNumber>:	[0-9]+ (\. [0-9]+)? ;<radixNumber>:		[0-9]+ r [0-9A-Z]+ (\. [0-9A-Z]+)? ;<scaledNumber>:		<decimalNumber> s [0-9]+ ;<exponentNumber>:	(<decimalNumber> | <radixNumber>) e \-? [0-9]+ ;<number>:			<decimalNumber> | <radixNumber> | <exponentNumber> | <scaledNumber> ;<negativeNumber>:	\- <number> ;<string>:				\'  [^\']* \' (\' [^\']* \')* ;<name>:				[a-zA-Z] [a-zA-Z0-9]* ;<keyword>:			<name> \: ;<multikeyword>:		<name> \: (<name> \: )+ ;<binarySymbol>:		[\~\!!\@\%\&\*\-\+\=\\\|\?\/\>\<\,] [\~\!!\@\%\&\*\-\+\=\\\|\?\/\>\<\,]* ;<assignment>:		\: \= | \_ ;<alternateKeyword>:	\: <name> \: (<name> \:)* ;<whitespace>:		\s+ ;<comment>:			\"" [^\""]* \"" ;<character>:			\$ . ;<period>:				\. ;<variableAssignment>:	<name> \: \= ;<anyChar>:			. ; # For VW literal arrays that handle #(;) -> #(#';');"! !!SqueakScanner methodsFor: 'token handling' stamp: 'md 10/18/2004 16:24'!binarySymbol	"Negative number takes precedence over binary symbol, so for example, '0@-1' means '0 @ -1', rather than '0 @- 1', which is how the scanner reads it. If the symbol is just $- and the next char is a digit, then the negative number token takes precedence and SqueakParser>>actionForCurrentToken converts it to a binary symbol. If there is space between $- and the digit, then it reaches here and we convert it to a negativeNumber token (and let SqueakParser>>actionForCurrentToken deal with it)."	| string negPos prevReturnMatchBlock |	string _ outputStream contents.	string last = $- ifFalse: [		matchActions _ {self binarySymbolId}.		^ self createTokenFor: outputStream contents].	stream peek ifNil: [		matchActions _ {self binarySymbolId}.		^ self createTokenFor: outputStream contents].	stream peek isDigit ifTrue: [		"Back up one and let scanner find negativeNumber token"		outputStream skip: -1.		stream skip: -1.		matchActions _ {self binarySymbolId}.		^ self createTokenFor: outputStream contents].	(stream peek = $  and: [string size = 1]) ifFalse: [		matchActions _ {self binarySymbolId}.		^ self createTokenFor: outputStream contents].	"Allow space between negative sign and number (wierd, but allowed in Smalltalk ANSI standard)"	negPos _ stream position.	[stream peek = $ ] whileTrue: [stream next].	stream peek isDigit ifFalse: [		stream position: negPos.		matchActions _ {self binarySymbolId}.		^ self createTokenFor: outputStream contents].	"scan number but catch return and convert it to a negative number"	prevReturnMatchBlock _ returnMatchBlock.	returnMatchBlock _ [:token | 		returnMatchBlock _ prevReturnMatchBlock.		token id first = self numberId ifFalse: [self error: 'unexpected token'].		token value: '-', token value			start: token start - 1			id: {self negativeNumberId}.		returnMatchBlock value: token].	self whitespace.  "eats whitespace and scans next token"! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 8/5/2006 14:11'!binarySymbolId	^30! !!SqueakScanner methodsFor: 'token handling' stamp: 'ajh 3/6/2003 00:15'!comment	comments add: outputStream contents.	super comment.! !!SqueakScanner methodsFor: 'private' stamp: 'ajh 3/6/2003 00:16'!comments	^ comments! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 8/5/2006 14:11'!emptySymbolTokenId	^79! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 8/5/2006 14:11'!errorTokenId	^80! !!SqueakScanner methodsFor: 'private' stamp: 'ajh 3/6/2003 00:13'!initialize	super initialize.	comments _ OrderedCollection new.! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 8/5/2006 14:11'!nameId	^27! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 8/5/2006 14:11'!negativeNumberId	^25! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 8/5/2006 14:11'!numberId	^24! !!SqueakScanner methodsFor: 'generated-tokens' stamp: 'ms 8/5/2006 14:11'!periodId	^36! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 8/5/2006 14:11'!scan1	self step.	currentCharacter isDigit 		ifTrue: 			[			[self recordMatch: #(24 ).			self step.			currentCharacter isDigit] 					whileTrue.			^ self reportLastMatch].	currentCharacter == $- ifTrue: [^ self scan2].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 8/5/2006 14:11'!scan10	self step.	(currentCharacter isDigit or: [currentCharacter between: $A and: $Z]) 		ifTrue: 			[			[self recordMatch: #(24 ).			self step.			currentCharacter isDigit or: [currentCharacter between: $A and: $Z]] 					whileTrue.			currentCharacter == $. 				ifTrue: 					[self step.					(currentCharacter isDigit or: [currentCharacter between: $A and: $Z]) 						ifTrue: 							[							[self recordMatch: #(24 ).							self step.							currentCharacter isDigit or: [currentCharacter between: $A and: $Z]] 									whileTrue.							currentCharacter == $e ifTrue: [^ self scan1].							^ self reportLastMatch].					^ self reportLastMatch].			currentCharacter == $e ifTrue: [^ self scan1].			^ self reportLastMatch].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 8/5/2006 14:11'!scan11	self step.	currentCharacter isDigit 		ifTrue: 			[			[self recordMatch: #(24 ).			self step.			currentCharacter isDigit] 					whileTrue.			currentCharacter == $e ifTrue: [^ self scan1].			currentCharacter == $s ifTrue: [^ self scan2].			^ self reportLastMatch].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 8/5/2006 14:11'!scan12	self recordMatch: #(28 ).	self step.	((currentCharacter between: $A and: $Z) 		or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan7].	currentCharacter == $= 		ifTrue: [^ self recordAndReportMatch: #variableAssignment].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 8/5/2006 14:11'!scan2	self step.	currentCharacter isDigit 		ifTrue: 			[			[self recordMatch: #(24 ).			self step.			currentCharacter isDigit] 					whileTrue.			^ self reportLastMatch].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 8/5/2006 14:11'!scan3	self step.	currentCharacter isDigit 		ifTrue: 			[			[self recordMatch: #(25 ).			self step.			currentCharacter isDigit] 					whileTrue.			^ self reportLastMatch].	currentCharacter == $- ifTrue: [^ self scan4].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 8/5/2006 14:11'!scan4	self step.	currentCharacter isDigit 		ifTrue: 			[			[self recordMatch: #(25 ).			self step.			currentCharacter isDigit] 					whileTrue.			^ self reportLastMatch].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 8/5/2006 14:11'!scan5		[self step.	currentCharacter ~~ $'] whileTrue.	^ self scan6! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 8/5/2006 14:11'!scan6	self recordMatch: #(26 ).	self step.	currentCharacter == $' ifTrue: [^ self scan5].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 8/5/2006 14:11'!scan7		[self step.	(currentCharacter between: $0 and: $9) or: 			[(currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]]] 			whileTrue.	currentCharacter == $: 		ifTrue: 			[self recordMatch: #(29 ).			self step.			((currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan7].			^ self reportLastMatch].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 8/5/2006 14:11'!scan8		[self step.	(currentCharacter between: $0 and: $9) or: 			[(currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]]] 			whileTrue.	currentCharacter == $: 		ifTrue: 			[self recordMatch: #(32 ).			self step.			((currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan8].			^ self reportLastMatch].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 8/5/2006 14:11'!scan9		[self recordMatch: #(27 ).	self step.	(currentCharacter between: $0 and: $9) or: 			[(currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]]] 			whileTrue.	currentCharacter == $: ifTrue: [^ self scan12].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'generated-scanner' stamp: 'ms 8/5/2006 14:11'!scanForToken	self step.	(currentCharacter <= Character backspace or: 			[(currentCharacter between: (Character value: 14) and: (Character value: 31)) 				or: [currentCharacter == $` or: [currentCharacter >= $]]]) 		ifTrue: [^ self recordAndReportMatch: #(38 )].	((currentCharacter between: $A and: $Z) or: 			[currentCharacter == $b or: 					[(currentCharacter between: $d and: $l) or: 							[(currentCharacter between: $n and: $o) 								or: [currentCharacter between: $q and: $z]]]]) 		ifTrue: 			[self recordMatch: #(27 38 ).			self step.			((currentCharacter between: $0 and: $9) or: 					[(currentCharacter between: $A and: $Z) 						or: [currentCharacter between: $a and: $z]]) 				ifTrue: [^ self scan9].			currentCharacter == $: ifTrue: [^ self scan12].			^ self reportLastMatch].	(currentCharacter == $!! or: 			[(currentCharacter between: $% and: $&) or: 					[(currentCharacter between: $+ and: $,) or: 							[currentCharacter == $/ or: 									[currentCharacter == $= or: 											[(currentCharacter between: $? and: $@) 												or: [currentCharacter == $\ or: [currentCharacter == $~]]]]]]]) 		ifTrue: 			[self recordMatch: #binarySymbol.			self step.			currentCharacter isSpecial 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter isSpecial] 							whileTrue.					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter isDigit 		ifTrue: 			[self recordMatch: #(24 38 ).			self step.			currentCharacter isDigit 				ifTrue: 					[					[self recordMatch: #(24 ).					self step.					currentCharacter isDigit] 							whileTrue.					currentCharacter == $. ifTrue: [^ self scan11].					currentCharacter == $e ifTrue: [^ self scan1].					currentCharacter == $r ifTrue: [^ self scan10].					currentCharacter == $s ifTrue: [^ self scan2].					^ self reportLastMatch].			currentCharacter == $. ifTrue: [^ self scan11].			currentCharacter == $e ifTrue: [^ self scan1].			currentCharacter == $r ifTrue: [^ self scan10].			currentCharacter == $s ifTrue: [^ self scan2].			^ self reportLastMatch].	(currentCharacter isSeparator 		or: [currentCharacter == (Character value: 11)]) 			ifTrue: 				[self recordMatch: #whitespace.				self step.				(currentCharacter isSeparator 					or: [currentCharacter == (Character value: 11)]) 						ifTrue: 							[							[self recordMatch: #whitespace.							self step.							currentCharacter isSeparator 								or: [currentCharacter == (Character value: 11)]] 									whileTrue.							^ self reportLastMatch].				^ self reportLastMatch].	currentCharacter == $" 		ifTrue: 			[self recordMatch: #(38 ).			self step.			currentCharacter ~~ $" 				ifTrue: 					[					[self step.					currentCharacter ~~ $"] whileTrue.					^ self recordAndReportMatch: #comment].			currentCharacter == $" ifTrue: [^ self recordAndReportMatch: #comment].			^ self reportLastMatch].	currentCharacter == $# 		ifTrue: 			[self recordMatch: #(20 38 ).			self step.			currentCharacter == $: ifTrue: [^ self recordAndReportMatch: #(18 )].			^ self reportLastMatch].	currentCharacter == $$ 		ifTrue: 			[self recordMatch: #(38 ).			self step.			^ self recordAndReportMatch: #(35 )].	currentCharacter == $' 		ifTrue: 			[self recordMatch: #(38 ).			self step.			currentCharacter ~~ $' ifTrue: [^ self scan5].			currentCharacter == $' ifTrue: [^ self scan6].			^ self reportLastMatch].	currentCharacter == $( ifTrue: [^ self recordAndReportMatch: #(3 38 )].	currentCharacter == $) ifTrue: [^ self recordAndReportMatch: #(4 38 )].	currentCharacter == $* 		ifTrue: 			[self recordMatch: #(17 30 38 ).			self step.			currentCharacter isSpecial 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter isSpecial] 							whileTrue.					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter == $- 		ifTrue: 			[self recordMatch: #binarySymbol.			self step.			currentCharacter isSpecial 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter isSpecial] 							whileTrue.					^ self reportLastMatch].			currentCharacter isDigit 				ifTrue: 					[					[self recordMatch: #(25 ).					self step.					currentCharacter isDigit] 							whileTrue.					currentCharacter == $. 						ifTrue: 							[self step.							currentCharacter isDigit 								ifTrue: 									[									[self recordMatch: #(25 ).									self step.									currentCharacter isDigit] 											whileTrue.									currentCharacter == $e ifTrue: [^ self scan3].									currentCharacter == $s ifTrue: [^ self scan4].									^ self reportLastMatch].							^ self reportLastMatch].					currentCharacter == $e ifTrue: [^ self scan3].					currentCharacter == $r 						ifTrue: 							[self step.							(currentCharacter isDigit or: [currentCharacter between: $A and: $Z]) 								ifTrue: 									[									[self recordMatch: #(25 ).									self step.									currentCharacter isDigit or: [currentCharacter between: $A and: $Z]] 											whileTrue.									currentCharacter == $. 										ifTrue: 											[self step.											(currentCharacter isDigit or: [currentCharacter between: $A and: $Z]) 												ifTrue: 													[													[self recordMatch: #(25 ).													self step.													currentCharacter isDigit or: [currentCharacter between: $A and: $Z]] 															whileTrue.													currentCharacter == $e ifTrue: [^ self scan3].													^ self reportLastMatch].											^ self reportLastMatch].									currentCharacter == $e ifTrue: [^ self scan3].									^ self reportLastMatch].							^ self reportLastMatch].					currentCharacter == $s ifTrue: [^ self scan4].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter == $. ifTrue: [^ self recordAndReportMatch: #(36 38 )].	currentCharacter == $: 		ifTrue: 			[self recordMatch: #(2 38 ).			self step.			((currentCharacter between: $A and: $Z) 				or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan8].			currentCharacter == $= ifTrue: [^ self recordAndReportMatch: #(31 )].			^ self reportLastMatch].	currentCharacter == $; ifTrue: [^ self recordAndReportMatch: #(11 38 )].	currentCharacter == $< 		ifTrue: 			[self recordMatch: #(7 30 38 ).			self step.			currentCharacter isSpecial 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter isSpecial] 							whileTrue.					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter == $> 		ifTrue: 			[self recordMatch: #(8 30 38 ).			self step.			currentCharacter isSpecial 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter isSpecial] 							whileTrue.					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter == $[ ifTrue: [^ self recordAndReportMatch: #(6 38 )].	currentCharacter == $] ifTrue: [^ self recordAndReportMatch: #(12 38 )].	currentCharacter == $^ ifTrue: [^ self recordAndReportMatch: #(5 38 )].	currentCharacter == $_ ifTrue: [^ self recordAndReportMatch: #(31 38 )].	currentCharacter == $a 		ifTrue: 			[self recordMatch: #(27 38 ).			self step.			((currentCharacter between: $0 and: $9) or: 					[(currentCharacter between: $A and: $Z) or: 							[(currentCharacter between: $a and: $o) 								or: [currentCharacter between: $q and: $z]]]) 				ifTrue: [^ self scan9].			currentCharacter == $: ifTrue: [^ self scan12].			currentCharacter == $p 				ifTrue: 					[self recordMatch: #(27 ).					self step.					(currentCharacter isDigit or: 							[(currentCharacter between: $A and: $Z) or: 									[(currentCharacter between: $a and: $h) 										or: [currentCharacter between: $j and: $z]]]) 						ifTrue: [^ self scan9].					currentCharacter == $: ifTrue: [^ self scan12].					currentCharacter == $i 						ifTrue: 							[self recordMatch: #(27 ).							self step.							((currentCharacter between: $0 and: $9) or: 									[(currentCharacter between: $A and: $Z) or: 											[(currentCharacter between: $a and: $b) 												or: [currentCharacter between: $d and: $z]]]) 								ifTrue: [^ self scan9].							currentCharacter == $: ifTrue: [^ self scan12].							currentCharacter == $c 								ifTrue: 									[self recordMatch: #(27 ).									self step.									(currentCharacter isDigit or: 											[(currentCharacter between: $A and: $Z) 												or: [currentCharacter between: $b and: $z]]) 										ifTrue: [^ self scan9].									currentCharacter == $: ifTrue: [^ self scan12].									currentCharacter == $a 										ifTrue: 											[self recordMatch: #(27 ).											self step.											((currentCharacter between: $0 and: $9) or: 													[(currentCharacter between: $A and: $Z) or: 															[(currentCharacter between: $a and: $k) 																or: [currentCharacter between: $m and: $z]]]) 												ifTrue: [^ self scan9].											currentCharacter == $: ifTrue: [^ self scan12].											currentCharacter == $l 												ifTrue: 													[self recordMatch: #(27 ).													self step.													((currentCharacter between: $0 and: $9) or: 															[(currentCharacter between: $A and: $Z) or: 																	[(currentCharacter between: $a and: $k) 																		or: [currentCharacter between: $m and: $z]]]) 														ifTrue: [^ self scan9].													currentCharacter == $: ifTrue: [^ self scan12].													currentCharacter == $l 														ifTrue: 															[self recordMatch: #(27 ).															self step.															((currentCharacter between: $0 and: $9) or: 																	[(currentCharacter between: $A and: $Z) 																		or: [currentCharacter between: $a and: $z]]) 																ifTrue: [^ self scan9].															currentCharacter == $: 																ifTrue: 																	[self recordMatch: #(																				14																				28																			).																	self step.																	((currentCharacter between: $A and: $Z) 																		or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan7].																	currentCharacter == $= 																		ifTrue: [^ self recordAndReportMatch: #variableAssignment].																	^ self reportLastMatch].															^ self reportLastMatch].													^ self reportLastMatch].											^ self reportLastMatch].									^ self reportLastMatch].							^ self reportLastMatch].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter == $c 		ifTrue: 			[self recordMatch: #(27 38 ).			self step.			((currentCharacter between: $0 and: $9) or: 					[(currentCharacter between: $A and: $Z) or: 							[(currentCharacter between: $a and: $c) 								or: [currentCharacter between: $e and: $z]]]) 				ifTrue: [^ self scan9].			currentCharacter == $: ifTrue: [^ self scan12].			currentCharacter == $d 				ifTrue: 					[self recordMatch: #(27 ).					self step.					(currentCharacter isDigit or: 							[(currentCharacter between: $A and: $Z) or: 									[(currentCharacter between: $a and: $d) 										or: [currentCharacter between: $f and: $z]]]) 						ifTrue: [^ self scan9].					currentCharacter == $: ifTrue: [^ self scan12].					currentCharacter == $e 						ifTrue: 							[self recordMatch: #(27 ).							self step.							((currentCharacter between: $0 and: $9) or: 									[(currentCharacter between: $A and: $Z) or: 											[(currentCharacter between: $a and: $b) 												or: [currentCharacter between: $d and: $z]]]) 								ifTrue: [^ self scan9].							currentCharacter == $: ifTrue: [^ self scan12].							currentCharacter == $c 								ifTrue: 									[self recordMatch: #(27 ).									self step.									((currentCharacter between: $0 and: $9) or: 											[(currentCharacter between: $A and: $Z) or: 													[(currentCharacter between: $a and: $k) 														or: [currentCharacter between: $m and: $z]]]) 										ifTrue: [^ self scan9].									currentCharacter == $: ifTrue: [^ self scan12].									currentCharacter == $l 										ifTrue: 											[self recordMatch: #(27 ).											self step.											((currentCharacter between: $0 and: $9) or: 													[(currentCharacter between: $A and: $Z) 														or: [currentCharacter between: $a and: $z]]) 												ifTrue: [^ self scan9].											currentCharacter == $: 												ifTrue: 													[self recordMatch: #(15 28 ).													self step.													((currentCharacter between: $A and: $Z) 														or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan7].													currentCharacter == $= 														ifTrue: [^ self recordAndReportMatch: #variableAssignment].													^ self reportLastMatch].											^ self reportLastMatch].									^ self reportLastMatch].							^ self reportLastMatch].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter == $m 		ifTrue: 			[self recordMatch: #(27 38 ).			self step.			(currentCharacter isDigit or: 					[(currentCharacter between: $A and: $Z) or: 							[(currentCharacter between: $a and: $n) 								or: [currentCharacter between: $p and: $z]]]) 				ifTrue: [^ self scan9].			currentCharacter == $: ifTrue: [^ self scan12].			currentCharacter == $o 				ifTrue: 					[self recordMatch: #(27 ).					self step.					((currentCharacter between: $0 and: $9) or: 							[(currentCharacter between: $A and: $Z) or: 									[(currentCharacter between: $a and: $c) 										or: [currentCharacter between: $e and: $z]]]) 						ifTrue: [^ self scan9].					currentCharacter == $: ifTrue: [^ self scan12].					currentCharacter == $d 						ifTrue: 							[self recordMatch: #(27 ).							self step.							(currentCharacter isDigit or: 									[(currentCharacter between: $A and: $Z) or: 											[(currentCharacter between: $a and: $t) 												or: [currentCharacter between: $v and: $z]]]) 								ifTrue: [^ self scan9].							currentCharacter == $: ifTrue: [^ self scan12].							currentCharacter == $u 								ifTrue: 									[self recordMatch: #(27 ).									self step.									((currentCharacter between: $0 and: $9) or: 											[(currentCharacter between: $A and: $Z) or: 													[(currentCharacter between: $a and: $k) 														or: [currentCharacter between: $m and: $z]]]) 										ifTrue: [^ self scan9].									currentCharacter == $: ifTrue: [^ self scan12].									currentCharacter == $l 										ifTrue: 											[self recordMatch: #(27 ).											self step.											(currentCharacter isDigit or: 													[(currentCharacter between: $A and: $Z) or: 															[(currentCharacter between: $a and: $d) 																or: [currentCharacter between: $f and: $z]]]) 												ifTrue: [^ self scan9].											currentCharacter == $: ifTrue: [^ self scan12].											currentCharacter == $e 												ifTrue: 													[self recordMatch: #(27 ).													self step.													((currentCharacter between: $0 and: $9) or: 															[(currentCharacter between: $A and: $Z) 																or: [currentCharacter between: $a and: $z]]) 														ifTrue: [^ self scan9].													currentCharacter == $: 														ifTrue: 															[self recordMatch: #(																		13																		28																	).															self step.															((currentCharacter between: $A and: $Z) 																or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan7].															currentCharacter == $= 																ifTrue: [^ self recordAndReportMatch: #variableAssignment].															^ self reportLastMatch].													^ self reportLastMatch].											^ self reportLastMatch].									^ self reportLastMatch].							^ self reportLastMatch].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter == $p 		ifTrue: 			[self recordMatch: #(27 38 ).			self step.			((currentCharacter between: $0 and: $9) or: 					[(currentCharacter between: $A and: $Z) or: 							[(currentCharacter between: $a and: $q) 								or: [currentCharacter between: $s and: $z]]]) 				ifTrue: [^ self scan9].			currentCharacter == $: ifTrue: [^ self scan12].			currentCharacter == $r 				ifTrue: 					[self recordMatch: #(27 ).					self step.					(currentCharacter isDigit or: 							[(currentCharacter between: $A and: $Z) or: 									[(currentCharacter between: $a and: $h) 										or: [currentCharacter between: $j and: $z]]]) 						ifTrue: [^ self scan9].					currentCharacter == $: ifTrue: [^ self scan12].					currentCharacter == $i 						ifTrue: 							[self recordMatch: #(27 ).							self step.							((currentCharacter between: $0 and: $9) or: 									[(currentCharacter between: $A and: $Z) or: 											[(currentCharacter between: $a and: $l) 												or: [currentCharacter between: $n and: $z]]]) 								ifTrue: [^ self scan9].							currentCharacter == $: ifTrue: [^ self scan12].							currentCharacter == $m 								ifTrue: 									[self recordMatch: #(27 ).									self step.									(currentCharacter isDigit or: 											[(currentCharacter between: $A and: $Z) or: 													[(currentCharacter between: $a and: $h) 														or: [currentCharacter between: $j and: $z]]]) 										ifTrue: [^ self scan9].									currentCharacter == $: ifTrue: [^ self scan12].									currentCharacter == $i 										ifTrue: 											[self recordMatch: #(27 ).											self step.											((currentCharacter between: $0 and: $9) or: 													[(currentCharacter between: $A and: $Z) or: 															[(currentCharacter between: $a and: $s) 																or: [currentCharacter between: $u and: $z]]]) 												ifTrue: [^ self scan9].											currentCharacter == $: ifTrue: [^ self scan12].											currentCharacter == $t 												ifTrue: 													[self recordMatch: #(27 ).													self step.													(currentCharacter isDigit or: 															[(currentCharacter between: $A and: $Z) or: 																	[(currentCharacter between: $a and: $h) 																		or: [currentCharacter between: $j and: $z]]]) 														ifTrue: [^ self scan9].													currentCharacter == $: ifTrue: [^ self scan12].													currentCharacter == $i 														ifTrue: 															[self recordMatch: #(27 ).															self step.															((currentCharacter between: $0 and: $9) or: 																	[(currentCharacter between: $A and: $Z) or: 																			[(currentCharacter between: $a and: $u) 																				or: [currentCharacter between: $w and: $z]]]) 																ifTrue: [^ self scan9].															currentCharacter == $: ifTrue: [^ self scan12].															currentCharacter == $v 																ifTrue: 																	[self recordMatch: #(27 ).																	self step.																	(currentCharacter isDigit or: 																			[(currentCharacter between: $A and: $Z) or: 																					[(currentCharacter between: $a and: $d) 																						or: [currentCharacter between: $f and: $z]]]) 																		ifTrue: [^ self scan9].																	currentCharacter == $: ifTrue: [^ self scan12].																	currentCharacter == $e 																		ifTrue: 																			[self recordMatch: #(27 ).																			self step.																			((currentCharacter between: $0 and: $9) or: 																					[(currentCharacter between: $A and: $Z) 																						or: [currentCharacter between: $a and: $z]]) 																				ifTrue: [^ self scan9].																			currentCharacter == $: 																				ifTrue: 																					[self recordMatch: #(																								1																								28																							).																					self step.																					((currentCharacter between: $A and: $Z) 																						or: [currentCharacter between: $a and: $z]) ifTrue: [^ self scan7].																					currentCharacter == $= 																						ifTrue: [^ self recordAndReportMatch: #variableAssignment].																					^ self reportLastMatch].																			^ self reportLastMatch].																	^ self reportLastMatch].															^ self reportLastMatch].													^ self reportLastMatch].											^ self reportLastMatch].									^ self reportLastMatch].							^ self reportLastMatch].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter == ${ ifTrue: [^ self recordAndReportMatch: #(16 38 )].	currentCharacter == $| 		ifTrue: 			[self recordMatch: #(10 30 38 ).			self step.			(currentCharacter == $!! or: 					[(currentCharacter between: $% and: $&) or: 							[(currentCharacter between: $* and: $-) or: 									[currentCharacter == $/ or: 											[(currentCharacter between: $< and: $@) 												or: [currentCharacter == $\ or: [currentCharacter == $~]]]]]]) 				ifTrue: 					[					[self recordMatch: #binarySymbol.					self step.					currentCharacter isSpecial] 							whileTrue.					^ self reportLastMatch].			currentCharacter == $| 				ifTrue: 					[self recordMatch: #(9 30 ).					self step.					currentCharacter isSpecial 						ifTrue: 							[							[self recordMatch: #binarySymbol.							self step.							currentCharacter isSpecial] 									whileTrue.							^ self reportLastMatch].					^ self reportLastMatch].			^ self reportLastMatch].	currentCharacter == $} ifTrue: [^ self recordAndReportMatch: #(19 38 )].	^ self reportLastMatch! !!SqueakScanner methodsFor: 'token handling' stamp: 'ajh 7/16/2004 10:57'!variableAssignment	outputStream skip: -2.	stream skip: -2.	matchActions _ {self nameId}.	self createTokenFor: outputStream contents.! !!SequenceableCollection methodsFor: '*newcompiler' stamp: 'kwl 6/25/2006 19:07'!literalIndexOf: anElement ifAbsent: exceptionBlock	"Answer the index of anElement within the receiver. If the receiver does 	not contain anElement, answer the result of evaluating the argument, 	exceptionBlock."	1 to: self size do:		[:i | ((self at: i) literalEqual: anElement) ifTrue: [^ i]].	^ exceptionBlock value! !!ASTChecker commentStamp: 'ajh 6/23/2004 19:43' prior: 0!I visit each node in the abstract syntax tree while growing and shrinking a SemScope chain. Each method and block node is linked with its corresponding scope object, and each variable def and ref is linked with its corresponding ScopeVar. Exceptions are raised for undefined variable references and so on (see subclasses of SemanticWarning).!!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'ajh 2/25/2003 19:43'!acceptArrayNode: anArrayNode 	anArrayNode statements do: [:each | self visitNode: each]! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'ajh 3/11/2003 18:21'!acceptAssignmentNode: anAssignmentNode	| var |	self visitNode: anAssignmentNode value.	var _ (scope lookupVar: anAssignmentNode variable name)		ifNil: [self undeclaredVariable: anAssignmentNode variable].	var markWrite.	anAssignmentNode variable binding: var.! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'ajh 6/25/2004 17:28'!acceptBlockNode: aBlockNode	aBlockNode isInlined ifTrue: [^ self acceptInlinedBlockNode: aBlockNode].	scope _ scope newFunctionScope.	aBlockNode scope: scope.	(scope addTemp: 'parent env') markArg. "first temp is receiver"	aBlockNode arguments do: [:node | (self declareVariableNode: node) markArg].	self visitNode: aBlockNode body.	scope _ scope popScope.! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'ajh 2/25/2003 22:15'!acceptCascadeNode: aCascadeNode 	aCascadeNode messages do: [:each | self visitNode: each]! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'md 6/29/2005 12:20'!acceptDoItNode: aDoItNode	| doItReceiverName |	doItReceiverName := scope isInstanceScope		ifTrue: ['self']		ifFalse: [(scope rawVar: 'theContext')			ifNil: ['theContext']			ifNotNil: ['the context']].	scope := scope newMethodScope.	"hack for Bytesurgeon: inlined code is a doit, yet we want access to self "	aDoItNode byteSurgeon ifTrue: [(scope addTemp: 'self')].	aDoItNode scope: scope.	(scope addTemp: doItReceiverName) markArg. "first temp is receiver"	self visitNode: aDoItNode body.	scope := scope popScope.! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'md 11/11/2004 16:05'!acceptInlinedBlockNode: aBlockNode		aBlockNode arguments do: [:node | (self declareVariableNode: node) markWrite "given"].	self visitNode: aBlockNode body.! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'ajh 2/25/2003 19:34'!acceptLiteralNode: aLiteralNode! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'ajh 3/11/2003 22:51'!acceptMessageNode: aMessageNode	(aMessageNode isCascaded not or: [aMessageNode isFirstCascaded]) 		ifTrue: [self visitNode: aMessageNode receiver].	aMessageNode arguments do: [:each | self visitNode: each].	"aMessageNode binding:"		((scope lookupSelector: aMessageNode selectorString)			ifNil: [self undeclaredSelector: aMessageNode])! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'ms 9/4/2006 00:01'!acceptMethodNode: aMethodNode	scope _ scope newMethodScope.	aMethodNode scope: scope.	(scope addTemp: 'self') markArg.  "first temp is receiver"	aMethodNode arguments do: [:node | (self declareVariableNode: node) markArg].		aMethodNode pragmas do: [:each | self visitNode: each].	self visitNode: aMethodNode body.	scope _ scope outerScope.! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'ms 9/4/2006 00:13'!acceptPragmaNode: aPragmaNode		aPragmaNode pragma setArguments: (aPragmaNode pragma arguments collect: 		[:arg | (arg isKindOf: RBVariableNode) ifTrue:[self visitNode: arg. 													  arg binding value]										       ifFalse:[arg]]).	aPragmaNode parent addPragma: aPragmaNode pragma.	aPragmaNode parent primitiveNode: aPragmaNode primitive		! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'ajh 6/26/2004 18:22'!acceptReturnNode: aReturnNode	| var |	self visitNode: aReturnNode value.	var _ scope lookupVar: 'top env'.  "nil var means local return"	var ifNotNil: [var markRead].	aReturnNode homeBinding: var.! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'ms 7/22/2006 19:11'!acceptSequenceNode: aSequenceNode	aSequenceNode temporaries do: [:node | self declareVariableNode: node].	aSequenceNode statements do: [:each | self visitNode: each].	aSequenceNode temporaries do: [:node |		node binding isUnused ifTrue: [self unusedVariable: node]].! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'md 11/16/2004 14:33'!acceptVariableNode: aVariableNode	| var name |	name := aVariableNode name.	name = 'super' ifTrue: [name := 'self'].	var := (scope lookupVar: name)		ifNil: [self undeclaredVariable: aVariableNode].	var isUndefined		ifTrue: [self uninitializedVariable: aVariableNode].	var markRead.	aVariableNode binding: var.! !!ASTChecker methodsFor: 'visitor-double dispatching' stamp: 'md 11/11/2004 16:22'!declareVariableNode: aVariableNode	| name var |	name := aVariableNode name.	var := scope rawVar: name.	var ifNotNil: [		var scope = scope ifTrue: [			"Reuse same var"			var := scope lookupVar: name.		] ifFalse: [			"Create new var that shadows outer one"			self variable: aVariableNode shadows: var.			var := scope addTemp: name.		]	] ifNil: [		"new var"		var := scope addTemp: name.	].	aVariableNode binding: var.	^ var! !!ASTChecker methodsFor: 'initialize-release' stamp: 'ajh 6/23/2004 20:40'!initialize	scope _ GlobalScope new.  "in case never initialized"! !!ASTChecker methodsFor: 'initialize-release' stamp: 'ajh 2/26/2003 19:58'!scope: aSemScope	scope _ aSemScope! !!ASTChecker methodsFor: 'error handling' stamp: 'ajh 3/11/2003 22:46'!undeclaredSelector: messageNode	^ UndeclaredSelectorWarning new		messageNode: messageNode;		signal! !!ASTChecker methodsFor: 'error handling' stamp: 'ajh 3/11/2003 12:06'!undeclaredVariable: variableNode	^ UndeclaredVariableWarning new		variableNode: variableNode;		signal! !!ASTChecker methodsFor: 'error handling' stamp: 'ajh 3/12/2003 13:35'!uninitializedVariable: variableNode	^ UninitializedVariableWarning new		variableNode: variableNode;		signal! !!ASTChecker methodsFor: 'error handling' stamp: 'ajh 3/12/2003 14:10'!unusedVariable: variableNode	^ UnusedVariableWarning new		variableNode: variableNode;		signal! !!ASTChecker methodsFor: 'error handling' stamp: 'ajh 3/19/2003 13:33'!variable: variableNode shadows: semVar	^ ShadowVariableWarning new		variableNode: variableNode;		shadowedVar: semVar;		signal! !!ASTTranslator commentStamp: 'ajh 3/24/2003 22:19' prior: 0!I visit an abstract syntax tree and generate IR (intermediate representation) instructions for each node by sending the appropriate message to my methodBuilder (an IRBuilder).  I hold onto my two subclasses one for generating instructions for value, the other for generating instructions for effect.!!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'md 2/27/2006 17:02'!acceptArrayNode: anArrayNode 	| elementNodes |	elementNodes _ anArrayNode children.	elementNodes size <= 4 ifTrue: [		"Short form: Array braceWith: a with: b ..."		methodBuilder pushLiteralVariable: Array binding.		elementNodes do: [:node | valueTranslator visitNode: node].		methodBuilder send: (#(braceWithNone braceWith: braceWith:with: braceWith:with:with: braceWith:with:with:with:) at: elementNodes size + 1).	] ifFalse: [		"Long form: (Array braceStream: N) nextPut: a; nextPut: b; ...; braceArray"		methodBuilder pushLiteralVariable: Array binding.		methodBuilder pushLiteral: elementNodes size.		methodBuilder send: #braceStream:.		elementNodes do: [:node |			methodBuilder pushDup.			valueTranslator visitNode: node.			methodBuilder send: #nextPut:.			methodBuilder popTop.		].		methodBuilder send: #braceArray.	].! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ajh 7/8/2004 10:43'!acceptAssignmentNode: anAssignmentNode 	valueTranslator visitNode: anAssignmentNode value.	anAssignmentNode variable binding emitStore: methodBuilder from: anAssignmentNode owningScope.! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ajh 2/25/2003 00:51'!acceptBlockNode: aBlockNode ! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ajh 3/10/2003 14:53'!acceptCascadeNode: aCascadeNode 	valueTranslator visitNode: aCascadeNode receiver.	aCascadeNode messages allButLastDo: [:node |		methodBuilder pushDup.		effectTranslator visitNode: node.	].	valueTranslator visitNode: aCascadeNode messages last.! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ajh 6/26/2004 13:48'!acceptDoItNode: aDoItNode 	methodBuilder numRargs: 1.	methodBuilder addTemps: aDoItNode scope tempVars.	aDoItNode scope emitPrologue: methodBuilder.	valueTranslator visitNode: aDoItNode body.	aDoItNode body lastIsReturn ifFalse: [		methodBuilder returnTop].! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ajh 2/24/2003 20:06'!acceptLiteralNode: aLiteralNode! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ajh 2/25/2003 13:23'!acceptMessageNode: aMessageNode 	aMessageNode isInlineIf ifTrue: [^ self emitIfNode: aMessageNode].	aMessageNode isInlineIfNil ifTrue: [^ self emitIfNilNode: aMessageNode].	aMessageNode isInlineAndOr ifTrue: [^ self emitAndOrNode: aMessageNode].	aMessageNode isInlineWhile ifTrue: [^ self emitWhileNode: aMessageNode].	aMessageNode isInlineToDo ifTrue: [^ self emitToDoNode: aMessageNode].	aMessageNode isInlineCase ifTrue: [^ self emitCaseNode: aMessageNode].	^ self emitMessageNode: aMessageNode! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ms 7/13/2006 17:33'!acceptMethodNode: aMethodNode 	methodBuilder properties: aMethodNode properties.	methodBuilder numRargs: aMethodNode arguments size + 1.	methodBuilder primitiveNode: aMethodNode primitiveNode.	methodBuilder addTemps: aMethodNode scope tempVars.	aMethodNode scope emitPrologue: methodBuilder.	effectTranslator visitNode: aMethodNode body.	aMethodNode body lastIsReturn ifFalse: [		methodBuilder pushReceiver; returnTop].! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ajh 7/8/2004 19:01'!acceptReturnNode: aReturnNode	valueTranslator visitNode: aReturnNode value.	aReturnNode homeBinding ifNil: [		methodBuilder returnTop.	] ifNotNil: [		aReturnNode homeBinding emitValue: methodBuilder from: aReturnNode owningScope.		methodBuilder remoteReturn.	].! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'md 3/17/2006 14:17'!acceptSequenceNode: aSequenceNode 	aSequenceNode statements allButLastDo: [:n | effectTranslator visitNode: n].	aSequenceNode statements notEmpty ifTrue: [self visitNode: aSequenceNode statements last].! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ajh 2/24/2003 20:06'!acceptVariableNode: aVariableNode! !!ASTTranslator methodsFor: 'inline messages' stamp: 'pmm 7/24/2006 22:42'!emitAndOrNode: aMessageNode	| arguments isOr |	isOr := aMessageNode selector beginsWith: #or:.	valueTranslator visitNode: aMessageNode receiver.	arguments := aMessageNode arguments.		arguments do: [ :each |		methodBuilder jumpAheadTo: #else if: isOr.		self visitNode: each body ].		self isValueTranslator ifTrue: [		methodBuilder jumpAheadTo: #end].		"there has to be a one-to-one correspondence between every jump and target"		arguments size timesRepeat: [ methodBuilder jumpAheadTarget: #else ].		self isValueTranslator ifTrue: [		methodBuilder pushLiteral: isOr.		methodBuilder jumpAheadTarget: #end.	].! !!ASTTranslator methodsFor: 'inline messages' stamp: 'pmm 7/20/2006 20:51'!emitCaseNode: aMessageNode	| cases assocMessageNode s |	cases _ aMessageNode arguments first statements.	valueTranslator visitNode: aMessageNode receiver.	1 to: cases size - 1 do: [:i |		methodBuilder pushDup.		assocMessageNode _ cases at: i.		valueTranslator visitNode: assocMessageNode receiver body.		methodBuilder send: #=.		methodBuilder jumpAheadTo: #next if: false.		methodBuilder popTop.		self visitNode: assocMessageNode arguments first body.		methodBuilder jumpAheadTo: #end.		methodBuilder jumpAheadTarget: #next.	].	aMessageNode arguments size = 2 ifTrue: [		"last case with otherwise"		assocMessageNode _ cases last.		valueTranslator visitNode: assocMessageNode receiver body.		methodBuilder send: #=.		methodBuilder jumpAheadTo: #next if: false.		self visitNode: assocMessageNode arguments first body.		methodBuilder jumpAheadTo: #end.		methodBuilder jumpAheadTarget: #next.		self visitNode: aMessageNode arguments last body.	] ifFalse: [		"last case without otherwise"		methodBuilder pushDup.		assocMessageNode _ cases last.		valueTranslator visitNode: assocMessageNode receiver body.		methodBuilder send: #=.		methodBuilder jumpAheadTo: #next if: false.		methodBuilder popTop.		self visitNode: assocMessageNode arguments first body.		methodBuilder jumpAheadTo: #end.		methodBuilder jumpAheadTarget: #next.		methodBuilder send: #caseError.		aMessageNode lastIsReturn ifTrue: [			(s _ aMessageNode owningScope) isBlockScope ifTrue: [				(s lookupVar: 'top env') emitValue: methodBuilder from: aMessageNode owningScope.				methodBuilder remoteReturn.			] ifFalse: [				methodBuilder returnTop.			]		] ifFalse: [			self isEffectTranslator ifTrue: [methodBuilder popTop].		].	].	"there has to be a one-to-one correspondence between every jump and target"		cases size timesRepeat: [methodBuilder jumpAheadTarget: #end].! !!ASTTranslator methodsFor: 'inline messages' stamp: 'pmm 7/24/2006 20:30'!emitIfNilNode: aMessageNode	| args selector |	valueTranslator visitNode: aMessageNode receiver.	args _ aMessageNode arguments.	(selector _ aMessageNode selector) caseOf: {		[#ifNil:] -> [self isValueTranslator ifTrue: [methodBuilder pushDup]].		[#ifNil:ifNotNil:] -> [args last arguments ifNotEmpty: [args first arguments first binding emitLocalStore: methodBuilder]].		[#ifNotNil:] -> [args first arguments ifNotEmpty: [args first arguments first binding emitLocalStore: methodBuilder]].		[#ifNotNilDo:] -> [args first arguments ifNotEmpty: [args first arguments first binding emitLocalStore: methodBuilder]].		[#ifNotNil:ifNil:] -> [args first arguments ifNotEmpty: [args first arguments first binding emitLocalStore: methodBuilder]]	}.	methodBuilder pushLiteral: nil.	methodBuilder send: #==.	methodBuilder jumpAheadTo: #else if: (selector beginsWith: #ifNotNil).	(self == valueTranslator and: [selector == #ifNil:])		ifTrue: [methodBuilder popTop].	self visitNode: args first body.	(args size > 1 or: [self == valueTranslator and: [selector == #ifNotNil: or: [selector == #ifNotNilDo:]]])		ifTrue: [methodBuilder jumpAheadTo: #end].	methodBuilder jumpAheadTarget: #else.	(args size > 1 or: [self isValueTranslator and: [selector == #ifNotNil: or: [selector == #ifNotNilDo:]]]) ifTrue: [		args size > 1			ifTrue: [self visitNode: args last body]			ifFalse: [methodBuilder pushLiteral: nil].		methodBuilder jumpAheadTarget: #end.	].! !!ASTTranslator methodsFor: 'inline messages' stamp: 'pmm 7/19/2006 11:55'!emitIfNode: aMessageNode	| args |	valueTranslator visitNode: aMessageNode receiver.	methodBuilder jumpAheadTo: #else if: (aMessageNode selector beginsWith: #ifFalse:).	args _ aMessageNode arguments.	self visitNode: args first body.	(args size > 1 or: [self isValueTranslator]) ifTrue: [		methodBuilder jumpAheadTo: #end].	methodBuilder jumpAheadTarget: #else.	(args size > 1 or: [self isValueTranslator]) ifTrue: [		args size > 1			ifTrue: [self visitNode: args last body]			ifFalse: [methodBuilder pushLiteral: nil].		methodBuilder jumpAheadTarget: #end.	].! !!ASTTranslator methodsFor: 'inline messages' stamp: 'pmm 4/24/2006 22:31'!emitMessageNode: aMessageNode	aMessageNode isCascaded ifFalse: [		valueTranslator visitNode: aMessageNode receiver].	aMessageNode arguments do: [:each | 		valueTranslator visitNode: each].	aMessageNode isSuperSend		ifTrue: [methodBuilder send: aMessageNode selector toSuperOf: aMessageNode owningScope classEncoding]		ifFalse: [methodBuilder send: aMessageNode selector].! !!ASTTranslator methodsFor: 'inline messages' stamp: 'md 3/17/2006 14:17'!emitToDoNode: aMessageNode	| limit step block iterator limitEmit |	limit := aMessageNode arguments first.	step := 1.	aMessageNode arguments size = 3 ifTrue: [		"to:by:do:"		step := aMessageNode arguments second.		step isLiteral ifFalse: [self error: 'should not have been inlined'].		step := step value.	].	block := aMessageNode arguments last.	"push start. allocate and initialize iterator"	valueTranslator visitNode: aMessageNode receiver.	iterator := block arguments first binding.	iterator emitLocalStore: methodBuilder.	"push limit, store in a temp if it's an expression or a changing variable"	valueTranslator visitNode: limit.	limitEmit := [valueTranslator visitNode: limit].	(limit isLiteral or: 	 [limit isVariable and:	  [ParseTreeSearcher new		matches: limit name , ' := `@object' do: [:n :a | false];		executeTree: block initialAnswer: true]]	) ifFalse: [		limit := {iterator. #limit}.  "must be unique throughout method"		methodBuilder addTemp: limit.		methodBuilder storeTemp: limit.		limitEmit := [methodBuilder pushTemp: limit].	].	"loop"	methodBuilder jumpBackTarget: #start.	methodBuilder send: (step > 0 ifTrue: [#<=] ifFalse: [#>=]).	methodBuilder jumpAheadTo: #done if: false.	effectTranslator visitNode: block body.	iterator emitLocalValue: methodBuilder.	methodBuilder pushLiteral: step.	methodBuilder send: #+.	iterator emitLocalStore: methodBuilder.	limitEmit value.	methodBuilder jumpBackTo: #start.	methodBuilder jumpAheadTarget: #done.! !!ASTTranslator methodsFor: 'inline messages' stamp: 'md 10/15/2004 12:37'!emitWhileNode: aMessageNode	methodBuilder jumpBackTarget: #begin.	valueTranslator visitNode: aMessageNode receiver body.	aMessageNode selector caseOf: {		[#whileTrue:]	-> [methodBuilder jumpAheadTo: #end if: false].		[#whileTrue]	-> [methodBuilder jumpAheadTo: #end if: false].		[#whileFalse:]	-> [methodBuilder jumpAheadTo: #end if: true].		[#whileFalse]	-> [methodBuilder jumpAheadTo: #end if: true]	}.	aMessageNode arguments ifNotEmpty: [		effectTranslator visitNode: aMessageNode arguments first body].	methodBuilder jumpBackTo: #begin.	methodBuilder jumpAheadTarget: #end.! !!ASTTranslator methodsFor: 'initialize' stamp: 'ms 7/16/2006 14:00'!initialize	methodBuilder := IRBuilder new.	effectTranslator := self as: ASTTranslatorForEffect.	valueTranslator := self as: ASTTranslatorForValue.	effectTranslator instVarNamed: #effectTranslator put: effectTranslator.	effectTranslator instVarNamed: #valueTranslator put: valueTranslator.	valueTranslator instVarNamed: #valueTranslator put: valueTranslator.! !!ASTTranslator methodsFor: 'accessing' stamp: 'ajh 3/10/2003 17:59'!ir	^ methodBuilder ir! !!ASTTranslator methodsFor: 'testing' stamp: 'pmm 7/19/2006 11:54'!isEffectTranslator	^self == effectTranslator! !!ASTTranslator methodsFor: 'testing' stamp: 'pmm 7/19/2006 11:52'!isValueTranslator	^self == valueTranslator! !!ASTTranslator methodsFor: 'visitor-double dispatching' stamp: 'ajh 6/26/2004 18:32'!translateBlockNode: aBlockNode 	methodBuilder numRargs: aBlockNode arguments size + 1.	methodBuilder addTemps: aBlockNode scope tempVars.	aBlockNode scope emitPrologue: methodBuilder.	valueTranslator visitNode: aBlockNode body.	aBlockNode body lastIsReturn ifFalse: [		methodBuilder returnTop].! !!ASTTranslator methodsFor: 'visiting' stamp: 'ajh 3/2/2003 03:31'!visitNode: aNode	methodBuilder mapToNode: aNode.	super visitNode: aNode.	methodBuilder popMap.! !!ASTTranslatorForEffect commentStamp: 'ajh 3/24/2003 22:20' prior: 0!I override some methods in my super to generate instructions for effect only.!!ASTTranslatorForEffect methodsFor: 'visitor-double dispatching' stamp: 'ajh 3/10/2003 14:56'!acceptArrayNode: anArrayNode 	super acceptArrayNode: anArrayNode.	methodBuilder popTop.! !!ASTTranslatorForEffect methodsFor: 'visitor-double dispatching' stamp: 'md 7/26/2006 14:45'!acceptAssignmentNode: anAssignmentNode 	super acceptAssignmentNode: anAssignmentNode.	methodBuilder popTop. ! !!ASTTranslatorForEffect methodsFor: 'visitor-double dispatching' stamp: 'ajh 3/10/2003 14:56'!acceptCascadeNode: aCascadeNode 	super acceptCascadeNode: aCascadeNode.	methodBuilder popTop.! !!ASTTranslatorForEffect methodsFor: 'emit messages' stamp: 'ajh 3/10/2003 14:57'!emitMessageNode: aMessageNode 	super emitMessageNode: aMessageNode.	methodBuilder popTop.! !!ASTTranslatorForValue commentStamp: 'ajh 3/24/2003 22:20' prior: 0!I override some methods in my super to generate instructions for effect and value only.!!ASTTranslatorForValue methodsFor: 'visitor-double dispatching' stamp: 'md 11/16/2004 15:14'!acceptBlockNode: aBlockNode 	| blockMethod args blockTemps |	Preferences compileBlocksAsClosures ifFalse: [	 		args := aBlockNode arguments collect: [:each | each binding].		blockTemps := aBlockNode body temporaries  collect: [:each | each binding].		methodBuilder addTemps: args.		methodBuilder addTemps: blockTemps.		methodBuilder pushThisContext.		methodBuilder pushLiteral: aBlockNode arguments size.		methodBuilder send: #blockCopy:.		methodBuilder jumpOverBlockTo: #jmp.     		args reverse do: [:arg | methodBuilder storeTemp: arg. methodBuilder popTop].		super visitNode: aBlockNode body.		aBlockNode body lastIsReturn ifFalse: [				methodBuilder blockReturnTop].		methodBuilder jumpAheadTarget: #jmp.	 ^self ].		blockMethod := aBlockNode generateIR.	aBlockNode freeVars isEmpty ifTrue: [		"Create block at compile time"		methodBuilder pushBlock: blockMethod.	] ifFalse: [		"Create block at run time"		| outerScope envVar |		outerScope := aBlockNode scope outerScope.		envVar := outerScope hasEscapingEnv			ifTrue: [outerScope thisEnvVar]			ifFalse: [outerScope receiverVar].		methodBuilder pushBlockMethod: blockMethod.		envVar emitLocalValue: methodBuilder.		methodBuilder send: #createBlock:.	].! !!ASTTranslatorForValue methodsFor: 'visitor-double dispatching' stamp: 'ajh 2/27/2003 18:18'!acceptLiteralNode: aLiteralNode	methodBuilder pushLiteral: aLiteralNode value.! !!ASTTranslatorForValue methodsFor: 'visitor-double dispatching' stamp: 'ajh 2/25/2003 18:21'!acceptSequenceNode: aSequenceNode 	super acceptSequenceNode: aSequenceNode.	aSequenceNode statements isEmpty ifTrue: [		methodBuilder pushLiteral: nil].! !!ASTTranslatorForValue methodsFor: 'visitor-double dispatching' stamp: 'md 10/15/2004 14:49'!acceptVariableNode: aVariableNode		aVariableNode binding emitValue: methodBuilder from: aVariableNode owningScope.		! !!ASTTranslatorForValue methodsFor: 'emit messages' stamp: 'ajh 2/25/2003 16:50'!emitToDoNode: aMessageNode	super emitToDoNode: aMessageNode.	methodBuilder pushLiteral: nil.! !!ASTTranslatorForValue methodsFor: 'emit messages' stamp: 'ajh 2/25/2003 16:49'!emitWhileNode: aMessageNode	super emitWhileNode: aMessageNode.	methodBuilder pushLiteral: nil.! !!NonClosureScopeFixer commentStamp: 'md 3/16/2006 17:49' prior: 0!Standard Squeak has only one scope for temporaries: the method. All temps and args,even those of the blocks, are just temps of the method.But when compiling, we for sure want to do a correct scope analysis to make surethat we do not access temps from outside their static scope... even if that's notpart of the semantic model of non-Closure Squeak.The idea now is to use the scoping of the ClosureCompiler to work normally, makingscopes for variables... checking for errors. And then, afterwards, we go overthe AST and rewrite all temp-bindings... ugly.!!NonClosureScopeFixer methodsFor: 'as yet unclassified' stamp: 'md 3/16/2006 17:52'!acceptDoItNode: aDoItNode	methodScope := aDoItNode scope.	self visitNode: aDoItNode body.! !!NonClosureScopeFixer methodsFor: 'as yet unclassified' stamp: 'md 3/16/2006 17:52'!acceptMethodNode: aMethodNode	methodScope := aMethodNode scope.	self visitNode: aMethodNode body.! !!NonClosureScopeFixer methodsFor: 'as yet unclassified' stamp: 'md 3/20/2006 14:58'!acceptVariableNode: aVariableNode	| temp |	aVariableNode binding isTemp ifFalse: [^self].	aVariableNode binding scope isHome ifTrue: [^self].		temp := methodScope rawVar: aVariableNode name.	temp ifNil: [temp := methodScope addTemp: aVariableNode name].	temp markArg.	aVariableNode binding: temp.	! !!LiteralList commentStamp: 'ajh 3/25/2003 00:31' prior: 0!Holds a unique ordered collection of literals!!LiteralList methodsFor: 'adding' stamp: 'ajh 3/6/2003 18:00'!addLast: object	"Only add if not already in list"	(equalitySet includes: object) ifTrue: [^ object].	equalitySet add: object.	super addLast: object.	^ object! !!LiteralList methodsFor: 'accessing' stamp: 'ajh 1/21/2003 12:21'!indexOf: anElement startingAt: start ifAbsent: exceptionBlock	start to: self size do:		[:index | ((self at: index) literalEqual: anElement) ifTrue: [^ index]].	^ exceptionBlock value! !!LiteralList methodsFor: 'private' stamp: 'ajh 1/21/2003 12:21'!setCollection: anArray	super setCollection: anArray.	equalitySet _ LiteralSet new: anArray size.! !!CompilerRegressionTest commentStamp: 'md 3/22/2005 14:51' prior: 0!These are tests that recompile the whole image. This takes a long time. Butif such a test runs to completion, we are sure that there are no errors.These tests are disabled by default. To enable:       CompilerRegressionTest runLongTestCases.Disable:       CompilerRegressionTest doNotRunLongTestCases.!!CompilerRegressionTest methodsFor: 'testing' stamp: 'md 3/22/2005 15:56'!testBytecodeDecompileToIR	"decompile all the byteocde of all methods of all classes to IR"	self shouldnt: [		Smalltalk allClasses do: [:class |				class methodDict values do: [:m |							m ir.				] displayingProgress: 'decompiling'		]	] raise: Error.! !!CompilerRegressionTest methodsFor: 'testing' stamp: 'md 3/22/2005 15:56'!testBytecodeDecompileToIRAndRegenerate	"decompile all the byteocde of all methods of all classes to IR. Then it      gnerates a new method using IRBuilder"	self shouldnt: [			Smalltalk allClasses do: [:class|					class methodDict values do: [:m |						(m ir) compiledMethodWith: #().					] displayingProgress: 'recompiling'			]	] raise: Error.! !!CompilerRegressionTest methodsFor: 'testing' stamp: 'md 3/22/2005 16:26'!testBytecodeRecompile	"recompile the image BC->IR->BC and install"	| new |	self shouldnt: [			Smalltalk allClasses do: [:class|					class methodDict keysAndValuesDo: [:s :m |							new := (m ir) compiledMethodWith: m trailer.							class methodDict at: s put: new.					]			]	] raise: Error.! !!BytecodeDecompiler commentStamp: 'ajh 3/25/2003 00:26' prior: 0!I interpret bytecode instructions, sending the appropriate instruction messages to my IRBuilder, resulting in an IRMethod.!!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'md 10/11/2004 15:21'!blockReturnTop	irBuilder blockReturnTop! !!BytecodeDecompiler methodsFor: 'public access' stamp: 'md 2/25/2006 16:20'!decompile: aCompiledMethod	| ir |	self method: aCompiledMethod pc: aCompiledMethod initialPC.	irBuilder := IRBuilder new.	irBuilder primitiveNode: aCompiledMethod primitiveNode.	irBuilder numRargs: aCompiledMethod numArgs + 1.	irBuilder addTemps: (0 to: aCompiledMethod numTemps).	irBuilder properties: aCompiledMethod properties copy.	aCompiledMethod isQuick		ifTrue: [self quickMethod]		ifFalse: [self interpret].	ir := irBuilder ir.	ir privCompiledMethod: aCompiledMethod.	^ ir! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/10/2003 14:53'!doDup	irBuilder pushDup! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/10/2003 14:55'!doPop	irBuilder popTop! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'md 8/2/2005 17:11'!interpretNextInstructionFor: client	| byteIndex |	byteIndex := pc - self method initialPC + 1.	irBuilder mapToByteIndex: byteIndex.	irBuilder testJumpAheadTarget: byteIndex.	super interpretNextInstructionFor: client.! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'md 9/29/2005 11:24'!jump: dist	| index seq instr newSeq seqs |	index := pc + dist - self method initialPC + 1.	dist >= 0 ifTrue: [		"Maybe we are jumping over a non-closure Block." 		(irBuilder currentSequence notEmpty and: [irBuilder currentSequence last isSend] and: [			irBuilder currentSequence last selector == #blockCopy:]) ifTrue:						[^irBuilder jumpOverBlockTo: index].		"jump forward"		^ irBuilder jumpAheadTo: index].	"jump backward"	seqs := irBuilder ir allSequences.	seq := seqs findLast: [:s | s notEmpty and: [s first bytecodeIndex <= index]].	seq := seqs at: seq.	seq first bytecodeIndex = index ifTrue: [		newSeq := seq.	] ifFalse: [		instr := seq detect: [:i | (seq after: i) bytecodeIndex = index].		newSeq := seq splitAfter: instr.	].	irBuilder addJumpBackTarget: index to: newSeq.	irBuilder jumpBackTo: index.! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 13:59'!jump: dist if: bool	| index |	index _ pc + dist - self method initialPC + 1.	dist >= 0 ifTrue: [		"jump forward"		^ irBuilder jumpAheadTo: index if: bool].	self error: 'can only conditional jump forward'! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:34'!methodReturnConstant: value	self		pushConstant: value;		methodReturnTop! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:33'!methodReturnReceiver	self		pushReceiver;		methodReturnTop! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:31'!methodReturnTop	irBuilder returnTop! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'md 7/7/2005 14:12'!popIntoLiteralVariable: offset	self		storeIntoLiteralVariable: offset;		doPop! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:33'!popIntoReceiverVariable: offset	self		storeIntoReceiverVariable: offset;		doPop! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:34'!popIntoTemporaryVariable: offset	self		storeIntoTemporaryVariable: offset;		doPop! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:34'!pushActiveContext	irBuilder pushThisContext! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:35'!pushConstant: value	irBuilder pushLiteral: value! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'md 7/9/2005 22:28'!pushLiteralVariable: assoc	irBuilder pushLiteralVariable: assoc.! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:35'!pushReceiver	irBuilder pushReceiver! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'md 6/13/2005 13:58'!pushReceiverVariable: offset	Preferences compileBlocksAsClosures ifTrue: [self pushReceiver].	irBuilder pushInstVar: offset + 1.! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:36'!pushTemporaryVariable: offset	irBuilder pushTemp: offset + 1! !!BytecodeDecompiler methodsFor: 'private' stamp: 'ajh 3/15/2003 15:43'!quickMethod	self method primitive = 256 ifTrue: [		^ self methodReturnReceiver	].	self method isReturnSpecial ifTrue: [		^ self methodReturnConstant: (BytecodeGenerator specialConstants at: self method primitive - 256)	].	self method isReturnField ifTrue: [		self pushReceiverVariable: self method returnField.		^ self methodReturnTop	].	self halt: 'quick method inconsistency'! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'md 6/20/2005 11:50'!send: selector super: superFlag numArgs: numArgs	selector == #privRemoteReturnTo: ifTrue: [^ irBuilder remoteReturn].	superFlag		ifTrue: [irBuilder send: selector toSuperOf: self method literals last value]		ifFalse: [irBuilder send: selector]! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'md 7/7/2005 14:14'!storeIntoLiteralVariable: value	irBuilder storeIntoLiteralVariable: value! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'md 6/13/2005 14:01'!storeIntoReceiverVariable: offset	Preferences compileBlocksAsClosures ifTrue: [self pushReceiver].	irBuilder storeInstVar: offset + 1.! !!BytecodeDecompiler methodsFor: 'instruction decoding' stamp: 'ajh 3/2/2003 11:39'!storeIntoTemporaryVariable: offset	irBuilder storeTemp: offset + 1! !!RBDoItNode methodsFor: '*newcompiler' stamp: 'ajh 6/28/2004 13:52'!compiledMethod	^ self ir compiledMethod! !!RBDoItNode methodsFor: '*newcompiler' stamp: 'md 2/21/2006 14:41'!generate	"The receiver is the root of a parse tree. Answer a CompiledMethod. The	argument, trailer, is the references to the source code that is stored with 	every CompiledMethod."	^self generate: #(0 0 0 0)! !!RBDoItNode methodsFor: '*newcompiler' stamp: 'ajh 3/10/2003 20:23'!generate: trailer	^ self generateIR compiledMethodWith: trailer! !!RBDoItNode methodsFor: '*newcompiler' stamp: 'ajh 6/23/2004 19:52'!generateIR	^ ir _ ASTTranslator new		visitNode: self;		ir! !!RBDoItNode methodsFor: '*newcompiler' stamp: 'pmm 8/16/2006 21:34'!generateWith: trailer using: aCompiledMethodClass	^ self generateIR compiledMethodWith: trailer using: aCompiledMethodClass! !!RBDoItNode methodsFor: '*newcompiler' stamp: 'ajh 3/10/2003 20:25'!ir	^ ir ifNil: [self generateIR]! !!RBDoItNode methodsFor: '*newcompiler' stamp: 'md 3/16/2006 18:47'!verifyIn: classOrScope	"Look up vars in classOrScope.  My tree will be annotated with bindings to LexicalScopes and ScopeVars."	ASTChecker new		scope: classOrScope parseScope;		visitNode: self.	Preferences compileBlocksAsClosures ifFalse: [ 		NonClosureScopeFixer new visitNode: self.	]	! !"NewCompiler"!!ChooserMorph class methodsFor: 'as yet unclassified' stamp: 'dvf 9/8/2001 15:25'!choose: messageString multipleSelect: multiSelectBoolean fromList: listCollection values: listValues cancel: aBlock 	^self 		choose: messageString		multipleSelect: multiSelectBoolean		fromList: listCollection		values: listValues		cancel: aBlock		initialSelections: #()! !!ChooserMorph class methodsFor: 'as yet unclassified' stamp: 'dvf 9/8/2001 15:24'!choose: messageString multipleSelect: multiSelectBoolean fromList: listCollection values: listValues cancel: aBlock initialSelections: initialSelectionCollection 	^self new 		choose: messageString		multipleSelect: multiSelectBoolean		fromList: listCollection		values: listValues		cancel: aBlock		initialSelections: initialSelectionCollection! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'dvf 9/30/2001 02:08'!accept	response := OrderedCollection new.	listSelections 		doWithIndex: [:selection :index | selection ifTrue: [response add: (values at: index)]].	response := response asArray.	isMultipleSelect 		ifFalse: [response := response ifEmpty: [nil] ifNotEmpty: [:col | col first]].	done := true! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'dvf 9/8/2001 02:13'!addButtonRow	| b spacer buttonRow |	b := SimpleButtonMorph new target: self; color: Color veryLightGray.	spacer := AlignmentMorph newSpacer: self color.	buttonRow := AlignmentMorph newRow		borderWidth: 1;		color: self color;		width: self innerBounds width;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		position: self innerBounds left@self lastSubmorph bottom.	buttonRow		addMorphBack: spacer fullCopy;		addMorphBack: (b fullCopy label: 'OK'; actionSelector: #accept);		addMorphBack: spacer fullCopy;		addMorphBack: (b fullCopy label: 'Cancel'; actionSelector: #cancel);		addMorphBack: spacer fullCopy.	self addMorphBack: buttonRow.! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'dvf 9/8/2001 02:12'!addLabel: queryString	| lines queryMorph |	lines := queryString asString findTokens: String cr.	queryMorph := AlignmentMorph newColumn		borderWidth: 1;		color: self color;		width: self innerBounds width;		hResizing: #spaceFill;		vResizing: #shrinkWrap;		position: self innerBounds topLeft.	lines do: [:s | queryMorph addMorphBack: (StringMorph contents: s)].	self addMorph: queryMorph.! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'bh 11/8/2000 16:29'!addLine	| line |	line := RectangleMorph new color: Color black;		extent: self width@borderWidth;		position: self left@self lastSubmorph bottom.	self addMorphBack: line.! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'bh 11/8/2000 16:30'!cancel	response := cancelBlock value.	done := true.! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'dvf 9/8/2001 15:25'!choose: messageString multipleSelect: multiSelectBoolean fromList: listCollection values: listValues cancel: aBlock 	^self 		choose: messageString		multipleSelect: multiSelectBoolean		fromList: listCollection		values: listValues		cancel: aBlock		initialSelections: #()! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'dvf 9/30/2001 01:57'!choose: messageString multipleSelect: multiSelectBoolean fromList: listCollection values: listValues cancel: aBlock initialSelections: initialSelectionCollection 	isMultipleSelect := multiSelectBoolean.	listSelections := listCollection collect: [:each | false].	values := listValues.	list := listCollection collect: [:each | each asString].	cancelBlock := aBlock.	done := false.	self openShowing: messageString.	self setInitialSelections: initialSelectionCollection.	^self getUserResponse! !!ChooserMorph methodsFor: 'accessing' stamp: 'bh 11/8/2000 16:30'!color	^Color white.! !!ChooserMorph methodsFor: 'submorphs-add/remove' stamp: 'bh 11/8/2000 16:30'!delete	self breakDependents.	^ super delete! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'dvf 9/30/2001 01:58'!getUserResponse	"Wait for the user to accept or cancel, and answer the result string. Answers the empty string if the user cancels."	| w |	w := self world.	w ifNil: [^response].	done := false.	[done] whileFalse: [w doOneCycle].	self delete.	w doOneCycle.	^response! !!ChooserMorph methodsFor: 'initialization' stamp: 'nk 2/25/2005 08:33'!initialize	super initialize.	self borderWidth: 0.	self layoutPolicy: TableLayout new.	self		hResizing: #shrinkWrap;		vResizing: #shrinkWrap.	self color: Color black.	self		layoutInset: 1;		cellInset: 0.	self extent: 200 @ 200.	listIndex := 0.! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'bh 11/8/2000 16:31'!list	^ list! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 08:07'!listIndex	^ listIndex! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'bh 11/8/2000 16:31'!listSelectionAt: anInteger	^listSelections at: anInteger.! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 08:03'!listSelectionAt: anInteger put: aBoolean	listSelections at: anInteger put: aBoolean.	self changed: #listSelectionAt:! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 08:35'!openShowing: messageString 	| listPane |	self removeAllMorphs.	listIndex := 0.	self addLabel: messageString.	self width: (self width max: self firstSubmorph width + (2 * borderWidth)).	listPane := isMultipleSelect 				ifTrue: 					[PluggableListMorphOfMany 						on: self						list: #list						primarySelection: #listIndex						changePrimarySelection: #toggleListIndex:						listSelection: #listSelectionAt:						changeListSelection: #listSelectionAt:put:						menu: nil						keystroke: nil]				ifFalse: 					[PluggableListMorph 						on: self						list: #list						selected: #listIndex						changeSelected: #toggleListIndex:						menu: nil						keystroke: nil].	listPane		color: self color;		hResizing: #spaceFill; vResizing: #spaceFill;		position: self innerBounds left @ self lastSubmorph bottom.	self addMorphBack: listPane.	self addButtonRow.	self height: ((((self list size * listPane font height) + submorphs first height + submorphs last height) min: Display height * 2 / 3) max: 100).	World addMorph: self centeredNear: ActiveHand position! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'bh 11/8/2000 16:32'!response	^ response! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'bh 11/8/2000 16:32'!response: aText	"Sent when text pane accepts."	response := aText asString.	done := true.	^ true! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 08:09'!setInitialSelections: aCollection 	list 		doWithIndex: [:item :index | self listSelectionAt: index put: (aCollection includes: item)].	listIndex := 0.	self changed: #listIndex.	self changed: #listIndexAt:! !!ChooserMorph methodsFor: 'as yet unclassified' stamp: 'nk 2/25/2005 08:08'!toggleListIndex: newListIndex	newListIndex isZero ifFalse: [		listSelections at: newListIndex put: (listSelections at: newListIndex) not.		self changed: #listSelectionAt: ].	listIndex := newListIndex.	self changed: #listIndex.! !!Trait methodsFor: '*RefactoringEngine' stamp: 'md 3/14/2006 16:44'!includesBehavior: aClass	^false! !!SharedPool class methodsFor: '*RefactoringEngine' stamp: 'dvf 9/17/2003 03:10'!keys	^self classPool keys! !!BrowserEnvironmentTest methodsFor: 'universal tests'!categoriesFor: anEnvironment 	| allCategories |	allCategories := Set withAll: BrowserEnvironment new categories.	allCategories removeAll: anEnvironment categories.	anEnvironment not categories 		do: [:each | allCategories remove: each ifAbsent: []].	allCategories 		do: [:each | self assert: (BrowserEnvironment new classNamesFor: each) isEmpty]! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!classNamesFor: anEnvironment 	| classNames |	classNames := (anEnvironment classNames asSet)				addAll: anEnvironment not classNames;				yourself.	self assert: classNames asSortedCollection 				= BrowserEnvironment new classNames asSortedCollection.	self assert: (anEnvironment & anEnvironment not) classNames isEmpty.	self 		assert: (anEnvironment | anEnvironment not) classNames asSortedCollection 				= BrowserEnvironment new classNames asSortedCollection! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!classesFor: aBrowserEnvironment 	| allClasses |	allClasses := aBrowserEnvironment classes asSet.	allClasses addAll: aBrowserEnvironment not classes.	BrowserEnvironment new classesDo: [:each | allClasses remove: each].	self assert: allClasses isEmpty! !!BrowserEnvironmentTest methodsFor: 'universal tests'!copyFor: aBrowserEnvironment 	| newEnvironment |	newEnvironment := aBrowserEnvironment copy.	self assert: newEnvironment numberSelectors 				= aBrowserEnvironment numberSelectors.	self 		assert: (newEnvironment not & aBrowserEnvironment) numberSelectors = 0! !!BrowserEnvironmentTest methodsFor: 'universal tests'!keysFor: aBrowserEnvironment 	| allKeys |	allKeys := Set withAll: aBrowserEnvironment keys.	allKeys addAll: aBrowserEnvironment not keys.	allKeys removeAll: Smalltalk keys.	self assert: allKeys isEmpty! !!BrowserEnvironmentTest methodsFor: 'universal tests'!numberSelectorsFor: aBrowserEnvironment 	self 		assert: aBrowserEnvironment numberSelectors 				+ aBrowserEnvironment not numberSelectors 					= BrowserEnvironment new numberSelectors.	self 		assert: (aBrowserEnvironment & aBrowserEnvironment not) numberSelectors = 0.	self assert: (universalEnvironment & aBrowserEnvironment) numberSelectors 				= aBrowserEnvironment numberSelectors.	self assert: (aBrowserEnvironment & universalEnvironment) numberSelectors 				= aBrowserEnvironment numberSelectors! !!BrowserEnvironmentTest methodsFor: 'set up'!setUp	super setUp.	universalEnvironment := BrowserEnvironment new! !!BrowserEnvironmentTest methodsFor: 'universal tests'!storeStringFor: aBrowserEnvironment	| newEnvironment |	newEnvironment := Compiler evaluate: aBrowserEnvironment storeString.	self assert: newEnvironment numberSelectors = aBrowserEnvironment numberSelectors.	self assert: (newEnvironment not & aBrowserEnvironment) numberSelectors = 0	! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests' stamp: 'dvf 8/27/2003 15:02'!testAllClassesDo	| allClasses aBrowserEnvironment |	aBrowserEnvironment := BrowserEnvironment new.	allClasses := Set new.	aBrowserEnvironment classesDo: [:each | allClasses add: each].	SystemNavigation new allBehaviorsDo: [:each | allClasses remove: each].	self assert: allClasses isEmpty! !!BrowserEnvironmentTest methodsFor: 'AndEnvironment tests' stamp: 'bh 4/10/2001 16:29'!testAndEnvironment	| originalEnvironment objectPrintStringEnvironment andEnvironment |	originalEnvironment := universalEnvironment referencesTo: #printOn:.	objectPrintStringEnvironment := universalEnvironment forClass: Object				selectors: #(#fullPrintString).	andEnvironment := objectPrintStringEnvironment & originalEnvironment.	self universalTestFor: andEnvironment.	self assert: andEnvironment numberSelectors = 1.	self assert: andEnvironment classNames asArray = #(#Object).	self assert: (andEnvironment protocolsFor: Object) size = 1.	andEnvironment := originalEnvironment 				& (universalEnvironment referencesTo: #printString).	self assert: andEnvironment numberSelectors 				= (originalEnvironment referencesTo: #printString) numberSelectors.	self assert: andEnvironment classNames asSortedCollection 				= (originalEnvironment referencesTo: #printString) classNames 						asSortedCollection! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testBrowserEnvironment	self universalTestFor: BrowserEnvironment new! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testCategoryEnvironment	| aCategoryEnvironment |	aCategoryEnvironment := CategoryEnvironment 				onEnvironment: BrowserEnvironment new				categories: #(#'Kernel-Objects').	self universalTestFor: aCategoryEnvironment.	self assert: (aCategoryEnvironment implementorsOf: #printString) numberSelectors = 1! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testClassEnvironment	| aClassEnvironment |	aClassEnvironment := ClassEnvironment 				onEnvironment: BrowserEnvironment new				classes: (Array with: Object with: Object class).	self universalTestFor: aClassEnvironment.	self assert: (aClassEnvironment implementorsOf: #printString) numberSelectors = 1! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testConstructedClassEnvironment	| environment |	environment := ClassEnvironment new.	environment		addClass: Object;		addClass: OrderedCollection;		addClass: Collection.	self assert: (environment includesClass: Object).	self assert: (environment includesClass: OrderedCollection).	self assert: (environment includesClass: Collection).	self deny: (environment includesClass: Object class).	environment removeClass: Collection.	self assert: (environment includesClass: Object).	self assert: (environment includesClass: OrderedCollection).	self deny: (environment includesClass: Collection).	self assert: environment numberClasses = 2.	environment addClass: Object class.	self assert: environment numberClasses = 2.	self assert: (environment includesClass: Object class).	environment removeClass: self class.	self assert: environment numberClasses = 2! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testConstructedSelectorEnvironment	| environment newEnvironment |	environment := SelectorEnvironment new.	environment		addClass: Object selector: #printString;		addClass: OrderedCollection selector: #add:;		addClass: Collection.	self assert: (environment includesClass: Object).	self assert: (environment selectorsForClass: Object) size = 1.	self assert: (environment includesClass: OrderedCollection).	self assert: (environment selectorsForClass: OrderedCollection) size = 1.	self assert: (environment includesClass: Collection).	self assert: (environment selectorsForClass: Collection) size 				= Collection selectors size.	self deny: (environment includesClass: Object class).	newEnvironment := environment copy.	newEnvironment		removeClass: OrderedCollection;		addClass: Object selector: #printOn:;		removeClass: Object selector: #printString.	self assert: (newEnvironment includesClass: Object).	self deny: (newEnvironment includesSelector: #printString in: Object).	self deny: (newEnvironment includesClass: OrderedCollection).	self assert: (newEnvironment includesClass: Collection).	self assert: newEnvironment numberClasses = 2.	self 		assert: newEnvironment numberSelectors + 1 = environment numberSelectors.	newEnvironment addClass: Object class.	self assert: newEnvironment numberClasses = 2.	self assert: (newEnvironment includesClass: Object class).	newEnvironment removeClass: self class.	self assert: newEnvironment numberClasses = 2! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testEnvironmentWrapper	| printString wrapper |	printString := BrowserEnvironment new referencesTo: #printString.	wrapper := BrowserEnvironmentWrapper onEnvironment: printString.	self assert: wrapper numberSelectors = printString numberSelectors.	self assert: wrapper numberClasses = printString numberClasses.	self assert: wrapper environment == printString! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testImplementorsMatching	| print |	print := BrowserEnvironment new implementorsMatching: '*print*'.	self universalTestFor: print.	self assert: (print implementorsOf: #printString) numberSelectors 				= (BrowserEnvironment new implementorsOf: #printString) numberSelectors.	print 		classesAndSelectorsDo: [:class :sel | self assert: ('*print*' match: sel)]! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testMatches	| envEnvironment environmentEnvironment |	envEnvironment := BrowserEnvironment new matches: '*env*'.	environmentEnvironment := BrowserEnvironment new 				referencesTo: #environment.	self assert: (envEnvironment referencesTo: #environment) numberSelectors 				= environmentEnvironment numberSelectors! !!BrowserEnvironmentTest methodsFor: 'NotEnvironment tests' stamp: 'dvf 9/19/2001 20:41'!testNotEnvironment	| notPrintStringEnvironment printStringEnvironment |	printStringEnvironment := universalEnvironment referencesTo: #printString.	notPrintStringEnvironment := printStringEnvironment not.	self universalTestFor: notPrintStringEnvironment.	self 		assert: (notPrintStringEnvironment referencesTo: #printString) isEmpty.	self assert: (notPrintStringEnvironment not includesClass: BrowserEnvironmentTest).	self assert: (notPrintStringEnvironment not 				includesSelector: #testNotEnvironment				in: BrowserEnvironmentTest)! !!BrowserEnvironmentTest methodsFor: 'OrEnvironment tests' stamp: 'bh 9/17/2001 02:02'!testOrEnvironment	| env1 env2 orEnvironment |	self needsWork. "the following line is temporary, to help a SUnit test pass.  Literal strings withing literal arrays don't show up as references for some reason."	env2 := #printOn:.	env2 := universalEnvironment forClass: Object selectors: #(#fullPrintString).	env1 := universalEnvironment forClass: Object selectors: #(#printOn:).	self assert: (env1 | env2) numberSelectors = 2.	self assert: (env2 | env1) numberSelectors = 2.	self universalTestFor: env1 | env2.	self assert: (env1 | env1) numberSelectors = 1.	orEnvironment := env1 | env1 not.	self universalTestFor: orEnvironment.	self assert: orEnvironment numberSelectors 				= universalEnvironment numberSelectors.	self assert: orEnvironment classNames asSortedCollection 				= universalEnvironment classNames asSortedCollection.	self assert: (orEnvironment protocolsFor: Object) 				= ((universalEnvironment protocolsFor: Object) reject: [:each| (Object allMethodsInCategory: each) isEmpty ])! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testProtocolEnvironment	| aProtocolEnvironment size |	aProtocolEnvironment := ProtocolEnvironment 				onEnvironment: BrowserEnvironment new				class: Object				protocols: #(#printing #testing).	self universalTestFor: aProtocolEnvironment.	self 		assert: (aProtocolEnvironment implementorsOf: #printString) numberSelectors 				= 1.	size := 0.	aProtocolEnvironment classesDo: [:each | size := size + 1].	self assert: size = 1.	aProtocolEnvironment selectorsForClass: Object		do: 			[:each | 			self assert: (#(#printing #testing) 						includes: (BrowserEnvironment new whichProtocolIncludes: each in: Object))]! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testRemoveSelectorByAndAndNot	| aBrowserEnvironment objectPrintString |	aBrowserEnvironment := BrowserEnvironment new.	objectPrintString := SelectorEnvironment 				onEnvironment: aBrowserEnvironment.	objectPrintString addClass: Object selector: #printString.	self assert: aBrowserEnvironment numberSelectors - 1 				= (aBrowserEnvironment & objectPrintString not) numberSelectors.	self universalTestFor: aBrowserEnvironment & objectPrintString not! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testSelectMethods	| environment |	environment := BrowserEnvironment new selectMethods: [:each | false].	self assert: environment numberSelectors = 0.	self assert: environment numberClasses = 0.	environment := BrowserEnvironment new selectMethods: [:each | true].	self assert: environment numberSelectors 				= BrowserEnvironment new numberSelectors.	environment := BrowserEnvironment new 				selectMethods: [:each | each refersToLiteral: #environment].	self assert: environment numberSelectors 				= (BrowserEnvironment new referencesTo: #environment) numberSelectors! !!BrowserEnvironmentTest methodsFor: 'BrowserEnvironment tests'!testSelectorEnvironment	| printString |	printString := BrowserEnvironment new referencesTo: #printString.	self universalTestFor: printString.	self assert: printString numberSelectors 				= (printString referencesTo: #printString) numberSelectors.	self assert: printString numberClasses 				= (printString referencesTo: #printString) numberClasses! !!BrowserEnvironmentTest methodsFor: 'universal tests'!uniqueClassesIn: aBrowserEnvironment 	| allClasses |	allClasses := Set new.	aBrowserEnvironment 		classesDo: [:each | self deny: (allClasses includes: each)]! !!BrowserEnvironmentTest methodsFor: 'universal tests'!universalTestFor: aBrowserEnvironment 	self uniqueClassesIn: aBrowserEnvironment.	self numberSelectorsFor: aBrowserEnvironment.	self storeStringFor: aBrowserEnvironment.	self classNamesFor: aBrowserEnvironment.	self copyFor: aBrowserEnvironment.	self categoriesFor: aBrowserEnvironment.	self classesFor: aBrowserEnvironment.	self keysFor: aBrowserEnvironment.	self 		assert: aBrowserEnvironment problemCount = 0 = aBrowserEnvironment isEmpty! !!VariableEnvironmentTest methodsFor: 'tests'!testAddRemove	| refs |	refs := VariableEnvironment new.	refs addClass: RefactoringManager instanceVariable: 'refactorings'.	self assert: refs numberSelectors > 0.	self assert: refs numberClasses = 1.	refs removeClass: RefactoringManager instanceVariable: 'refactorings'.	self assert: refs numberSelectors = 0.	self assert: refs numberClasses = 0.	refs addClass: RefactoringManager instanceVariableReader: 'refactorings'.	self assert: refs numberSelectors > 0.	self assert: refs numberClasses = 1.	refs removeClass: RefactoringManager instanceVariableReader: 'refactorings'.	self assert: refs numberSelectors = 0.	self assert: refs numberClasses = 0.	refs addClass: RefactoringManager instanceVariableWriter: 'refactorings'.	self assert: refs numberSelectors > 0.	self assert: refs numberClasses = 1.	refs removeClass: RefactoringManager instanceVariableWriter: 'refactorings'.	self assert: refs numberSelectors = 0.	self assert: refs numberClasses = 0! !!VariableEnvironmentTest methodsFor: 'tests'!testInstVars	| refs writers readers |	refs := VariableEnvironment referencesToInstanceVariable: 'refactorings'				in: RefactoringManager.	writers := VariableEnvironment writersOfInstanceVariable: 'refactorings'				in: RefactoringManager.	readers := VariableEnvironment readersOfInstanceVariable: 'refactorings'				in: RefactoringManager.	self universalTestFor: refs.	self universalTestFor: writers.	self universalTestFor: readers.	self assert: refs numberSelectors = (writers | readers) numberSelectors! !!ExtraParsingAndFormattingTests class methodsFor: 'testing' stamp: 'nk 2/23/2005 15:56'!methodsNotToTest	^ {"WonderlandCamera >> #destroy:. 	Parser >> #externalFunctionDeclaration. 	BalloonEngineSimulation >> #circleSinTable. 	BalloonEngineSimulation >> #circleCosTable.	PlayWithMe1 >> #listPane2NewSelection:. 	PlayWithMe1 >> #listPane1NewSelection:." 	Interval >> #valuesInclude:. 	Float class >> #initialize }! !!ExtraParsingAndFormattingTests methodsFor: 'testing' stamp: 'bh 4/29/2000 17:34'!methodsNotToTest	^ self class methodsNotToTest.! !!ExtraParsingAndFormattingTests methodsFor: 'testing' stamp: 'bh 9/16/2001 22:21'!testParsingAndFormattingEverything	self needsWork. "commented to speed regression testing.  be sure to uncomment."	"Smalltalk allBehaviorsDo: 		[:class | Transcript cr; show:class name.		class selectors do: 			[:sel | (self methodsNotToTest includes: class >> sel) ifFalse: 				[| source tree1 tree2| 				tree2 := RBParser parseMethod: (tree1 := RBParser parseMethod: (class sourceCodeAt: sel)) formattedCode.				self assert:tree1 = tree2]]]"! !!ParserTest methodsFor: 'accessing'!buildArgumentSearch	self 		createArgumentSearchWith: 'aSmalllintContext'		selectors: #(#checkMethod: #checkClass:)		inClass: BasicLintRuleTest! !!ParserTest methodsFor: 'accessing'!buildMessageSearch	self 		createSearchWith: '``@receiver -> ``@arg'		selectors: #(superSends superSends)		inClass: TransformationRuleTest! !!ParserTest methodsFor: 'accessing'!buildMethodArgumentSearch	"Two argument methods"	self 		createMethodSearchWith: '`arg1: `arg1 `arg2: `arg2 | `@temps | `@.Stmts'		selectors: #(#subclassOf:overrides: #createMatcherFor:method: #createParseTreeRule:name:)		inClass: BasicLintRuleTest class! !!ParserTest methodsFor: 'accessing'!buildMethodSearch	"Simple forwarders"	self 		createMethodSearchWith: '`@methodName: `@args ^`@object `@methodName: `@args'		selectors: #(#problemCount isEmpty)		inClass: TransformationRuleTest! !!ParserTest methodsFor: 'accessing'!buildMethodTitleSearch	self 		createMethodSearchWith: 'initialize | `@temps | `@.Stmts'		selectors: #(#initialize)		inClass: BasicLintRuleTest! !!ParserTest methodsFor: 'accessing'!buildSimpleLiteralSearch	| search |	search := ParseTreeSearcher new.	search 		matchesAnyTreeOf: (Array with: (RBParser 						parseExpression: '#(''bugs'' ''possible bugs'' ''unnecessary code'' ''intention revealing'' ''miscellaneous'')'))		do: 			[:aNode :answer | 			answer				remove: self currentSelector ifAbsent: [self error: 'failed'];				yourself].	search answer: #(#protocols) asBag.	(classSearches at: BasicLintRuleTest class ifAbsentPut: [Set new]) 		add: search! !!ParserTest methodsFor: 'accessing'!buildSimpleVariableSearch	self 		createSearchWith: 'result'		selectors: #(#checkClass: #checkMethod: #isEmpty #problemCount #resetResult #resetResult #resetResult #result #result: #resultClass: #viewResults)		inClass: BasicLintRuleTest! !!ParserTest methodsFor: 'accessing'!buildStatementSearch	"Two or more statements"	self 		createSearchWith: '| `@temps | ``@.Stmts1. ``.Stmt1. ``@.Stmts2. ``.Stmt2. ``@.Stmts3'		selectors: #(#checkMethod: #rewriteUsing: #viewResults #superSends)		inClass: TransformationRuleTest! !!ParserTest methodsFor: 'accessing'!compare: anObject to: anotherObject 	self assert: anObject hash = anotherObject hash.	self assert: anObject = anotherObject! !!ParserTest methodsFor: 'accessing'!createArgumentSearchWith: aCodeString selectors: selectorCollection inClass: aClass 	| search |	search := ParseTreeSearcher new.	search matchesAnyArgumentOf: (Array with: aCodeString)		do: 			[:aNode :answer | 			answer				remove: self currentSelector ifAbsent: [self error: 'failed'];				yourself].	search answer: selectorCollection asBag.	(classSearches at: aClass ifAbsentPut: [Set new]) add: search! !!ParserTest methodsFor: 'accessing'!createMethodSearchWith: aCodeString selectors: selectorCollection inClass: aClass 	| search |	search := ParseTreeSearcher new.	search matchesAnyMethodOf: (Array with: aCodeString)		do: 			[:aNode :answer | 			answer				remove: self currentSelector ifAbsent: [self error: 'failed'];				yourself].	search answer: selectorCollection asBag.	(classSearches at: aClass ifAbsentPut: [Set new]) add: search! !!ParserTest methodsFor: 'accessing'!createSearchWith: aCodeString selectors: selectorCollection inClass: aClass 	| search |	search := ParseTreeSearcher new.	search matches: aCodeString		do: 			[:aNode :answer | 			answer				remove: self currentSelector ifAbsent: [self error: 'failed'];				yourself].	search answer: selectorCollection asBag.	(classSearches at: aClass ifAbsentPut: [Set new]) add: search! !!ParserTest methodsFor: 'accessing'!currentSelector	^currentSelector! !!ParserTest methodsFor: 'private'!parseError: each 	RBParser parseExpression: each first		onError: [:string :pos | ^self assert: pos = each last].	self error: 'Parser didn''t fail'! !!ParserTest methodsFor: 'accessing'!setUp	super setUp.	classSearches := Dictionary new.	self		buildMethodSearch;		buildSimpleVariableSearch;		buildSimpleLiteralSearch;		buildMessageSearch;		buildStatementSearch;		buildArgumentSearch;		buildMethodTitleSearch;		buildMethodArgumentSearch! !!ParserTest methodsFor: 'tests'!testAllSearches	classSearches keysAndValuesDo: 			[:class :searches | 			class selectors do: 					[:sel | 					currentSelector := sel.					searches 						do: [:each | each executeTree: (class parseTreeFor: sel) initialAnswer: each answer]]].	classSearches 		do: [:searches | searches do: [:each | self assert: each answer isEmpty]]! !!ParserTest methodsFor: 'tests'!testBestNodeFor	| tree |	tree := self treeWithEverything.	tree nodesDo: 			[:each | 			each sourceInterval isEmpty 				ifFalse: 					[self assert: ((tree bestNodeFor: each sourceInterval) = each 								or: [each parent isCascade and: [each parent messages last = each]])]]! !!ParserTest methodsFor: 'tests'!testBlockRewrites	| rewriter tree |	tree := RBParser 				parseMethod: 'method: asdf	<primitive: 1>	<primitive: 2>	^asdf + self foo + asdf'.	rewriter := ParseTreeRewriter new.	rewriter 		replace: 'asdf'		with: 'fdsa'		when: [:aNode | aNode parent parent isReturn].	rewriter replace: 'self foo'		withValueFrom: [:aNode | RBVariableNode named: aNode selector asString].	rewriter 		replaceArgument: 'asdf'		withValueFrom: [:aNode | RBVariableNode named: 'xxx']		when: [:aNode | false].	rewriter executeTree: tree.	self compare: tree		to: (RBParser 				parseMethod: 'method: asdf	<primitive: 1>	<primitive: 2>	^asdf +  foo + fdsa')! !!ParserTest methodsFor: 'tests'!testCascadeReplacement	| cascade |	cascade := RBParser parseExpression: 'self foo; bar; baz'.	(cascade messages at: 2) 		replaceWith: (RBParser parseExpression: 'self bar: 2').	self compare: cascade		to: (RBParser parseExpression: 'self foo; bar: 2; baz')! !!ParserTest methodsFor: 'tests'!testComparingTrees	| class |	class := BasicLintRuleTest class.	class selectors 		do: [:each | self compare: (class parseTreeFor: each) to: (class parseTreeFor: each)]! !!ParserTest methodsFor: 'tests'!testCopy	| tree |	tree := self treeWithEverything.	self compare: tree to: tree copy! !!ParserTest methodsFor: 'tests'!testCreationProtocol	| messageNode |	self compare: (RBMessageNode 				receiver: (RBVariableNode named: 'self')				selector: #+				arguments: (Array with: (RBLiteralNode value: 0)))		to: (RBParser parseExpression: 'self + 0').	messageNode := RBMessageNode receiver: (RBVariableNode named: 'self')				selector: #foo.	self compare: (RBMethodNode selector: #bar				body: (RBSequenceNode statements: (Array 								with: (RBCascadeNode messages: (Array with: messageNode with: messageNode)))))		to: (RBParser parseMethod: 'bar self foo; foo')! !!ParserTest methodsFor: 'tests' stamp: 'nk 2/23/2005 15:58'!testEquivalentExceptRenaming	#(('a 3-4' 'a 4-3' false ) ('a #[3 4]' 'a #(3 4)' false ) ('a variable1 ~~ "comment" variable2' 'a variable1 ~~ variable2' true ) ('a variable1' 'a variable2' false ) ('a [:a :b | a + b]' 'a [:b :a | a + b]' false ) ('a | a b | a + b' 'a | b a | a + b' true ) ('a | a | a msg1; msg2' 'a | b | b msg2; msg2' false ) ('a c' 'a d' true ) ('a | a b | a := b. ^b msg1' 'a | a b | b := a. ^a msg1' true ) ('a | a b | a := b. ^b msg1: a' 'a | a b | b := a. ^b msg1: a' false ) ('a: b b + 4' 'a: e e + 4' true ) ('a: b b + 4' 'b: b b + 4' false ) ('a: b b: c b + c' 'a: c b: b c + b' true ) ('a: a b: b a + b' 'a: b b: a a + b' false ) ) do: [:each | self assert: ((RBParser parseMethod: each first)				equalTo: (RBParser parseMethod: (each at: 2))				exceptForVariables: #('c' ))				== each last ]! !!ParserTest methodsFor: 'tests'!testFormatter	| class |	class := BasicLintRuleTest class.	class selectors do: 			[:each | 			self compare: (class parseTreeFor: each)				to: (RBParser parseMethod: (class parseTreeFor: each) printString)]! !!ParserTest methodsFor: 'tests'!testIntervals	| tree |	tree := self treeWithEverything.	tree nodesDo: 			[:each | 			(each parent isNil or: [each parent isCascade not]) 				ifTrue: 					[| newNode source |					source := tree source copyFrom: each start to: each stop.					newNode := each isMethod 								ifTrue: [RBParser parseMethod: source]								ifFalse: [RBParser parseExpression: source].					self compare: each to: newNode]]! !!ParserTest methodsFor: 'tests'!testIsA	| nodes types |	nodes := Bag new.	types := Set new.	#(#(#isAssignment 1) #(#isBlock 1) #(#isCascade 1) #(#isLiteral 1) #(#isMessage 3) #(#isMethod 1) #(#isReturn 1) #(#isSequence 2) #(#isValue 14) #(#isVariable 7) #(#isUsed 9) #(#isDirectlyUsed 8) #(#hasParentheses 1) #(#isBinary 0) #(#isPrimitive 0) #(#isImmediate 9)) 		do: 			[:each | 			each last timesRepeat: [nodes add: each first].			types add: each first].	self treeWithEverything nodesDo: 			[:each | 			types do: 					[:sel | 					((each respondsTo: sel) and: [each perform: sel]) 						ifTrue: [nodes remove: sel]]].	self assert: nodes isEmpty! !!ParserTest methodsFor: 'tests'!testLiteralIntevals	| tree |	tree := RBParser parseExpression: '#(#a b #( c ))'.	self assert: tree token value first start = 3.	self assert: tree token value first stop = 4.	self assert: tree token value last value first start = 11! !!ParserTest methodsFor: 'tests'!testMethodPatterns	#(#('+ a ^self + a' #+) #('foo ^self foo' #foo) #('foo: a bar: b ^a + b' #foo:bar:)) 		do: [:each | self assert: (RBParser parseMethodPattern: each first) == each last]! !!ParserTest methodsFor: 'tests' stamp: 'md 2/26/2006 14:48'!testModifying	| tree |	tree := RBParser 				parseMethod: 'foo: a bar: b | c | self first. self second. a + b + c'.	self deny: tree lastIsReturn.	self deny: (tree body statements at: 2) isUsed.	self assert: tree body statements last arguments first isUsed.	self assert: (tree isLast: tree body statements last).	self deny: (tree isLast: tree body statements first).	self assert: (tree defines: 'a').	self deny: (tree defines: 'c').	self assert: (tree body defines: 'c').	self deny: (tree body defines: 'a').	tree		addReturn;		selector: #bar:foo:.	(tree body)		addTemporaryNamed: 'd';		removeTemporaryNamed: 'c'.	self compare: tree		to: (RBParser 				parseMethod: 'bar: a foo: b | d | self first. self second. ^a + b + c').	self 		assert: ((tree argumentNames asSet)				removeAll: #('a' 'b');				yourself) isEmpty.	self 		assert: ((tree allDefinedVariables asSet)				removeAll: #('a' 'b' 'd');				yourself) isEmpty.	tree := RBParser parseExpression: 'self foo: 0'.	tree selector: #+.	self compare: tree to: (RBParser parseExpression: 'self + 0').	self should: [tree selector: #foo] raise: TestResult error.! !!ParserTest methodsFor: 'tests'!testMultimatch	| rewriter count |	count := 0.	rewriter := ParseTreeRewriter new.	rewriter 		replace: '``@object at: ``@foo'		with: '``@object foo: ``@foo'		when: [:aNode | (count := count + 1) == 2].	self compare: (rewriter				executeTree: (RBParser parseExpression: 'self at: (bar at: 3)');				tree)		to: (RBParser parseExpression: 'self at: (bar foo: 3)')! !!ParserTest methodsFor: 'tests'!testNodesDo	| size |	size := 0.	self treeWithEverything nodesDo: [:e | size := size + 1].	self assert: size = 18! !!ParserTest methodsFor: 'tests' stamp: 'nk 2/23/2005 14:44'!testNumberParsing	2 to: 32		do: 			[:radix | | radixString |			radixString := radix printString, 'r'.			0 to: 72				do: 					[:i | 					self 						assert: (RBParser 								parseExpression: (radixString, (i radix: radix)))									value = i]]! !!ParserTest methodsFor: 'tests'!testParserErrors	#(#('self foo. + 3' 11) #('#(' 2) #('self 0' 6) #('self asdf;;asfd' 11)) 		do: [:each | self parseError: each]! !!ParserTest methodsFor: 'tests'!testParsingLiteralMessages	self assert: (RBParser parseExpression: 'self nil') isMessage.	self assert: (RBParser parseExpression: 'self true') isMessage.	self assert: (RBParser parseExpression: 'self false') isMessage.	self assert: (RBParser parseExpression: 'self -1') isMessage! !!ParserTest methodsFor: 'tests'!testPatternCascade	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter replace: 'self `;messages; foo: 4; `;messages1'		with: 'self `;messages1; bar: 4; `;messages'.	self compare: (rewriter				executeTree: (RBParser 							parseExpression: 'self foo; printString; foo: 4; bar. self foo: 4');				tree)		to: (RBParser 				parseExpression: 'self bar; bar: 4; foo; printString. self foo:4')! !!ParserTest methodsFor: 'tests' stamp: 'md 2/26/2006 14:45'!testPositions	| blockNode |	blockNode := RBParser parseExpression: '[:a :b | ]'.	self assert: blockNode left = 1.	self assert: blockNode right = 10.	self assert: blockNode bar = 8.	self assert: blockNode sourceInterval = (1 to: 10).	self assert: blockNode size = 1.	"test dummy collection protocol"	blockNode printString.	"coverage"	self deny: (blockNode isLast: (RBVariableNode named: 'b')).	self compare: blockNode		to: (RBBlockNode 				arguments: (OrderedCollection with: (RBVariableNode named: 'a')						with: (RBVariableNode named: 'b'))				body: (RBSequenceNode statements: #())).				! !!ParserTest methodsFor: 'tests' stamp: 'nk 2/23/2005 15:58'!testPrimitives	self assert: (Object parseTreeFor: #basicAt:) isPrimitive.	#(('foo ^true' false ) ('foo <some tag> ^true' false ) (' foo <some tag> <primitive: 123> ^true' true ) ) do: [:each | self assert: (RBParser parseMethod: each first) isPrimitive = each last]! !!ParserTest methodsFor: 'tests'!testQuerying	| tree aNode arg1Node bNode |	tree := RBParser 				parseMethod: ('test: a`	| b |`	b := (self foo: a; bar) baz.`	b := super test: b.`	^[:arg1 | self foa1 + (super foo: arg1 foo: a foo: b)]' 						copyReplaceAll: '`'						with: (String with: (Character value: 13))).	self 		assert: tree selfMessages asSortedCollection asArray = #(#bar #foa1 #foo:).	self assert: tree superMessages asSortedCollection asArray 				= #(#foo:foo:foo: #test:).	aNode := tree whichNodeIsContainedBy: (112 to: 112).	self assert: aNode name = 'a'.	bNode := tree whichNodeIsContainedBy: (119 to: 119).	self assert: bNode name = 'b'.	arg1Node := tree whichNodeIsContainedBy: (102 to: 105).	self assert: arg1Node name = 'arg1'.	self assert: (arg1Node statementNode isMessage 				and: [arg1Node statementNode selector = #+]).	self assert: (arg1Node whoDefines: 'arg1') isBlock.	self assert: (aNode whoDefines: 'a') isMethod.	self assert: (aNode whoDefines: 'b') isSequence.	self assert: (tree whichNodeIsContainedBy: (91 to: 119)) selector 				= #foo:foo:foo:.	self assert: (tree whichNodeIsContainedBy: (69 to: 121)) isBlock.	self assert: (tree whichNodeIsContainedBy: (69 to: 118)) isNil.	self assert: aNode blockVariables asSortedCollection asArray = #('arg1').	self assert: aNode temporaryVariables asSortedCollection asArray = #('b').	self assert: tree allDefinedVariables asSortedCollection asArray 				= #('a' 'arg1' 'b').	self assert: tree allArgumentVariables asSortedCollection asArray 				= #('a' 'arg1').	self 		assert: tree allTemporaryVariables asSortedCollection asArray = #('b')! !!ParserTest methodsFor: 'tests' stamp: 'nk 2/23/2005 15:58'!testReadBeforeWritten	#(('a ifTrue: [^self]' true ) ('self foo. a := b' false ) ('condition ifTrue: [a := b] ifFalse: [self foo: a]' true ) ('condition ifTrue: [a := b] ifFalse: [self foo]. a isNil' true ) ('condition ifTrue: [a := b]. a := c' false ) ('[a := b] whileFalse: [a isNil]' false ) ('self foo: b' false ) ) do: 		[:each | 		self assert: ((RBReadBeforeWrittenTester readBeforeWritten: #('a' ) in: (RBParser parseExpression: each first))				includes: 'a')				== each last.		self assert: (RBReadBeforeWrittenTester isVariable: 'a' readBeforeWrittenIn: (RBParser parseExpression: each first))				= each last].	#('| temp read written written1 |			read ifTrue: [^self].			written1 := self foo ifFalse: [written := true] ifTrue: [written := false].			[temp := true] whileTrue: [temp notNil & written].			^temp' '| read written |			self foo ifTrue: [written := true] ifFalse: [written := false].			self foo ifTrue: [read := true].			^read' '| read written |			self foo do: [:i | i].			[| i | i := 1. i == 1] whileFalse: [read notNil]' '| written |			[written := 2] whileFalse.			self do: [:each | | read | each & read]' '| read |			self do: [:each | read := each].			self do: [:each | each & read]' ) do: 		[:each | 		| read | 		read := RBReadBeforeWrittenTester variablesReadBeforeWrittenIn: (RBParser parseExpression: each).		self assert: (read size = 1 and: [read includes: 'read'])]! !!ParserTest methodsFor: 'tests'!testReadBeforeWritten1	self 		assert: (RBReadBeforeWrittenTester variablesReadBeforeWrittenIn: (RBParser 						parseMethod: 'addAll: aCollection 	"Answer aCollection, having added all elements	 of aCollection to the receiver.	 Fail if aCollection is not a kind of	 Collection."	| newSize elementsSize growSize |	(newSize := aCollection size * 2) > elements size ifTrue: [self rehash: newSize].	elementsSize := elements size.	growSize := elementsSize // 2.	aCollection do: 			[:newObject | 			| hashIndex element |			newObject == nil ifFalse: 					[hashIndex := self hashIndexFor: newObject.										[(element := elements at: hashIndex) == nil						ifTrue: 							[elements at: hashIndex put: newObject.							(elementCount := elementCount + 1) > growSize ifTrue: 									[self expand.									elementsSize := elements size.									growSize := elementsSize // 2].							true]						ifFalse: [element == newObject]]							whileFalse: 								[(hashIndex := hashIndex + 1) > elementsSize ifTrue: [hashIndex := 1]]]].	^aCollection')) 				isEmpty! !!ParserTest methodsFor: 'tests'!testReplacingNodes	| tree search block |	tree := RBParser 				parseMethod: '+ a | a b | self ifTrue: [a] ifFalse: [b := c]. a := b. [:b :c :a | a foo: a; foo1: a; foo2: a foo: b]. ^a'.	search := ParseTreeSearcher new.	block := [:aNode :answer | aNode replaceWith: (RBVariableNode named: 'q')].	search		matches: 'a' do: block;		matchesArgument: 'a' do: block.	search executeTree: tree.	self 		assert: tree = (RBParser 						parseMethod: '+ q | q b | self ifTrue: [q] ifFalse: [b := c]. q := b. [:b :c :q | q foo: q; foo1: q; foo2: q foo: b]. ^q').	self 		assert: tree removeDeadCode = (RBParser 						parseMethod: '+ q | q b | self ifTrue: [] ifFalse: [b := c]. q := b. ^q')! !!ParserTest methodsFor: 'tests'!testRewriteMethods	#(#('arg1: a arg2: b | temp1 temp2 | self stmt1 ifTrue: [^a]. self arg1: a arg2: b' 'arg2: a arg1: b | temp1 temp2 | self stmt1 ifTrue: [^a]. self arg2: b arg2: a' '`arg1: `var1 `arg2: `var2 | `@temps | ``@.stmts. self `arg1: `var1 `arg2: `var2. `@.stmts1' '`arg2: `var1 `arg1: `var2 | `@temps | ``@.stmts. self `arg2: `var2 `arg2: `var1. `@.stmts1') #('arg1: a arg2: b | temp1 temp2 | self stmt1. self arg1: a arg2: b' 'arg1: a arg2: b | temp1 temp2 | [self stmt1] repeat' '`@args: `@vars | `@temps | `@.stmts. self `@args: `@vars' '`@args: `@vars | `@temps | [`@.stmts] repeat') #('+ a | temps | ^self primitiveValue' '- a | temps | ^self primitiveValue' '+ `temp | `@tmps | `@.stmts' '- `temp | `@tmps | `@.stmts') #('a self stmt1. self stmt2' 'a self stmt1. self stmt2' 'b | `@temps | `@.stmts' 'c | `@temps | `@.stmts')) 		do: 			[:each | 			| rewrite |			rewrite := ParseTreeRewriter new.			rewrite replaceMethod: (each at: 3) with: each last.			self compare: (RBParser 						parseMethod: (rewrite								executeTree: (RBParser parseMethod: each first);								tree) formattedCode)				to: (RBParser parseMethod: (each at: 2)).			rewrite := ParseTreeRewriter new.			rewrite replaceTree: (RBParser parseRewriteMethod: (each at: 3))				withTree: (RBParser parseRewriteMethod: each last).			self compare: (RBParser 						parseMethod: (rewrite								executeTree: (RBParser parseMethod: each first);								tree) formattedCode)				to: (RBParser parseMethod: (each at: 2))]! !!ParserTest methodsFor: 'tests' stamp: 'bh 3/16/2000 23:16'!testRewrites	#(('[:c | |a| a foo1; foo2]' '[:c | |a| b foo1; foo2]' 'a' 'b' ) ('self foo: 1. bar foo1 foo: 2. (self foo: a) foo: (b foo: c)' 'self bar: 1. bar foo1 bar: 2. (self bar: a) bar: (b bar: c)' '``@rcvr foo: ``@arg1' '``@rcvr bar: ``@arg1' ) ('3 + 4' '4 + 4' '3' '4' ) ('a := self a' 'b := self a' 'a' 'b' ) ('^self at: 1 put: 2' '^self put: 1 put: 2' '^`@rcvr `at: `@arg1 put: `@arg2' '^`@rcvr put: `@arg1 put: `@arg2' ) ('1 + 2 + 3' '0 + 0 + 0' '`#literal' '0' ) ('1 + 2 + 3. 3 foo: 4' '3 + (2 + 1). 4 foo: 3' '``@rcvr `msg: ``@arg' '``@arg `msg: ``@rcvr' ) ('self foo: a bar: b. 1 foo: a bar: b' '2 foo: a bar: b. 1 foo: a bar: b' 'self `@msg: `@args' '2 `@msg: `@args' ) ('a := b. a := c + d' 'b := a. a := c + d' '`var1 := `var2' '`var2 := `var1' ) ('^self foo value: 1' 'self return: (self foo value: 1)' '^`@anything' 'self return: `@anything' ) ('self first; second. self first; second. self a. self b' '2 timesRepeat: [self first; second]. self a. self b' '`.Stmt1. `.Stmt1. `@.stmts' '2 timesRepeat: [`.Stmt1]. `@.stmts' ) ('[:a | self a: 1 c: 2; b]' '[:a | self d: 2 e: 1; f. self halt]' '`@rcvr `msg1: `@arg1 `msg2: `@arg2; `msg' '`@rcvr d: `@arg2 e: `@arg1; f. self halt' )  ) do: 		[:each | 		| rewrite | 		rewrite := ParseTreeRewriter new.		rewrite replace: (each at: 3)			with: each last.		self compare: (RBParser parseExpression: (rewrite executeTree: (RBParser parseExpression: each first);				 tree) formattedCode)			to: (RBParser parseExpression: (each at: 2))]! !!ParserTest methodsFor: 'tests'!testSearching	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: '``@rcv at: ``@arg `sel: ``@arg1'		do: [:aNode :answer | answer + 1].	self 		assert: (searcher executeTree: (RBParser 						parseExpression: 'self at: 1 put: 2; at: 2 ifAbsent: []; ifAbsent: 2 at: 1; at: 4; foo')				initialAnswer: 0) = 2.	searcher := ParseTreeSearcher new.	searcher matches: '``@rcv `at: ``@arg1 `at: ``@arg2'		do: [:aNode :answer | answer + 1].	self 		assert: (searcher executeTree: (RBParser 						parseExpression: 'self at: 1 at: 3; at: 1 put: 32; at: 2; foo; at: 1 at: 1 at: 2')				initialAnswer: 0) = 1.	searcher := ParseTreeSearcher new.	searcher matchesMethod: 'at: `object `put: `o1 ``@rcv `put: 1'		do: [:aNode :answer | true].	self assert: (searcher 				executeTree: (RBParser parseMethod: 'at: a put: b self foo put: 1')				initialAnswer: false)! !!ParserTest methodsFor: 'tests'!testSmallDictionary	| dictionary total |	dictionary := RBSmallDictionary new: 100.	dictionary		add: 1 -> 3;		at: 2 put: 4;		at: 1 put: 4.	self assert: dictionary size = 2.	self assert: (dictionary inject: 0 into: [:sum :each | sum + each]) = 8.	self assert: (dictionary includesKey: 1).	self deny: (dictionary includesKey: 3).	total := 0.	dictionary keysDo: [:each | total := total + each].	self assert: total = 3.	dictionary removeKey: 2.	dictionary copy associationsDo: [:each | dictionary remove: each].	self assert: dictionary size = 0! !!ParserTest methodsFor: 'private'!treeWithEverything	^RBParser 		parseMethod: 'method: arg1 | temps | temps := #(10). temps foo; foo. ^(temps collect: [:e | ])'! !!ParserTest methodsFor: 'long running' stamp: 'dvf 8/27/2003 15:01'!verifyParser	SystemNavigation new allBehaviorsDo: 			[:each | 			each compilerClass = Compiler 				ifTrue: [each selectors do: [:sel | self verifySelector: sel inClass: each]]]! !!ParserTest methodsFor: 'private' stamp: 'md 8/2/2005 22:29'!verifySelector: aSelector inClass: aClass 	| myTree otherTree source |	source := aClass sourceCodeAt: aSelector.	source isNil ifTrue: [^self].	myTree := aClass parseTreeFor: aSelector.	otherTree := Parser new 				parse: (ReadStream on: source)				class: aClass				noPattern: false				context: nil				notifying: "SilentCompilerErrorHandler new" nil				ifFail: [^self].	self assert: (myTree notNil or: [otherTree isNil]).	"self should: 			[""	((Compiler new 		compile: myTree formattedCode		in: aClass		notifying: nil		ifFail: [self assert: false]) generate 		isEqualTo: (Compiler new 				compile: otherTree formattedCode				in: aClass				notifying: nil				ifFail: [self assert: false]) generate) 			ifFalse: [self halt]"	"]"! !!RBClassTest methodsFor: 'set up' stamp: 'bh 11/8/2000 14:12'!setUp	| st |	super setUp.	st := RBNamespace new.	objectClass := st classNamed: #Object.	messageNodeClass := st classNamed: #RBMessageNode.	st defineClass: 'Object subclass: #SomeClassName	instanceVariableNames: ''instanceVariable1 instanceVariable2''	classVariableNames: ''ClassVariable1''	poolDictionaries: ''TextConstants''	category: #''Refactory-Testing'''.	newClass := st classNamed: #SomeClassName! !!RBClassTest methodsFor: 'method tests'!testDefinesClassVariable	self deny: (objectClass definesClassVariable: #ClassVariable1).	self assert: (objectClass definesClassVariable: self objectClassVariable).	self assert: (newClass definesClassVariable: #ClassVariable1).	self deny: (messageNodeClass definesClassVariable: #ClassVariable1).	self 		assert: (messageNodeClass definesClassVariable: self objectClassVariable)! !!RBClassTest methodsFor: 'method tests'!testDefinesInstanceVariable	self deny: (objectClass definesInstanceVariable: 'instanceVariable1').	self assert: (newClass definesInstanceVariable: 'instanceVariable1').	self deny: (messageNodeClass definesInstanceVariable: 'instanceVariable1').	self assert: (messageNodeClass definesInstanceVariable: 'parent').	self assert: (messageNodeClass definesInstanceVariable: 'selector')! !!RBClassTest methodsFor: 'method tests'!testDefinesMethod	self assert: (objectClass definesMethod: #printString).	self assert: (newClass definesMethod: #printString).	self assert: (messageNodeClass definesMethod: #printString)! !!RBClassTest methodsFor: 'method tests' stamp: 'bh 4/3/2000 22:22'!testDefinesPoolDictionary	self deny: (objectClass definesPoolDictionary: #OpcodePool).	self assert: (newClass definesPoolDictionary: #TextConstants).	self deny: (messageNodeClass definesPoolDictionary: #OpcodePool).	self assert: ((RBNamespace new classNamed: #Text) 				definesPoolDictionary: #TextConstants)! !!RBClassTest methodsFor: 'method tests'!testHierarchy	| meta |	meta := objectClass metaclass.	self assert: (objectClass withAllSubclasses includes: meta).	self assert: (meta withAllSuperclasses includes: objectClass)! !!RBNamespaceTest methodsFor: 'class tests'!testAllClassesDo	| model classes |	classes := 0.	model := RBNamespace new.	model allClassesDo: 			[:each | 			each name = #Object ifTrue: [each allSubclasses].			classes := classes + 1].	BrowserEnvironment new classesDo: [:each | classes := classes - 1].	self assert: classes = 0! !!RBNamespaceTest methodsFor: 'class tests'!testDefineClassAfterDeletedChange	| st |	st := RBNamespace new.	st removeClassNamed: self class name.	self deny: (st includesClassNamed: self class name).	st defineClass: self class definition.	self assert: (st includesClassNamed: self class name).	self assert: (st classNamed: self class name) notNil! !!RBNamespaceTest methodsFor: 'class tests' stamp: 'bh 11/8/2000 14:13'!testDefineClassChange	| st |	st := RBNamespace new.	st 		defineClass: 'RefactoringBrowserTest subclass: #SmalltalkTestXXX				instanceVariableNames: ''''				classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Testing'''.	self assert: (st includesClassNamed: #SmalltalkTestXXX).	self assert: (st classNamed: #SmalltalkTestXXX) notNil! !!RBNamespaceTest methodsFor: 'class tests'!testImplementors	| st |	st := RBNamespace new.	self assert: ((st allImplementorsOf: #printString) 				includes: (st classNamed: #Object)).	(st classNamed: #Object) removeMethod: #printString.	self deny: ((st allImplementorsOf: #printString) 				includes: (st classNamed: #Object))! !!RBNamespaceTest methodsFor: 'class tests'!testIncludesClass	self assert: (RBNamespace new includesClassNamed: #Object).	self deny: (RBNamespace new includesClassNamed: #Object1).	self 		deny: ((RBNamespace 				onEnvironment: (ClassEnvironment onEnvironment: BrowserEnvironment new						classes: (Array with: Object))) 					includesClassNamed: #OrderedCollection)! !!RBNamespaceTest methodsFor: 'class tests' stamp: 'bh 9/17/2001 02:03'!testModelImplementorsSenders	| model class modelImps refs found |	model := RBNamespace new.	model 		defineClass: 'Object subclass: #Asdf			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Testing'''.	class := model classNamed: #Asdf.	class compile: 'storeOn: aStream ^super storeOn: aStream'		classified: #(#printing).	modelImps := model allImplementorsOf: #storeOn:.	self assert: (modelImps includes: class).	self assert: modelImps size - 1 				= (BrowserEnvironment new implementorsOf: #storeOn:) numberSelectors.	refs := BrowserEnvironment new referencesTo: #storeOn:.	found := false.	model allReferencesTo: #storeOn:		do: 			[:each | 			each modelClass = class 				ifTrue: [found := true]				ifFalse: 					[self 						assert: (refs includesSelector: each selector in: each modelClass realClass)]].	self assert: found! !!RBNamespaceTest methodsFor: 'class tests' stamp: 'bh 11/8/2000 14:13'!testRedefineClassChange	| st |	st := RBNamespace new.	st defineClass: 'nil subclass: #Object				instanceVariableNames: ''a''				classVariableNames: ''A''				poolDictionaries: ''TextConstants''				category: #''Refactory-Testing'''.	self assert: (st includesClassNamed: #Object).	self assert: (st classNamed: #Object) notNil! !!RBNamespaceTest methodsFor: 'class tests' stamp: 'bh 4/10/2001 16:21'!testReferencesPrintOn	| hasFoundObject hasFoundSelf st |	hasFoundObject := false.	hasFoundSelf := false.	st := RBNamespace new.	st allReferencesTo: #printOn:		do: 			[:each | 			hasFoundObject := hasFoundObject or: 							[each selector = #fullPrintString 								and: [each modelClass = (st classNamed: #Object)]].			hasFoundSelf := hasFoundSelf or: 							[each selector = #testReferencesPrintOn 								and: [each modelClass = (st classNamed: self class name)]]].	self assert: hasFoundObject.	self assert: hasFoundSelf! !!RBNamespaceTest methodsFor: 'class tests'!testReferencesPrintOnAfterRemove	| hasFoundObject hasFoundSelf st |	hasFoundObject := false.	hasFoundSelf := false.	st := RBNamespace new.	(st classNamed: #Object) removeMethod: #printString.	st allReferencesTo: #printOn:		do: 			[:each | 			hasFoundObject := hasFoundObject or: 							[each selector = #printString 								and: [each modelClass = (st classNamed: #Object)]].			hasFoundSelf := hasFoundSelf or: 							[each selector = #testReferencesPrintOnAfterRemove 								and: [each modelClass = (st classNamed: self class name)]]].	self deny: hasFoundObject.	self assert: hasFoundSelf! !!RBNamespaceTest methodsFor: 'class tests'!testRemoveClassChange	| st |	st := RBNamespace new.	st removeClassNamed: self class name.	self deny: (st includesClassNamed: self class name).	self assert: (st classNamed: self class name) isNil! !!RBNamespaceTest methodsFor: 'class tests'!testReparentSuperclassChange	| st superclass subclasses |	st := RBNamespace new.	superclass := st classFor: TestCase superclass.	subclasses := TestCase subclasses collect: [:each | st classFor: each].	st reparentClasses: subclasses to: superclass.	subclasses do: [:each | self assert: each superclass = superclass]! !!RBNamespaceTest methodsFor: 'class tests' stamp: 'bh 4/3/2000 15:47'!testRoots	| model |	model := RBNamespace new.	self 		assert: (model rootClasses asSortedCollection: [:a :b | a name < b name]) 				asArray 					= ((Class rootsOfTheWorld collect: [:each | model classFor: each]) 							asSortedCollection: [:a :b | a name < b name]) asArray! !!RefactoringBrowserTest class methodsFor: 'as yet unclassified' stamp: 'nk 2/23/2005 15:36'!runAllTests	"	RefactoringBrowserTest runAllTests	"	| package runner |	package := PackageInfo named: 'Refactory'.	runner := TestRunner new.	runner openAsMorph.	runner selectTestsSuchThat: [ :t | package includesClass: (Smalltalk classNamed: t) ].! !!RefactoringBrowserTest methodsFor: 'private'!convertInterval: anInterval for: aString 	"Convert the interval to ignore differences in end of line conventions."	^anInterval! !!RefactoringBrowserTest methodsFor: 'private'!executeRefactoring: aRefactoring 	aRefactoring primitiveExecute.	RBParser parseExpression: aRefactoring storeString! !!RefactoringBrowserTest methodsFor: 'private'!objectClassVariable	^Object classPool keys detect: [:each | true]! !!RefactoringBrowserTest methodsFor: 'private' stamp: 'md 8/2/2005 23:36'!proceedThroughWarning: aBlock 	aBlock on: RefactoringWarning do: [:ex | ex resume]! !!AbstractClassVariableTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AbstractClassVariableTest methodsFor: 'tests'!testAbstractClassVariable	| refactoring meta class |	refactoring := AbstractClassVariableRefactoring 				variable: 'RecursiveSelfRule'				class: TransformationRuleTest.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #TransformationRuleTest.	meta := class metaclass.	self assert: (meta parseTreeFor: #recursiveSelfRule) 				= (RBParser parseMethod: 'recursiveSelfRule ^RecursiveSelfRule').	self 		assert: (meta parseTreeFor: #recursiveSelfRule:) = (RBParser 						parseMethod: 'recursiveSelfRule: anObject RecursiveSelfRule := anObject').	self assert: (meta parseTreeFor: #nuke) 				= (RBParser parseMethod: 'nuke							self recursiveSelfRule: nil').	self 		assert: (meta parseTreeFor: #initializeAfterLoad1) = (RBParser 						parseMethod: 'initializeAfterLoad1							self recursiveSelfRule: ParseTreeSearcher new.							self recursiveSelfRule								addMethodSearches: #(''`@methodName: `@args | `@temps | self `@methodName: `@args'' ''`@methodName: `@args | `@temps | ^self `@methodName: `@args'')										-> [:aNode :answer | true]').	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext 							class := aSmalllintContext selectedClass.							(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 									[(self class recursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)										ifFalse: 											[builder compile: rewriteRule tree printString												in: class												classified: aSmalllintContext protocols]]')! !!AbstractClassVariableTest methodsFor: 'failure tests'!testInheritedName	self 		shouldFail: (AbstractClassVariableRefactoring variable: #DependentsFields				class: BasicLintRuleTest)! !!AbstractClassVariableTest methodsFor: 'failure tests'!testMetaClassFailure	self 		shouldFail: (AbstractClassVariableRefactoring variable: #RecursiveSelfRule				class: TransformationRuleTest class)! !!AbstractClassVariableTest methodsFor: 'tests'!testModelAbstractClassVariable	| refactoring meta class |	class := model classNamed: #Foo.	meta := class metaclass.	refactoring := AbstractClassVariableRefactoring 				model: model				variable: 'ClassVarName1'				class: class.	self executeRefactoring: refactoring.	self assert: (meta parseTreeFor: #classVarName1) 				= (RBParser parseMethod: 'classVarName1 ^ClassVarName1').	self 		assert: (meta parseTreeFor: #classVarName1:) = (RBParser 						parseMethod: 'classVarName1: anObject ^ClassVarName1 := anObject').	self 		assert: (meta parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo					^self classVarName1: self classVarName1 * self classVarName1 * self classVarName1').	self assert: (class parseTreeFor: #classVarName1) 				= (RBParser parseMethod: 'classVarName1							^self class classVarName1').	self 		assert: (class parseTreeFor: #classVarName1:) = (RBParser 						parseMethod: 'classVarName1: anObject							^self class classVarName1: anObject').	self 		assert: (class parseTreeFor: #asdf) = (RBParser 						parseMethod: 'asdf						^self classVarName1: (self class classVarName1: self class classVarName1 + 1)').	self 		assert: ((model classNamed: #Bar) parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo					instVarName1 := instVarName1 + instVarName2 + self class classVarName1').	self 		assert: ((model classNamed: #Bar) parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo						instVarName1 := instVarName1 + instVarName2 + self class classVarName1')! !!AbstractClassVariableTest methodsFor: 'tests'!testModelAbstractClassVariableOverridenMethodsInSubclass	| refactoring meta class |	class := model classNamed: #Foo.	meta := class metaclass.	refactoring := AbstractClassVariableRefactoring 				model: model				variable: 'ClassVarName2'				class: class.	self executeRefactoring: refactoring.	self assert: (meta parseTreeFor: #classVarName21) 				= (RBParser parseMethod: 'classVarName21 ^ClassVarName2').	self 		assert: (meta parseTreeFor: #classVarName21:) = (RBParser 						parseMethod: 'classVarName21: anObject ClassVarName2 := anObject')! !!AbstractClassVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (AbstractClassVariableRefactoring variable: #Foo				class: BasicLintRuleTest)! !!AbstractInstanceVariableTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AbstractInstanceVariableTest methodsFor: 'tests'!testAbstractInstanceVariable	| refactoring class |	refactoring := AbstractInstanceVariableRefactoring variable: 'class'				class: TransformationRuleTest.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #TransformationRuleTest.	self assert: (class parseTreeFor: #class1) 				= (RBParser parseMethod: 'class1 ^class').	self assert: (class parseTreeFor: #class:) 				= (RBParser parseMethod: 'class: anObject	class := anObject').	self 		assert: (class parseTreeFor: #superSends) = (RBParser 						parseMethod: 'superSends	| rule |	rule := ParseTreeRewriter new.	rule addSearch: ''super `@message: ``@args'' 				-> (					[:aNode | 					(self class1 withAllSubclasses 						detect: [:each | each includesSelector: aNode selector]						ifNone: [nil]) isNil] 							-> ''self `@message: ``@args'').	self rewriteUsing: rule').	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext 	self class: aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) 		ifTrue: 			[(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false) 				ifFalse: 					[builder 						compile: rewriteRule tree printString						in: self class1						classified: aSmalllintContext protocols]]')! !!AbstractInstanceVariableTest methodsFor: 'tests'!testAbstractWithAssignmentUsed	| refactoring class |	class := model classNamed: #Foo.	refactoring := AbstractInstanceVariableRefactoring 				model: model				variable: 'instVarName2'				class: class.	self executeRefactoring: refactoring.	self assert: (class parseTreeFor: #foo) 				= (RBParser parseMethod: 'foo						^self instVarName21: 3').	self 		assert: (class parseTreeFor: #instVarName2:) = (RBParser 						parseMethod: 'instVarName2: anObject						self instVarName21: anObject').	self 		assert: (class parseTreeFor: #instVarName21:) = (RBParser 						parseMethod: 'instVarName21: anObject						^instVarName2 := anObject').	self assert: (class parseTreeFor: #instVarName2) 				= (RBParser parseMethod: 'instVarName2						^instVarName2').	self 		assert: ((model classNamed: #Bar) parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo						instVarName1 := instVarName1 + self instVarName2 + ClassVarName1')! !!AbstractInstanceVariableTest methodsFor: 'tests'!testAbstractWithDefaultNamesUsed	| refactoring class |	class := model classNamed: #Foo.	refactoring := AbstractInstanceVariableRefactoring 				model: model				variable: 'instVarName1'				class: class.	self executeRefactoring: refactoring.	self 		assert: (class parseTreeFor: #bar) = (RBParser 						parseMethod: 'bar						"Add one to instVarName1"						self instVarName11: self instVarName11 + 1').	self 		assert: (class parseTreeFor: #instVarName11:) = (RBParser 						parseMethod: 'instVarName11: anObject						instVarName1 := anObject').	self assert: (class parseTreeFor: #instVarName11) 				= (RBParser parseMethod: 'instVarName11						^instVarName1').	self 		assert: ((model classNamed: #Bar) parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo						self instVarName11: self instVarName11 + instVarName2 + ClassVarName1')! !!AbstractInstanceVariableTest methodsFor: 'failure tests'!testInheritedName	self shouldFail: (AbstractInstanceVariableRefactoring variable: 'name'				class: BasicLintRuleTest)! !!AbstractInstanceVariableTest methodsFor: 'tests'!testMetaclassInstanceVariables	| refactoring class |	class := model metaclassNamed: #Foo.	class addInstanceVariable: 'foo'.	class compile: 'zzz ^foo := foo + foo * 2' classified: #(#testing).	refactoring := AbstractInstanceVariableRefactoring 				model: model				variable: 'foo'				class: class.	self executeRefactoring: refactoring.	self assert: (class parseTreeFor: #foo1) 				= (RBParser parseMethod: 'foo1						^foo').	self assert: (class parseTreeFor: #foo:) 				= (RBParser parseMethod: 'foo: anObject						^foo := anObject').	self assert: (class parseTreeFor: #zzz) 				= (RBParser parseMethod: 'zzz ^self foo: self foo1 + self foo1 * 2')! !!AbstractInstanceVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (AbstractInstanceVariableRefactoring variable: 'foo'				class: BasicLintRuleTest)! !!AddClassTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AddClassTest methodsFor: 'tests'!testAddClass	| refactoring newClass superClass classTest |	refactoring := AddClassRefactoring 				addClass: #FooTest				superclass: RefactoringTest				subclasses: (Array with: self class)				category: #'Refactory-Testing'.	self executeRefactoring: refactoring.	newClass := refactoring model classNamed: #FooTest.	superClass := refactoring model classNamed: #RefactoringTest.	classTest := refactoring model classNamed: self class name.	self assert: newClass superclass = superClass.	self assert: (superClass subclasses includes: newClass).	self assert: newClass metaclass superclass = superClass metaclass.	self 		assert: (superClass metaclass subclasses includes: newClass metaclass).	self assert: classTest superclass = newClass.	self assert: (newClass subclasses includes: classTest).	self assert: classTest metaclass superclass = newClass metaclass.	self assert: (newClass metaclass subclasses includes: classTest metaclass)! !!AddClassTest methodsFor: 'failure tests'!testExistingName	self shouldFail: (AddClassRefactoring 				addClass: #Object				superclass: self class				subclasses: #()				category: #'Refactory-Testing')! !!AddClassTest methodsFor: 'failure tests'!testInvalidSubclass	self shouldFail: (AddClassRefactoring 				addClass: #Foo				superclass: CompositeLintRuleTest				subclasses: (Array with: BasicLintRuleTest)				category: #'Refactory-Tesing')! !!AddClassTest methodsFor: 'failure tests'!testMetaClassFailure	self shouldFail: (AddClassRefactoring 				addClass: #Foo				superclass: self class class				subclasses: #()				category: #'Refactory-Testing')! !!AddClassTest methodsFor: 'tests' stamp: 'bh 3/27/2000 22:39'!testModelAddClass	| refactoring newClass superClass subclass |	subclass := model classNamed: #Bar.	superClass := model classNamed: #Foo.	refactoring := AddClassRefactoring 				model: model				addClass: #FooTest				superclass: superClass				subclasses: (Array with: subclass)				category: #'Refactory-Testing'.	self executeRefactoring: refactoring.	newClass := model classNamed: #FooTest.	self assert: newClass superclass = superClass.	self assert: (superClass subclasses includes: newClass).	self assert: newClass metaclass superclass = superClass metaclass.	self 		assert: (superClass metaclass subclasses includes: newClass metaclass).	self assert: subclass superclass = newClass.	self assert: (newClass subclasses includes: subclass).	self assert: subclass metaclass superclass = newClass metaclass.	self assert: (newClass metaclass subclasses includes: subclass metaclass)! !!AddClassTest methodsFor: 'failure tests'!testModelExistingName	| refactoring |	refactoring := AddClassRefactoring 				model: model				addClass: #Foo				superclass: Object				subclasses: #()				category: #'Refactory-Testing'.	self shouldFail: refactoring! !!AddClassTest methodsFor: 'failure tests'!testModelInvalidSubclass	| refactoring |	refactoring := AddClassRefactoring 				model: model				addClass: #Foo2				superclass: Object				subclasses: (Array with: (model classNamed: #Bar))				category: #'Refactory-Tesing'.	self shouldFail: refactoring! !!AddClassVariableTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AddClassVariableTest methodsFor: 'tests'!testAddClassVariable	| refactoring |	refactoring := AddClassVariableRefactoring variable: 'Asdf'				class: TransformationRuleTest.	self executeRefactoring: refactoring.	self assert: ((refactoring model classNamed: #TransformationRuleTest) 				directlyDefinesClassVariable: #Asdf)! !!AddClassVariableTest methodsFor: 'failure tests'!testAlreadyExistingName	self		shouldFail: (AddClassVariableRefactoring variable: #RecursiveSelfRule					class: TransformationRuleTest);		shouldFail: (AddClassVariableRefactoring variable: self objectClassVariable					class: TransformationRuleTest)! !!AddClassVariableTest methodsFor: 'failure tests'!testMetaClassFailure	self shouldFail: (AddClassVariableRefactoring variable: #VariableName				class: TransformationRuleTest class)! !!AddClassVariableTest methodsFor: 'failure tests'!testMetaclass	| refactoring |	refactoring := AddClassVariableRefactoring variable: #ClassVarName3				class: (model classNamed: #Object) metaclass.	refactoring model: model.	self shouldFail: refactoring! !!AddClassVariableTest methodsFor: 'tests'!testModelAddClassVariable	| refactoring |	refactoring := AddClassVariableRefactoring 				model: model				variable: #ClassVarName3				class: (model classNamed: #Bar).	self executeRefactoring: refactoring.	self assert: ((model classNamed: #Bar) 				directlyDefinesClassVariable: #ClassVarName3)! !!AddClassVariableTest methodsFor: 'failure tests'!testModelAlreadyExistingName	| refactoring |	refactoring := AddClassVariableRefactoring 				model: model				variable: #ClassVarName2				class: (model classNamed: #Bar).	self shouldFail: refactoring! !!AddClassVariableTest methodsFor: 'failure tests'!testModelMetaclass	| refactoring |	refactoring := AddClassVariableRefactoring 				model: model				variable: #ClassVarName3				class: (model classNamed: #Bar) metaclass.	self shouldFail: refactoring! !!AddInstanceVariableTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AddInstanceVariableTest methodsFor: 'tests'!testAddInstanceVariable	| refactoring |	refactoring := AddInstanceVariableRefactoring variable: 'asdf'				class: TransformationRuleTest.	self executeRefactoring: refactoring.	self assert: ((refactoring model classNamed: #TransformationRuleTest) 				directlyDefinesInstanceVariable: 'asdf')! !!AddInstanceVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:07'!testAddToModel	| refactoring |	model := RBNamespace new.	model name: 'Add instance variable'.	model 		defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''fdsa'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.	refactoring := AddInstanceVariableRefactoring 				model: model				variable: 'asdf'				class: (model classNamed: #FOOBAR).	self executeRefactoring: refactoring.	self assert: ((refactoring model classNamed: #FOOBAR) 				directlyDefinesInstanceVariable: 'asdf')! !!AddInstanceVariableTest methodsFor: 'failure tests'!testAlreadyExistingName	self		shouldFail: (AddInstanceVariableRefactoring variable: 'class'					class: TransformationRuleTest);		shouldFail: (AddInstanceVariableRefactoring variable: 'name'					class: TransformationRuleTest)! !!AddInstanceVariableTest methodsFor: 'failure tests'!testModelAlreadyExistingName	| refactoring |	refactoring := AddInstanceVariableRefactoring 				model: model				variable: 'instVarName1'				class: (model classNamed: #Bar).	self shouldFail: refactoring! !!AddInstanceVariableTest methodsFor: 'failure tests'!testModelMetaclassAlreadyExistingName	| refactoring |	(model metaclassNamed: #Foo) addInstanceVariable: 'instVarName1'.	refactoring := AddInstanceVariableRefactoring 				model: model				variable: 'instVarName1'				class: (model classNamed: #Bar).	self shouldFail: refactoring! !!AddInstanceVariableTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:07'!testNewExistingName	| refactoring |	model := RBNamespace new.	model name: 'Add instance variable'.	model 		defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''asdf'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.	refactoring := AddInstanceVariableRefactoring 				model: model				variable: 'asdf'				class: (model classNamed: #FOOBAR).	self shouldFail: refactoring! !!AddInstanceVariableTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:07'!testNewHierarchyExistingName	| refactoring |	model := RBNamespace new.	model name: 'Add instance variable'.	model 		defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''asdf'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.	model 		defineClass: 'FOOBAR subclass: #BARFOO 				instanceVariableNames: '''' 					classVariableNames: ''''				poolDictionaries: ''''				category: ''Refactory-Test data'''.	refactoring := AddInstanceVariableRefactoring 				model: model				variable: 'asdf'				class: (model classNamed: #BARFOO).	self shouldFail: refactoring! !!AddMethodTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AddMethodTest methodsFor: 'tests'!testAddMethod	| refactoring |	refactoring := AddMethodRefactoring 				addMethod: 'printString1 ^super printString'				toClass: BasicLintRuleTest				inProtocols: #(#accessing).	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #BasicLintRuleTest) 				parseTreeFor: #printString1) 					= (RBParser parseMethod: 'printString1 ^super printString')! !!AddMethodTest methodsFor: 'failure tests'!testBadMethod	self shouldFail: (AddMethodRefactoring 				addMethod: 'asdf ^super ^printString'				toClass: BasicLintRuleTest				inProtocols: #(#accessing))! !!AddMethodTest methodsFor: 'failure tests'!testExistingSelector	self shouldFail: (AddMethodRefactoring 				addMethod: 'printString ^super printString'				toClass: BasicLintRuleTest				inProtocols: #(#accessing))! !!AddMethodTest methodsFor: 'tests'!testModelAddMethod	| refactoring class |	class := model metaclassNamed: #Bar.	refactoring := AddMethodRefactoring 				model: model				addMethod: 'printString1 ^super printString'				toClass: class				inProtocols: #(#accessing).	self executeRefactoring: refactoring.	self assert: (class parseTreeFor: #printString1) 				= (RBParser parseMethod: 'printString1 ^super printString')! !!AddMethodTest methodsFor: 'failure tests'!testModelExistingSelector	| refactoring |	refactoring := AddMethodRefactoring 				model: model				addMethod: 'classVarName1 ^super printString'				toClass: (model classNamed: #Bar)				inProtocols: #(#accessing).	self shouldFail: refactoring! !!AddMethodTest methodsFor: 'failure tests'!testModelInheritedSelector	| refactoring |	refactoring := AddMethodRefactoring 				model: model				addMethod: 'printString ^super printString'				toClass: (model classNamed: #Bar)				inProtocols: #(#accessing).	self shouldFail: refactoring! !!AddParameterTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!AddParameterTest methodsFor: 'tests'!testAddParameterForTwoArgumentMessage	| refactoring class |	refactoring := AddParameterRefactoring 				addParameterToMethod: ('called:' , 'on:') asSymbol				in: RefactoryTestDataApp				newSelector: #called:bar:on:				initializer: '#(1.0)'.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self 		assert: (class parseTreeFor: #called:bar:on:) = (RBParser 						parseMethod: 'called: anObject bar: aBlock on: anObject1							Transcript								show: anObject printString;								cr.								aBlock value').	self 		assert: (class parseTreeFor: #caller) = (RBParser 						parseMethod: 'caller							| anObject |							anObject := 5.							self 								called: anObject + 1								bar: [^anObject] on: #(1.0)').	self deny: (class directlyDefinesMethod: ('called:' , 'on:') asSymbol)! !!AddParameterTest methodsFor: 'tests'!testAddParameterThatReferencesGlobalAndLiteral	| refactoring class |	refactoring := AddParameterRefactoring 				addParameterToMethod: ('test' , 'Foo:') asSymbol				in: RefactoryTestDataApp				newSelector: #testFoo:bar:				initializer: 'OrderedCollection new: 5'.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self 		assert: (class parseTreeFor: #testFoo:bar:) = (RBParser 						parseMethod: 'testFoo: anObject bar: anObject1								^self class + anObject').	self 		assert: (class parseTreeFor: #callFoo) = (RBParser 						parseMethod: 'callFoo ^self testFoo: 5 bar: (OrderedCollection new: 5)').	self deny: (class directlyDefinesMethod: ('test' , 'Foo:') asSymbol)! !!AddParameterTest methodsFor: 'tests'!testAddParameterThatReferencesModelGlobal	| refactoring class |	refactoring := AddParameterRefactoring 				model: model				addParameterToMethod: ('test' , 'Foo:') asSymbol				in: RefactoryTestDataApp				newSelector: #testFoo:bar:				initializer: 'Bar new'.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self 		assert: (class parseTreeFor: #testFoo:bar:) = (RBParser 						parseMethod: 'testFoo: anObject bar: anObject1								^self class + anObject').	self assert: (class parseTreeFor: #callFoo) 				= (RBParser parseMethod: 'callFoo ^self testFoo: 5 bar: (Bar new)').	self deny: (class directlyDefinesMethod: ('test' , 'Foo:') asSymbol)! !!AddParameterTest methodsFor: 'tests' stamp: 'bh 3/14/2000 18:15'!testAddParameterThatReferencesSelf	| refactoring class |	refactoring := AddParameterRefactoring				addParameterToMethod: ('test' , 'Foo:') asSymbol				in: RefactoryTestDataApp				newSelector: #testFoo:bar:				initializer: 'self printString'.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self assert: (class parseTreeFor: #testFoo:bar:)			= (RBParser parseMethod: 'testFoo: anObject bar: anObject1								^self class + anObject').	self assert: (class parseTreeFor: #callFoo)			= (RBParser parseMethod: 'callFoo ^self testFoo: 5 bar: (self printString)').	self deny: (class directlyDefinesMethod: ('test' , 'Foo:') asSymbol)! !!AddParameterTest methodsFor: 'failure tests'!testBadInitializationCode	self		shouldFail: (AddParameterRefactoring 					addParameterToMethod: #name					in: LintRuleTest					newSelector: #name:					initializer: 'foo:');		shouldFail: (AddParameterRefactoring 					addParameterToMethod: #name					in: LintRuleTest					newSelector: #name:					initializer: 'foo')! !!AddParameterTest methodsFor: 'failure tests'!testModelBadInitializationCode	| refactoring |	model removeClassNamed: #Refactoring.	refactoring := AddParameterRefactoring 				model: model				addParameterToMethod: #name1				in: LintRuleTest				newSelector: #name1:				initializer: 'AddParameterRefactoring new'.	self shouldFail: refactoring! !!AddParameterTest methodsFor: 'failure tests'!testModelNonExistantName	| refactoring |	(model classNamed: #LintRuleTest) removeMethod: #name.	refactoring := AddParameterRefactoring 				model: model				addParameterToMethod: #name				in: LintRuleTest				newSelector: #nameNew:				initializer: 'nil'.	self shouldFail: refactoring! !!AddParameterTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (AddParameterRefactoring 				addParameterToMethod: #name1				in: LintRuleTest				newSelector: #name1:				initializer: 'nil')! !!AddParameterTest methodsFor: 'failure tests'!testPrimitiveMethods	| refactoring |	(model classNamed: #Object) 		compile: 'foo <primitive: 100> ^#() primitiveFailed'		classified: #(#accessing).	refactoring := AddParameterRefactoring 				model: model				addParameterToMethod: #foo				in: Object				newSelector: #foo123124321s:				initializer: '1'.	self shouldFail: refactoring.	refactoring := AddParameterRefactoring 				addParameterToMethod: #at:				in: Object				newSelector: #at:foo:				initializer: '1'.	self shouldFail: refactoring.	! !!ChildrenToSiblingsTest methodsFor: 'set up' stamp: 'md 7/25/2005 18:08'!setUp	super setUp.	model :=  Compiler evaluate: self childrenToSiblingTestData.! !!ChildrenToSiblingsTest methodsFor: 'failure tests'!testBadName	self shouldFail: (ChildrenToSiblingsRefactoring 				name: #'Obje ct'				class: LintRuleTest				subclasses: (Array with: BasicLintRuleTest with: CompositeLintRuleTest))! !!ChildrenToSiblingsTest methodsFor: 'failure tests'!testExistingName	self		shouldFail: (ChildrenToSiblingsRefactoring 					name: #Object					class: LintRuleTest					subclasses: (Array with: BasicLintRuleTest with: CompositeLintRuleTest));		shouldFail: (ChildrenToSiblingsRefactoring 					name: #Processor					class: LintRuleTest					subclasses: (Array with: BasicLintRuleTest with: CompositeLintRuleTest))! !!ChildrenToSiblingsTest methodsFor: 'failure tests'!testInvalidSubclass	self shouldFail: (ChildrenToSiblingsRefactoring 				name: #Foo				class: LintRuleTest				subclasses: (Array with: BasicLintRule with: CompositeLintRule))! !!ChildrenToSiblingsTest methodsFor: 'failure tests'!testMetaClassFailure	self shouldFail: (ChildrenToSiblingsRefactoring 				name: #Foo				class: LintRuleTest class				subclasses: (Array with: BasicLintRuleTest class						with: CompositeLintRuleTest class))! !!ChildrenToSiblingsTest methodsFor: 'tests'!testModelChildrenToSibling	| refactoring class subclass superclass |	class := model classNamed: #ConcreteSuperclass.	subclass := model classNamed: #ConcreteSubclass.	refactoring := ChildrenToSiblingsRefactoring 				model: model				name: #AbstractSuperclass				class: class				subclasses: (Array with: subclass).	self executeRefactoring: refactoring.	superclass := refactoring model classNamed: #AbstractSuperclass.	self assert: class superclass = superclass.	self assert: class metaclass superclass = superclass metaclass.	self assert: subclass superclass = superclass.	self assert: subclass metaclass superclass = superclass metaclass.	self 		assert: (superclass parseTreeFor: #same) = (RBParser 						parseMethod: 'same ^self initialize isKindOf: AbstractSuperclass').	self assert: (superclass parseTreeFor: #different) 				= (RBParser parseMethod: 'different self subclassResponsibility').	self 		assert: (superclass parseTreeFor: #initialize) = (RBParser 						parseMethod: 'initialize							instVarName1 := instVarName2 := ClassVarName1 := ClassVarName2 := 0').	self assert: (superclass directlyDefinesInstanceVariable: 'instVarName1').	self assert: (superclass directlyDefinesInstanceVariable: 'instVarName2').	self assert: (superclass directlyDefinesClassVariable: 'ClassVarName1').	self assert: (superclass directlyDefinesClassVariable: 'ClassVarName2').	self assert: (superclass metaclass 				directlyDefinesInstanceVariable: 'classInstVarName1').	self 		assert: (superclass metaclass parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo							^classInstVarName1 + ClassVarName1 + ClassVarName2').	self assert: (superclass metaclass parseTreeFor: #new) 				= (RBParser parseMethod: 'new							^super new initialize').	self assert: (superclass metaclass parseTreeFor: #bar) 				= (RBParser parseMethod: 'bar							self subclassResponsibility').	self deny: (class directlyDefinesInstanceVariable: 'instVarName1').	self deny: (class directlyDefinesInstanceVariable: 'instVarName2').	self deny: (class directlyDefinesClassVariable: 'ClassVarName1').	self deny: (class directlyDefinesClassVariable: 'ClassVarName2').	self 		deny: (class metaclass directlyDefinesInstanceVariable: 'classInstVarName1').	self deny: (class directlyDefinesMethod: #same).	self deny: (class directlyDefinesMethod: #initialize).	self deny: (class metaclass directlyDefinesMethod: #new).	self assert: (class parseTreeFor: #different) 				= (RBParser parseMethod: 'different							^instVarName1 + instVarName2').	self assert: (class metaclass parseTreeFor: #bar) 				= (RBParser parseMethod: 'bar							^self printString')! !!CreateAccessorsForVariableTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!CreateAccessorsForVariableTest methodsFor: 'tests'!testExistingInstanceVariableAccessors	| ref |	ref := CreateAccessorsForVariableRefactoring 				variable: 'name'				class: LintRuleTest				classVariable: false.	self executeRefactoring: ref.	self assert: ref changes changes isEmpty.	self assert: ref setterMethod == #name:.	self assert: ref getterMethod == #name! !!CreateAccessorsForVariableTest methodsFor: 'tests'!testNewClassVariableAccessors	| ref class |	ref := CreateAccessorsForVariableRefactoring 				variable: 'Foo1'				class: LintRuleTest				classVariable: true.	self executeRefactoring: ref.	class := ref model metaclassNamed: #LintRuleTest.	self deny: ref changes changes isEmpty.	self assert: ref setterMethod == #foo1:.	self assert: ref getterMethod == #foo1.	self 		assert: (class parseTreeFor: #foo1) = (RBParser parseMethod: 'foo1 ^Foo1').	self assert: (class parseTreeFor: #foo1:) 				= (RBParser parseMethod: 'foo1: anObject Foo1 := anObject')! !!CreateAccessorsForVariableTest methodsFor: 'tests'!testNewInstanceVariableAccessors	| ref class |	ref := CreateAccessorsForVariableRefactoring 				variable: 'foo1'				class: LintRuleTest				classVariable: false.	self executeRefactoring: ref.	class := ref model classNamed: #LintRuleTest.	self deny: ref changes changes isEmpty.	self assert: ref setterMethod == #foo1:.	self assert: ref getterMethod == #foo1.	self 		assert: (class parseTreeFor: #foo1) = (RBParser parseMethod: 'foo1 ^foo1').	self assert: (class parseTreeFor: #foo1:) 				= (RBParser parseMethod: 'foo1: anObject foo1 := anObject')! !!CreateAccessorsForVariableTest methodsFor: 'failure tests'!testNonExistantName	self		shouldFail: (CreateAccessorsForVariableRefactoring 					variable: #Foo					class: BasicLintRuleTest					classVariable: true);		shouldFail: (CreateAccessorsForVariableRefactoring 					variable: 'foo'					class: BasicLintRuleTest					classVariable: true)! !!ExtractMethodTest methodsFor: 'failure tests'!testBadInterval	self		shouldFail: (ExtractMethodRefactoring 					extract: (self convertInterval: (24 to: 30)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					from: #testMethod					in: RefactoryTestDataApp);		shouldFail: (ExtractMethodRefactoring 					extract: (self convertInterval: (80 to: 147)							for: (BasicLintRuleTest class sourceCodeAt: #subclassOf:overrides:))					from: #subclassOf:overrides:					in: BasicLintRuleTest class)! !!ExtractMethodTest methodsFor: 'failure tests'!testExtractFailure	self		shouldFail: (ExtractMethodRefactoring 					extract: (self convertInterval: (80 to: 269)							for: (BasicLintRuleTest class sourceCodeAt: #subclassOf:overrides:))					from: #subclassOf:overrides:					in: BasicLintRuleTest class);		shouldFail: (ExtractMethodRefactoring 					extract: (self convertInterval: (53 to: 56)							for: (BasicLintRuleTest class sourceCodeAt: #subclassOf:overrides:))					from: #subclassOf:overrides:					in: BasicLintRuleTest class);		shouldFail: (ExtractMethodRefactoring 					extract: (self convertInterval: (77 to: 222)							for: (BasicLintRuleTest class 									sourceCodeAt: #subclassResponsibilityNotDefined))					from: #subclassResponsibilityNotDefined					in: BasicLintRuleTest class)! !!ExtractMethodTest methodsFor: 'tests' stamp: 'bh 3/16/2000 12:13'!testExtractMethodAtEndOfMethodThatNeedsReturn	| refactoring class |	refactoring := ExtractMethodRefactoring 				extract: (self convertInterval: (52 to: 182)						for: (LintRuleTest sourceCodeAt: #openEditor))				from: #openEditor				in: LintRuleTest.	self setupMethodNameFor: refactoring toReturn: #foo:.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #LintRuleTest.	self 		assert: (class parseTreeFor: #openEditor) = (RBParser 						parseMethod: 'openEditor	| rules |	rules := self failedRules.	^self foo: rules').	self 		assert: (class parseTreeFor: #foo:) = (RBParser 						parseMethod: 'foo: rules	rules isEmpty ifTrue: [^self].	rules size == 1 ifTrue: [^rules first viewResults].	SmalllintResultEditor openOn: self label: name')! !!ExtractMethodTest methodsFor: 'tests'!testExtractMethodThatMovesTemporaryVariable	| refactoring class |	refactoring := ExtractMethodRefactoring 				extract: (self convertInterval: (22 to: 280)						for: (TransformationRuleTest sourceCodeAt: #superSends))				from: #superSends				in: TransformationRuleTest.	self setupMethodNameFor: refactoring toReturn: #foo.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #TransformationRuleTest.	self 		assert: (class parseTreeFor: #superSends) = (RBParser 						parseMethod: 'superSends	| rule |	rule := self foo.	self rewriteUsing: rule').	self 		assert: (class parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo | rule | 	rule := ParseTreeRewriter new.	rule addSearch: ''super `@message: ``@args''				-> (					[:aNode | 					(class withAllSubclasses						detect: [:each | each includesSelector: aNode selector]						ifNone: [nil]) isNil]							-> ''self `@message: ``@args'').		^rule')! !!ExtractMethodTest methodsFor: 'tests'!testExtractMethodThatNeedsArgument	| refactoring class |	refactoring := ExtractMethodRefactoring 				extract: (self convertInterval: (145 to: 343)						for: (TransformationRuleTest sourceCodeAt: #checkMethod:))				from: #checkMethod:				in: TransformationRuleTest.	self setupMethodNameFor: refactoring toReturn: #foo:.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #TransformationRuleTest.	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext 	class := aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[self foo: aSmalllintContext]').	self 		assert: (class parseTreeFor: #foo:) = (RBParser 						parseMethod: 'foo: aSmalllintContext (RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)				ifFalse: 					[builder compile: rewriteRule tree printString						in: class						classified: aSmalllintContext protocols]')! !!ExtractMethodTest methodsFor: 'tests'!testExtractMethodThatNeedsTemporaryVariable	| refactoring class |	refactoring := ExtractMethodRefactoring 				extract: (self convertInterval: (78 to: 197)						for: (LintRuleTest sourceCodeAt: #displayName))				from: #displayName				in: LintRuleTest.	self setupMethodNameFor: refactoring toReturn: #foo:.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #LintRuleTest.	self 		assert: (class parseTreeFor: #displayName) = (RBParser 						parseMethod: 'displayName	| nameStream |	nameStream := WriteStream on: (String new: 64).	self foo: nameStream.	^nameStream contents').	self 		assert: (class parseTreeFor: #foo:) = (RBParser 						parseMethod: 'foo: nameStream 	nameStream nextPutAll: self name;		nextPutAll: '' (''.	self problemCount printOn: nameStream.	nameStream nextPut: $).')! !!ExtractMethodTest methodsFor: 'tests'!testModelExtractMethodWithTemporariesSelected	| class refactoring |	model := RBNamespace new.	class := model classNamed: self class name.	class compile: 'foo [| temp | temp := 5. temp * temp] value'		classified: #(#accessing).	refactoring := ExtractMethodRefactoring 				model: model				extract: (6 to: 36)				from: #foo				in: class.	self setupMethodNameFor: refactoring toReturn: #foobar.	self executeRefactoring: refactoring.	self assert: (class parseTreeFor: #foo) 				= (RBParser parseMethod: 'foo [self foobar] value').	self assert: (class parseTreeFor: #foobar) 				= (RBParser parseMethod: 'foobar |temp | temp := 5. ^temp * temp')! !!ExtractMethodTest methodsFor: 'tests' stamp: 'bh 9/16/2001 21:06'!testModelExtractMethodWithTemporaryAssigned	| class refactoring |	model := RBNamespace new.	class := model classNamed: self class name.	class 		compile: 'foo 				| temp bar | 				bar := 5. 				temp := bar * bar. 				Transcript show: temp printString; cr. 				^temp * temp'		classified: #(#accessing).	refactoring := ExtractMethodRefactoring 				model: model				extract: (26 to: 102)				from: #foo				in: class.	self setupMethodNameFor: refactoring toReturn: #foobar.	self executeRefactoring: refactoring.	self assert: (class parseTreeFor: #foo) 				= (RBParser parseMethod: 'foo | temp | temp := self foobar. ^temp * temp').	self 		assert: ((class parseTreeFor: #foobar) = (RBParser 						parseMethod: 'foobar | bar temp | bar := 5. temp := bar * bar. Transcript show: temp printString; cr. ^temp.')) |				((class parseTreeFor: #foobar) = (RBParser 						parseMethod: 'foobar | temp bar | bar := 5. temp := bar * bar. Transcript show: temp printString; cr. ^temp.'))! !!ExtractMethodTest methodsFor: 'failure tests'!testNonExistantSelector	self shouldFail: (ExtractMethodRefactoring 				extract: (10 to: 20)				from: #checkClass1:				in: BasicLintRuleTest)! !!ExtractMethodToComponentTest methodsFor: 'failure tests'!testBadInterval	self		shouldFail: (ExtractMethodToComponentRefactoring 					extract: (self convertInterval: (24 to: 30)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					from: #testMethod					in: RefactoryTestDataApp);		shouldFail: (ExtractMethodToComponentRefactoring 					extract: (self convertInterval: (80 to: 147)							for: (BasicLintRuleTest class sourceCodeAt: #subclassOf:overrides:))					from: #subclassOf:overrides:					in: BasicLintRuleTest class)! !!ExtractMethodToComponentTest methodsFor: 'failure tests'!testExtractFailure	self		shouldFail: (ExtractMethodToComponentRefactoring 					extract: (self convertInterval: (80 to: 269)							for: (BasicLintRuleTest class sourceCodeAt: #subclassOf:overrides:))					from: #subclassOf:overrides:					in: BasicLintRuleTest class);		shouldFail: (ExtractMethodToComponentRefactoring 					extract: (self convertInterval: (53 to: 56)							for: (BasicLintRuleTest class sourceCodeAt: #subclassOf:overrides:))					from: #subclassOf:overrides:					in: BasicLintRuleTest class);		shouldFail: (ExtractMethodToComponentRefactoring 					extract: (self convertInterval: (77 to: 222)							for: (BasicLintRuleTest class 									sourceCodeAt: #subclassResponsibilityNotDefined))					from: #subclassResponsibilityNotDefined					in: BasicLintRuleTest class)! !!ExtractMethodToComponentTest methodsFor: 'tests' stamp: 'bh 3/16/2000 12:14'!testExtractMethodAtEndOfMethodThatNeedsReturn	| refactoring class selectorsSize |	refactoring := ExtractMethodToComponentRefactoring 				extract: (self convertInterval: (52 to: 182)						for: (LintRuleTest sourceCodeAt: #openEditor))				from: #openEditor				in: LintRuleTest.	self setupMethodNameFor: refactoring toReturn: #foo:.	self setupSelfArgumentNameFor: refactoring toReturn: 'asdf'.	self setupVariableToMoveToFor: refactoring toReturn: 'rules'.	self setupVariableTypesFor: refactoring		toReturn: (Array with: (refactoring model classNamed: #Collection)).	class := refactoring model classNamed: #LintRuleTest.	selectorsSize := class selectors size.	self proceedThroughWarning: [self executeRefactoring: refactoring].	self 		assert: (class parseTreeFor: #openEditor) = (RBParser 						parseMethod: 'openEditor								| rules |								rules := self failedRules.								^rules foo: self').	self 		assert: ((refactoring model classNamed: #Collection) parseTreeFor: #foo:) 				= (RBParser 						parseMethod: 'foo: asdf								self isEmpty ifTrue: [^asdf].								self size == 1 ifTrue: [^self first viewResults].								SmalllintResultEditor openOn: asdf label: asdf name.								^asdf').	self assert: class selectors size = selectorsSize! !!ExtractMethodToComponentTest methodsFor: 'tests'!testMoveWithoutSelfReference	| refactoring class selectorsSize |	refactoring := ExtractMethodToComponentRefactoring 				extract: (self convertInterval: (118 to: 285)						for: (RBReadBeforeWrittenTester sourceCodeAt: #copyDictionary:))				from: #copyDictionary:				in: RBReadBeforeWrittenTester.	self setupMethodNameFor: refactoring toReturn: #copyWithAssociations.	self setupVariableToMoveToFor: refactoring toReturn: 'aDictionary'.	self setupVariableTypesFor: refactoring		toReturn: (Array with: (refactoring model classNamed: #Dictionary)).	class := refactoring model classNamed: #RBReadBeforeWrittenTester.	selectorsSize := class selectors size.	self executeRefactoring: refactoring.	self 		assert: (class parseTreeFor: #copyDictionary:) = (RBParser 						parseMethod: 'copyDictionary: aDictionary ^aDictionary copyWithAssociations').	self 		assert: ((refactoring model classNamed: #Dictionary) 				parseTreeFor: #copyWithAssociations) = (RBParser 							parseMethod: 'copyWithAssociations 							| newDictionary |							newDictionary := Dictionary new: self size.							self								keysAndValuesDo: [:key :value | newDictionary at: key put: value].							^newDictionary').	self assert: class selectors size = selectorsSize! !!ExtractMethodToComponentTest methodsFor: 'failure tests'!testNonExistantSelector	self shouldFail: (ExtractMethodToComponentRefactoring 				extract: (10 to: 20)				from: #checkClass1:				in: BasicLintRuleTest)! !!ExtractToTemporaryTest methodsFor: 'failure tests'!testBadInterval	self		shouldFail: (ExtractToTemporaryRefactoring 					extract: (self convertInterval: (24 to: 30)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					to: 'asdf'					from: #testMethod					in: RefactoryTestDataApp);		shouldFail: (ExtractToTemporaryRefactoring 					extract: (self convertInterval: (14 to: 105)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod1))					to: 'asdf'					from: #testMethod1					in: RefactoryTestDataApp);		shouldFail: (ExtractToTemporaryRefactoring 					extract: (self convertInterval: (61 to: 101)							for: (RefactoryTestDataApp sourceCodeAt: #noMoveDefinition))					to: 'asdf'					from: #noMoveDefinition					in: RefactoryTestDataApp)! !!ExtractToTemporaryTest methodsFor: 'failure tests'!testBadName	self shouldFail: (ExtractToTemporaryRefactoring 				extract: (self convertInterval: (14 to: 23)						for: (RefactoryTestDataApp sourceCodeAt: #testMethod))				to: 'a sdf'				from: #testMethod				in: RefactoryTestDataApp)! !!ExtractToTemporaryTest methodsFor: 'tests'!testExtractToTemporaryForLastStatementInBlock	| refactoring |	refactoring := ExtractToTemporaryRefactoring 				extract: (self convertInterval: (52 to: 73)						for: (RefactoryTestDataApp sourceCodeAt: #caller2))				to: 'temp'				from: #caller2				in: RefactoryTestDataApp.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #caller2) = (RBParser 							parseMethod: 'caller2	^(1 to: 10) inject: 1 into: [:sum :each | | temp | temp := sum * (self foo: each). temp]')! !!ExtractToTemporaryTest methodsFor: 'tests'!testExtractToTemporaryInsideBlock	| refactoring |	refactoring := ExtractToTemporaryRefactoring 				extract: (self convertInterval: (133 to: 141)						for: (RefactoryTestDataApp sourceCodeAt: #noMoveDefinition))				to: 'asdf'				from: #noMoveDefinition				in: RefactoryTestDataApp.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #noMoveDefinition) = (RBParser 							parseMethod: 'noMoveDefinition	| temp |	^(self collect: 			[:each | 			temp := each printString.			temp , temp]) 		select: [:each | | asdf | asdf := each size. temp := asdf + temp]')! !!ExtractToTemporaryTest methodsFor: 'failure tests'!testNonExistantSelector	self shouldFail: (ExtractToTemporaryRefactoring 				extract: (14 to: 23)				to: 'asdf'				from: #checkClass1:				in: RefactoryTestDataApp)! !!InlineAllMethodTest methodsFor: 'tests'!testInlineMethodWithMultipleSendersInMethod	| refactoring |	refactoring := InlineAllSendersRefactoring sendersOf: #caller2				in: RefactoryTestDataApp.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineLast) = (RBParser 							parseMethod: 'inlineLast	5 = 3 ifTrue: [^self caller] ifFalse: [^(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)]] ').	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #multipleCalls) = (RBParser 							parseMethod: 'multipleCalls	(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)].	(1 to: 10) inject: 1 into: [:sum1 :each1 | sum1 * (self foo: each1)]')! !!InlineAllMethodTest methodsFor: 'tests'!testRecursiveMethod	| class |	model := RBNamespace new.	class := model classNamed: self class name.	class		compile: 'foo ^self foo' classified: #(#accessing);		compile: 'bar ^self foo' classified: #(#accessing).	self executeRefactoring: (InlineAllSendersRefactoring 				model: model				sendersOf: #foo				in: class).	self assert: (class parseTreeFor: #foo) 				= (RBParser parseMethod: 'foo ^self foo').	self assert: (class parseTreeFor: #bar) 				= (RBParser parseMethod: 'bar ^self foo')! !!InlineMethodFromComponentTest methodsFor: 'tests'!testInlineComponentIntoCascadedMessage	| refactoring |	self proceedThroughWarning: 			[refactoring := InlineMethodFromComponentRefactoring 						inline: (self convertInterval: (35 to: 79)								for: (RefactoryTestDataApp sourceCodeAt: #inlineComponent))						inMethod: #inlineComponent						forClass: RefactoryTestDataApp.			(refactoring model classNamed: #Behavior) 				compile: 'hasImmediateInstances ^self format = 0'				classified: #(#accessing).			self setupInlineExpressionFor: refactoring toReturn: false.			self executeRefactoring: refactoring].	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineComponent) = (RBParser 							parseMethod: 'inlineComponent	| a aBehavior |	a := 5.	aBehavior := a class.	aBehavior superclass.	aBehavior format = 0.	^aBehavior yourself')! !!InlineMethodFromComponentTest methodsFor: 'tests'!testInlineComponentMethodMax	| refactoring |	self proceedThroughWarning: 			[| class |			refactoring := InlineMethodFromComponentRefactoring 						inline: (self convertInterval: (47 to: 58)								for: (RefactoryTestDataApp sourceCodeAt: #inlineMax))						inMethod: #inlineMax						forClass: RefactoryTestDataApp.			self setupInlineExpressionFor: refactoring toReturn: true.			class := refactoring model classNamed: #Magnitude.			class 				compile: 'max: aMagnitude 					"Answer the receiver or the argument, whichever has the greater magnitude."					self > aMagnitude						ifTrue: [^self]						ifFalse: [^aMagnitude]'				classified: #(#accessing).			self setupImplementorToInlineFor: refactoring toReturn: class.			self executeRefactoring: refactoring].	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineMax) = (RBParser 							parseMethod: 'inlineMax								| x y q |								x := 5.								y := 10.								q := x + 1 > y									ifTrue: [x + 1]									ifFalse: [y].								^q')! !!InlineMethodFromComponentTest methodsFor: 'tests'!testInlineEmptyComponentMethod	| refactoring |	self proceedThroughWarning: 			[refactoring := InlineMethodFromComponentRefactoring 						inline: (self convertInterval: (35 to: 91)								for: (RefactoryTestDataApp sourceCodeAt: #inlineComponent))						inMethod: #inlineComponent						forClass: RefactoryTestDataApp.			self setupInlineExpressionFor: refactoring toReturn: false.			self executeRefactoring: refactoring].	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineComponent) = (RBParser 							parseMethod: 'inlineComponent	| a anObject |	a := 5.	anObject := a class.	anObject superclass.	anObject hasImmediateInstances.	^anObject')! !!InlineMethodFromComponentTest methodsFor: 'failure tests'!testInlineMethodFromComponentFailure	self shouldFail: (InlineMethodFromComponentRefactoring 				inline: (self convertInterval: (50 to: 64)						for: (RefactoryTestDataApp sourceCodeAt: #inlineFailed))				inMethod: #inlineFailed				forClass: RefactoryTestDataApp)! !!InlineMethodFromComponentTest methodsFor: 'tests'!testModelInlineMethodWithSameVariableNames	| class refactoring |	model := RBNamespace new.	class := model classNamed: self class name.	class compile: 'a9: a b9: b ^self + a + b' classified: #(#accessing).	(model classNamed: #Object) 		compile: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^a a9: b b9: c'		classified: #(#accessing).	self proceedThroughWarning: 			[refactoring := InlineMethodFromComponentRefactoring 						model: model						inline: (72 to: 84)						inMethod: #foo						forClass: (model classNamed: #Object).			self setupInlineExpressionFor: refactoring toReturn: false.			self executeRefactoring: refactoring].	self assert: ((refactoring model classNamed: #Object) parseTreeFor: #foo) 				= (RBParser 						parseMethod: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^a + b + c')! !!InlineMethodFromComponentTest methodsFor: 'tests'!testModelInlineMethodWithSameVariableNames1	| class refactoring |	model := RBNamespace new.	class := model classNamed: #Rectangle.	class 		compile: 'rectangleRelativeTo: aRectangle ^self origin extent: aRectangle extent'		classified: #(#accessing).	(model classNamed: #Object) 		compile: 'foo | aRectangle temp | aRectangle := 0@0 corner: 1@1. temp := aRectangle. ^aRectangle rectangleRelativeTo: temp'		classified: #(#accessing).	self proceedThroughWarning: 			[refactoring := InlineMethodFromComponentRefactoring 						model: model						inline: (77 to: 112)						inMethod: #foo						forClass: (model classNamed: #Object).			self setupInlineExpressionFor: refactoring toReturn: false.			self setupImplementorToInlineFor: refactoring toReturn: class.			self executeRefactoring: refactoring].	self assert: ((refactoring model classNamed: #Object) parseTreeFor: #foo) 				= (RBParser 						parseMethod: 'foo | aRectangle temp | aRectangle := 0@0 corner: 1@1. temp := aRectangle. ^aRectangle origin extent: temp extent')! !!InlineMethodFromComponentTest methodsFor: 'tests'!testModelInlineMethodWithSameVariableNames2	| class refactoring |	model := RBNamespace new.	class := model classNamed: self class name.	class compile: 'a9: a b9: b ^self + a + b' classified: #(#accessing).	(model classNamed: #Object) 		compile: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^c a9: b b9: a'		classified: #(#accessing).	self proceedThroughWarning: 			[refactoring := InlineMethodFromComponentRefactoring 						model: model						inline: (72 to: 84)						inMethod: #foo						forClass: (model classNamed: #Object).			self setupInlineExpressionFor: refactoring toReturn: false.			self executeRefactoring: refactoring].	self assert: ((refactoring model classNamed: #Object) parseTreeFor: #foo) 				= (RBParser 						parseMethod: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^c + b + a')! !!InlineMethodTest methodsFor: 'failure tests'!testBadInterval	self		shouldFail: (InlineMethodRefactoring 					inline: (self convertInterval: (13 to: 23)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					inMethod: #testMethod					forClass: RefactoryTestDataApp);		shouldFail: (InlineMethodRefactoring 					inline: (self convertInterval: (14 to: 17)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					inMethod: #testMethod					forClass: RefactoryTestDataApp);		shouldFail: (InlineMethodRefactoring 					inline: (self convertInterval: (24 to: 30)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					inMethod: #testMethod					forClass: RefactoryTestDataApp);		shouldFail: (InlineMethodRefactoring 					inline: (self convertInterval: (1 to: 30)							for: (RefactoryTestDataApp sourceCodeAt: #testMethod))					inMethod: #testMethod					forClass: RefactoryTestDataApp)! !!InlineMethodTest methodsFor: 'tests'!testInlineMethod	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (455 to: 504)						for: (BasicLintRuleTest class 								sourceCodeAt: #sentNotImplementedInApplication))				inMethod: #sentNotImplementedInApplication				forClass: BasicLintRuleTest class.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model metaclassNamed: #BasicLintRuleTest) 				parseTreeFor: #sentNotImplementedInApplication) = (RBParser 							parseMethod: 'sentNotImplementedInApplication									| detector |									detector := self new.									detector name: ''Messages sent but not implemented in application''.									detector methodBlock: 											[:context :result | 											| message class block |											message := context messages 														detect: [:each | (context isItem: each in: context application) not]														ifNone: [nil].											class := context selectedClass.											block := 													[:each | 													| app methodApp root |													app := context application.													((class canUnderstand: each) 														ifTrue: 															[root := app rootApplication.															methodApp := ((class whichClassIncludesSelector: each) 																		compiledMethodAt: each) application 																		rootApplication.															methodApp == root or: [root isBasedOn: methodApp]]														ifFalse: [false]) not].											message isNil 												ifTrue: [message := context selfMessages detect: block ifNone: [nil]].											message isNil 												ifTrue: 													[class := class superclass.													class isNil 														ifTrue: 															[context superMessages isEmpty 																ifFalse: [message := context superMessages asArray first]]														ifFalse: [message := context superMessages detect: block ifNone: [nil]]].											message notNil 												ifTrue: 													[result addSearchString: message.													result addClass: context selectedClass selector: context selector]].									^detector')! !!InlineMethodTest methodsFor: 'tests'!testInlineMethod1	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (39 to: 84)						for: (RefactoryTestDataApp sourceCodeAt: #caller))				inMethod: #caller				forClass: RefactoryTestDataApp.	self setupInlineExpressionFor: refactoring toReturn: false.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #caller) = (RBParser 							parseMethod: 'caller 									| anObject anObject1 | 									anObject := 5.									anObject1 := anObject + 1.									Transcript										show: anObject1 printString;										cr.									^anObject')! !!InlineMethodTest methodsFor: 'tests'!testInlineMethod2	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (40 to: 120)						for: (RefactoryTestDataApp sourceCodeAt: #caller1))				inMethod: #caller1				forClass: RefactoryTestDataApp.	self setupInlineExpressionFor: refactoring toReturn: false.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #caller1) = (RBParser 							parseMethod: 'caller1 								| anObject each1 anObject1 | 								anObject := 5.								anObject1 := anObject + 1.								each1 := anObject1 printString.								Transcript									show: each1;									cr.								[:each | each printString. ^anObject] value: each1')! !!InlineMethodTest methodsFor: 'tests'!testInlineMethod3	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (58 to: 73)						for: (RefactoryTestDataApp sourceCodeAt: #caller2))				inMethod: #caller2				forClass: RefactoryTestDataApp.	self setupInlineExpressionFor: refactoring toReturn: false.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #caller2) = (RBParser 							parseMethod: 'caller2								^(1 to: 10) inject: 1 into: [:sum :each | sum * ((1 to: 10) inject: each into: [:sum1 :each1 | sum1 + each1])]	')! !!InlineMethodTest methodsFor: 'tests'!testInlineMethod4	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (31 to: 112)						for: (RefactoryTestDataApp sourceCodeAt: #inlineJunk))				inMethod: #inlineJunk				forClass: RefactoryTestDataApp.	self setupInlineExpressionFor: refactoring toReturn: false.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineJunk) = (RBParser 							parseMethod: 'inlineJunk										| asdf bar1 baz1 asdf1 |										bar1 := 												[:each | 												| temp |												temp := each.												temp , temp] value: self.										baz1 := bar1 + bar1.										asdf1 := baz1 + bar1.										asdf := asdf1.										^asdf foo: 												[:bar | 												| baz |												baz := bar.												baz * baz]')! !!InlineMethodTest methodsFor: 'tests'!testInlineMethod5	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (53 to: 64)						for: (RefactoryTestDataApp sourceCodeAt: #inlineLast))				inMethod: #inlineLast				forClass: RefactoryTestDataApp.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineLast) = (RBParser 							parseMethod: 'inlineLast									5 = 3 ifTrue: [^self caller] ifFalse: [^	(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)]]')! !!InlineMethodTest methodsFor: 'tests' stamp: 'md 7/25/2005 18:14'!testInlineMethodForSuperSend	| refactoring |	model := Compiler evaluate: self inlineMethodTestData.	(model classNamed: #RenameVariableChange) removeMethod: #executeNotifying:.	refactoring := InlineMethodRefactoring 				model: model				inline: (self convertInterval: (102 to: 131)						for: ((model classNamed: #RenameInstanceVariableChange) 								sourceCodeFor: #executeNotifying:))				inMethod: #executeNotifying:				forClass: (model classNamed: #RenameInstanceVariableChange).	self executeRefactoring: refactoring.	self 		assert: ((model classNamed: #RenameInstanceVariableChange) 				parseTreeFor: #executeNotifying:) = (RBParser 							parseMethod: 'executeNotifying: aBlock 									| undo undos undo1 |									self addNewVariable.									self copyOldValuesToNewVariable.									undos := changes collect: [:each | each executeNotifying: aBlock].									undo1 := self copy.									undo1 changes: undos reverse.									undo := undo1.									self removeOldVariable.									^undo')! !!InlineMethodTest methodsFor: 'failure tests' stamp: 'md 7/25/2005 18:14'!testInlineMethodForSuperSendThatAlsoSendsSuper	| refactoring |	model := Compiler evaluate: self inlineMethodTestData.	refactoring := InlineMethodRefactoring 				inline: (102 to: 131)				inMethod: #executeNotifying:				forClass: (model classNamed: #RenameInstanceVariableChange).	self shouldFail: refactoring! !!InlineMethodTest methodsFor: 'tests'!testInlineRecursiveCascadedMethod	| refactoring |	refactoring := InlineMethodRefactoring 				inline: (self convertInterval: (33 to: 62)						for: (RefactoryTestDataApp sourceCodeAt: #inlineMethod))				inMethod: #inlineMethod				forClass: RefactoryTestDataApp.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineMethod) = (RBParser 							parseMethod: 'inlineMethod									| temp temp1 |									self foo.									temp1 := self foo; inlineMethod; bar.									temp := self bar.									^temp')! !!InlineMethodTest methodsFor: 'tests'!testModelInlineRecursiveMethod	| refactoring class |	class := model classNamed: #Object.	class compile: 'foo self bar. self foo. self bar' classified: #(#accessing).	refactoring := InlineMethodRefactoring 				model: model				inline: (15 to: 23)				inMethod: #foo				forClass: class.	self executeRefactoring: refactoring.	self 		assert: (class parseTreeFor: #foo) = (RBParser 						parseMethod: 'foo self bar. self bar. self foo. self bar. self bar')! !!InlineMethodTest methodsFor: 'failure tests'!testNonExistantSelector	self shouldFail: (InlineMethodRefactoring 				inline: (14 to: 17)				inMethod: #checkClass1:				forClass: RefactoryTestDataApp)! !!InlineMethodTest methodsFor: 'failure tests'!testOverriden	self shouldWarn: (InlineMethodRefactoring 				inline: (self convertInterval: (15 to: 26)						for: (LintRuleTest sourceCodeAt: #failedRules))				inMethod: #failedRules				forClass: LintRuleTest)! !!InlineMethodTest methodsFor: 'failure tests'!testPrimitive	self shouldFail: (InlineMethodRefactoring 				inline: (self convertInterval: (14 to: 23)						for: (RefactoryTestDataApp sourceCodeAt: #testMethod))				inMethod: #testMethod				forClass: RefactoryTestDataApp)! !!InlineMethodTest methodsFor: 'failure tests'!testReturn	self shouldFail: (InlineMethodRefactoring 				inline: (self convertInterval: (418 to: 485)						for: (BasicLintRuleTest class sourceCodeAt: #utilityMethods))				inMethod: #utilityMethods				forClass: BasicLintRuleTest class)! !!InlineParameterTest methodsFor: 'failure tests'!testInlineBlockFailure	self shouldFail: (InlineParameterRefactoring 				inlineParameter: 'aBlock'				in: RefactoryTestDataApp				selector: ('inline' , 'Foo:') asSymbol)! !!InlineParameterTest methodsFor: 'tests'!testInlineLiteralArray	| refactoring class |	refactoring := InlineParameterRefactoring 				inlineParameter: 'aSymbol'				in: RefactoryTestDataApp				selector: ('inline' , 'ParameterMethod:') asSymbol.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self 		assert: (class parseTreeFor: #inlineParameterMethod) = (RBParser 						parseMethod: 'inlineParameterMethod | aSymbol | aSymbol := #(asdf). ^aSymbol isSymbol').	self 		assert: (class parseTreeFor: #sendInlineParameterMethod) = (RBParser 						parseMethod: 'sendInlineParameterMethod ^self inlineParameterMethod').	self deny: (class 				directlyDefinesMethod: ('inline' , 'ParameterMethod:') asSymbol)! !!InlineTemporaryTest methodsFor: 'tests'!testInlineTemporary	| refactoring |	refactoring := InlineTemporaryRefactoring 				inline: (self convertInterval: (24 to: 72)						for: (RefactoryTestDataApp sourceCodeAt: #inlineMethod))				from: #inlineMethod				in: RefactoryTestDataApp.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #inlineMethod) = (RBParser 							parseMethod: 'inlineMethod										^self													foo;													inlineMethod;													bar')! !!InlineTemporaryTest methodsFor: 'tests'!testInlineTemporaryBadInterval	self shouldFail: (InlineTemporaryRefactoring 				inline: (self convertInterval: (29 to: 100)						for: (RefactoryTestDataApp sourceCodeAt: #moveDefinition))				from: #moveDefinition				in: RefactoryTestDataApp)! !!InlineTemporaryTest methodsFor: 'tests'!testInlineTemporaryMutlipleAssignment	self shouldFail: (InlineTemporaryRefactoring 				inline: (self convertInterval: (60 to: 83)						for: (RefactoryTestDataApp sourceCodeAt: #moveDefinition))				from: #moveDefinition				in: RefactoryTestDataApp)! !!InlineTemporaryTest methodsFor: 'tests'!testInlineTemporaryReadBeforeWritten	self shouldFail: (InlineTemporaryRefactoring 				inline: (self convertInterval: (48 to: 56)						for: (RefactoryTestDataApp sourceCodeAt: #inlineTemporary))				from: #inlineTemporary				in: RefactoryTestDataApp)! !!MoveMethodTest methodsFor: 'tests'!testMoveMethodIntoArgument	| refactoring class |	self proceedThroughWarning: 			[refactoring := MoveMethodRefactoring 						selector: #checkMethod:						class: TransformationRuleTest						variable: 'aSmalllintContext'.			self setupSelfArgumentNameFor: refactoring toReturn: 'transformationRule'.			self setupVariableTypesFor: refactoring				toReturn: (Array with: (refactoring model classNamed: #SmalllintContext)).			self setupMethodNameFor: refactoring toReturn: #foo:.			self executeRefactoring: refactoring].	class := refactoring model classNamed: #TransformationRuleTest.	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext aSmalllintContext foo: self').	self 		assert: ((refactoring model classNamed: #SmalllintContext) 				parseTreeFor: #foo:) = (RBParser 							parseMethod: 'foo: transformationRule	transformationRule class: self selectedClass.	(transformationRule rewriteRule executeTree: self parseTree) ifTrue: 			[(transformationRule class recursiveSelfRule executeTree: transformationRule rewriteRule tree initialAnswer: false)				ifFalse: 					[transformationRule builder compile: transformationRule rewriteRule tree printString						in: transformationRule class1						classified: self protocols]]').	self assert: (class parseTreeFor: #class1) 				= (RBParser parseMethod: 'class1 ^class').	self assert: (class parseTreeFor: #class:) 				= (RBParser parseMethod: 'class: anObject class := anObject').	self 		assert: (class metaclass parseTreeFor: #recursiveSelfRule:) = (RBParser 						parseMethod: 'recursiveSelfRule: anObject RecursiveSelfRule := anObject').	self assert: (class metaclass parseTreeFor: #recursiveSelfRule) 				= (RBParser parseMethod: 'recursiveSelfRule ^RecursiveSelfRule').	self assert: (class parseTreeFor: #builder) 				= (RBParser parseMethod: 'builder ^builder').	self assert: (class parseTreeFor: #builder:) 				= (RBParser parseMethod: 'builder: anObject builder := anObject').	self assert: (class parseTreeFor: #rewriteRule) 				= (RBParser parseMethod: 'rewriteRule ^rewriteRule').	self assert: (class parseTreeFor: #rewriteRule:) 				= (RBParser parseMethod: 'rewriteRule: anObject rewriteRule := anObject')! !!MoveMethodTest methodsFor: 'tests'!testMoveMethodIntoClassVariable	| refactoring class |	self proceedThroughWarning: 			[refactoring := MoveMethodRefactoring 						selector: #checkMethod:						class: TransformationRuleTest						variable: 'RecursiveSelfRule'.			self setupSelfArgumentNameFor: refactoring toReturn: 'transformationRule'.			self setupVariableTypesFor: refactoring				toReturn: (Array with: (refactoring model classNamed: #ParseTreeSearcher)).			self 				setupMethodNameFor: refactoring				toReturn: #foo:foo:				withArguments: #('transformationRule' 'aSmalllintContext').			self executeRefactoring: refactoring].	class := refactoring model classNamed: #TransformationRuleTest.	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext RecursiveSelfRule foo: self foo: aSmalllintContext').	self 		assert: ((refactoring model classNamed: #ParseTreeSearcher) 				parseTreeFor: #foo:foo:) = (RBParser 							parseMethod: 'foo: transformationRule foo: aSmalllintContext	transformationRule class: aSmalllintContext selectedClass.	(transformationRule rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[(self executeTree: transformationRule rewriteRule tree initialAnswer: false)				ifFalse: 					[transformationRule builder compile: transformationRule rewriteRule tree printString						in: transformationRule class1						classified: aSmalllintContext protocols]]').	self assert: (class parseTreeFor: #class1) 				= (RBParser parseMethod: 'class1 ^class').	self assert: (class parseTreeFor: #class:) 				= (RBParser parseMethod: 'class: anObject class := anObject').	self assert: (class parseTreeFor: #builder) 				= (RBParser parseMethod: 'builder ^builder').	self assert: (class parseTreeFor: #builder:) 				= (RBParser parseMethod: 'builder: anObject builder := anObject').	self assert: (class parseTreeFor: #rewriteRule) 				= (RBParser parseMethod: 'rewriteRule ^rewriteRule').	self assert: (class parseTreeFor: #rewriteRule:) 				= (RBParser parseMethod: 'rewriteRule: anObject rewriteRule := anObject')! !!MoveMethodTest methodsFor: 'tests'!testMoveMethodIntoInstanceVariable	| refactoring class |	self proceedThroughWarning: 			[refactoring := MoveMethodRefactoring 						selector: #checkMethod:						class: TransformationRuleTest						variable: 'rewriteRule'.			self setupSelfArgumentNameFor: refactoring toReturn: 'transformationRule'.			self setupVariableTypesFor: refactoring				toReturn: (Array with: (refactoring model classNamed: #ParseTreeRewriter)).			self 				setupMethodNameFor: refactoring				toReturn: #foo:foo:				withArguments: #('transformationRule' 'aSmalllintContext').			self executeRefactoring: refactoring].	class := refactoring model classNamed: #TransformationRuleTest.	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext rewriteRule foo: self foo: aSmalllintContext').	self 		assert: ((refactoring model classNamed: #ParseTreeRewriter) 				parseTreeFor: #foo:foo:) = (RBParser 							parseMethod: 'foo: transformationRule foo: aSmalllintContext	transformationRule class: aSmalllintContext selectedClass.	(self executeTree: aSmalllintContext parseTree) ifTrue: 			[(transformationRule class recursiveSelfRule executeTree: self tree initialAnswer: false)				ifFalse: 					[transformationRule builder compile: self tree printString						in: transformationRule class1						classified: aSmalllintContext protocols]]').	self assert: (class parseTreeFor: #class1) 				= (RBParser parseMethod: 'class1 ^class').	self assert: (class parseTreeFor: #class:) 				= (RBParser parseMethod: 'class: anObject class := anObject').	self 		assert: (class metaclass parseTreeFor: #recursiveSelfRule:) = (RBParser 						parseMethod: 'recursiveSelfRule: anObject RecursiveSelfRule := anObject').	self assert: (class metaclass parseTreeFor: #recursiveSelfRule) 				= (RBParser parseMethod: 'recursiveSelfRule ^RecursiveSelfRule').	self assert: (class parseTreeFor: #builder) 				= (RBParser parseMethod: 'builder ^builder').	self assert: (class parseTreeFor: #builder:) 				= (RBParser parseMethod: 'builder: anObject builder := anObject')! !!MoveMethodTest methodsFor: 'tests' stamp: 'bh 5/1/2000 00:09'!testMoveMethodThatReferencesPoolDictionary	| refactoring class |	self		proceedThroughWarning: 			[refactoring := MoveMethodRefactoring						selector: #junk						class: LintRuleTest						variable: 'RefactoryTestDataApp'.			self setupSelfArgumentNameFor: refactoring toReturn: 'transformationRule'.			self setupVariableTypesFor: refactoring toReturn: (Array with: (refactoring model classNamed: 'RefactoryTestDataApp class' asSymbol)).			self setupMethodNameFor: refactoring toReturn: #junk1.			self executeRefactoring: refactoring].	class := refactoring model classNamed: #LintRuleTest.	self assert: (class parseTreeFor: #junk)			= (RBParser parseMethod: 'junk ^RefactoryTestDataApp junk1').	self assert: ((refactoring model metaclassNamed: #RefactoryTestDataApp)			parseTreeFor: #junk1)			= (RBParser parseMethod: 'junk1	^self printString copyFrom: 1 to: CR').	self assert: (class directlyDefinesPoolDictionary: 'TextConstants' asSymbol)! !!MoveMethodTest methodsFor: 'failure tests'!testMovePrimitiveMethod	| refactoring |	(model classNamed: #Object) 		compile: 'foo <primitive: 100> ^#() primitiveFailed'		classified: #(#accessing).	refactoring := MoveMethodRefactoring 				model: model				selector: #foo				class: Object				variable: 'OrderedCollection'.	self shouldFail: refactoring! !!MoveVariableDefinitionTest methodsFor: 'tests'!testMoveDefinition	| refactoring |	refactoring := MoveVariableDefinitionRefactoring 				bindTight: (self convertInterval: (19 to: 22)						for: (RefactoryTestDataApp sourceCodeAt: #moveDefinition))				in: RefactoryTestDataApp				selector: #moveDefinition.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #moveDefinition) = (RBParser 							parseMethod: 'moveDefinition								^(self collect: 										[:each | 										| temp |										temp := each printString.										temp , temp]) 									select: 										[:each | 										| temp |										temp := each size.										temp odd]')! !!MoveVariableDefinitionTest methodsFor: 'tests'!testMoveDefinitionIntoBlockThatIsAReceiverOfACascadedMessage	| refactoring |	refactoring := MoveVariableDefinitionRefactoring 				bindTight: (self convertInterval: (48 to: 58)						for: (RefactoryTestDataApp sourceCodeAt: #referencesConditionFor:))				in: RefactoryTestDataApp				selector: #referencesConditionFor:.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				parseTreeFor: #referencesConditionFor:) = (RBParser 							parseMethod: 'referencesConditionFor: aClass 								| environment  |								^(RBCondition withBlock: 										[| association |association := Smalltalk associationAt: aClass name													ifAbsent: [self refactoringError: ''Could not find class''].										environment := (self environment referencesTo: association) 													| (self environment referencesTo: aClass name).										environment isEmpty])									errorMacro: aClass , '' is referenced.<n>Browse references?'';									errorBlock: [environment openEditor];									yourself')! !!MoveVariableDefinitionTest methodsFor: 'tests'!testNoMoveDefinition	self shouldFail: (MoveVariableDefinitionRefactoring 				bindTight: (self convertInterval: (21 to: 24)						for: (RefactoryTestDataApp sourceCodeAt: #moveDefinition))				in: RefactoryTestDataApp				selector: #noMoveDefinition)! !!MoveVariableDefinitionTest methodsFor: 'tests'!testNonExistantName	self		shouldFail: (MoveVariableDefinitionRefactoring 					bindTight: (1 to: 10)					in: LintRuleTest					selector: #name1);		shouldFail: (MoveVariableDefinitionRefactoring 					bindTight: (self convertInterval: (44 to: 54)							for: (LintRuleTest sourceCodeAt: #displayName))					in: LintRuleTest					selector: #displayName);		shouldFail: (MoveVariableDefinitionRefactoring 					bindTight: (self convertInterval: (16 to: 25)							for: (LintRuleTest sourceCodeAt: #displayName))					in: LintRuleTest					selector: #displayName)! !!ProtectInstanceVariableTest methodsFor: 'tests'!testProtectInstanceVariable	| refactoring class |	refactoring := ProtectInstanceVariableRefactoring 				variable: 'rewrite' , 'Rule1'				class: SubclassOfClassToRename.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #SubclassOfClassToRename.	self 		assert: (class parseTreeFor: #calls1) = (RBParser 						parseMethod: 'calls1								^rewriteRule1 := (rewriteRule1 := self calls)').	self 		assert: (class parseTreeFor: #calls) = (RBParser 						parseMethod: 'calls								^rewriteRule1 := rewriteRule1 , rewriteRule1').	self deny: (class directlyDefinesMethod: ('rewrite' , 'Rule1') asSymbol).	self deny: (class directlyDefinesMethod: ('rewrite' , 'Rule1:') asSymbol)! !!ProtectInstanceVariableTest methodsFor: 'failure tests' stamp: 'bh 4/29/2000 21:33'!testVariableNotDefined	| refactoring |	refactoring := ProtectInstanceVariableRefactoring variable: 'rewrite' class: SubclassOfClassToRename.	self shouldFail: refactoring.! !!PullUpClassVariableTest methodsFor: 'failure tests'!testMetaClassFailure	self 		shouldFail: (PullUpClassVariableRefactoring variable: #RecursiveSelfRule				class: LintRuleTest class)! !!PullUpClassVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (PullUpClassVariableRefactoring variable: #Foo				class: LintRuleTest)! !!PullUpClassVariableTest methodsFor: 'tests'!testPullUpClassVariable	| refactoring |	refactoring := PullUpClassVariableRefactoring variable: #RecursiveSelfRule				class: LintRuleTest.	self executeRefactoring: refactoring.	self assert: ((refactoring model classNamed: #LintRuleTest) 				directlyDefinesClassVariable: #RecursiveSelfRule).	self deny: ((refactoring model classNamed: #TransformationRuleTest) 				directlyDefinesClassVariable: #RecursiveSelfRule)! !!PushDownClassVariableTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:09'!testModelNonExistantName	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	self shouldFail: (PushDownClassVariableRefactoring 				model: model				variable: #Foo				class: (model classNamed: #SomeClass))! !!PushDownClassVariableTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:09'!testModelPushDownToMultipleSubclassesFailure	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #Subclass) compile: 'foo ^Foo' classified: #(#accessing).	model 		defineClass: 'SomeClass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model metaclassNamed: #AnotherSubclass) compile: 'bar ^Foo'		classified: #(#accessing).	self shouldFail: (PushDownClassVariableRefactoring 				model: model				variable: #Foo				class: (model classNamed: #SomeClass))! !!PushDownClassVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:09'!testModelPushDownVariable	| class |	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	class := model classNamed: #Subclass.	class compile: 'foo ^Foo' classified: #(#accessing).	self executeRefactoring: (PushDownClassVariableRefactoring 				model: model				variable: #Foo				class: class superclass).	self deny: (class superclass directlyDefinesClassVariable: #Foo).	self assert: (class directlyDefinesClassVariable: #Foo)! !!PushDownClassVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:09'!testModelPushDownVariableToClassDownTwoLevels	| class |	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'Subclass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	class := model metaclassNamed: #AnotherSubclass.	class compile: 'bar ^Foo' classified: #(#accessing).	class := class nonMetaclass.	self executeRefactoring: (PushDownClassVariableRefactoring 				model: model				variable: #Foo				class: class superclass superclass).	self 		deny: (class superclass superclass directlyDefinesClassVariable: #Foo).	self deny: (class superclass directlyDefinesClassVariable: #Foo).	self assert: (class directlyDefinesClassVariable: #Foo)! !!PushDownClassVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:10'!testModelPushDownVariableToMultipleClassesInSameHierarchy	| class |	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	class := model classNamed: #Subclass.	class compile: 'foo ^Foo' classified: #(#accessing).	model 		defineClass: 'Subclass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model metaclassNamed: #AnotherSubclass) compile: 'bar ^Foo'		classified: #(#accessing).	self executeRefactoring: (PushDownClassVariableRefactoring 				model: model				variable: #Foo				class: class superclass).	self deny: (class superclass directlyDefinesClassVariable: #Foo).	self assert: (class directlyDefinesClassVariable: #Foo)! !!PushDownClassVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:10'!testModelRemoveUnusedVariable	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	self 		assert: ((model classNamed: #SomeClass) directlyDefinesVariable: #Foo).	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	self executeRefactoring: (PushDownClassVariableRefactoring 				model: model				variable: #Foo				class: (model classNamed: #SomeClass)).	self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: #Foo).	self deny: ((model classNamed: #Subclass) directlyDefinesVariable: #Foo)! !!PushDownClassVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (PushDownClassVariableRefactoring variable: #Foo				class: BasicLintRuleTest)! !!PushDownClassVariableTest methodsFor: 'tests'!testPushDownClassVariable	| refactoring |	refactoring := PushDownClassVariableRefactoring variable: #Foo1				class: LintRuleTest.	self assert: ((refactoring model classNamed: #LintRuleTest) 				directlyDefinesClassVariable: #Foo1).	self executeRefactoring: refactoring.	(refactoring model classNamed: #LintRuleTest) withAllSubclasses 		do: [:each | self deny: (each directlyDefinesClassVariable: #Foo1)]! !!PushDownInstanceVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:10'!testModelPushDownToMetaclass	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model metaclassNamed: #SomeClass) addInstanceVariable: 'foo'.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model metaclassNamed: #Subclass) compile: 'foo ^foo'		classified: #(#accessing).	self executeRefactoring: (PushDownInstanceVariableRefactoring 				model: model				variable: 'foo'				class: (model metaclassNamed: #SomeClass)).	self 		deny: ((model metaclassNamed: #SomeClass) directlyDefinesVariable: 'foo').	self 		assert: ((model metaclassNamed: #Subclass) directlyDefinesVariable: 'foo')! !!PushDownInstanceVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:10'!testModelPushDownToMultipleSubclasses	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: ''foo'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #Subclass) compile: 'foo ^foo' classified: #(#accessing).	model 		defineClass: 'SomeClass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #AnotherSubclass) compile: 'bar ^foo'		classified: #(#accessing).	self executeRefactoring: (PushDownInstanceVariableRefactoring 				model: model				variable: 'foo'				class: (model classNamed: #SomeClass)).	self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: 'foo').	self 		assert: ((model classNamed: #Subclass) directlyDefinesVariable: 'foo').	self assert: ((model classNamed: #AnotherSubclass) 				directlyDefinesVariable: 'foo')! !!PushDownInstanceVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:10'!testModelRemoveUnusedVariable	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: ''foo'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	self executeRefactoring: (PushDownInstanceVariableRefactoring 				model: model				variable: 'foo'				class: (model classNamed: #SomeClass)).	self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: 'foo').	self deny: ((model classNamed: #Subclass) directlyDefinesVariable: 'foo')! !!PushDownInstanceVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (PushDownInstanceVariableRefactoring variable: 'foo'				class: BasicLintRuleTest)! !!PushDownInstanceVariableTest methodsFor: 'tests'!testPushDownInstanceVariable	| refactoring |	refactoring := PushDownInstanceVariableRefactoring variable: 'foo1'				class: LintRuleTest.	self executeRefactoring: refactoring.	(refactoring model classNamed: #LintRuleTest) withAllSubclasses 		do: [:each | self deny: (each directlyDefinesInstanceVariable: 'foo1')]! !!PushDownMethodTest methodsFor: 'tests'!testPushDownMethod	| refactoring class |	refactoring := PushDownMethodRefactoring pushDown: #(#name:)				from: LintRuleTest.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #LintRuleTest.	self deny: (class directlyDefinesMethod: #name:).	class subclasses do: 			[:each | 			self assert: (each parseTreeFor: #name:) 						= (RBParser parseMethod: 'name: aString name := aString')]! !!PushDownMethodTest methodsFor: 'failure tests'!testPushDownMethodOnNonAbstractClass	| refactoring |	refactoring := PushDownMethodRefactoring pushDown: #(#yourself)				from: Object.	self shouldFail: refactoring! !!PushDownMethodTest methodsFor: 'tests' stamp: 'bh 3/17/2000 13:33'!testPushDownMethodThatReferencesPoolDictionary	| refactoring class parseTree |	parseTree := LintRuleTest parseTreeFor: #junk.	self		proceedThroughWarning: 			[refactoring := PushDownMethodRefactoring pushDown: #(junk ) from: LintRuleTest.			self executeRefactoring: refactoring].	class := refactoring model classNamed: #LintRuleTest.	self deny: (class directlyDefinesMethod: #junk).	class subclasses do: 		[:each | 		self assert: (each parseTreeFor: #junk)				= parseTree.		self assert: (each directlyDefinesPoolDictionary: 'TextConstants' asSymbol)]! !!PushDownMethodTest methodsFor: 'failure tests'!testPushDownNonExistantMenu	| refactoring |	refactoring := PushDownMethodRefactoring 				pushDown: #(#someMethodThatDoesNotExist)				from: LintRuleTest.	self shouldFail: refactoring! !!PushUpInstanceVariableTest methodsFor: 'tests'!testPullUpInstVar	| refactoring |	self proceedThroughWarning: 			[refactoring := PullUpInstanceVariableRefactoring variable: 'result'						class: LintRuleTest.			self executeRefactoring: refactoring].	self assert: ((refactoring model classNamed: #LintRuleTest) 				directlyDefinesInstanceVariable: 'result').	self deny: ((refactoring model classNamed: #BasicLintRuleTest) 				directlyDefinesInstanceVariable: 'result')! !!PushUpInstanceVariableTest methodsFor: 'failure tests'!testPullUpVariableNotDefined	self shouldFail: (PullUpInstanceVariableRefactoring 				variable: 'notDefinedVariable'				class: LintRuleTest)! !!PushUpMethodTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:11'!testPushUpAndCopyDown	| class |	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'Subclass subclass: #Foo1 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'Subclass subclass: #Foo2 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	class := model classNamed: #Foo1.	class compile: 'yourself ^1' classified: #(#accessing).	self executeRefactoring: (PushUpMethodRefactoring 				model: model				pushUp: #(#yourself)				from: class).	self assert: (class superclass parseTreeFor: #yourself) 				= (RBParser parseMethod: 'yourself ^1').	self deny: (class directlyDefinesMethod: #yourself).	class := model classNamed: #Foo2.	self assert: (class directlyDefinesMethod: #yourself).	self assert: (class parseTreeFor: #yourself) 				= ((model classNamed: #Object) parseTreeFor: #yourself)! !!PushUpMethodTest methodsFor: 'failure tests'!testPushUpClassMethod	| class |	class := model classNamed: #Object.	class addClassVariable: #Foo.	class metaclass compile: 'foo ^Foo' classified: #(#accessing).	self shouldFail: (PushUpMethodRefactoring 				model: model				pushUp: #(#foo)				from: class metaclass)! !!PushUpMethodTest methodsFor: 'tests'!testPushUpMethodWithCopyOverriddenMethodsDown	| refactoring |	self proceedThroughWarning: 			[refactoring := PushUpMethodRefactoring pushUp: #(#isComposite)						from: CompositeLintRuleTest.			self executeRefactoring: refactoring].	self 		assert: ((refactoring model classNamed: #BasicLintRuleTest) 				parseTreeFor: #isComposite) = (RBParser parseMethod: 'isComposite ^false').	self 		assert: ((refactoring model classNamed: ('Foo' , 'LintRuleTest') asSymbol) 				parseTreeFor: #isComposite) = (RBParser parseMethod: 'isComposite ^false').	self 		assert: ((refactoring model classNamed: #LintRuleTest) 				parseTreeFor: #isComposite) = (RBParser parseMethod: 'isComposite ^true').	self deny: ((refactoring model classNamed: #CompositeLintRuleTest) 				directlyDefinesMethod: #isComposite)! !!PushUpMethodTest methodsFor: 'failure tests'!testPushUpReferencesInstVar	self shouldFail: (PushUpMethodRefactoring pushUp: #(#checkClass:)				from: BasicLintRuleTest)! !!PushUpMethodTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:11'!testPushUpWithInvalidSuperSend	| class |	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'Subclass subclass: #Foo1 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'Subclass subclass: #Foo2 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #Foo2) compile: 'yourself ^super yourself + 1'		classified: #(#accessing).	class := model classNamed: #Foo1.	class compile: 'yourself ^1' classified: #(#accessing).	self shouldFail: (PushUpMethodRefactoring 				model: model				pushUp: #(#yourself)				from: class)! !!PushUpMethodTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:11'!testPushUpWithMethodThatCannotBePushedDown	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #SomeClass) compile: 'yourself ^54'		classified: #(#accessing).	self shouldFail: (PushUpMethodRefactoring 				model: model				pushUp: #(#yourself)				from: (model classNamed: #SomeClass))! !!PushUpMethodTest methodsFor: 'failure tests' stamp: 'bh 11/8/2000 14:11'!testPushUpWithSuperSendThatCannotBeCopiedDown	| class |	model 		defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #Object) compile: 'foo ^3' classified: #(#accessing).	model 		defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(model classNamed: #Subclass) compile: 'foo ^super foo'		classified: #(#accessing).	model 		defineClass: 'Subclass subclass: #Foo1 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	model 		defineClass: 'Subclass subclass: #Foo2 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	(class := model classNamed: #Foo2) compile: 'foo ^1'		classified: #(#accessing).	self shouldFail: (PushUpMethodRefactoring 				model: model				pushUp: #(#foo)				from: class)! !!RefactoringTest methodsFor: 'private' stamp: 'md 7/25/2005 15:15'!abstractVariableTestData^'| model |(model := RBNamespace 			onEnvironment: ((ClassEnvironment onEnvironment: BrowserEnvironment new) 					classes: (#(#Bar #Foo) inject: OrderedCollection new							into: 								[:sum :each | 								| class |								class := Smalltalk at: each ifAbsent: [nil].								class notNil ifTrue: [sum add: class].								sum]) 								, (#(#Bar #Foo) inject: OrderedCollection new										into: 											[:sum :each | 											| class |											class := Smalltalk at: each ifAbsent: [nil].											class notNil ifTrue: [sum add: class class].											sum])) 						not) 		name: ''Test''.#(''Object subclass: #Foo	instanceVariableNames: ''''instVarName1 instVarName2 ''''	classVariableNames: ''''ClassVarName1 ClassVarName2 ''''	poolDictionaries: ''''''''	category: ''''Testing'''''' ''Foo subclass: #Bar	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Testing'''''') 	do: [:each | model defineClass: each].#(#(#Bar #(#(''instVarName1	^1242321'' #tests) #(''foo	instVarName1 := instVarName1 + instVarName2 + ClassVarName1'' #tests))) #(#Foo #(#(''foo	^instVarName2 := 3'' #tests) #(''bar	"Add one to instVarName1"	instVarName1 := instVarName1 + 1'' #tests) #(''classVarName1	^ClassVarName1'' #tests) #(''instVarName1: anObject	^anObject'' #tests) #(''asdf	^self classVarName1: (ClassVarName1 := ClassVarName1 + 1)'' #tests) #(''instVarName2	^instVarName2'' #tests) #(''instVarName2: anObject	instVarName2 := anObject'' #tests) #(''classVarName1: anObject	^ClassVarName1 := anObject'' #tests))) #(''Bar class'' #(#(''classVarName2: anObject	ClassVarName2 := anObject'' #tests) #(''classVarName2	^ClassVarName2'' #tests))) #(''Foo class'' #(#(''foo	^ClassVarName1 := ClassVarName1 * ClassVarName1 * ClassVarName1'' #tests)))) 	do: 		[:each | 		| class |		class := model classNamed: each first.		each last do: [:meth | class compile: meth first classified: meth last]].model'! !!RefactoringTest methodsFor: 'private' stamp: 'md 7/25/2005 18:12'!childrenToSiblingTestData^'| m |(m:= RBNamespace 			onEnvironment: ((ClassEnvironment onEnvironment: BrowserEnvironment new) 					classes: (#(#ConcreteSubclass #ConcreteSuperclass #NoMoveSubclass) 							inject: OrderedCollection new							into: 								[:sum :each | 								| class |								class := Smalltalk at: each ifAbsent: [nil].								class notNil ifTrue: [sum add: class].								sum]) 								, (#(#ConcreteSubclass #ConcreteSuperclass #NoMoveSubclass) 										inject: OrderedCollection new										into: 											[:sum :each | 											| class |											class := Smalltalk at: each ifAbsent: [nil].											class notNil ifTrue: [sum add: class class].											sum])) 						not) 		name: ''Test''.#(''ConcreteSuperclass subclass: #NoMoveSubclass	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Testing'''''' ''Object subclass: #ConcreteSuperclass	instanceVariableNames: ''''instVarName1 instVarName2 ''''	classVariableNames: ''''ClassVarName1 ClassVarName2 ''''	poolDictionaries: ''''''''	category: ''Testing'''''' ''ConcreteSuperclass subclass: #ConcreteSubclass	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Testing'''''') 	do: [:each | m defineClass: each].(m metaclassNamed: #ConcreteSuperclass) 	addInstanceVariable: ''classInstVarName1''.#(#(#ConcreteSubclass #(#(''initialize	super initialize.	instVarName1 := nil'' #everyone) #(''different	^0'' #everyone))) #(#ConcreteSuperclass #(#(''same	^self initialize isKindOf: ConcreteSuperclass'' #''one def'') #(''different	^instVarName1 + instVarName2'' #everyone) #(''initialize	instVarName1 := instVarName2 := ClassVarName1 := ClassVarName2 := 0'' #everyone))) #(#NoMoveSubclass #(#(''same	^123'' #''one def''))) #(''ConcreteSubclass class'' #(#(''bar	^self storeString'' #testing))) #(''ConcreteSuperclass class'' #(#(''foo	^classInstVarName1 + ClassVarName1 + ClassVarName2'' #testing) #(''new	^super new initialize'' #testing) #(''bar	^self printString'' #testing))) #(''NoMoveSubclass class'' #())) 	do: 		[:each | 		| class |		class := m classNamed: each first.		each last do: [:meth | class compile: meth first classified: meth last]].m'! !!RefactoringTest methodsFor: 'private' stamp: 'md 7/25/2005 18:45'!inlineMethodTestData^ '| m |(m := RBNamespace 			onEnvironment: ((ClassEnvironment onEnvironment: BrowserEnvironment new) 					classes: (#(#RenameClassVariableChange #VariableCompositeRefactoryChange #RenameInstanceVariableChange #CompositeRefactoryChange #RenameVariableChange #RefactoryChange) 							inject: OrderedCollection new							into: 								[:sum :each | 								| class |								class := Smalltalk at: each ifAbsent: [nil].								class notNil ifTrue: [sum add: class].								sum]) 								, (#() inject: OrderedCollection new										into: 											[:sum :each | 											| class |											class := Smalltalk at: each ifAbsent: [nil].											class notNil ifTrue: [sum add: class class].											sum])) 						not) 		name: ''Test''.#(''Object subclass: #RefactoryChange	instanceVariableNames: ''''name ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RefactoryChange subclass: #CompositeRefactoryChange	instanceVariableNames: ''''changes ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''CompositeRefactoryChange subclass: #VariableCompositeRefactoryChange	instanceVariableNames: ''''className isMeta ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''VariableCompositeRefactoryChange subclass: #RenameVariableChange	instanceVariableNames: ''''oldName newName ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RenameVariableChange subclass: #RenameClassVariableChange	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RenameVariableChange subclass: #RenameInstanceVariableChange	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''') 	do: [:each | m defineClass: each].#(#(#RenameClassVariableChange #(#(''removeOldVariable	(RemoveClassVariableChange remove: oldName from: self changeClass) execute'' #private) #(''addNewVariable	(AddClassVariableChange add: newName to: self changeClass) execute'' #private) #(''executeNotifying: aBlock 	| undo |	self addNewVariable.	self copyOldValuesToNewVariable.	undo := super executeNotifying: aBlock.	self removeOldVariable.	^undo'' #private) #(''copyOldValuesToNewVariable	| oldValue |	oldValue := self changeClass classPool at: oldName ifAbsent: [].	self changeClass at: newName asSymbol put: oldValue'' #private))) #(#VariableCompositeRefactoryChange #(#(''displayClassName	^isMeta 		ifTrue: [self changeClassName , '''' class'''']		ifFalse: [self changeClassName asString]'' #printing) #(''isMeta	^isMeta'' #private) #(''changeClass: aBehavior 	isMeta := aBehavior isMeta.	className := isMeta 				ifTrue: [aBehavior soleInstance name]				ifFalse: [aBehavior name]'' #accessing) #(''hash	^self changeClassName hash'' #comparing) #(''changeClassName: aSymbol 	className := aSymbol.	isMeta isNil ifTrue: [isMeta := false]'' #accessing) #(''changeClass	| class |	class := Smalltalk at: self changeClassName ifAbsent: [^nil].	^isMeta ifTrue: [class class] ifFalse: [class]'' #accessing) #(''printOn: aStream	aStream nextPutAll: self displayString'' #printing) #(''changeClassName	^className'' #accessing) #(''= aRefactoryClassChange 	self class = aRefactoryClassChange class ifFalse: [^false].	^className = aRefactoryClassChange changeClassName 		and: [isMeta = aRefactoryClassChange isMeta]'' #comparing))) #(#RenameInstanceVariableChange #(#(''removeOldVariable	(RemoveInstanceVariableChange remove: oldName from: self changeClass) 		execute'' #private) #(''addNewVariable	(AddInstanceVariableChange add: newName to: self changeClass) execute'' #private) #(''executeNotifying: aBlock 	| undo |	self addNewVariable.	self copyOldValuesToNewVariable.	undo := super executeNotifying: aBlock.	self removeOldVariable.	^undo'' #private) #(''copyOldValuesToNewVariable	| newIndex oldIndex |	oldIndex := self changeClass allInstVarNames indexOf: oldName asString.	newIndex := self changeClass allInstVarNames indexOf: newName asString.	self changeClass withAllSubclasses do: 			[:each | 			each allInstances 				do: [:inst | each instVarAt: newIndex put: (each instVarAt: oldIndex)]]'' #private))) #(#CompositeRefactoryChange #(#(''compile: source in: class 	^self addChange: (AddMethodChange compile: source in: class)'' #''refactory-changes'') #(''addClassVariable: variableName to: aClass 	^self addChange: (AddClassVariableChange add: variableName to: aClass)'' #''refactory-changes'') #(''addChangeFirst: aRefactoryChange 	changes addFirst: aRefactoryChange.	^aRefactoryChange'' #accessing) #(''removeChange: aChange 	changes remove: aChange ifAbsent: []'' #''private-inspector accessing'') #(''addPool: aPoolVariable to: aClass 	^self addChange: (AddPoolVariableChange add: aPoolVariable to: aClass)'' #''refactory-changes'') #(''initialize	super initialize.	changes := OrderedCollection new'' #''initialize-release'') #(''defineClass: aString 	^self addChange: (AddClassChange definition: aString)'' #''refactory-changes'') #(''changeForClass: aRBClass selector: aSelector 	changes reverseDo: 			[:each | 			| change |			change := each changeForClass: aRBClass selector: aSelector.			change notNil ifTrue: [^change]].	^nil'' #accessing) #(''removeInstanceVariable: variableName from: aClass 	^self 		addChange: (RemoveInstanceVariableChange remove: variableName from: aClass)'' #''refactory-changes'') #(''printOn: aStream 	aStream nextPutAll: name'' #printing) #(''inspect	RefactoryBuilderInspector openOn: self'' #''user interface'') #(''flattenOnto: aCollection 	changes do: [:each | each flattenOnto: aCollection]'' #private) #(''hash	^changes size'' #comparing) #(''= aRefactoryBuilder 	self class = aRefactoryBuilder class ifFalse: [^false].	changes size = aRefactoryBuilder changes size ifFalse: [^false].	changes with: aRefactoryBuilder changes		do: [:each :change | each = change ifFalse: [^false]].	^true'' #comparing) #(''renameClass: class to: newName 	^self addChange: (RenameClassChange rename: class name to: newName)'' #''refactory-changes'') #(''renameChangesForClass: aClassName to: newClassName 	^(self copy)		changes: (self changes 					collect: [:each | each renameChangesForClass: aClassName to: newClassName]);		yourself'' #accessing) #(''postCopy	super postCopy.	changes := changes collect: [:each | each copy]'' #copying) #(''changes: aCollection 	changes := aCollection'' #''private-inspector accessing'') #(''addInstanceVariable: variableName to: aClass 	^self addChange: (AddInstanceVariableChange add: variableName to: aClass)'' #''refactory-changes'') #(''compile: source in: class classified: aProtocol 	^self addChange: (AddMethodChange 				compile: source				in: class				classified: aProtocol)'' #''refactory-changes'') #(''changeForMetaclass: aSymbol selector: aSelector 	changes reverseDo: 			[:each | 			| change |			change := each changeForMetaclass: aSymbol selector: aSelector.			change notNil ifTrue: [^change]].	^nil'' #accessing) #(''removeClassVariable: variableName from: aClass 	^self 		addChange: (RemoveClassVariableChange remove: variableName from: aClass)'' #''refactory-changes'') #(''executeNotifying: aBlock 	| undos undo |	undos := changes collect: [:each | each executeNotifying: aBlock].	undo := self copy.	undo changes: undos reverse.	^undo'' #private) #(''changes	^changes'' #''private-inspector accessing'') #(''removeMethod: aSelector from: aClass 	^self addChange: (RemoveMethodChange remove: aSelector from: aClass)'' #''refactory-changes'') #(''removeClass: aClass 	^self addChange: (RemoveClassChange removeClassName: aClass)'' #''refactory-changes'') #(''addChange: aRefactoryChange 	changes add: aRefactoryChange.	^aRefactoryChange'' #accessing) #(''changesSize	^changes inject: 0 into: [:sum :each | sum + each changesSize]'' #accessing) #(''displayString	^super displayString asText allBold'' #printing) #(''problemCount	^self changesSize'' #accessing))) #(#RenameVariableChange #(#(''oldName: aString	oldName := aString'' #private) #(''executeNotifying: aBlock 	| undo |	undo := super executeNotifying: aBlock.	undo		oldName: newName;		newName: oldName.	^undo'' #private) #(''newName: aString 	newName := aString'' #private) #(''changeString	^''''Rename '''' , oldName , '''' to '''' , newName'' #printing))) #(#RefactoryChange #(#(''flattenedChanges	| changes |	changes := OrderedCollection new.	self flattenOnto: changes.	^changes'' #private) #(''name: aString	name := aString'' #''initialize-release'') #(''initialize'' #''initialize-release'') #(''changeForMetaclass: aSymbol selector: aSelector 	^nil'' #accessing) #(''changeString	^self class name'' #printing) #(''changeForClass: aRBClass selector: aSelector 	^nil'' #accessing) #(''executeWithMessage: aString 	| tally controller m done |	m := 0 asValue.	done := 0.	tally := self changesSize.	controller := aString isNil 				ifTrue: [nil]				ifFalse: [ProgressWidgetView progressOpenOn: m label: aString].	m value: 0.	^	[self executeNotifying: 			[done := done + 1.			m value: done asFloat / tally]] 			ensure: [controller notNil ifTrue: [controller closeAndUnschedule]]'' #''performing-changes'') #(''executeNotifying: aBlock 	self subclassResponsibility'' #private) #(''changes	^Array with: self'' #accessing) #(''execute	^self executeNotifying: []'' #''performing-changes'') #(''inspect	^((CompositeRefactoryChange new)		changes: (Array with: self);		yourself) inspect'' #''user interface'') #(''flattenOnto: aCollection 	aCollection add: self'' #private) #(''name	^name isNil ifTrue: [self changeString] ifFalse: [name]'' #accessing) #(''changesSize	^1'' #accessing) #(''displayString	^name isNil ifTrue: [self changeString] ifFalse: [name]'' #printing) #(''renameChangesForClass: aClassName to: newClassName 	"We are in the middle of performing a rename operation. If we stored 	the class name, we need to change the class name to the new 	name to perform the compiles."	self subclassResponsibility'' #accessing)))) 	do: 		[:each | 		| class |		class := m classNamed: each first.		each last do: [:meth | class compile: meth first classified: meth last]].m'! !!RefactoringTest methodsFor: 'set up'!setUp	| assoc |	super setUp.	assoc := RefactoringManager classPool associationAt: #Instance				ifAbsent: [RefactoringManager classPool associationAt: 'Instance'].	manager := assoc value.	assoc value: nil.	model := RBNamespace new! !!RefactoringTest methodsFor: 'set up'!setupImplementorToInlineFor: aRefactoring toReturn: anObject 	| options |	options := aRefactoring options copy.	options at: #implementorToInline put: [:ref :imps | anObject].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!setupInlineExpressionFor: aRefactoring toReturn: aBoolean 	| options |	options := aRefactoring options copy.	options at: #inlineExpression put: [:ref :string | aBoolean].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!setupMethodNameFor: aRefactoring toReturn: aSelector 	| options |	options := aRefactoring options copy.	options at: #methodName		put: 			[:ref :aMethodName | 			aMethodName				selector: aSelector;				yourself].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!setupMethodNameFor: aRefactoring toReturn: aSelector withArguments: stringCollection 	| options |	options := aRefactoring options copy.	options at: #methodName		put: 			[:ref :aMethodName | 			aMethodName				selector: aSelector;				arguments: stringCollection;				yourself].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!setupSelfArgumentNameFor: aRefactoring toReturn: aString 	| options |	options := aRefactoring options copy.	options at: #selfArgumentName put: [:ref | aString].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!setupVariableToMoveToFor: aRefactoring toReturn: aString 	| options |	options := aRefactoring options copy.	options at: #selectVariableToMoveTo put: [:ref :class :selector | aString].	aRefactoring options: options! !!RefactoringTest methodsFor: 'set up'!setupVariableTypesFor: aRefactoring toReturn: anObject 	| options |	options := aRefactoring options copy.	options at: #variableTypes put: [:ref :ignore1 :ignore2 | anObject].	aRefactoring options: options! !!RefactoringTest methodsFor: 'private'!shouldFail: aRefactoring 	self proceedThroughWarning: 			[self should: [self executeRefactoring: aRefactoring]				raise: RefactoringError]! !!RefactoringTest methodsFor: 'private'!shouldWarn: aRefactoring 	self should: [self executeRefactoring: aRefactoring]		raise: RefactoringWarning! !!RefactoringTest methodsFor: 'set up'!tearDown	super tearDown.	RefactoringManager instance release.	(RefactoringManager classPool associationAt: #Instance		ifAbsent: [RefactoringManager classPool associationAt: 'Instance']) 			value: manager! !!RefactoringTest methodsFor: 'tests' stamp: 'bh 4/2/2000 22:28'!testConditions	| condition newCondition |	condition := RBCondition new 				type: #false				block: [false]				errorString: 'false'.	condition errorMacro: '<1?true:false>'.	self deny: condition check.	self assert: condition errorString = 'false'.	self assert: condition not check.	self assert: condition printString = 'false'.	self assert: condition not printString = 'NOT false'.	self deny: (condition not & condition) check.	self 		assert: (condition not & condition) printString = 'NOT false & false'.	self assert: (condition & condition) not check.	self assert: (condition | condition not) check.	self deny: (newCondition := condition | condition) check.	self assert: newCondition errorString = 'false AND false'.	self assert: (condition not | condition not) check.	self deny: (newCondition := condition & condition) check.	self assert: newCondition errorString = 'false'.	self assert: (condition not & condition not) check.	self assert: (condition & condition) errorString = 'false OR false'! !!RefactoringTest methodsFor: 'tests' stamp: 'md 8/2/2005 22:19'!testPrintRefactoringManager	Transcript		show: RefactoringManager instance printString;		cr.! !!RemoveClassTest methodsFor: 'failure tests'!testBadName	self 		shouldFail: (RemoveClassRefactoring classNames: #(#RecursiveSelfRule))! !!RemoveClassTest methodsFor: 'tests'!testRemoveClass	| refactoring |	refactoring := RemoveClassRefactoring 				classNames: (Array with: ('Foo' , 'LintRuleTest') asSymbol).	self executeRefactoring: refactoring.	self 		assert: (refactoring model classNamed: ('Foo' , 'LintRuleTest') asSymbol) 				isNil.	self 		assert: (refactoring model classNamed: #TransformationRuleTest) superclass 				= (refactoring model classNamed: #LintRuleTest)! !!RemoveClassTest methodsFor: 'failure tests'!testRemoveReferenced	self 		shouldFail: (RemoveClassRefactoring classNames: #(#BasicLintRuleTest))! !!RemoveClassVariableTest methodsFor: 'failure tests'!testNonExistantName	self 		shouldFail: (RemoveClassVariableRefactoring variable: #RecursiveSelfRule1				class: TransformationRuleTest)! !!RemoveClassVariableTest methodsFor: 'failure tests'!testReferencedVariable	self 		shouldFail: (RemoveClassVariableRefactoring variable: #RecursiveSelfRule				class: TransformationRuleTest)! !!RemoveClassVariableTest methodsFor: 'tests'!testRemoveClassVar	| refactoring class |	refactoring := RemoveClassVariableRefactoring variable: 'Foo1'				class: LintRuleTest.	class := refactoring model classNamed: #LintRuleTest.	self assert: (class definesClassVariable: 'Foo1').	self executeRefactoring: refactoring.	self deny: (class definesClassVariable: 'Foo1')! !!RemoveInstanceVariableTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:13'!testModelRemoveInstanceVariable	| class |	model 		defineClass: 'nil subclass: #Object instanceVariableNames: ''foo1'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	class := model classNamed: #Object.	self assert: (class definesInstanceVariable: 'foo1').	self executeRefactoring: (RemoveInstanceVariableRefactoring 				model: model				variable: 'foo1'				class: class).	self deny: (class definesInstanceVariable: 'foo1')! !!RemoveInstanceVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (RemoveInstanceVariableRefactoring variable: 'name1'				class: LintRuleTest)! !!RemoveInstanceVariableTest methodsFor: 'failure tests'!testReferencedVariable	self shouldFail: (RemoveInstanceVariableRefactoring variable: 'name'				class: LintRuleTest)! !!RemoveInstanceVariableTest methodsFor: 'tests'!testRemoveInstVar	| refactoring class |	refactoring := RemoveInstanceVariableRefactoring variable: 'foo1'				class: LintRuleTest.	class := refactoring model classNamed: #LintRuleTest.	self assert: (class definesInstanceVariable: 'foo1').	self executeRefactoring: refactoring.	self deny: (class definesInstanceVariable: 'foo1')! !!RemoveMethodTest methodsFor: 'tests'!testModelRecursiveMethodThatIsNotReferencedFromOtherMethods	| class otherClass |	class := model classNamed: #Object.	class compile: 'someMethodThatIsNotReferenced ^2' classified: #(#accessing).	self assert: (class definesMethod: #someMethodThatIsNotReferenced).	otherClass := model metaclassNamed: self class superclass name.	otherClass 		compile: 'someMethodThatIsNotReferenced ^3 someMethodThatIsNotReferenced'		classified: #(#accessing).	model removeClassNamed: self class name.	self executeRefactoring: (RemoveMethodRefactoring 				model: model				removeMethods: #(#someMethodThatIsNotReferenced)				from: class).	self deny: (class definesMethod: #someMethodThatIsNotReferenced)! !!RemoveMethodTest methodsFor: 'tests'!testRemoveMethod	| refactoring selectors |	selectors := Array with: ('selectorNot' , 'Referenced') asSymbol.	refactoring := RemoveMethodRefactoring removeMethods: selectors				from: RefactoryTestDataApp.	self assert: ((refactoring model classNamed: #RefactoryTestDataApp) 				directlyDefinesMethod: selectors first).	self executeRefactoring: refactoring.	self deny: ((refactoring model classNamed: #RefactoryTestDataApp) 				directlyDefinesMethod: selectors first)! !!RemoveMethodTest methodsFor: 'failure tests'!testRemoveReferenced	self shouldFail: (RemoveMethodRefactoring removeMethods: #(#checkClass:)				from: BasicLintRuleTest)! !!RemoveMethodTest methodsFor: 'failure tests'!testRemoveSameMethodButSendsSuper	self shouldWarn: (RemoveMethodRefactoring removeMethods: #(#new)				from: BasicLintRuleTest class)! !!RemoveParameterTest methodsFor: 'failure tests'!testNonExistantName	self		shouldFail: (RemoveParameterRefactoring 					removeParameter: 'asdf'					in: BasicLintRuleTest					selector: #checkClass:);		shouldFail: (RemoveParameterRefactoring 					removeParameter: 'aSmalllintContext'					in: BasicLintRuleTest					selector: #checkClass1:)! !!RemoveParameterTest methodsFor: 'failure tests'!testPrimitiveMethods	| refactoring |	(model classNamed: #Object) 		compile: 'foo123: a <primitive: 100> ^#() primitiveFailed'		classified: #(#accessing).	refactoring := RemoveParameterRefactoring 				model: model				removeParameter: 'a'				in: Object				selector: #foo123:.	self shouldFail: refactoring! !!RemoveParameterTest methodsFor: 'tests'!testRemoveParameter	| refactoring class |	refactoring := RemoveParameterRefactoring 				removeParameter: 'anArg'				in: RefactoryTestDataApp				selector: ('rename' , 'ThisMethod:') asSymbol.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self assert: (class parseTreeFor: #renameThisMethod) 				= (RBParser parseMethod: 'renameThisMethod								^self').	self assert: (class parseTreeFor: #callMethod) 				= (RBParser parseMethod: 'callMethod								^(self renameThisMethod)').	self 		deny: (class directlyDefinesMethod: ('rename' , 'ThisMethod:') asSymbol)! !!RenameClassTest methodsFor: 'failure tests'!testBadName	self		shouldFail: (RenameClassRefactoring rename: LintRuleTest					to: self objectClassVariable);		shouldFail: (RenameClassRefactoring rename: LintRuleTest to: #'Ob ject')! !!RenameClassTest methodsFor: 'failure tests'!testExistingName	self shouldFail: (RenameClassRefactoring rename: self class to: #Object)! !!RenameClassTest methodsFor: 'failure tests'!testMetaClassFailure	self 		shouldFail: (RenameClassRefactoring rename: self class class to: #Foo)! !!RenameClassTest methodsFor: 'tests' stamp: 'bh 11/8/2000 14:13'!testModelRenameClass	| refactoring class |	model 		defineClass: 'Object subclass: #Foo instanceVariableNames: ''a'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.	class := model classNamed: #Foo.	class		compile: 'foo	^Object' classified: #(#accessing);		compile: 'objectName ^#(Object)' classified: #(#accessing).	refactoring := RenameClassRefactoring 				model: model				rename: Object				to: #Thing.	self executeRefactoring: refactoring.	self assert: (model includesClassNamed: #Thing).	self deny: (model includesClassNamed: #Object).	self 		assert: (class parseTreeFor: #foo) = (RBParser parseMethod: 'foo ^Thing').	self assert: (class parseTreeFor: #objectName) 				= (RBParser parseMethod: 'objectName ^#(Thing)').	self assert: class superclass name = #Thing! !!RenameClassTest methodsFor: 'tests'!testRenameClass	| refactoring class |	refactoring := RenameClassRefactoring 				rename: (Smalltalk at: ('Class' , 'ToRename') asSymbol)				to: 'New' , 'ClassName' asSymbol.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: ('New' , 'ClassName') asSymbol) 				parseTreeFor: #method1) = (RBParser parseMethod: 'method1	^self method2').	self deny: (refactoring model 				includesClassNamed: ('Class' , 'ToRename') asSymbol).	class := refactoring model 				classNamed: ('Subclass' , 'OfClassToRename') asSymbol.	self assert: class superclass 				= (refactoring model classNamed: ('New' , 'ClassName') asSymbol).	self assert: (class parseTreeFor: #symbolReference) 				= (RBParser parseMethod: 'symbolReference								^#NewClassName').	self assert: (class parseTreeFor: #reference) 				= (RBParser parseMethod: 'reference								^NewClassName new')! !!RenameClassVariableTest methodsFor: 'failure tests'!testAlreadyExistingName	self shouldFail: (RenameClassVariableRefactoring 				rename: #RecursiveSelfRule				to: self objectClassVariable				in: TransformationRuleTest)! !!RenameClassVariableTest methodsFor: 'failure tests'!testMetaClassFailure	self shouldFail: (RenameClassVariableRefactoring 				rename: #RecursiveSelfRule				to: #Foo				in: TransformationRuleTest class)! !!RenameClassVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (RenameClassVariableRefactoring 				rename: #foo				to: #newFoo				in: BasicLintRuleTest)! !!RenameClassVariableTest methodsFor: 'tests'!testRenameClassVar	| refactoring class |	refactoring := RenameClassVariableRefactoring 				rename: #RecursiveSelfRule				to: #RSR				in: TransformationRuleTest.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #TransformationRuleTest.	self assert: (class directlyDefinesClassVariable: #RSR).	self deny: (class directlyDefinesClassVariable: #RecursiveSelfRule).	self 		assert: (class metaclass parseTreeFor: #initializeAfterLoad1) = (RBParser 						parseMethod: 'initializeAfterLoad1								RSR := ParseTreeSearcher new.								RSR									addMethodSearches: #(''`@methodName: `@args | `@temps | self `@methodName: `@args'' ''`@methodName: `@args | `@temps | ^self `@methodName: `@args'')											-> [:aNode :answer | true]').	self assert: (class metaclass parseTreeFor: #nuke) 				= (RBParser parseMethod: 'nuke								RSR := nil').	self 		assert: (class parseTreeFor: #checkMethod:) = (RBParser 						parseMethod: 'checkMethod: aSmalllintContext 								class := aSmalllintContext selectedClass.								(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 										[(RSR executeTree: rewriteRule tree initialAnswer: false)											ifFalse: 												[builder compile: rewriteRule tree printString													in: class													classified: aSmalllintContext protocols]]')! !!RenameInstanceVariableTest methodsFor: 'failure tests'!testAlreadyExistingName	self shouldFail: (RenameInstanceVariableRefactoring 				rename: 'classBlock'				to: 'name'				in: BasicLintRuleTest)! !!RenameInstanceVariableTest methodsFor: 'failure tests'!testNonExistantName	self shouldFail: (RenameInstanceVariableRefactoring 				rename: 'foo'				to: 'newFoo'				in: BasicLintRuleTest)! !!RenameInstanceVariableTest methodsFor: 'tests'!testRenameInstVar	| refactoring class |	refactoring := RenameInstanceVariableRefactoring 				rename: 'classBlock'				to: 'asdf'				in: BasicLintRuleTest.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #BasicLintRuleTest.	self assert: (class directlyDefinesInstanceVariable: 'asdf').	self deny: (class directlyDefinesInstanceVariable: 'classBlock').	self 		assert: (class parseTreeFor: #checkClass:) = (RBParser 						parseMethod: 'checkClass: aSmalllintContext 								^asdf value: aSmalllintContext value: result').	self 		assert: (class parseTreeFor: #classBlock:) = (RBParser 						parseMethod: 'classBlock: aBlock								asdf := aBlock testMethod1').	self 		assert: (class parseTreeFor: #initialize) = (RBParser 						parseMethod: 'initialize								super initialize.								asdf := [:context :aResult | ].								methodBlock := [:context :aResult | ].								self resultClass: SelectorEnvironment.')! !!RenameMethodTest methodsFor: 'failure tests' stamp: 'md 3/15/2006 17:28'!testExistingSelector	self shouldFail: (RenameMethodRefactoring 				renameMethod: #checkClass:				in: BasicLintRuleTest				to: #runOnEnvironment:				permutation: (1 to: 1))! !!RenameMethodTest methodsFor: 'failure tests' stamp: 'md 3/15/2006 17:28'!testMultipleSelectors	self shouldWarn: (RenameMethodRefactoring 				renameMethod: #checkClass:				in: BasicLintRuleTest				to: #foo:				permutation: (1 to: 1))! !!RenameMethodTest methodsFor: 'tests' stamp: 'md 3/15/2006 17:28'!testRenamePermuteArgs	| refactoring class |	refactoring := RenameMethodRefactoring 				renameMethod: ('rename:' , 'two:') asSymbol				in: RefactoryTestDataApp				to: ('rename:' , 'two:') asSymbol				permutation: #(2 1).	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self 		assert: (class parseTreeFor: ('rename:' , 'two:') asSymbol) = (RBParser 						parseMethod: 'rename: argumentMethod two: this ^self printString, this, argumentMethod').	self assert: (class parseTreeFor: #exampleCall) 				= (RBParser parseMethod: 'exampleCall ^self rename: 2 two: 1')! !!RenameMethodTest methodsFor: 'tests' stamp: 'md 3/15/2006 17:29'!testRenamePrimitive	| refactoring count |	count := 0.	model allReferencesTo: #basicAt:put: do: [:method | count := count + 1].	refactoring := RenameMethodRefactoring 				model: model				renameMethod: #basicAt:put:				in: Object				to: ('at:' , 'bar:') asSymbol				permutation: (1 to: 2).	self proceedThroughWarning: [self executeRefactoring: refactoring].	model allReferencesTo: #basicAt:put:		do: 			[:method | 			count := count - 1.			self assert: method source isNil].	model allReferencesTo: ('at:' , 'bar:') asSymbol		do: [:method | count := count - 1].	self assert: count = 0! !!RenameMethodTest methodsFor: 'tests' stamp: 'md 3/15/2006 17:28'!testRenameTestMethod	| refactoring class |	refactoring := RenameMethodRefactoring 				renameMethod: ('rename' , 'ThisMethod:') asSymbol				in: RefactoryTestDataApp				to: #renameThisMethod2:				permutation: (1 to: 1).	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self assert: (class parseTreeFor: #renameThisMethod2:) 				= (RBParser parseMethod: 'renameThisMethod2: anArg	^self').	self assert: (class parseTreeFor: #callMethod) 				= (RBParser parseMethod: 'callMethod	^(self renameThisMethod2: 5)').	self 		assert: (class parseTreeFor: #symbolReference) = (RBParser 						parseMethod: 'symbolReference		^ #(#renameThisMethod2: #(4 #renameThisMethod2:))').	self 		deny: (class directlyDefinesMethod: ('rename' , 'ThisMethod:') asSymbol)! !!RenameMethodTest methodsFor: 'tests' stamp: 'md 3/15/2006 17:29'!testRenameTestMethod1	| refactoring class |	refactoring := RenameMethodRefactoring 				renameMethod: ('test' , 'Method1') asSymbol				in: RefactoryTestDataApp				to: #testMethod2				permutation: (1 to: 0).	self executeRefactoring: refactoring.	class := refactoring model classNamed: #RefactoryTestDataApp.	self 		assert: (class parseTreeFor: #testMethod2) = (RBParser 						parseMethod: 'testMethod2	^self testMethod2 , ([:each | each testMethod2] value: #(#(#testMethod2) 2 #testMethod2))').	self 		assert: ((refactoring model classNamed: #BasicLintRuleTest) 				parseTreeFor: #classBlock:) = (RBParser 							parseMethod: 'classBlock: aBlock	classBlock := aBlock testMethod2').	self deny: (class directlyDefinesMethod: ('test' , 'Method1') asSymbol)! !!RenameTemporaryTest methodsFor: 'failure tests'!testBadInterval	self shouldFail: (RenameTemporaryRefactoring 				renameTemporaryFrom: (self convertInterval: (14 to: 17)						for: (RefactoryTestDataApp sourceCodeAt: #testMethod))				to: 'asdf'				in: RefactoryTestDataApp				selector: #testMethod)! !!RenameTemporaryTest methodsFor: 'failure tests'!testBadName	self		shouldFail: (RenameTemporaryRefactoring 					renameTemporaryFrom: (self convertInterval: (15 to: 19)							for: (LintRuleTest sourceCodeAt: #openEditor))					to: 'name'					in: LintRuleTest					selector: #openEditor);		shouldFail: (RenameTemporaryRefactoring 					renameTemporaryFrom: (self convertInterval: (15 to: 19)							for: (LintRuleTest sourceCodeAt: #openEditor))					to: 'rules'					in: LintRuleTest					selector: #openEditor);		shouldFail: (RenameTemporaryRefactoring 					renameTemporaryFrom: (self convertInterval: (15 to: 19)							for: (LintRuleTest sourceCodeAt: #openEditor))					to: 'DependentFields'					in: LintRuleTest					selector: #openEditor);		shouldFail: (RenameTemporaryRefactoring 					renameTemporaryFrom: (self convertInterval: (15 to: 19)							for: (LintRuleTest sourceCodeAt: #openEditor))					to: 'a b'					in: LintRuleTest					selector: #openEditor)! !!RenameTemporaryTest methodsFor: 'failure tests'!testModelBadName	| class |	model := RBNamespace new.	class := model classNamed: #Object.	class 		compile: 'aMethod: temp1 ^[| temp2 | temp2 := [:temp3 | temp3 = 5] value: 5. temp2] value'		classified: #(#accessing).	self		shouldFail: (RenameTemporaryRefactoring 					renameTemporaryFrom: (20 to: 24)					to: 'temp3'					in: class					selector: #aMethod:);		shouldFail: (RenameTemporaryRefactoring 					renameTemporaryFrom: (20 to: 24)					to: 'temp1'					in: class					selector: #aMethod:)! !!RenameTemporaryTest methodsFor: 'tests' stamp: 'bh 4/29/2000 21:21'!testRenameTemporary	| refactoring |	refactoring := RenameTemporaryRefactoring 				renameTemporaryFrom: (self convertInterval: (15 to: 19)						for: (LintRuleTest sourceCodeAt: #openEditor))				to: 'asdf'				in: LintRuleTest				selector: #openEditor.	self executeRefactoring: refactoring.	self 		assert: ((refactoring model classNamed: #LintRuleTest) 				parseTreeFor: #openEditor) = (RBParser 							parseMethod: 'openEditor								| asdf |								asdf := self failedRules.								asdf isEmpty ifTrue: [^self].								asdf size == 1 ifTrue: [^asdf first viewResults].								SmalllintResultEditor openOn: self label: name')! !!TemporaryToInstanceVariableTest methodsFor: 'set up' stamp: 'md 7/25/2005 15:17'!setUp	super setUp.	model := Compiler evaluate: self abstractVariableTestData.! !!TemporaryToInstanceVariableTest methodsFor: 'failure tests'!testNonExistantName	self		shouldFail: (TemporaryToInstanceVariableRefactoring 					class: BasicLintRuleTest					selector: #checkClass:					variable: 'asdf');		shouldFail: (TemporaryToInstanceVariableRefactoring 					class: BasicLintRuleTest					selector: #checkClass1:					variable: 'aSmalllintContext')! !!TemporaryToInstanceVariableTest methodsFor: 'failure tests'!testRedefinedTemporary	| class |	class := model classNamed: #Foo.	class 		compile: 'someMethod | instVarName1 | instVarName1 := 4. ^instVarName1'		classified: #(#accessing).	self shouldFail: (TemporaryToInstanceVariableRefactoring 				class: class				selector: #someMethod				variable: 'instVarName1')! !!TemporaryToInstanceVariableTest methodsFor: 'tests'!testTemporaryToInstanceVariable	| refactoring class |	refactoring := TemporaryToInstanceVariableRefactoring 				class: LintRuleTest				selector: #displayName				variable: 'nameStream'.	self executeRefactoring: refactoring.	class := refactoring model classNamed: #LintRuleTest.	self 		assert: (class parseTreeFor: #displayName) = (RBParser 						parseMethod: 'displayName								nameStream := WriteStream on: (String new: 64).								nameStream									nextPutAll: self name;									nextPutAll: '' (''.								self problemCount printOn: nameStream.								nameStream nextPut: $).								^nameStream contents').	self assert: (class directlyDefinesInstanceVariable: 'nameStream')! !!ReferenceFinderTest methodsFor: 'tests' stamp: 'bh 4/29/2000 18:16'!testAllPaths	self needsWork. "slows, then hangs (100% CPU) on or after level 5 - 4551 objects to search.		is this because Squeak can't handle large collections efficiently?""	| paths |	paths := ReferenceFinder findAllPathsTo: RefactoringManager instance.	self deny: paths isEmpty.	paths do: 		[:each | 		self assert: each last == RefactoringManager instance.		self assert: each first == Smalltalk]"! !!ReferenceFinderTest methodsFor: 'tests' stamp: 'bh 4/29/2000 18:16'!testAllPathsToInstance	self needsWork. "slows, then hangs (100% CPU) on or after level 5 - 4551 objects to search.		is this because Squeak can't handle large collections efficiently?""	| paths |     	paths := ReferenceFinder findAllPathsToInstanceOf: RefactoringManager. 	    self deny: paths isEmpty.     	paths do:      	[:each |      	self assert: each last class == RefactoringManager.     	self assert: each first == Smalltalk]"! !!ReferenceFinderTest methodsFor: 'tests' stamp: 'bh 4/29/2000 18:17'!testFound	self needsWork. "slows, then hangs (100% CPU) on or after level 5 - 4551 objects to search.		is this because Squeak can't handle large collections efficiently?""	| path |	path := ReferenceFinder findPathTo: RefactoringManager instance.	self assert: path last == RefactoringManager instance.	self assert: (path at: path size - 1) isVariableBinding.	self assert: (path at: path size - 1) key == #Instance.	self assert: path first == Smalltalk"! !!ReferenceFinderTest methodsFor: 'tests' stamp: 'bh 4/29/2000 18:17'!testNotFound	self needsWork. "slows, then hangs (100% CPU) on or after level 5 - 4551 objects to search.		is this because Squeak can't handle large collections efficiently?""	| path |	path := ReferenceFinder findPathTo: Object new.	self assert: path isNil"! !!ReferenceFinderTest methodsFor: 'tests' stamp: 'bh 4/29/2000 18:17'!testPathToInstance	self needsWork. "slows, then hangs (100% CPU) on or after level 5 - 4551 objects to search.		is this because Squeak can't handle large collections efficiently?""	| path |	path := ReferenceFinder findPathToInstanceOf: RefactoringManager.	self assert: path last class == RefactoringManager.	self assert: path first == Smalltalk"! !!SmalllintTest methodsFor: 'set up'!blockRuleFor: aSelector 	self blockRuleFor: aSelector plusSelectors: #()! !!SmalllintTest methodsFor: 'set up' stamp: 'nk 2/22/2005 21:20'!blockRuleFor: aSelector plusSelectors: symbolCollection 	| rule returnedEnvironment testSel |	testSel := aSelector asString copyFrom: 5 to: aSelector size.	testSel at: 1 put: testSel first asLowercase.	testSel := testSel asSymbol.	(BlockLintRule class includesSelector: testSel) ifFalse: [^self].	SmalllintChecker runRule: (rule := BlockLintRule perform: testSel)		onEnvironment: self refactoryTestAppEnvironment.	returnedEnvironment := SelectorEnvironment new.	returnedEnvironment addClass: RefactoryTestDataApp selector: testSel.	symbolCollection 		do: [:each | returnedEnvironment addClass: RefactoryTestDataApp selector: each].	self checkRule: rule isEqualTo: returnedEnvironment! !!SmalllintTest methodsFor: 'set up'!checkRule: aLintRule isEqualTo: anEnvironment 	| returnedEnvironment |	returnedEnvironment := aLintRule result.	self compare: returnedEnvironment to: anEnvironment.	self compare: anEnvironment to: returnedEnvironment! !!SmalllintTest methodsFor: 'set up'!compare: subEnvironment to: superEnvironment 	subEnvironment classesDo: 			[:each | 			(subEnvironment selectorsForClass: each) 				do: [:sel | self assert: (superEnvironment includesSelector: sel in: each)]]! !!SmalllintTest methodsFor: 'set up'!currentSelector	^thisContext sender selector! !!SmalllintTest methodsFor: 'set up'!parseTreeRuleFor: aSelector 	self parseTreeRuleFor: aSelector plusSelectors: #()! !!SmalllintTest methodsFor: 'set up' stamp: 'nk 2/22/2005 21:20'!parseTreeRuleFor: aSelector plusSelectors: symbolCollection 	| returnedEnvironment testSel rule |	testSel := aSelector asString copyFrom: 5 to: aSelector size.	testSel at: 1 put: testSel first asLowercase.	testSel := testSel asSymbol.	SmalllintChecker 		runRule: (rule := ParseTreeLintRule perform: testSel)		onEnvironment: self refactoryTestAppEnvironment.	returnedEnvironment := SelectorEnvironment new.	returnedEnvironment addClass: RefactoryTestDataApp selector: testSel.	symbolCollection 		do: [:each | returnedEnvironment addClass: RefactoryTestDataApp selector: each].	self checkRule: rule isEqualTo: returnedEnvironment! !!SmalllintTest methodsFor: 'set up'!refactoryTestAppEnvironment	| classEnvironment |	classEnvironment := ClassEnvironment new.	classEnvironment addClass: RefactoryTestDataApp.	^classEnvironment! !!SmalllintTest methodsFor: 'tests'!testAsOrderedCollectionNotNeeded	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testAssignmentInBlock	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testAssignmentInIfTrue	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testAtIfAbsent	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testBadMessage	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testBooleanPrecedence	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testCollectSelectNotUsed	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testCollectionMessagesToExternalObject	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testCollectionProtocol	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testConsistencyCheck	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testContains	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testDetectContains	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testEndTrueFalse	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testEqualNotUsed	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testEqualsTrue	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testEquivalentSuperclassMethods	| returnedEnvironment rule |	SmalllintChecker 		runRule: (rule := BlockLintRule equivalentSuperclassMethods)		onEnvironment: self refactoryTestAppEnvironment.	returnedEnvironment := SelectorEnvironment new.	returnedEnvironment addClass: RefactoryTestDataApp selector: #isLiteral.	self checkRule: rule isEqualTo: returnedEnvironment! !!SmalllintTest methodsFor: 'tests'!testExtraBlock	self parseTreeRuleFor: self currentSelector plusSelectors: #(#testMethod1)! !!SmalllintTest methodsFor: 'tests'!testFileBlocks	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests' stamp: 'bh 4/8/2000 19:06'!testFullBlocks	"skip this test in squeak""	self blockRuleFor: self currentSelector		plusSelectors: #(#caller1 #fullBlocks #detectContains #fileBlocks #moveDefinition #caller #assignmentInBlock #equalNotUsed #stringConcatenation #noMoveDefinition #referencesConditionFor: #returnInEnsure)"! !!SmalllintTest methodsFor: 'tests'!testGuardingClause	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testIfTrueBlocks	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testIfTrueReturns	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testJustSendsSuper	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testLiteralArrayCharacters	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testLongMethods	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testMinMax	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testMissingYourself	self parseTreeRuleFor: self currentSelector plusSelectors: #(#inlineMethod)! !!SmalllintTest methodsFor: 'tests'!testModifiesCollection	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testPrecedence	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testRefersToClass	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testReturnInEnsure	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testReturnsBooleanAndOther	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testReturnsIfTrue	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testSearchingLiteral	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testSendsDifferentSuper	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testSizeCheck	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testStringConcatenation	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testSuperSends	| rule returnedEnvironment |	SmalllintChecker runRule: (rule := BlockLintRule superSends)		onEnvironment: self refactoryTestAppEnvironment.	returnedEnvironment := SelectorEnvironment new.	returnedEnvironment addClass: RefactoryTestDataApp selector: #release.	self checkRule: rule isEqualTo: returnedEnvironment! !!SmalllintTest methodsFor: 'tests'!testTempVarOverridesInstVar	self blockRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testTempsReadBeforeWritten	self blockRuleFor: self currentSelector		plusSelectors: #(#inlineTemporary #noMoveDefinition #tempsReadBeforeWritten #equalNotUsed #fileBlocks #referencesConditionFor:)! !!SmalllintTest methodsFor: 'tests'!testThreeElementPoint	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testToDo	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testToDoCollect	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testToDoWithIncrement	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testUsesAdd	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testWhileTrue	self parseTreeRuleFor: self currentSelector! !!SmalllintTest methodsFor: 'tests'!testYourselfNotUsed	self parseTreeRuleFor: self currentSelector! !!VariableTypeTest methodsFor: 'tests'!testBasicLintRuleTypes	| typer types |	typer := RefactoryTyper new.	types := typer guessTypesFor: 'classBlock' in: BasicLintRuleTest.	"self assert: types size = 1."	self 		assert: ([] class withAllSuperclasses 				detect: [:each | types includes: (typer model classFor: each)]				ifNone: [nil]) notNil.	types := typer typesFor: 'methodBlock' in: (typer model classFor: BasicLintRuleTest).	"self should: [types size = 2]."	self 		assert: ([] class withAllSuperclasses 				detect: [:each | types includes: (typer model classFor: each)]				ifNone: [nil]) notNil.	"self should: [types includes: MessageChannel]."	typer printString! !!VariableTypeTest methodsFor: 'tests' stamp: 'bh 4/4/2000 09:32'!testCompositeLintRuleTypes	| typer types |	typer := RefactoryTyper new runOn: CompositeLintRuleTest.	types := typer guessTypesFor: 'rules'.	self assert: types size = 1.	self assert: (types includes: (typer model classFor: Collection)).	types := typer typesFor: '-rules-'.	self assert: types size = 2.	self assert: (types includes: (typer model classFor: LintRule)).	self assert: (types includes: (typer model classFor: LintRuleTest)).	self assert: (typer guessTypesFor: 'asdf') isEmpty.	typer printString! !!VariableTypeTest methodsFor: 'tests'!testLintRuleTypes	| typer types |	typer := RefactoryTyper new.	types := typer guessTypesFor: 'name' in: LintRuleTest.	self assert: types size = 1.	self assert: (types includes: (typer model classFor: String))! !!VariableTypeTest methodsFor: 'tests'!testParseTreeTypes	| types model |	model := RBNamespace new.	types := RefactoryTyper 				typesFor: 'foo'				in: (RBParser 						parseExpression: 'foo printString; testBasicLintRuleTypes; testParseTreeTypes')				model: model.	self assert: types size = 1.	self assert: (types includes: (model classFor: self class))! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 4/29/2000 21:41'!checker	"^ self checkerForAllRules"	"^ self checkerForSentNotImplemented"	^ CompositeLintRule rules: (OrderedCollection new add: BlockLintRule utilityMethods;		 yourself)! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'dvf 9/28/2001 22:40'!checkerForAllRules	^ CompositeLintRule rules: (OrderedCollection new addAll: 	(((BlockLintRule class methodDictionary keys asArray select: [:sel | sel 	numArgs == 0]) 	collect: [:sel | BlockLintRule perform: sel]) 	select: [:each | each isKindOf: LintRule]); 	 addAll: (((ParseTreeLintRule class methodDictionary keys asArray 	select: [:sel | sel numArgs == 0]) 	collect: [:sel | ParseTreeLintRule perform: sel]) 	select: [:each | each isKindOf: LintRule]); 	 yourself)! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/13/2000 12:38'!checkerForBugs	^CompositeLintRule ruleFor:BasicLintRule protocol:'bugs'.! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/13/2000 12:40'!checkerForSentNotImplemented	^ CompositeLintRule rules: (OrderedCollection new add: BlockLintRule sentNotImplemented;		 yourself)! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/13/2000 12:39'!checkerForSpecific	^CompositeLintRule rules:(OrderedCollection new       	        add:BlockLintRule sentNotImplemented;      	        add:BlockLintRule subclassResponsibilityNotDefined;      	        add:BlockLintRule usesTrue ;      	        add:BlockLintRule overridesSpecialMessage;      	        add:ParseTreeLintRule booleanPrecedence ;      	        add:BlockLintRule definesEqualNotHash ;      	        add:BlockLintRule undeclaredReference ;      	        yourself).! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 9/16/2001 22:06'!classes	self needsWork. "for complete testing, be sure to uncomment classesForAllClasses line.  This is very slow though."	^ self classesForAllClasses."	^ self classesForObject.	^ self classesForRefactoryClasses"! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/13/2000 12:41'!classesForAllClasses	^ Object withAllSubclasses! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/13/2000 12:41'!classesForObject	^ {Object}! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/13/2000 12:41'!classesForRefactoryClasses	^ Object withAllSubclasses select: [:class | class theNonMetaClass category asString beginsWith: 'Refactory']! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'bh 3/12/2000 13:35'!setUp	! !!SentNotImplementedTestCase methodsFor: 'running' stamp: 'md 2/27/2006 00:26'!test	| checker context |	checker := self checker.	context := SmalllintContext newNoCache.	checker resetResult.	self classes do: 		[:aClass | 		Transcript show: aClass printString;		 cr.		context selectedClass: aClass.		checker checkClass: context.		aClass methodDictionary keys do: [:each | (ExtraParsingAndFormattingTests methodsNotToTest includes: aClass >> each)				| (each = #DoIt)				ifFalse: 					[context selector: each.					checker checkMethod: context]]].	checker isEmpty ifTrue: ["'Nobody' inspect"].	Transcript cr;cr;cr.	(checker rules select: [:rule | rule result isEmpty not])		do: [:rule | rule result logOrInspect]! !!CategoryAndClassSelector class methodsFor: 'dialogs' stamp: 'nk 2/27/2005 14:11'!getClassEnvironmentFromUser	"	CategoryAndClassSelector getClassEnvironmentFromUser	"	^self new getClassEnvironmentFromUser! !!CategoryAndClassSelector class methodsFor: 'dialogs' stamp: 'nk 2/27/2005 14:09'!getSelectorEnvironmentFromUser	"	CategoryAndClassSelector getSelectorEnvironmentFromUser	"	^self new getSelectorEnvironmentFromUser! !!CategoryAndClassSelector class methodsFor: 'dialogs' stamp: 'nk 2/27/2005 15:03'!windowColorSpecification	^  WindowColorSpec classSymbol: self name  wording: 'Class chooser' brightColor: #lightGreen pastelColor: #paleGreen helpMessage: 'A dialog to select classes'! !!CategoryAndClassSelector methodsFor: 'button actions' stamp: 'nk 2/25/2005 09:11'!accept	done := true! !!CategoryAndClassSelector methodsFor: 'button actions' stamp: 'nk 2/27/2005 13:38'!cancel	self deselectAll.	done := true! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 13:45'!categoryAndClassChooserMorph	^(Morph new)		color: Color transparent;		borderWidth: 0;		layoutPolicy: ProportionalLayout new;		addMorph: self classCategoryMorph			fullFrame: (LayoutFrame fractions: (0 @ 0 extent: 0.5 @ 1));		addMorph: self classMorph			fullFrame: (LayoutFrame fractions: (0.5 @ 0 extent: 0.5 @ 1));		yourself! !!CategoryAndClassSelector methodsFor: 'menus' stamp: 'nk 3/1/2005 09:30'!classCategoryMenuFor: aMenuMorph in: aMultipleSelectionModel 	| package category |	category := aMultipleSelectionModel selectedItem ifNil: [^aMenuMorph].	aMenuMorph 		add: 'Select category'		target: self		selector: #selectCategory:		argument: category.	package := self packageForSystemCategory: category.	package ifNotNil: 			[aMenuMorph 				add: 'Select package'				target: self				selector: #selectPackage:				argument: package].	^aMenuMorph! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 13:45'!classCategoryMorph	^self listMorphFor: classCategories! !!CategoryAndClassSelector methodsFor: 'menus' stamp: 'nk 3/1/2005 09:43'!classMenuFor: aMenuMorph in: aMultipleSelectionModel 	| package class |	class := aMultipleSelectionModel selectedItem ifNil: [^aMenuMorph].	aMenuMorph 		add: 'Select category'		target: self		selector: #selectCategory:		argument: (self class environment organization categoryOfElement: class).	package := self packageForClassNamed: class.	package ifNotNil: 			[aMenuMorph 				add: 'Select package'				target: self				selector: #selectPackage:				argument: package].	^aMenuMorph! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 13:45'!classMorph	^self listMorphFor: classes! !!CategoryAndClassSelector methodsFor: 'accessing' stamp: 'nk 2/27/2005 13:36'!classesFromCategories	^classCategories trueIndexes inject: SortedCollection new into:		[:partialList :each | partialList addAll: (SystemOrganization listAtCategoryNumber: each).		partialList].! !!CategoryAndClassSelector methodsFor: 'accessing' stamp: 'nk 3/1/2005 07:41'!defaultClassCategoriesModel	^(MultipleSelectionModel withModel: self		withList: SystemOrganization categories)		menuGetter: #classCategoryMenuFor:in:;		yourself! !!CategoryAndClassSelector methodsFor: 'accessing' stamp: 'nk 3/1/2005 07:42'!defaultClassesModel	^(MultipleSelectionModel 		withModel: self		withList: #()		withMessage: #classesFromCategories)		menuGetter: #classMenuFor:in:;		yourself! !!CategoryAndClassSelector methodsFor: 'accessing' stamp: 'nk 2/27/2005 13:37'!deselectAll	classes selectNone.! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 15:02'!getClassEnvironmentFromUser	"Wait for the user to choose classes, then accept or cancel.	Answers a (possibly empty) ClassEnvironment."	| m |	m := self morphicDialog.	self runModal: ((SystemWindow labelled: 'Select classes')				model: self;				addMorph: m frame: (0 @ 0 corner: 1 @ 1);				yourself).	^self selectedClassEnvironment! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/25/2005 09:24'!getSelectorEnvironmentFromUser	^self getClassEnvironmentFromUser asSelectorEnvironment! !!CategoryAndClassSelector methodsFor: 'initialize-release' stamp: 'nk 2/27/2005 13:37'!initialize	done := false.	classCategories := self defaultClassCategoriesModel.	classCategories addDependent: self.	classes := self defaultClassesModel.	self addDependent: classes! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 13:41'!listMorphFor: aPluggableListOfManyArray 	^aPluggableListOfManyArray listMorph! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 15:49'!morphicDialog	| m |	m := AlignmentMorph newColumn.	m		extent: 400 @ 400;		borderWidth: 2;		color: Color white.	m addMorphBack: ((self categoryAndClassChooserMorph)				vResizing: #spaceFill;				hResizing: #spaceFill;				yourself).	m 		addMorphBack: (((AlignmentMorph inARow: { 						(SimpleButtonMorph newWithLabel: 'OK')							color: self defaultBackgroundColor darker;							cornerStyle: #square;							target: self;							actionSelector: #accept;							yourself.						m transparentSpacerOfSize: 40 @ 1.						(SimpleButtonMorph newWithLabel: 'Cancel')							color: self defaultBackgroundColor darker;							cornerStyle: #square;							target: self;							actionSelector: #cancel;							yourself})				hResizing: #spaceFill;				borderWidth: 0;				yourself)				listCentering: #center;				yourself).	^m! !!CategoryAndClassSelector methodsFor: 'menus' stamp: 'nk 3/1/2005 09:43'!packageForClassNamed: aClass	^PackageInfo allPackages detect: [ :p | p includesClassNamed: aClass ]		ifNone: [ ^nil ].! !!CategoryAndClassSelector methodsFor: 'menus' stamp: 'nk 3/1/2005 09:30'!packageForSystemCategory: aClassCategory	^PackageInfo allPackages detect: [ :p | p includesSystemCategory: aClassCategory ]		ifNone: [ ^nil ].! !!CategoryAndClassSelector methodsFor: 'morphic UI' stamp: 'nk 2/27/2005 14:50'!runModal: m 	done := false.	World addMorph: m centeredNear: ActiveHand position.	m openInWorld.	[done] whileFalse: [World doOneCycle].	m delete.	World doOneCycle! !!CategoryAndClassSelector methodsFor: 'menus' stamp: 'nk 3/1/2005 09:50'!selectCategory: cat 	| classList |	classCategories listSelectionAt: (classCategories list indexOf: cat asString) put: true.	classList := classes list.	(SystemOrganization listAtCategoryNamed: cat) do: [ :clsName |		classes listSelectionAt: (classList indexOf: clsName asString) put: true	].! !!CategoryAndClassSelector methodsFor: 'menus' stamp: 'nk 3/1/2005 09:50'!selectPackage: aPackage 	classCategories list withIndexDo: 			[:catName :i | 			(aPackage includesSystemCategory: catName) 				ifTrue: 					[ self selectCategory: catName]]! !!CategoryAndClassSelector methodsFor: 'accessing' stamp: 'nk 2/27/2005 13:37'!selectedClassEnvironment	| cls |	^ClassEnvironment new		classes: (Array streamContents: [ :s |			classes selectedItems do: [:clsName |				cls := Smalltalk at: clsName.				s nextPut: cls; nextPut: cls class ]]);		yourself! !!CategoryAndClassSelector methodsFor: 'updating' stamp: 'nk 2/27/2005 14:18'!update: aSelector	self changed: #classesFromCategories! !!ClassToRename methodsFor: 'performing'!method1	^self method2! !!ClassToRename methodsFor: 'performing'!method2	^self method1! !!SubclassOfClassToRename methodsFor: 'accessing'!calls	^self rewriteRule1: self name , self rewriteRule1! !!SubclassOfClassToRename methodsFor: 'accessing'!calls1	^self rewriteRule1: (self rewriteRule1: self calls)! !!SubclassOfClassToRename methodsFor: 'accessing'!name	^rewriteRule1! !!SubclassOfClassToRename methodsFor: 'performing'!reference	^ClassToRename new! !!SubclassOfClassToRename methodsFor: 'accessing'!rewriteRule1	^rewriteRule1! !!SubclassOfClassToRename methodsFor: 'accessing'!rewriteRule1: anObject	^rewriteRule1 := anObject! !!SubclassOfClassToRename methodsFor: 'performing'!symbolReference	^#ClassToRename! !!LintDialog class methodsFor: 'class initialization' stamp: 'nk 2/26/2005 10:13'!initialize	"self initialize"	TheWorldMenu registerOpenCommand: {'Lint'. {self. #open}}.	self registerInFlapsRegistry.! !!LintDialog class methodsFor: 'instance creation' stamp: 'nk 3/4/2005 11:10'!onEnvironment: anEnvironment	self new environment: anEnvironment; open! !!LintDialog class methodsFor: 'instance creation' stamp: 'nk 2/26/2005 10:14'!open	^self new open! !!LintDialog class methodsFor: 'instance creation' stamp: 'nk 2/26/2005 10:14'!prototypicalToolWindow	"Answer an example of myself seen in a tool window, for the benefit of parts-launching tools"	^self new lintWindow! !!LintDialog class methodsFor: 'class initialization' stamp: 'nk 2/26/2005 10:10'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(#LintDialog #prototypicalToolWindow 'SmallLint' 'A tool to check for bugs in code' ) 						forFlapNamed: 'Tools']! !!LintDialog class methodsFor: 'instance creation' stamp: 'nk 2/27/2005 13:19'!runOnEnvironment: anEnvironment	self new open; runOnEnvironment: anEnvironment! !!LintDialog class methodsFor: 'class initialization' stamp: 'nk 2/26/2005 10:13'!unload	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self].	TheWorldMenu unregisterOpenCommandWithReceiver: self.! !!LintDialog class methodsFor: 'window color' stamp: 'nk 2/27/2005 15:00'!windowColorSpecification	"Answer a WindowColorSpec object that declares my preference"	^ WindowColorSpec classSymbol: self name  wording: 'Lint' brightColor: #lightGreen pastelColor: #paleGreen helpMessage: 'A tool for finding bugs in your code'! !!LintDialog methodsFor: 'actions' stamp: 'nk 3/4/2005 11:06'!canRun	^tests anySelected 		and: [self environment notNil and: [self environment isEmpty not]]! !!LintDialog methodsFor: 'displaying' stamp: 'nk 2/27/2005 15:44'!canSelectClasses	^true! !!LintDialog methodsFor: 'initialize-release' stamp: 'nk 2/27/2005 15:32'!defaultTestsCategoriesModel	^ MultipleSelectionModel withModel: self withList: self determineTestCategories! !!LintDialog methodsFor: 'initialize-release' stamp: 'nk 2/27/2005 15:23'!defaultTestsModel	^(MultipleSelectionModel 		withModel: self 		withList: #()		withMessage: #testsFromCategories)		menuGetter: #listMenuFor:in:;		yourself! !!LintDialog methodsFor: 'initialize-release' stamp: 'nk 3/4/2005 13:38'!determineTestCategories	| taskCategories |	taskCategories := (self determineTestCategoriesForClass: BlockLintRule),		(self determineTestCategoriesForClass: ParseTreeLintRule).	taskCategories removeAllFoundIn: #(#'instance creation' #private #accessing).		^taskCategories asArray! !!LintDialog methodsFor: 'initialize-release' stamp: 'nk 2/25/2005 08:46'!determineTestCategoriesForClass: aClass 	^ aClass withAllSubclasses		inject: Set new		into: [:sum :each | sum addAll: each class organization categories;				 yourself]! !!LintDialog methodsFor: 'accessing' stamp: 'nk 3/4/2005 11:05'!environment	^environment! !!LintDialog methodsFor: 'accessing' stamp: 'nk 3/4/2005 11:10'!environment: anObject	environment := anObject.	results := #().	self changed: #canRun.! !!LintDialog methodsFor: 'initialize-release' stamp: 'nk 2/27/2005 15:32'!initialize	super initialize.	tests := self defaultTestsModel.	tests addDependent: self.	testCategories := self defaultTestsCategoriesModel.	testCategories addDependent: self.	testCategories addDependent: tests.! !!LintDialog methodsFor: 'displaying' stamp: 'nk 3/4/2005 12:10'!labelString	| theLabel |	theLabel := self environment printStringLimitedTo: 60.	^theLabel isEmpty ifFalse: [ 'SmallLint on ', theLabel ] ifTrue: ['SmallLint'].! !!LintDialog methodsFor: 'displaying' stamp: 'nk 3/4/2005 12:09'!lintWindow	^(SystemWindow labelled: self labelString)		model: self;		addMorph: testCategories listMorph frame: (0.0 @ 0.0 extent: 1 @ 0.3);		addMorph: tests listMorph			fullFrame: (LayoutFrame fractions: (0.0 @ 0.3 extent: 1 @ 0.7)					offsets: (0 @ 0 corner: 0 @ -40));		addMorph: self selectClassesButton			fullFrame: (LayoutFrame fractions: (0 @ 1 corner: 0.5 @ 1)					offsets: (10 @ -35 corner: -10 @ -5));		addMorph: self runButton			fullFrame: (LayoutFrame fractions: (0.5 @ 1 corner: 1 @ 1)					offsets: (10 @ -35 corner: -10 @ -5));		yourself! !!LintDialog methodsFor: 'menus' stamp: 'nk 2/25/2005 12:02'!listMenuFor: aMenu in: aMultipleSelectionModel 	aMenu add: 'View rationale for selected rules'		target: self		selector: #viewRationaleForSelectionsIn:		argument: aMultipleSelectionModel.! !!LintDialog methodsFor: 'displaying' stamp: 'nk 3/4/2005 11:09'!makeResultDialogOn: aNumber	| env |	aNumber = 0 ifTrue: [^self].	env := (results at: aNumber) result.	env openEditor.! !!LintDialog methodsFor: 'displaying' stamp: 'nk 2/27/2005 15:45'!open	| w |	w := self lintWindow openInWorld; yourself.	self changed: #canRun.	self changed: #canSelectClasses.	^w! !!LintDialog methodsFor: 'accessing' stamp: 'nk 2/25/2005 08:46'!resultsAsText	^results collect:[:each| each asString , ' [' , each result problemCount asString , ']']! !!LintDialog methodsFor: 'displaying' stamp: 'nk 3/4/2005 14:38'!resultsDialog	| theLabel |	theLabel := self labelString copyReplaceAll: 'SmallLint on' with: 'SmallLint Results for'.	^(SystemWindow labelled: theLabel)		model: self;		addMorph: (self resultsListMorph) frame:(0@0 extent: 1@1);		openInWorld;		yourself! !!LintDialog methodsFor: 'actions' stamp: 'nk 2/27/2005 13:14'!resultsForEnvironment: anEnvironment 	| allResults progress addAmount |	progress := ProgressMorph label: 'SLint progress'.	progress openInWorld.	addAmount := 1.0 / tests selectedItems size.	allResults := tests selectedItems				collect: [:each | 					progress subLabel: each name.					progress incrDone: addAmount.					SmalllintChecker runRule: each onEnvironment: anEnvironment].	progress delete.	^ allResults		select: [:each | each result problemCount > 0]! !!LintDialog methodsFor: 'displaying' stamp: 'nk 2/27/2005 14:24'!resultsListMorph	| list |	list := PluggableListMorph 				on: self				list: #resultsAsText				selected: #returnZero				changeSelected: #makeResultDialogOn:.	^list! !!LintDialog methodsFor: 'accessing' stamp: 'nk 2/25/2005 08:47'!returnZero	^0! !!LintDialog methodsFor: 'actions' stamp: 'nk 3/4/2005 11:06'!run	self canRun ifFalse: [^self].	Cursor wait 		showWhile: [results := self resultsForEnvironment: self environment].	self resultsDialog! !!LintDialog methodsFor: 'displaying' stamp: 'nk 2/27/2005 15:45'!runButton	| button |	button := PluggableButtonMorph 				on: self				getState: #canRun				action: #run.	button		label: 'Run';		onColor: self defaultBackgroundColor lighter		offColor: self defaultBackgroundColor muchDarker;		hResizing: #shrinkWrap.	self addDependent: button.	^button! !!LintDialog methodsFor: 'actions' stamp: 'nk 3/4/2005 11:07'!runOnEnvironment: anEnvironment	self environment: anEnvironment.	results := #().	tests anySelected		ifFalse: [^ self].	anEnvironment isEmpty		ifTrue: [^ self].	Cursor wait		showWhile: [results := self resultsForEnvironment: anEnvironment].	self resultsDialog! !!LintDialog methodsFor: 'actions' stamp: 'nk 3/4/2005 11:06'!selectClasses	selector ifNil: [selector := CategoryAndClassSelector new].	self environment: selector getClassEnvironmentFromUser.	self changed: #canRun! !!LintDialog methodsFor: 'displaying' stamp: 'nk 2/27/2005 15:45'!selectClassesButton	| button |	button := PluggableButtonMorph 				on: self				getState: #canSelectClasses				action: #selectClasses.	button		label: 'Select Classes';		onColor: self defaultBackgroundColor lighter		offColor: self defaultBackgroundColor muchDarker;		hResizing: #shrinkWrap.	^button! !!LintDialog methodsFor: 'accessing' stamp: 'nk 2/25/2005 08:45'!testsFromCategories	^testCategories selectedItems inject: Array new into:		[:partialList :each | (self testsFromCategory: each) , partialList].! !!LintDialog methodsFor: 'accessing' stamp: 'nk 2/25/2005 08:47'!testsFromCategory: aCategory 	^ (self testsFromCategory: aCategory inClassAndSubclasses: BlockLintRule)		, (self testsFromCategory: aCategory inClassAndSubclasses: ParseTreeLintRule)! !!LintDialog methodsFor: 'accessing' stamp: 'nk 2/25/2005 08:47'!testsFromCategory: aSymbol inClass: aClass	| classTests |	classTests := aClass class organization listAtCategoryNamed: aSymbol.	^classTests collect:[: each | aClass perform: each].! !!LintDialog methodsFor: 'accessing' stamp: 'nk 2/25/2005 08:47'!testsFromCategory: aSymbol inClassAndSubclasses: aClass 	| classAndSubclassesTests |	classAndSubclassesTests := (self testsFromCategory: aSymbol inClass: aClass) asOrderedCollection.	aClass allSubclasses		do: [:each | classAndSubclassesTests				addAll: (self testsFromCategory: aSymbol inClass: each)].	^ classAndSubclassesTests! !!LintDialog methodsFor: 'updating' stamp: 'nk 2/27/2005 15:29'!update: aSymbol	aSymbol == #allSelections ifTrue: [		self changed: #canRun.	]! !!LintDialog methodsFor: 'menus' stamp: 'nk 2/25/2005 12:02'!viewRationaleForSelectionsIn: aMultipleSelectionModel	| rationale |	rationale := String streamContents: [ :strm |		aMultipleSelectionModel selectedItems do: [ :rule | | str |			str := rule rationale.			str isEmpty ifFalse: [ strm nextPutAll: rule name; cr; nextPutAll: str; cr; cr ]]].	(StringHolder new contents: rationale)		openLabel: 'Rationale for selected rules'! !!MethodNameEditor class methodsFor: 'examples' stamp: 'mga 8/27/2001 01:36'!example	self new		argumentList: #('1' '2');		argumentListIndex: 1;		openAsMorph! !!MethodNameEditor class methodsFor: 'instance creation' stamp: 'dvf 9/1/2001 18:51'!for: aMethodName 	| editor newMethodName |	newMethodName := aMethodName deepCopy.	newMethodName arguments 		ifNil: [newMethodName arguments: OrderedCollection new].	newMethodName selector		ifNil: [newMethodName selector: String new].	editor := self new.	editor for: newMethodName.	^editor! !!MethodNameEditor class methodsFor: 'instance creation' stamp: 'mga 8/27/2001 17:23'!forMethodName: aMethodName	^self modalEditorForMethodName: aMethodName ! !!MethodNameEditor class methodsFor: '-- all --' stamp: 'dvf 9/1/2001 20:43'!modalEditorForMethodName: aMethodName 	| editor window |	editor := self for: aMethodName.	window := editor openAsMorph.	editor modalView: window.	[window world notNil] 		whileTrue: [window outermostWorldMorph doOneCycleNow].	^editor accepted ifFalse: [nil] ifTrue: [(window valueOfProperty: #methodNameEditorModel) methodName]! !!MethodNameEditor methodsFor: 'accessing' stamp: 'dvf 9/1/2001 20:44'!accepted	^accepted! !!MethodNameEditor methodsFor: 'accessing' stamp: 'vd 5/19/2004 18:08'!accepted: anObject	bodyPane accept.		accepted := anObject! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:51'!addArgumentListTo: window 	| anArgumentListMorph |	(anArgumentListMorph := PluggableListMorph new) 		on: self		list: #argumentList		selected: #argumentListIndex		changeSelected: #argumentListIndex:		menu: nil		keystroke: nil.	window addMorph: anArgumentListMorph frame: (0 @ 0.1 corner: 0.9 @ 0.7)! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:53'!addCancelButtonTo: window 	window addMorph: ((PluggableButtonMorph 				on: self				getState: nil				action: #cancel)				label: 'cancel';				onColor: Color white offColor: Color white)		frame: (0.5 @ 0.8 corner: 1 @ 1)! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:52'!addDownButtonTo: window 	window addMorph: ((PluggableButtonMorph 				on: self				getState: #downActivated				action: #down)				label: 'down';				setBalloonText: 'move argument down';				onColor: Color white offColor: Color lightGray)		frame: (0.9 @ 0.4 corner: 1 @ 0.7)! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:52'!addOkButtonTo: window 	window addMorph: ((PluggableButtonMorph 				on: self				getState: #okEnabled				action: #ok)				label: 'ok';				setBalloonText: 'accept selector as shown in the preview';				onColor: Color white offColor: Color lightGray)		frame: (0 @ 0.8 corner: 0.5 @ 1)! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:52'!addPreviewPaneTo: window 	| methodPreview |	methodPreview := PluggableTextMorph 				on: self				text: #methodPreview				accept: nil				readSelection: nil				menu: nil.	window addMorph: methodPreview frame: (0 @ 0.7 corner: 1.0 @ 0.8)! !!MethodNameEditor methodsFor: 'action' stamp: 'vd 5/19/2004 18:07'!addSelectorPaneTo: window 		bodyPane := PluggableTextMorph 				on: self				text: #selector				accept: #selector:				readSelection: nil				menu: nil.	bodyPane acceptOnCR: true.	window addMorph: bodyPane frame: (0 @ 0 corner: 1.0 @ 0.1)! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:52'!addUpButtonTo: window 	window addMorph: ((PluggableButtonMorph 				on: self				getState: #upActivated				action: #up)				label: 'up';				setBalloonText: 'move argument up';				onColor: Color white offColor: Color lightGray)		frame: (0.9 @ 0.1 corner: 1 @ 0.4)! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 02:40'!argumentList	^ methodName arguments! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 02:35'!argumentList: aCollection	methodName argumentList: aCollection! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'mga 8/27/2001 00:57'!argumentListIndex	^argumentListIndex! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 13:21'!argumentListIndex: anInteger	argumentListIndex := anInteger.	self selectionChanged.! !!MethodNameEditor methodsFor: 'accessing' stamp: 'dvf 9/1/2001 02:34'!arguments	^methodName arguments! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/1/2001 20:44'!cancel	self modalView delete.! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 20:02'!down	self downActivated ifFalse: [^self].	self argumentList swap: argumentListIndex with: argumentListIndex + 1.	self argumentListIndex: self argumentListIndex + 1.	self selectionChanged! !!MethodNameEditor methodsFor: 'testing' stamp: 'dvf 9/1/2001 20:10'!downActivated	| newIndex |	newIndex := argumentListIndex + 1.	^newIndex between: 1 and: self arguments size! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 02:32'!for: aMethodName 	self methodName: aMethodName! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 20:41'!initialize	argumentListIndex := 1.	accepted := false! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'mga 8/27/2001 01:12'!methodName	^methodName! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'mga 8/27/2001 01:12'!methodName: aSelector	methodName := aSelector! !!MethodNameEditor methodsFor: 'accessing' stamp: 'dvf 9/1/2001 20:46'!methodPreview	| stream |	stream := String new writeStream.	self selector numArgs > 0 		ifTrue: 			[self selector keywords with: self argumentList				do: 					[:keyword :arg | 					stream						nextPutAll: keyword;						nextPut: $ ;						nextPutAll: arg;						nextPut: $ ]]		ifFalse: [stream nextPutAll: self selector].	^stream contents! !!MethodNameEditor methodsFor: 'accessing' stamp: 'dvf 9/29/2001 14:52'!modalView	^modalView! !!MethodNameEditor methodsFor: 'accessing' stamp: 'mga 8/27/2001 15:20'!modalView: aSystemWindow	modalView := aSystemWindow	! !!MethodNameEditor methodsFor: 'action' stamp: 'vd 5/19/2004 18:07'!ok	self okEnabled 		ifFalse: 			[self modalView flash.			^self].	self accepted: true.	self modalView delete! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/1/2001 20:04'!okEnabled	^self selector isEmpty not and: [self methodName isValid]! !!MethodNameEditor methodsFor: 'action' stamp: 'dvf 9/30/2001 01:53'!openAsMorph	"self new openAsMorph"	| window |	window := (SystemWindow labelled: 'Selector editor') model: self.	self addSelectorPaneTo: window.	self addArgumentListTo: window.	self addUpButtonTo: window.	self addDownButtonTo: window.	self addPreviewPaneTo: window.	self addOkButtonTo: window.	self addCancelButtonTo: window.	window		center: Display center;		extent: 100 @ 100.	self selectionChanged.	window openInWorld.	window setProperty: #methodNameEditorModel toValue: self.	^window! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'mga 8/27/2001 11:08'!selectionChanged	self 		changed: #argumentListIndex;		changed: #argumentList;		changed: #upActivated;		changed: #downActivated;		changed: #methodPreview	! !!MethodNameEditor methodsFor: 'accessing' stamp: 'dvf 9/1/2001 02:36'!selector	^methodName selector! !!MethodNameEditor methodsFor: 'accessing' stamp: 'dvf 9/1/2001 14:14'!selector: aString 	methodName selector: aString asString.	self changed: #selector.	self changed: #methodPreview.	^true.! !!MethodNameEditor methodsFor: 'as yet unclassified' stamp: 'dvf 9/1/2001 20:00'!up	self upActivated ifFalse: [^self].	self argumentList swap: argumentListIndex with: argumentListIndex - 1.	self argumentListIndex: self argumentListIndex - 1.	self selectionChanged! !!MethodNameEditor methodsFor: 'testing' stamp: 'dvf 9/1/2001 20:09'!upActivated	| newIndex |	newIndex := argumentListIndex - 1.	^newIndex between: 1 and: self arguments size! !!MultipleSelectionModel class methodsFor: '*RefactoringEngine' stamp: 'nk 2/27/2005 14:03'!withModel: aModel withList: aList	^self withModel: aModel withList: aList withMessage: nil! !!MultipleSelectionModel class methodsFor: '*RefactoringEngine' stamp: 'nk 2/27/2005 14:02'!withModel: aModel  withList: aList  withMessage: aSelector 	^super new 		model: aModel		list: aList		message: aSelector		selection: Dictionary new! !!MultipleSelectionModel methodsFor: 'selections' stamp: 'MPH 10/18/2000 18:34'!anySelected	^selection includes:true.! !!MultipleSelectionModel methodsFor: 'accessing' stamp: 'MPH 10/18/2000 17:03'!list	^list collect:[:each| each asString]! !!MultipleSelectionModel methodsFor: 'user interface' stamp: 'nk 3/1/2005 09:13'!listMorph	| m |	m := PluggableListMorphOfMany				on: self				list: #list				primarySelection: #primarySelection				changePrimarySelection: #primarySelection:				listSelection: #listSelectionAt:				changeListSelection: #listSelectionAt:put:				menu: #menu:.	m color: Color transparent; borderWidth: 0.	^ m! !!MultipleSelectionModel methodsFor: 'accessing' stamp: 'MPH 10/18/2000 16:12'!listSelectionAt: anIndex	^selection at: anIndex ifAbsent:[^false]! !!MultipleSelectionModel methodsFor: 'accessing' stamp: 'ls 11/8/2003 16:20'!listSelectionAt: anIndex put: aValue 	selection at: anIndex put: aValue.	self selectionsChanged! !!MultipleSelectionModel methodsFor: 'menus' stamp: 'nk 2/27/2005 14:05'!menu: aMenu 	aMenu		add: 'Select All' action: #selectAll;		add: 'Select None' action: #selectNone.	getMenu ifNotNil: 			[model perform: getMenu				withArguments: { 						aMenu.						self}].	^aMenu! !!MultipleSelectionModel methodsFor: 'menus' stamp: 'nk 2/27/2005 14:05'!menuGetter: aSelector	getMenu := aSelector! !!MultipleSelectionModel methodsFor: 'initialization' stamp: 'nk 3/1/2005 09:14'!model: aModel list: aList message: aSelector selection: anArray 	model := aModel.	list := aList.	getList := aSelector.	selection := anArray.	primary := 0! !!MultipleSelectionModel methodsFor: 'menus' stamp: 'nk 2/27/2005 14:06'!perform: selector orSendTo: otherTarget	^(self respondsTo: selector)		ifTrue: [ self perform: selector]		ifFalse: [ otherTarget perform: selector]! !!MultipleSelectionModel methodsFor: 'accessing' stamp: 'nk 3/1/2005 09:13'!primarySelection	^primary! !!MultipleSelectionModel methodsFor: 'accessing' stamp: 'nk 3/1/2005 09:13'!primarySelection: aNumber	primary := aNumber! !!MultipleSelectionModel methodsFor: 'updating' stamp: 'nk 2/27/2005 14:15'!refreshList	| newList oldSelection newSelection index |	newSelection := Dictionary new.	(model notNil and: [getList notNil]) 		ifTrue: 			[newList := model perform: getList.			oldSelection := self selectedItems collect: [:each | each asString].			index := 0.			(newList collect: [:each | each asString]) do: 					[:each | 					index := index + 1.					(oldSelection includes: each) ifTrue: [newSelection at: index put: true]].			list := newList.			self changed: #list].	selection := newSelection.	self selectionsChanged! !!MultipleSelectionModel methodsFor: 'selections' stamp: 'MPH 10/22/2000 22:31'!selectAll	1 to: list size do:[:each | selection at: each put: true].	self changed: #allSelections.! !!MultipleSelectionModel methodsFor: 'selections' stamp: 'MPH 10/22/2000 22:30'!selectNone	selection := Dictionary new.	self changed: #allSelections.! !!MultipleSelectionModel methodsFor: 'selections' stamp: 'nk 3/1/2005 09:21'!selectedItem	primary isZero ifTrue: [ ^nil ].	^list at: primary.! !!MultipleSelectionModel methodsFor: 'selections' stamp: 'MPH 10/19/2000 11:43'!selectedItems	| index |	index := 0.	^list select:		[:each | index := index + 1.		 self listSelectionAt: index]! !!MultipleSelectionModel methodsFor: 'selections' stamp: 'ls 11/8/2003 16:20'!selectionsChanged	self changed: #allSelections.! !!MultipleSelectionModel methodsFor: 'accessing' stamp: 'MPH 10/18/2000 16:57'!trueIndexes	| indexList |	indexList := Set new.	selection keysAndValuesDo:[:eachKey :eachValue | eachValue ifTrue: [indexList add: eachKey]].	^indexList! !!MultipleSelectionModel methodsFor: 'updating' stamp: 'nk 2/27/2005 15:31'!update: aSelector 	self refreshList! !!ClassTrait methodsFor: '*refactoringEngine' stamp: 'md 3/14/2006 16:45'!includesBehavior: aClass	^false! !!ClassTrait methodsFor: '*refactoringEngine' stamp: 'md 3/14/2006 16:37'!soleInstance	^baseTrait! !!BrowserEnvironment methodsFor: 'environments'!& anEnvironment 	"If we or anEnvironment includes everything, then just include the other environment (optimization)"	self isSystem ifTrue: [^anEnvironment].	anEnvironment isSystem ifTrue: [^self].	^AndEnvironment onEnvironment: self and: anEnvironment! !!BrowserEnvironment methodsFor: 'accessing'!addSearchString: aString 	searchStrings isNil ifTrue: 			[searchStrings := SortedCollection sortBlock: 							[:a :b | 							(a indexOf: $: ifAbsent: [a size]) > (b indexOf: $: ifAbsent: [b size])]].	searchStrings add: aString! !!BrowserEnvironment methodsFor: 'private' stamp: 'nk 8/8/2003 09:07'!allClassesDo: aBlock 	self systemNavigation allBehaviorsDo: aBlock! !!BrowserEnvironment methodsFor: 'accessing' stamp: 'nk 3/4/2005 12:41'!asSelectorEnvironment	^(ClassEnvironment onEnvironment: self classes: self classes) asSelectorEnvironment! !!BrowserEnvironment methodsFor: 'accessing-classes' stamp: 'dvf 10/9/2001 16:14'!associationAt: aKey	| association class |	association := Smalltalk associationAt: aKey ifAbsent: [^nil].	class := association value isBehavior				ifTrue: [association value]				ifFalse: [association value class].	^((self includesClass: class) or: [self includesClass: class class])		ifTrue: [association]		ifFalse: [nil]! !!BrowserEnvironment methodsFor: 'accessing-classes' stamp: 'md 8/2/2005 23:26'!at: aKey	^self at: aKey ifAbsent: [self error:'key ',aKey printString,' was not found'.]! !!BrowserEnvironment methodsFor: 'accessing-classes'!at: aKey ifAbsent: aBlock	| assoc |	assoc := self associationAt: aKey.	^assoc isNil		ifTrue: [aBlock value]		ifFalse: [assoc value]! !!BrowserEnvironment methodsFor: 'accessing'!categories	^Smalltalk organization categories select: [:each | self includesCategory: each]! !!BrowserEnvironment methodsFor: 'accessing-classes'!classNames	| names |	names := Set new.	self classesDo: 			[:each | 			names add: (each isMeta ifTrue: [each soleInstance] ifFalse: [each]) name].	^names! !!BrowserEnvironment methodsFor: 'accessing'!classNamesFor: aCategoryName	^(Smalltalk organization listAtCategoryNamed: aCategoryName)		select:			[:each |			| class |			class := Smalltalk at: each ifAbsent: [nil].			class notNil and: [(self includesClass: class)					or: [self includesClass: class class]]]! !!BrowserEnvironment methodsFor: 'accessing'!classVariablesFor: aClass 	^aClass classVarNames! !!BrowserEnvironment methodsFor: 'accessing-classes'!classes	| classes |	classes := Set new.	self classesDo: [:each | classes add: each].	^classes! !!BrowserEnvironment methodsFor: 'accessing'!classesAndSelectorsDo: aBlock 	self classesDo: 			[:class | 			self selectorsForClass: class do: [:sel | aBlock value: class value: sel]]! !!BrowserEnvironment methodsFor: 'accessing-classes' stamp: 'md 2/26/2006 15:11'!classesDo: aBlock 	self allClassesDo: [:each | (self includesClass: each) ifTrue: [aBlock value: each]]! !!BrowserEnvironment methodsFor: 'copying' stamp: 'bh 3/16/2000 23:24'!copy	^self shallowCopy postCopy! !!BrowserEnvironment methodsFor: 'copying'!copyEmpty	^self class new! !!BrowserEnvironment methodsFor: 'private'!defaultLabel	^'Smalltalk'! !!BrowserEnvironment methodsFor: 'testing'!definesClass: aClass	^true! !!BrowserEnvironment methodsFor: 'environments'!forCategories: categoryList 	^CategoryEnvironment onEnvironment: self categories: categoryList! !!BrowserEnvironment methodsFor: 'environments'!forClass: aClass protocols: protocolCollection 	^ProtocolEnvironment onEnvironment: self		class: aClass		protocols: protocolCollection! !!BrowserEnvironment methodsFor: 'environments'!forClass: aClass selectors: selectorCollection 	^(SelectorEnvironment 		onMethods: selectorCollection		forClass: aClass		in: self)		label: aClass name , '>>' 					, (selectorCollection detect: [:each | true] ifNone: ['']);		yourself! !!BrowserEnvironment methodsFor: 'environments'!forClasses: classCollection 	| classes |	classes := OrderedCollection new: classCollection size * 2.	classCollection do: 			[:each | 			classes add: each;				add: each class].	^ClassEnvironment onEnvironment: self classes: classes! !!BrowserEnvironment methodsFor: 'environments' stamp: 'lr 1/3/2006 12:14'!forPackage: aPackageInfo	^ PackageEnvironment onEnvironment: self package: aPackageInfo.! !!BrowserEnvironment methodsFor: 'environments' stamp: 'lr 1/3/2006 12:14'!forPackageContainingClassCategory: aClassCategory	| package |	package := PackageInfo allPackages 		detect: [ :each | each includesSystemCategory: aClassCategory ]		ifNone: [ self inform: 'no package for this category'. ^nil ].	^ self forPackage: package.! !!BrowserEnvironment methodsFor: 'environments' stamp: 'lr 1/3/2006 12:14'!forPackageNamed: aString	^ PackageEnvironment onEnvironment: self packageNamed: aString.! !!BrowserEnvironment methodsFor: 'environments'!implementorsMatching: aString 	^SelectorEnvironment implementorsMatching: aString in: self! !!BrowserEnvironment methodsFor: 'environments'!implementorsOf: aSelector 	^SelectorEnvironment implementorsOf: aSelector in: self! !!BrowserEnvironment methodsFor: 'testing'!includesCategory: aCategory	^true! !!BrowserEnvironment methodsFor: 'testing'!includesClass: aClass	^true! !!BrowserEnvironment methodsFor: 'testing'!includesProtocol: aProtocol in: aClass	^true! !!BrowserEnvironment methodsFor: 'testing'!includesSelector: aSelector in: aClass	^true! !!BrowserEnvironment methodsFor: 'initialize-release'!initialize! !!BrowserEnvironment methodsFor: 'environments'!instVarReadersTo: instVarName in: aClass 	^VariableEnvironment 		on: self		readersOfInstanceVariable: instVarName		in: aClass! !!BrowserEnvironment methodsFor: 'environments'!instVarRefsTo: instVarName in: aClass 	^VariableEnvironment 		on: self		referencesToInstanceVariable: instVarName		in: aClass! !!BrowserEnvironment methodsFor: 'environments'!instVarWritersTo: instVarName in: aClass 	^VariableEnvironment 		on: self		writersOfInstanceVariable: instVarName		in: aClass! !!BrowserEnvironment methodsFor: 'accessing'!instanceVariablesFor: aClass 	^aClass instVarNames! !!BrowserEnvironment methodsFor: 'testing'!isClassEnvironment	^false! !!BrowserEnvironment methodsFor: 'testing'!isEmpty	^false! !!BrowserEnvironment methodsFor: 'testing'!isSelector	^false! !!BrowserEnvironment methodsFor: 'testing'!isSystem	^true! !!BrowserEnvironment methodsFor: 'accessing-classes'!keys	| keys |	keys := Set new.	Smalltalk keysAndValuesDo: 			[:key :value | 			| class |			value isBehavior 				ifTrue: [(self includesClass: value) ifTrue: [keys add: key]].			class := value class.			(self includesClass: class) ifTrue: [keys add: key]].	^keys! !!BrowserEnvironment methodsFor: 'private'!label	^label isNil		ifTrue: [self defaultLabel]		ifFalse: [label]! !!BrowserEnvironment methodsFor: 'initialize-release'!label: aString	label := aString! !!BrowserEnvironment methodsFor: 'environments'!matches: aString 	^SelectorEnvironment matches: aString in: self! !!BrowserEnvironment methodsFor: 'environments'!not	self isSystem ifTrue: [^SelectorEnvironment new].	^NotEnvironment onEnvironment: self! !!BrowserEnvironment methodsFor: 'accessing'!numberClasses	^self classNames size! !!BrowserEnvironment methodsFor: 'accessing'!numberSelectors	| total |	total := 0.	self 		allClassesDo: [:each | self selectorsForClass: each do: [:sel | total := total + 1]].	^total! !!BrowserEnvironment methodsFor: 'SqueakRB-UserInterface' stamp: 'nk 3/4/2005 12:41'!openEditor	^self asSelectorEnvironment openEditor! !!BrowserEnvironment methodsFor: 'copying' stamp: 'dvf 9/12/2003 13:21'!postCopy	^self! !!BrowserEnvironment methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self label! !!BrowserEnvironment methodsFor: 'accessing'!problemCount	^self numberSelectors! !!BrowserEnvironment methodsFor: 'accessing'!protocolsFor: aClass	^aClass organization categories select: [:each | self includesProtocol: each in: aClass]! !!BrowserEnvironment methodsFor: 'environments'!referencesTo: aLiteral 	^SelectorEnvironment referencesTo: aLiteral in: self! !!BrowserEnvironment methodsFor: 'environments'!referencesTo: aLiteral in: aClass 	| classes |	classes := aClass withAllSuperclasses asSet.	classes		addAll: aClass allSubclasses;		addAll: aClass class withAllSuperclasses;		addAll: aClass class allSubclasses.	^(self forClasses: classes) referencesTo: aLiteral! !!BrowserEnvironment methodsFor: 'accessing'!searchStrings	^searchStrings isNil		ifTrue: [#()]		ifFalse: [searchStrings]! !!BrowserEnvironment methodsFor: 'accessing'!searchStrings: aCollection 	searchStrings := aCollection! !!BrowserEnvironment methodsFor: 'environments'!selectMethods: aBlock 	| env |	env := SelectorEnvironment onEnvironment: self.	self classesAndSelectorsDo: 			[:each :sel | 			(aBlock value: (each compiledMethodAt: sel)) 				ifTrue: [env addClass: each selector: sel]].	^env! !!BrowserEnvironment methodsFor: 'accessing' stamp: 'bh 5/8/2000 21:02'!selectionIntervalFor: aString 	| interval |	self searchStrings isEmpty ifTrue: [^nil].	interval := self selectionParseTreeIntervalFor: aString.	interval notNil ifTrue: [^interval].	self searchStrings do: 			[:each | 			| search index |			search := each isSymbol ifTrue: [each keywords first] ifFalse: [each].			index := aString indexOfSubCollection: search startingAt: 1.			index > 0 ifTrue: [^index to: index + search size - 1]].	^nil! !!BrowserEnvironment methodsFor: 'accessing' stamp: 'bh 5/8/2000 21:03'!selectionParseTreeIntervalFor: aString 	| parseTree answerBlock |	parseTree := RBParser parseMethod: aString onError: [:str :pos | ^nil].	answerBlock := [:aNode :answer | ^aNode sourceInterval].	self searchStrings do: 			[:each | 			| matcher tree |			matcher := ParseTreeSearcher new.			each isSymbol 				ifTrue: 					[matcher matchesTree: (RBLiteralNode value: each) do: answerBlock.					tree := ParseTreeSearcher buildSelectorTree: each.					tree notNil ifTrue: [matcher matchesTree: tree do: answerBlock]]				ifFalse: 					[tree := RBVariableNode named: each.					matcher						matchesTree: tree do: answerBlock;						matchesArgumentTree: tree do: answerBlock].			matcher executeTree: parseTree].	^nil! !!BrowserEnvironment methodsFor: 'accessing'!selectorsFor: aProtocol in: aClass	^(aClass organization listAtCategoryNamed: aProtocol)		select: [:each | self includesSelector: each in: aClass]! !!BrowserEnvironment methodsFor: 'accessing'!selectorsForClass: aClass 	| selectors |	selectors := Set new: 50.	self selectorsForClass: aClass do: [:each | selectors add: each].	^selectors! !!BrowserEnvironment methodsFor: 'accessing'!selectorsForClass: aClass do: aBlock 	aClass selectorsAndMethodsDo: 			[:each :meth | 			(self includesSelector: each in: aClass) ifTrue: [aBlock value: each]]! !!BrowserEnvironment methodsFor: 'printing'!storeOn: aStream 	aStream		nextPutAll: self class name;		nextPutAll: ' new'! !!BrowserEnvironment methodsFor: 'accessing'!whichCategoryIncludes: aClassName	^Smalltalk organization categoryOfElement: aClassName! !!BrowserEnvironment methodsFor: 'accessing'!whichProtocolIncludes: aSelector in: aClass	^aClass organization categoryOfElement: aSelector! !!BrowserEnvironment methodsFor: 'environments'!| anEnvironment 	"If we or anEnvironment includes everything, then return it instead of creating 	an or that will include everything."	self isSystem ifTrue: [^self].	anEnvironment isSystem ifTrue: [^anEnvironment].	^(self not & anEnvironment not) not! !!AndEnvironment class methodsFor: 'instance creation'!onEnvironment: anEnvironment and: anotherEnvironment 	^(self onEnvironment: anEnvironment)		andedEnvironment: anotherEnvironment;		yourself! !!AndEnvironment methodsFor: 'private'!andedEnvironment	^andedEnvironment! !!AndEnvironment methodsFor: 'initialize-release'!andedEnvironment: aBrowserEnvironment 	andedEnvironment := aBrowserEnvironment! !!AndEnvironment methodsFor: 'accessing'!classesDo: aBlock 	environment 		classesDo: [:each | (self includesClass: each) ifTrue: [aBlock value: each]]! !!AndEnvironment methodsFor: 'testing'!includesCategory: aCategory 	^(self classNamesFor: aCategory) isEmpty not! !!AndEnvironment methodsFor: 'testing'!includesClass: aClass 	| doesntHaveSelectors |	(environment includesClass: aClass) ifFalse: [^false].	(andedEnvironment includesClass: aClass) ifFalse: [^false].	doesntHaveSelectors := true.	environment selectorsForClass: aClass		do: 			[:each | 			doesntHaveSelectors := false.			(andedEnvironment includesSelector: each in: aClass) ifTrue: [^true]].	^doesntHaveSelectors! !!AndEnvironment methodsFor: 'testing'!includesProtocol: aProtocol in: aClass 	^(self selectorsFor: aProtocol in: aClass) isEmpty not! !!AndEnvironment methodsFor: 'testing'!includesSelector: aSelector in: aClass 	^(environment includesSelector: aSelector in: aClass) 		and: [andedEnvironment includesSelector: aSelector in: aClass]! !!AndEnvironment methodsFor: 'accessing'!numberSelectors	| total |	total := 0.	environment classesAndSelectorsDo: 			[:each :sel | 			(andedEnvironment includesSelector: sel in: each) 				ifTrue: [total := total + 1]].	^total! !!AndEnvironment methodsFor: 'accessing'!problemCount	^environment isClassEnvironment 		ifTrue: [self numberClasses]		ifFalse: [super problemCount]! !!AndEnvironment methodsFor: 'accessing' stamp: 'bh 5/8/2000 21:01'!selectionIntervalFor: aString 	| interval |	interval := super selectionIntervalFor: aString.	interval notNil ifTrue: [^interval].	^andedEnvironment selectionIntervalFor: aString! !!AndEnvironment methodsFor: 'accessing'!selectorsForClass: aClass do: aBlock 	environment selectorsForClass: aClass		do: 			[:each | 			(andedEnvironment includesSelector: each in: aClass) 				ifTrue: [aBlock value: each]]! !!AndEnvironment methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	environment storeOn: aStream.	aStream nextPutAll: ' & '.	andedEnvironment storeOn: aStream.	aStream nextPut: $)! !!BrowserEnvironmentWrapper class methodsFor: 'instance creation'!new	^self onEnvironment: BrowserEnvironment new! !!BrowserEnvironmentWrapper class methodsFor: 'instance creation'!onEnvironment: anEnvironment 	^(self basicNew)		initialize;		onEnvironment: anEnvironment;		yourself! !!BrowserEnvironmentWrapper methodsFor: 'private'!environment	^environment! !!BrowserEnvironmentWrapper methodsFor: 'testing'!includesCategory: aCategory	^environment includesCategory: aCategory! !!BrowserEnvironmentWrapper methodsFor: 'testing'!includesClass: aClass	^environment includesClass: aClass! !!BrowserEnvironmentWrapper methodsFor: 'testing'!includesProtocol: aProtocol in: aClass	^(self includesClass: aClass)		and: [environment includesProtocol: aProtocol in: aClass]! !!BrowserEnvironmentWrapper methodsFor: 'testing'!includesSelector: aSelector in: aClass	^(self includesClass: aClass)		and: [environment includesSelector: aSelector in: aClass]! !!BrowserEnvironmentWrapper methodsFor: 'testing'!isEmpty	self classesDo: [:each | ^false].	^true! !!BrowserEnvironmentWrapper methodsFor: 'testing'!isSystem	^false! !!BrowserEnvironmentWrapper methodsFor: 'initialize-release'!onEnvironment: anEnvironment	environment := anEnvironment! !!BrowserEnvironmentWrapper methodsFor: 'accessing' stamp: 'bh 5/8/2000 21:03'!selectionIntervalFor: aString 	| interval |	interval := super selectionIntervalFor: aString.	^interval notNil 		ifTrue: [interval]		ifFalse: [environment selectionIntervalFor: aString]! !!BrowserEnvironmentWrapper methodsFor: 'printing'!storeOn: aStream 	aStream		nextPutAll: '(';		nextPutAll: self class name;		nextPutAll: ' onEnvironment: '.	environment storeOn: aStream.	aStream nextPut: $)! !!CategoryEnvironment class methodsFor: 'instance creation'!onEnvironment: anEnvironment categories: aCollection	^(self onEnvironment: anEnvironment)		categories: aCollection; yourself! !!CategoryEnvironment methodsFor: 'accessing'!categories	^categories select: [:each | self includesCategory: each]! !!CategoryEnvironment methodsFor: 'initialize-release'!categories: aCollection	categories := aCollection! !!CategoryEnvironment methodsFor: 'accessing-classes'!classNames	^self categories inject: OrderedCollection new into: [:col :each | col addAll: (self classNamesFor: each); yourself]! !!CategoryEnvironment methodsFor: 'private'!defaultLabel	| stream |	stream := String new writeStream.	categories do: [:each | stream nextPutAll: each; nextPut: $ ].	^stream contents! !!CategoryEnvironment methodsFor: 'testing'!includesCategory: aCategory	^(categories includes: aCategory)		and: [super includesCategory: aCategory]! !!CategoryEnvironment methodsFor: 'testing'!includesClass: aClass 	^(super includesClass: aClass) and: 			[| nonMetaClass |			nonMetaClass := aClass isMeta 						ifTrue: [aClass soleInstance]						ifFalse: [aClass].			categories 				includes: (environment whichCategoryIncludes: nonMetaClass name)]! !!CategoryEnvironment methodsFor: 'initialize-release'!initialize	super initialize.	categories := Set new! !!CategoryEnvironment methodsFor: 'testing'!isEmpty	^categories isEmpty! !!CategoryEnvironment methodsFor: 'accessing'!numberSelectors	| total |	total := 0.	self 		classesDo: [:each | self selectorsForClass: each do: [:sel | total := total + 1]].	^total! !!CategoryEnvironment methodsFor: 'as yet unclassified' stamp: 'nk 3/4/2005 12:43'!openEditor	^(ClassEnvironment onEnvironment: self classes: self classes) openEditor! !!CategoryEnvironment methodsFor: 'copying'!postCopy	categories := categories copy.	^super postCopy! !!CategoryEnvironment methodsFor: 'printing'!storeOn: aStream	aStream nextPut: $(.	super storeOn: aStream.	aStream nextPutAll: ' categories: '.	categories asArray storeOn: aStream.	aStream nextPut: $)! !!ClassEnvironment class methodsFor: 'instance creation'!onEnvironment: anEnvironment classes: aCollection	^(self onEnvironment: anEnvironment)		classes: aCollection; yourself! !!ClassEnvironment methodsFor: 'adding'!addClass: aClass 	aClass isMeta		ifTrue: [metaClasses add: aClass soleInstance name]		ifFalse: [classes add: aClass name]! !!ClassEnvironment methodsFor: 'accessing' stamp: 'bh 6/10/2000 17:05'!asSelectorEnvironment	^SelectorEnvironment new		searchStrings:#();		label:self label;		onEnvironment: self environment;		classSelectors: self classSelectorDictionary metaClassSelectors: self metaClassSelectorDictionary;		yourself.! !!ClassEnvironment methodsFor: 'accessing-classes'!classNames	^(Set withAll: classes) addAll: metaClasses;		yourself! !!ClassEnvironment methodsFor: 'printing' stamp: 'bh 6/10/2000 17:39'!classSelectorDictionary	^classes inject:Dictionary new into:		[:answer :class |		answer at:class put:(Smalltalk at:class) selectors;			yourself].	! !!ClassEnvironment methodsFor: 'initialize-release'!classes: aCollection 	aCollection do: [:each | self addClass: each]! !!ClassEnvironment methodsFor: 'accessing-classes'!classesDo: aBlock 	classes		do: 			[:each | 			| class |			class := Smalltalk at: each ifAbsent: [nil].			(class notNil and: [environment includesClass: class])				ifTrue: [aBlock value: class]].	metaClasses		do: 			[:each | 			| class |			class := Smalltalk at: each ifAbsent: [nil].			(class notNil and: [environment includesClass: class class])				ifTrue: [aBlock value: class class]]! !!ClassEnvironment methodsFor: 'private'!defaultLabel	| stream |	stream := String new writeStream.	classes do: 			[:each | 			stream nextPutAll: each;				nextPut: $ ].	^stream contents! !!ClassEnvironment methodsFor: 'testing'!includesCategory: aCategory	^(super includesCategory: aCategory)		and: [(environment classNamesFor: aCategory)				inject: false into: [:bool :each | bool					or:						[| class |						class := Smalltalk at: each ifAbsent: [nil].						class notNil and: [(self includesClass: class)								or: [self includesClass: class class]]]]]! !!ClassEnvironment methodsFor: 'testing'!includesClass: aClass 	^(aClass isMeta		ifTrue: [metaClasses includes: aClass soleInstance name]		ifFalse: [classes includes: aClass name])			and: [super includesClass: aClass]! !!ClassEnvironment methodsFor: 'initialize-release'!initialize	super initialize.	classes := Set new.	metaClasses := Set new! !!ClassEnvironment methodsFor: 'testing'!isClassEnvironment	^true! !!ClassEnvironment methodsFor: 'testing'!isEmpty	^classes isEmpty and: [metaClasses isEmpty]! !!ClassEnvironment methodsFor: 'printing' stamp: 'bh 4/29/2000 17:53'!logOrInspect	Transcript cr; cr; show:self name.	(classes asArray, metaClasses asArray) asSet do: 		[:class | 		Transcript cr; show: '     ',class asString].! !!ClassEnvironment methodsFor: 'printing' stamp: 'bh 6/10/2000 17:39'!metaClassSelectorDictionary	^metaClasses inject:Dictionary new into:		[:answer :class |		answer at:class put:(Smalltalk at:class) class selectors;			yourself].	! !!ClassEnvironment methodsFor: '*RefactoringEngine' stamp: 'dvf 10/3/2001 01:32'!openEditor	^(ClassEnvironmentBrowser openOnEnvironment: self) openInWorld.! !!ClassEnvironment methodsFor: 'copying'!postCopy	classes := classes copy.	metaClasses := metaClasses copy.	^super postCopy! !!ClassEnvironment methodsFor: 'accessing'!problemCount	^self numberClasses! !!ClassEnvironment methodsFor: 'removing'!removeClass: aClass 	aClass isMeta		ifTrue: [metaClasses remove: aClass soleInstance name ifAbsent: []]		ifFalse: [classes remove: aClass name ifAbsent: []]! !!ClassEnvironment methodsFor: 'printing'!storeOn: aStream	aStream nextPut: $(.	super storeOn: aStream.	aStream nextPutAll: ' classes: (('.	classes asArray storeOn: aStream.	aStream nextPutAll: ' inject: OrderedCollection new into: [:sum :each | 				| class |				class := Smalltalk at: each ifAbsent: [nil].				class notNil ifTrue: [sum add: class].				sum]) , ('.	metaClasses asArray storeOn: aStream.	aStream nextPutAll: ' inject: OrderedCollection new into: [:sum :each | 				| class |				class := Smalltalk at: each ifAbsent: [nil].				class notNil ifTrue: [sum add: class class].				sum])))'! !!MultiEnvironment methodsFor: 'adding'!addClass: aClass into: aValue 	(environmentDictionaries at: aValue ifAbsentPut: [SelectorEnvironment new]) 		addClass: aClass! !!MultiEnvironment methodsFor: 'adding'!addClass: aClass selector: aSymbol into: aValue 	(environmentDictionaries at: aValue ifAbsentPut: [SelectorEnvironment new]) 		addClass: aClass		selector: aSymbol! !!MultiEnvironment methodsFor: 'accessing' stamp: 'rr 4/19/2004 16:04'!asSelectorEnvironment	| s |	s := SelectorEnvironment new.	s label: self label.	environmentDictionaries do: [:each | | env |			env := each asSelectorEnvironment. 			env classesDo: [:cls | env selectorsForClass: cls do:  [:sel | s addClass: cls selector: sel]]].	^ s	  ! !!MultiEnvironment methodsFor: 'accessing'!environments	^environmentDictionaries keys! !!MultiEnvironment methodsFor: 'initialize-release'!initialize	super initialize.	environmentDictionaries := Dictionary new.	environment := SelectorEnvironment new! !!MultiEnvironment methodsFor: 'testing'!isEmpty	^environmentDictionaries isEmpty! !!MultiEnvironment methodsFor: 'GUI' stamp: 'lr 12/13/2005 15:00'!openEditor	self explore.! !!MultiEnvironment methodsFor: 'accessing'!problemCount	^environmentDictionaries size! !!MultiEnvironment methodsFor: 'removing'!removeClass: aClass into: aValue 	(environmentDictionaries at: aValue ifAbsent: [SelectorEnvironment new]) 		removeClass: aClass! !!MultiEnvironment methodsFor: 'removing'!removeClass: aClass selector: aSelector into: aValue 	(environmentDictionaries at: aValue ifAbsentPut: [SelectorEnvironment new]) 		removeClass: aClass		selector: aSelector! !!MultiEnvironment methodsFor: 'accessing'!selectEnvironment: aValue 	environment := environmentDictionaries at: aValue				ifAbsent: [SelectorEnvironment new]! !!NotEnvironment methodsFor: 'testing'!includesCategory: aCategory 	^(self classNamesFor: aCategory) isEmpty not! !!NotEnvironment methodsFor: 'testing'!includesClass: aClass 	(environment includesClass: aClass) ifFalse: [^true].	aClass selectorsAndMethodsDo: 			[:each :meth | 			(environment includesSelector: each in: aClass) ifFalse: [^true]].	^false! !!NotEnvironment methodsFor: 'testing'!includesProtocol: aProtocol in: aClass 	^(self selectorsFor: aProtocol in: aClass) isEmpty not! !!NotEnvironment methodsFor: 'testing'!includesSelector: aSelector in: aClass	^(environment includesSelector: aSelector in: aClass) not! !!NotEnvironment methodsFor: 'environments'!not	^environment! !!NotEnvironment methodsFor: 'printing'!storeOn: aStream	environment storeOn: aStream.	aStream nextPutAll: ' not'! !!PackageEnvironment class methodsFor: 'instance creation' stamp: 'lr 1/3/2006 12:14'!onEnvironment: anEnvironment package: aPackageInfo	^ (self onEnvironment: anEnvironment)		package: aPackageInfo;		yourself.! !!PackageEnvironment class methodsFor: 'instance creation' stamp: 'lr 1/3/2006 12:14'!onEnvironment: anEnvironment packageNamed: aString	^ self onEnvironment: anEnvironment package: (PackageInfo named: aString).! !!PackageEnvironment methodsFor: 'accessing' stamp: 'lr 1/3/2006 12:05'!asSelectorEnvironment	| result |	result := SelectorEnvironment onEnvironment: self.	self classesAndSelectorsDo: [ :class :selector | 		result addClass: class selector: selector ].	^ result.! !!PackageEnvironment methodsFor: 'accessing' stamp: 'lr 1/3/2006 12:05'!classesAndSelectorsDo: aBlock	self package coreMethods do: [ :method |		(self includesSelector: method methodSymbol in: method actualClass)			ifTrue: [ aBlock value: method actualClass value: method methodSymbol ] ].	self package extensionMethods do: [ :method |		(self includesSelector: method methodSymbol in: method actualClass)			ifTrue: [ aBlock value: method actualClass value: method methodSymbol ] ].! !!PackageEnvironment methodsFor: 'accessing' stamp: 'lr 1/3/2006 12:05'!classesDo: aBlock	self package classesAndMetaClasses do: [ :each |		(self includesClass: each)			ifTrue: [ aBlock value: each ] ].	self package extensionClasses do: [ :each |		(self environment includesClass: each)			ifTrue: [ aBlock value: each ].		(self environment includesClass: each class)			ifTrue: [ aBlock value: each class ] ].! !!PackageEnvironment methodsFor: 'testing' stamp: 'lr 1/3/2006 12:06'!includesCategory: aCategory	^ (super includesCategory: aCategory) 		and: [ self package includesSystemCategory: aCategory ].! !!PackageEnvironment methodsFor: 'testing' stamp: 'lr 1/3/2006 12:06'!includesClass: aClass	^ (super includesClass: aClass) 		and: [ self package includesClass: aClass ].! !!PackageEnvironment methodsFor: 'testing' stamp: 'lr 1/3/2006 12:12'!includesProtocol: aProtocol in: aClass	^ (self environment includesProtocol: aProtocol in: aClass) 		and: [ self package includesMethodCategory: aProtocol ofClass: aClass ].! !!PackageEnvironment methodsFor: 'testing' stamp: 'lr 1/3/2006 12:12'!includesSelector: aSelector in: aClass	^ (self environment includesSelector: aSelector in: aClass) 		and: [ self package includesMethod: aSelector ofClass: aClass ].! !!PackageEnvironment methodsFor: 'accessing' stamp: 'lr 1/3/2006 12:05'!package	^ package! !!PackageEnvironment methodsFor: 'private' stamp: 'lr 1/3/2006 12:12'!package: aPackageInfo	package := aPackageInfo! !!PackageEnvironment methodsFor: 'printing' stamp: 'lr 1/3/2006 12:06'!storeOn: aStream 	aStream nextPut: $(; nextPutAll: self class name; nextPutAll: ' onEnvironment: '.	environment storeOn: aStream.	aStream nextPutAll: ' packageNamed: '; print: self package packageName; nextPut: $).! !!ProtocolEnvironment class methodsFor: 'instance creation'!onEnvironment: anEnvironment class: aClass protocols: aCollection	^(self onEnvironment: anEnvironment)		class: aClass protocols: aCollection; yourself! !!ProtocolEnvironment methodsFor: 'initialize-release'!class: aClass protocols: aCollection	class := aClass.	protocols := aCollection! !!ProtocolEnvironment methodsFor: 'private'!defaultLabel	| stream |	stream := String new writeStream.	stream nextPutAll: class name;		nextPut: $>.	protocols do: 			[:each | 			stream nextPutAll: each;				nextPut: $ ].	^stream contents! !!ProtocolEnvironment methodsFor: 'testing'!includesCategory: aCategory	^(super includesCategory: aCategory)		and: [(environment classNamesFor: aCategory)				inject: false into: [:bool :each | bool					or:						[| aClass |						aClass := Smalltalk at: each ifAbsent: [nil].						aClass == class or: [aClass class == class]]]]! !!ProtocolEnvironment methodsFor: 'testing'!includesClass: aClass	^aClass == class and: [super includesClass: aClass]! !!ProtocolEnvironment methodsFor: 'testing'!includesProtocol: aProtocol in: aClass	^aClass == class and: [(super includesProtocol: aProtocol in: aClass)			and: [protocols includes: aProtocol]]! !!ProtocolEnvironment methodsFor: 'testing'!includesSelector: aSelector in: aClass 	^(super includesSelector: aSelector in: aClass) and: 			[protocols 				includes: (environment whichProtocolIncludes: aSelector in: aClass)]! !!ProtocolEnvironment methodsFor: 'testing'!isEmpty	^protocols isEmpty! !!ProtocolEnvironment methodsFor: 'copying'!postCopy	protocols := protocols copy.	^super postCopy! !!ProtocolEnvironment methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	super storeOn: aStream.	aStream		nextPutAll: ' class: ';		nextPutAll: class name;		nextPutAll: ' protocols: '.	protocols asArray storeOn: aStream.	aStream nextPut: $)! !!ParseTreeEnvironment methodsFor: 'initialize-release'!matcher: aParseTreeSearcher	matcher := aParseTreeSearcher! !!ParseTreeEnvironment methodsFor: 'accessing' stamp: 'bh 5/9/2000 00:19'!selectionIntervalFor: aString 	| parseTree node |	matcher isNil ifTrue: [^super selectionIntervalFor: aString].	parseTree := RBParser parseMethod: aString				onError: [:error :position | ^super selectionIntervalFor: aString].	node := matcher executeTree: parseTree initialAnswer: nil.	^node isNil 		ifTrue: [super selectionIntervalFor: aString]		ifFalse: [node sourceInterval]! !!SelectorEnvironment class methodsFor: 'instance creation'!implementorsMatching: aString in: anEnvironment 	| classDict metaDict |	classDict := IdentityDictionary new.	metaDict := IdentityDictionary new.	anEnvironment classesDo: 			[:class | 			| selectors |			selectors := Set new.			anEnvironment selectorsForClass: class				do: [:each | (aString match: each) ifTrue: [selectors add: each]].			selectors isEmpty 				ifFalse: 					[class isMeta 						ifTrue: [metaDict at: class soleInstance name put: selectors]						ifFalse: [classDict at: class name put: selectors]]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: 'Implementors of ' , aString;		yourself! !!SelectorEnvironment class methodsFor: 'instance creation'!implementorsOf: aSelector in: anEnvironment 	| classDict metaDict selectors |	classDict := IdentityDictionary new.	metaDict := IdentityDictionary new.	selectors := Array with: aSelector.	anEnvironment classesDo: 			[:class | 			((class includesSelector: aSelector) 				and: [anEnvironment includesSelector: aSelector in: class]) 					ifTrue: 						[class isMeta 							ifTrue: [metaDict at: class soleInstance name put: selectors]							ifFalse: [classDict at: class name put: selectors]]].	^(self onEnvironment: anEnvironment)		classSelectors: classDict metaClassSelectors: metaDict;		label: 'Implementors of ' , aSelector;		yourself! !!SelectorEnvironment class methodsFor: 'instance creation'!matches: aString in: anEnvironment 	| newEnvironment |	newEnvironment := (self onEnvironment: anEnvironment)				label: 'Matching: ' , aString;				searchStrings: (Array with: aString);				yourself.	anEnvironment classesAndSelectorsDo: 			[:each :sel | 			| method |			method := each compiledMethodAt: sel.			method allLiterals do: 					[:lit | 					lit isString 						ifTrue: 							[(aString match: lit) ifTrue: [newEnvironment addClass: each selector: sel]]]].	^newEnvironment! !!SelectorEnvironment class methodsFor: 'instance creation'!onMethods: selectorCollection forClass: aClass in: anEnvironment 	| env |	env := self onEnvironment: anEnvironment.	selectorCollection do: [:each | env addClass: aClass selector: each].	^env! !!SelectorEnvironment class methodsFor: 'instance creation'!referencesTo: aLiteral in: anEnvironment 	| classDict literalPrintString |	literalPrintString := aLiteral isVariableBinding				ifTrue: [aLiteral key asString]				ifFalse: 					[aLiteral isString ifTrue: [aLiteral] ifFalse: [aLiteral printString]].	classDict := Dictionary new.	anEnvironment classesDo: 			[:class | 			| selectors |			selectors := (class whichSelectorsReferTo: aLiteral)						select: [:aSelector | anEnvironment includesSelector: aSelector in: class].			selectors isEmpty ifFalse: [classDict at: class put: selectors]].	^(self onEnvironment: anEnvironment) on: classDict;		label: 'References to: ' , literalPrintString;		searchStrings: (Array with: literalPrintString);		yourself! !!SelectorEnvironment methodsFor: 'adding'!addClass: aClass 	aClass isMeta 		ifTrue: 			[metaClassSelectors at: aClass soleInstance name put: aClass selectors]		ifFalse: [classSelectors at: aClass name put: aClass selectors]! !!SelectorEnvironment methodsFor: 'adding'!addClass: aClass selector: aSymbol 	(aClass isMeta 		ifTrue: 			[metaClassSelectors at: aClass soleInstance name ifAbsentPut: [Set new]]		ifFalse: [classSelectors at: aClass name ifAbsentPut: [Set new]]) add: aSymbol! !!SelectorEnvironment methodsFor: 'accessing' stamp: 'rr 4/19/2004 16:06'!asSelectorEnvironment	^ self! !!SelectorEnvironment methodsFor: 'accessing-classes'!classNames	| names |	names := Set new: classSelectors size + metaClassSelectors size.	names		addAll: classSelectors keys;		addAll: metaClassSelectors keys.	^names asOrderedCollection! !!SelectorEnvironment methodsFor: 'initialize-release'!classSelectors: classSelectorDictionary metaClassSelectors: metaClassSelectorDictionary 	classSelectors := classSelectorDictionary.	metaClassSelectors := metaClassSelectorDictionary! !!SelectorEnvironment methodsFor: 'initialize-release'!classes: classArray metaClasses: metaArray 	"Used to recreate an environment from its storeString"	classSelectors := Dictionary new.	metaClassSelectors := Dictionary new.	classArray 		do: [:each | classSelectors at: each first put: each last asSet].	metaArray 		do: [:each | metaClassSelectors at: each first put: each last asSet]! !!SelectorEnvironment methodsFor: 'accessing-classes'!classesDo: aBlock 	classSelectors keysDo: 			[:each | 			| class |			class := Smalltalk at: each ifAbsent: [nil].			class notNil 				ifTrue: [(self includesClass: class) ifTrue: [aBlock value: class]]].	metaClassSelectors keysDo: 			[:each | 			| class |			class := Smalltalk at: each ifAbsent: [nil].			class notNil 				ifTrue: 					[(self includesClass: class class) ifTrue: [aBlock value: class class]]]! !!SelectorEnvironment methodsFor: 'private'!defaultLabel	^'some methods'! !!SelectorEnvironment methodsFor: 'testing'!includesCategory: aCategory 	^(super includesCategory: aCategory) and: 			[(self classNamesFor: aCategory) contains: 					[:className | 					(classSelectors includesKey: className) 						or: [metaClassSelectors includesKey: className]]]! !!SelectorEnvironment methodsFor: 'testing'!includesClass: aClass 	^(self privateSelectorsForClass: aClass) isEmpty not 		and: [super includesClass: aClass]! !!SelectorEnvironment methodsFor: 'testing'!includesProtocol: aProtocol in: aClass 	^(super includesProtocol: aProtocol in: aClass)		and: [(environment selectorsFor: aProtocol in: aClass)				contains: [:aSelector | self privateIncludesSelector: aSelector inClass: aClass]]! !!SelectorEnvironment methodsFor: 'testing'!includesSelector: aSelector in: aClass 	^(environment includesSelector: aSelector in: aClass)		and: [self privateIncludesSelector: aSelector inClass: aClass]! !!SelectorEnvironment methodsFor: 'initialize-release'!initialize	super initialize.	classSelectors := IdentityDictionary new.	metaClassSelectors := IdentityDictionary new! !!SelectorEnvironment methodsFor: 'testing'!isEmpty	^classSelectors isEmpty and: [metaClassSelectors isEmpty]! !!SelectorEnvironment methodsFor: 'testing'!isSelector	^true! !!SelectorEnvironment methodsFor: 'adding' stamp: 'bh 4/29/2000 18:09'!logOrInspect	Transcript cr; cr; show:self name.	searchStrings ifNotNil:		[Transcript cr;show:'     ( '.		searchStrings do:[:string| Transcript show:string asString,' '].		Transcript show:')'.].	self logOrInspectDictionary:classSelectors.	self logOrInspectDictionary:metaClassSelectors.! !!SelectorEnvironment methodsFor: 'adding' stamp: 'bh 4/29/2000 18:09'!logOrInspectDictionary:aDictionary	aDictionary keysAndValuesDo: 		[:class :selectors | 		selectors do: 			[:sel |			Transcript cr; show: '     ',class name asString , '>>' , sel asString]].! !!SelectorEnvironment methodsFor: 'accessing'!numberSelectors	"This doesn't compute the correct result when a method that is included in our method list is not in the	environment we are wrapping. It is implemented this way for efficiency."	^(classSelectors inject: 0 into: [:sum :each | sum + each size]) 		+ (metaClassSelectors inject: 0 into: [:sum :each | sum + each size])! !!SelectorEnvironment methodsFor: 'initialize-release'!on: aDict 	aDict keysAndValuesDo: 			[:class :selectors | 			class isMeta 				ifTrue: [metaClassSelectors at: class soleInstance name put: selectors]				ifFalse: [classSelectors at: class name put: selectors]]! !!SelectorEnvironment methodsFor: '*RefactoringEngine' stamp: 'dvf 10/3/2001 01:32'!openEditor	^(SelectorEnvironmentBrowser openOnEnvironment: self) openInWorld.! !!SelectorEnvironment methodsFor: 'copying'!postCopy	| newDict |	newDict := classSelectors copy.	newDict keysAndValuesDo: [:key :value | newDict at: key put: value copy].	classSelectors := newDict.	newDict := metaClassSelectors copy.	newDict keysAndValuesDo: [:key :value | newDict at: key put: value copy].	metaClassSelectors := newDict.	^super postCopy! !!SelectorEnvironment methodsFor: 'private'!privateIncludesSelector: aSelector inClass: aClass 	^(self privateSelectorsForClass: aClass) includes: aSelector! !!SelectorEnvironment methodsFor: 'private'!privateSelectorsForClass: aClass 	^aClass isMeta 		ifTrue: [metaClassSelectors at: aClass soleInstance name ifAbsent: [#()]]		ifFalse: [classSelectors at: aClass name ifAbsent: [#()]]! !!SelectorEnvironment methodsFor: 'removing'!removeClass: aClass 	aClass isMeta 		ifTrue: [metaClassSelectors removeKey: aClass soleInstance name ifAbsent: []]		ifFalse: [classSelectors removeKey: aClass name ifAbsent: []]! !!SelectorEnvironment methodsFor: 'removing'!removeClass: aClass selector: aSelector 	(aClass isMeta 		ifTrue: [metaClassSelectors at: aClass soleInstance name ifAbsent: [^self]]		ifFalse: [classSelectors at: aClass name ifAbsent: [^self]]) 			remove: aSelector			ifAbsent: []! !!SelectorEnvironment methodsFor: 'accessing'!selectorsForClass: aClass do: aBlock 	^(self privateSelectorsForClass: aClass) 		do: [:each | (aClass includesSelector: each) ifTrue: [aBlock value: each]]! !!SelectorEnvironment methodsFor: 'printing'!storeOn: aStream 	| classBlock |	aStream		nextPutAll: '((';		nextPutAll: self class name;		nextPutAll: ' onEnvironment: '.	environment storeOn: aStream.	aStream		nextPut: $);		nextPutAll: ' classes: #('.	classBlock := 			[:key :value | 			aStream				nextPutAll: '#(';				nextPutAll: key;				nextPutAll: ' #('.			value do: 					[:each | 					aStream						nextPutAll: each;						nextPut: $ ].			aStream				nextPutAll: '))';				cr].	classSelectors keysAndValuesDo: classBlock.	aStream nextPutAll: ') metaClasses: #('.	metaClassSelectors keysAndValuesDo: classBlock.	aStream nextPutAll: '))'! !!VariableEnvironment class methodsFor: 'instance creation' stamp: 'nk 3/4/2005 13:20'!on: anEnvironment readersOfInstanceVariable: aString in: aClass 	| newEnv |	newEnv := (self onEnvironment: anEnvironment)				label: 'Readers of ''' , aString , ''' in ' , aClass name;				yourself.	(aClass whichClassDefinesInstVar: aString) withAllSubclassesDo: 			[:cls | 			(cls whichSelectorsRead: aString) isEmpty				ifFalse: [newEnv addClass: cls instanceVariableReader: aString]].	^newEnv! !!VariableEnvironment class methodsFor: 'instance creation' stamp: 'md 1/17/2006 14:17'!on: anEnvironment referencesToClassVariable: aSymbol in: aClass 	| newEnv definingClass assoc |	newEnv := (self onEnvironment: anEnvironment)				label: 'References to ''' , aSymbol , ''' in ' , aClass name;				yourself.	definingClass := aClass whichClassDefinesClassVar: aSymbol.	assoc := definingClass bindingOf: aSymbol.	definingClass withAllSubclassesDo: 			[:cls | 			(cls whichSelectorsReferTo: assoc) isEmpty 				ifFalse: [newEnv addClass: cls classVariable: aSymbol]].	^newEnv! !!VariableEnvironment class methodsFor: 'instance creation' stamp: 'nk 3/4/2005 13:23'!on: anEnvironment referencesToInstanceVariable: aString in: aClass 	| newEnv |	newEnv := (self onEnvironment: anEnvironment)				label: 'References to ''' , aString , ''' in ' , aClass name;				yourself.	(aClass whichClassDefinesInstVar: aString) withAllSubclassesDo: 			[:cls | 			((cls whichSelectorsRead: aString) isEmpty not 				or: [(cls whichSelectorsAssign: aString) isEmpty not]) 					ifTrue: [newEnv addClass: cls instanceVariable: aString]].	^newEnv! !!VariableEnvironment class methodsFor: 'instance creation' stamp: 'nk 3/4/2005 13:17'!on: anEnvironment writersOfInstanceVariable: aString in: aClass 	| newEnv |	newEnv := (self onEnvironment: anEnvironment)				label: 'Writers of ''' , aString , ''' in ' , aClass name;				yourself.	(aClass whichClassDefinesInstVar: aString) withAllSubclassesDo: 			[:cls | 			(cls whichSelectorsAssign: aString) isEmpty				ifFalse: [newEnv addClass: cls instanceVariableWriter: aString]].	^newEnv! !!VariableEnvironment class methodsFor: 'instance creation'!readersOfInstanceVariable: aString in: aClass 	^self 		on: BrowserEnvironment new		readersOfInstanceVariable: aString		in: aClass! !!VariableEnvironment class methodsFor: 'instance creation'!referencesToClassVariable: aSymbol in: aClass 	^self 		on: BrowserEnvironment new		referencesToClassVariable: aSymbol		in: aClass! !!VariableEnvironment class methodsFor: 'instance creation'!referencesToInstanceVariable: aString in: aClass 	^self 		on: BrowserEnvironment new		referencesToInstanceVariable: aString		in: aClass! !!VariableEnvironment class methodsFor: 'instance creation'!writersOfInstanceVariable: aString in: aClass 	^self 		on: BrowserEnvironment new		writersOfInstanceVariable: aString		in: aClass! !!VariableEnvironment methodsFor: 'private'!accessorMethods	^#(#instanceVariables #instanceVariableReaders #instanceVariableWriters #classVariables)! !!VariableEnvironment methodsFor: 'accessing'!addClass: aClass classVariable: aSymbol 	(classVariables at: aClass name ifAbsentPut: [Set new]) add: aSymbol.	self flushCachesFor: aClass.	self addSearchString: aSymbol! !!VariableEnvironment methodsFor: 'accessing'!addClass: aClass instanceVariable: aString 	(instanceVariables at: aClass name ifAbsentPut: [Set new]) add: aString.	self flushCachesFor: aClass.	self addSearchString: aString! !!VariableEnvironment methodsFor: 'accessing'!addClass: aClass instanceVariableReader: aString 	(instanceVariableReaders at: aClass name ifAbsentPut: [Set new]) 		add: aString.	self flushCachesFor: aClass.	self addSearchString: aString! !!VariableEnvironment methodsFor: 'accessing'!addClass: aClass instanceVariableWriter: aString 	(instanceVariableWriters at: aClass name ifAbsentPut: [Set new]) 		add: aString.	self flushCachesFor: aClass.	self addSearchString: aString! !!VariableEnvironment methodsFor: 'private'!allClassesDo: aBlock 	| classes instVarBlock |	classes := Set new.	instVarBlock := 			[:each | 			| class |			class := self classForName: each.			classes addAll: class withAllSubclasses].	instanceVariables keysDo: instVarBlock.	instanceVariableReaders keysDo: instVarBlock.	instanceVariableWriters keysDo: instVarBlock.	classVariables keysDo: 			[:each | 			| class |			class := self classForName: each.			class notNil 				ifTrue: 					[classes						addAll: class withAllSubclasses;						addAll: class class withAllSubclasses]].	classes do: aBlock! !!VariableEnvironment methodsFor: 'private'!classForName: aString 	| name isMeta class |	isMeta := aString includes: $ .	name := (isMeta 				ifTrue: [aString copyFrom: 1 to: (aString size - 6 max: 1)]				ifFalse: [aString]) asSymbol.	class := Smalltalk at: name ifAbsent: [nil].	^class notNil & isMeta ifTrue: [class class] ifFalse: [class]! !!VariableEnvironment methodsFor: 'accessing'!classNamesWithVariables	| classNames |	classNames := Set new.	classNames		addAll: instanceVariables keys;		addAll: instanceVariableReaders keys;		addAll: instanceVariableWriters keys;		addAll: classVariables keys.	^classNames! !!VariableEnvironment methodsFor: 'private' stamp: 'md 1/17/2006 14:17'!classVariableSelectorsFor: aClass 	| selectors classVars nonMetaClass |	nonMetaClass := aClass isMeta 				ifTrue: [aClass soleInstance]				ifFalse: [aClass].	selectors := Set new.	classVars := Set new.	classVariables keysDo: 			[:each | 			| cls |			cls := self classForName: each.			(cls notNil and: [nonMetaClass includesBehavior: cls]) 				ifTrue: [classVars addAll: (classVariables at: each)]].	classVars do: 			[:each | 			| binding |			binding := aClass bindingOf: each.			binding notNil 				ifTrue: [selectors addAll: (aClass whichSelectorsReferTo: binding)]].	^selectors! !!VariableEnvironment methodsFor: 'private'!classVariables	^classVariables! !!VariableEnvironment methodsFor: 'private'!classVariables: anObject	classVariables := anObject! !!VariableEnvironment methodsFor: 'accessing'!classVariablesFor: aClass 	^classVariables at: aClass name ifAbsent: [#()]! !!VariableEnvironment methodsFor: 'private'!computeSelectorCacheFor: aClass 	^(self instanceVariableSelectorsFor: aClass)		addAll: (self classVariableSelectorsFor: aClass);		yourself! !!VariableEnvironment methodsFor: 'copying'!copyDictionary: aDictionary 	| copy |	copy := Dictionary new: aDictionary size.	aDictionary keysAndValuesDo: [:key :value | copy at: key put: value].	^copy! !!VariableEnvironment methodsFor: 'accessing' stamp: 'md 1/17/2006 14:17'!environmentForClassVariable: aSymbol in: aClass 	| selectorEnvironment assoc block |	selectorEnvironment := SelectorEnvironment onEnvironment: self.	selectorEnvironment addSearchString: aSymbol.	((classVariables at: aClass name ifAbsent: [#()]) includes: aSymbol) 		ifFalse: [^selectorEnvironment].	assoc := aClass bindingOf: aSymbol.	block := 			[:each | 			(each whichSelectorsReferTo: assoc) 				do: [:sel | selectorEnvironment addClass: each selector: sel]].	aClass withAllSubAndSuperclassesDo: 			[:each | 			block				value: each;				value: each class].	^selectorEnvironment! !!VariableEnvironment methodsFor: 'accessing' stamp: 'nk 2/26/2005 07:24'!environmentForInstanceVariable: aString in: aClass 	| selectorEnvironment isReader isWriter |	selectorEnvironment := SelectorEnvironment onEnvironment: self.	selectorEnvironment addSearchString: aString.	isReader := isWriter := false.	((instanceVariables at: aClass name ifAbsent: [#()]) includes: aString) 		ifTrue: 			[isReader := true.			isWriter := true].	((instanceVariableWriters at: aClass name ifAbsent: [#()]) 		includes: aString) ifTrue: [isWriter := true].	((instanceVariableReaders at: aClass name ifAbsent: [#()]) 		includes: aString) ifTrue: [isReader := true].	aClass withAllSubAndSuperclassesDo:			[:each | 			isWriter 				ifTrue: 					[(each whichSelectorsAssign: aString) 						do: [:sel | selectorEnvironment addClass: each selector: sel]].			isReader 				ifTrue: 					[(each whichSelectorsRead: aString) 						do: [:sel | selectorEnvironment addClass: each selector: sel]]].	^selectorEnvironment! !!VariableEnvironment methodsFor: 'private'!flushCachesFor: aClass 	| nonMetaClass |	selectorCache isNil ifTrue: [^self].	nonMetaClass := aClass isMeta 				ifTrue: [aClass soleInstance]				ifFalse: [aClass].	nonMetaClass withAllSubclasses do: 			[:each | 			selectorCache				removeKey: each ifAbsent: [];				removeKey: each class ifAbsent: []]! !!VariableEnvironment methodsFor: 'testing'!includesCategory: aCategory 	^(self classNamesFor: aCategory) isEmpty not! !!VariableEnvironment methodsFor: 'testing'!includesClass: aClass 	(super includesClass: aClass) ifFalse: [^false].	(instanceVariables includesKey: aClass) ifTrue: [^true].	(classVariables includesKey: aClass) ifTrue: [^true].	^((self selectorCacheFor: aClass) 		detect: [:each | self includesSelector: each in: aClass]		ifNone: [nil]) notNil! !!VariableEnvironment methodsFor: 'testing'!includesProtocol: aProtocol in: aClass 	^(self selectorsFor: aProtocol in: aClass) isEmpty not! !!VariableEnvironment methodsFor: 'testing'!includesSelector: aSymbol in: aClass 	^(environment includesSelector: aSymbol in: aClass) 		and: [(self selectorCacheFor: aClass) includes: aSymbol]! !!VariableEnvironment methodsFor: 'initialize-release'!initialize	super initialize.	instanceVariables := Dictionary new.	classVariables := Dictionary new.	instanceVariableReaders := Dictionary new.	instanceVariableWriters := Dictionary new! !!VariableEnvironment methodsFor: 'private'!instanceVariableReaders	^instanceVariableReaders! !!VariableEnvironment methodsFor: 'private'!instanceVariableReaders: anObject	instanceVariableReaders := anObject! !!VariableEnvironment methodsFor: 'private'!instanceVariableSelectorsFor: aClass 	| selectors |	selectors := Set new.	#(#instanceVariables #instanceVariableReaders #instanceVariableWriters) 		with: #(#whichSelectorsAccess: #whichSelectorsRead: #whichSelectorsAssign:)		do: 			[:var :sel | 			| instVars |			instVars := Set new.			(self perform: var) keysDo: 					[:each | 					| cls |					cls := self classForName: each.					(cls notNil and: [aClass includesBehavior: cls]) 						ifTrue: [instVars addAll: ((self perform: var) at: each)]].			instVars do: [:each | selectors addAll: (aClass perform: sel with: each)]].	^selectors! !!VariableEnvironment methodsFor: 'private'!instanceVariableWriters	^instanceVariableWriters! !!VariableEnvironment methodsFor: 'private'!instanceVariableWriters: anObject	instanceVariableWriters := anObject! !!VariableEnvironment methodsFor: 'private'!instanceVariables	^instanceVariables! !!VariableEnvironment methodsFor: 'private'!instanceVariables: anObject	instanceVariables := anObject! !!VariableEnvironment methodsFor: 'accessing'!instanceVariablesFor: aClass 	| vars name |	vars := Set new.	name := aClass name.	vars		addAll: (instanceVariables at: name ifAbsent: [#()]);		addAll: (instanceVariableReaders at: name ifAbsent: [#()]);		addAll: (instanceVariableWriters at: name ifAbsent: [#()]).	^vars! !!VariableEnvironment methodsFor: 'testing'!isEmpty	self accessorMethods 		do: [:each | (self perform: each) isEmpty ifFalse: [^false]].	^true! !!VariableEnvironment methodsFor: 'printing' stamp: 'bh 4/29/2000 18:10'!logOrInspect	Transcript cr; cr; show:self name.	instanceVariables keysAndValuesDo: 		[:class :variables | 		variables do: 			[:variable |			Transcript cr; show: '     ',class name asString , '->' , variable asString]].	classVariables keysAndValuesDo: 		[:class :variables | 		variables do: 			[:variable |			Transcript cr; show: '     ',class name asString , ' (cvar) ' , variable asString]].! !!VariableEnvironment methodsFor: 'accessing'!numberVariables	^self accessorMethods inject: 0		into: [:sum :each | sum + ((self perform: each) inject: 0 into: [:s :e | s + e size])]! !!VariableEnvironment methodsFor: '*RefactoringEngine' stamp: 'dvf 10/3/2001 01:32'!openEditor	^(VariableEnvironmentBrowser openOnEnvironment: self) openInWorld.! !!VariableEnvironment methodsFor: 'copying'!postCopy	super postCopy.	instanceVariables := self copyDictionary: instanceVariables.	instanceVariableReaders := self copyDictionary: instanceVariableReaders.	instanceVariableWriters := self copyDictionary: instanceVariableWriters.	classVariables := self copyDictionary: classVariables.	selectorCache := nil! !!VariableEnvironment methodsFor: 'accessing'!problemCount	^self numberVariables! !!VariableEnvironment methodsFor: 'accessing'!removeClass: aClass classVariable: aSymbol 	| vars |	vars := classVariables at: aClass name ifAbsent: [Set new].	vars remove: aSymbol ifAbsent: [].	vars isEmpty ifTrue: [classVariables removeKey: aClass name ifAbsent: []].	self flushCachesFor: aClass! !!VariableEnvironment methodsFor: 'accessing'!removeClass: aClass instanceVariable: aString 	| vars |	vars := instanceVariables at: aClass name ifAbsent: [Set new].	vars remove: aString ifAbsent: [].	vars isEmpty 		ifTrue: [instanceVariables removeKey: aClass name ifAbsent: []].	self flushCachesFor: aClass! !!VariableEnvironment methodsFor: 'accessing'!removeClass: aClass instanceVariableReader: aString 	| vars |	vars := instanceVariableReaders at: aClass name ifAbsent: [Set new].	vars remove: aString ifAbsent: [].	vars isEmpty 		ifTrue: [instanceVariableReaders removeKey: aClass name ifAbsent: []].	self flushCachesFor: aClass! !!VariableEnvironment methodsFor: 'accessing'!removeClass: aClass instanceVariableWriter: aString 	| vars |	vars := instanceVariableWriters at: aClass name ifAbsent: [Set new].	vars remove: aString ifAbsent: [].	vars isEmpty 		ifTrue: [instanceVariableWriters removeKey: aClass name ifAbsent: []].	self flushCachesFor: aClass! !!VariableEnvironment methodsFor: 'private'!selectorCache	^selectorCache isNil 		ifTrue: [selectorCache := Dictionary new]		ifFalse: [selectorCache]! !!VariableEnvironment methodsFor: 'private'!selectorCacheFor: aClass 	^self selectorCache at: aClass		ifAbsentPut: [self computeSelectorCacheFor: aClass]! !!VariableEnvironment methodsFor: 'printing'!storeOn: aStream 	aStream		nextPut: $(;		nextPutAll: self class name;		nextPutAll: ' new '.	#(#instanceVariables #instanceVariableReaders #instanceVariableWriters #classVariables) 		do: 			[:each | 			aStream				nextPutAll: each;				nextPutAll: ': '.			(self perform: each) storeOn: aStream.			aStream nextPutAll: '; '].	aStream nextPutAll: ' yourself)'! !!FinderTool commentStamp: 'nk 2/25/2005 10:53' prior: 0!To match unknown code, use "Jokers" (explained below) that start with a ` , like the `@Expression in the example.That Joker will match any expression: 3 halt and (3 + 4) halt both match.The condition (second) paneBeyond the pattern match in the top pane, the expression found is also checked against a test condition in the second pane. Within that condition, aNode is set to each node that matches the pattern. If that pane is empty, the default pattern is true which is equivalent to this test block:[:aNode | true]Edit the second pane to make the test block more selective.See below for a quick reference to the node accessors and some tests.Browse RBProgramNode and subclasses to see what other tests they support.Joker referenceAll of the wild-card patterns used in the FinderTool start with a ` character. They include:`#literal		matches any literal (#(), #foo, 1, etc.)`@	(list of...) When applied to a variable node, this will match a literal, variable, or a sequence of messages sent to a literal or variable.When applied to a keyword in a message, it will match a list of keyword messages (i.e., any message send).When applied with a statement character, it will match a list of statements.	| `@Temps |				matches list of temps	`@.Statements			matches list of statements	`@object					matches any message node, literal node or block node	foo `@message: `@args	matches any message sent to foo`.Statement				matches a single statement in a sequence node`@.Statements			matches list of statements in a sequence node`		(recurse into)Whenever a match is found, look inside this matched node for more matches.	``@object foo				matches foo sent to any object, plus for each match found look for more matches in the ``@object part`{ :node :context | code }		Abitrary code; matches if code returns true. Block is passed the node being examined, and a Dictionary that can be used to hold context. The context is reset every method.For more information on Joker, aka meta-variables, see this page on the rewrite rule editor, with whom this tool shares much logic. http://st-www.cs.uiuc.edu/users/brant/Refactory/Rewrite.htmlTest condition quick referenceBrowse RBProgramNode and subclasses to see what other tests the nodes support.accessors:allArgumentVariables allDefinedVariables allTemporaryVariables asReturn blockVariables children comments comments: formattedCode formatterClass parent parent: precedence sentMessages source sourceInterval start stop temporaryVariablestests:isList isPatternNode assigns: containedBy: containsReturn defines: directlyUses: evaluatedFirst: intersectsInterval: isAssignment isBlock isCascade isDirectlyUsed isEvaluatedFirst isImmediate isLast: isLiteral isMessage isMethod isReturn isSequence isUsed isValue isVariable lastIsReturn references: uses:!!FinderTool class methodsFor: 'class initialization' stamp: 'nk 2/25/2005 10:16'!initialize	"self initialize"	TheWorldMenu unregisterOpenCommandWithReceiver: self.	TheWorldMenu registerOpenCommand: {'Code Finder'. {self. #open}}.	self registerInFlapsRegistry.! !!FinderTool class methodsFor: 'instance creation' stamp: 'nk 2/25/2005 10:54'!jokerHelp	^'This tool searches for code matching the pattern in the top pane.', self comment! !!FinderTool class methodsFor: 'instance creation' stamp: 'nk 2/25/2005 09:32'!onBrowserEnvironment: anEvironment	^self new searchEnvironment: anEvironment! !!FinderTool class methodsFor: 'instance creation' stamp: 'dvf 9/28/2001 23:31'!onClass: aClass	^self new searchEnvironment: (BrowserEnvironment new forClasses: {aClass}).! !!FinderTool class methodsFor: 'instance creation' stamp: 'dvf 9/29/2001 00:03'!onClassCategory: aClassCategory	^self new searchEnvironment: (BrowserEnvironment new forCategories: {aClassCategory}).! !!FinderTool class methodsFor: 'instance creation' stamp: 'nk 2/25/2005 07:43'!onClassHierarchyIncluding: aClass	| classes |	classes := Set new.	aClass withAllSubAndSuperclassesDo: [ :cls | classes add: cls ].	^self new searchEnvironment: (BrowserEnvironment new forClasses: classes).! !!FinderTool class methodsFor: 'instance creation' stamp: 'nk 3/4/2005 13:36'!onPackageWithClassCategory: aClassCategory	^self new searchEnvironment: ((BrowserEnvironment new forPackageContainingClassCategory: aClassCategory) ifNil: [ ^nil ])! !!FinderTool class methodsFor: 'instance creation' stamp: 'dvf 8/27/2003 14:50'!open	self new openAsMorph! !!FinderTool class methodsFor: 'instance creation' stamp: 'nk 2/25/2005 10:14'!prototypicalToolWindow	^(self new createMorphicWindow) extent: 400@400; yourself.! !!FinderTool class methodsFor: 'class initialization' stamp: 'nk 2/25/2005 10:17'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(#FinderTool #prototypicalToolWindow 'Finder Tool' 'For finding advanced patterns in code' ) 						forFlapNamed: 'Tools']! !!FinderTool class methodsFor: 'initialize-release' stamp: 'nk 2/25/2005 10:19'!unload	TheWorldMenu unregisterOpenCommandWithReceiver: self.	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!FinderTool class methodsFor: 'as yet unclassified' stamp: 'nk 2/27/2005 14:56'!windowColorSpecification	^RefactoringBrowser windowColorSpecification! !!FinderTool methodsFor: 'user interface' stamp: 'nk 2/25/2005 10:26'!addModelItemsToWindowMenu: aMenu	super addModelItemsToWindowMenu: aMenu.	^aMenu		addLine;		add: 'select classes to operate on' target: self action: #chooseClasses;		yourself.! !!FinderTool methodsFor: 'user interface' stamp: 'nk 2/27/2005 15:42'!canSearch	^searchEnvironment isEmpty not ! !!FinderTool methodsFor: 'class membership' stamp: 'nk 2/27/2005 13:48'!chooseClasses	| newEnvironment |	newEnvironment := CategoryAndClassSelector new getClassEnvironmentFromUser.	newEnvironment isEmpty ifFalse: [self searchEnvironment: newEnvironment]! !!FinderTool methodsFor: 'menus' stamp: 'nk 3/1/2005 07:35'!codePaneMenu: aMenu shifted: shifted	"Note that unless we override perform:orSendTo:, PluggableTextController will respond to all menu items in a text pane"	| donorMenu |	donorMenu := shifted		ifTrue:			[ParagraphEditor shiftedYellowButtonMenu]		ifFalse:			[ParagraphEditor yellowButtonMenu].	^ aMenu labels: donorMenu labelString lines: donorMenu lineArray selections: donorMenu selections! !!FinderTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 13:00'!commentPaneFrame	^0 @ 0.4 corner: 1 @ 0.9! !!FinderTool methodsFor: 'accessing' stamp: 'dvf 9/22/2001 15:42'!conditionString	^conditionString! !!FinderTool methodsFor: 'accessing' stamp: 'nk 2/24/2005 14:39'!conditionString: anObject	conditionString := anObject.	foundEnvironment := nil.	self changed: #conditionString.	^true! !!FinderTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 13:00'!conditionsPaneFrame	^0 @ 0.2 corner: 1.0 @ 0.4! !!FinderTool methodsFor: 'initialization' stamp: 'nk 8/13/2003 16:39'!createConditionBlock	^self conditionString isEmpty 		ifFalse: [Compiler evaluate: '[ :aNode | ' , conditionString , ' ]' for: self logged: false ]		ifTrue: [[:aNode | true]]! !!FinderTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:28'!createMorphicWindow	| conditionsPane searchStringPane window |	window := (SystemWindow labelled: self labelString) model: self.	searchStringPane := PluggableTextMorph 				on: self				text: #searchPatternString				accept: #searchString:				readSelection: nil				menu: #codePaneMenu:shifted:.	window addMorph: searchStringPane frame: self searchStringPaneFrame.	conditionsPane := PluggableTextMorph 				on: self				text: #conditionString				accept: #conditionString:				readSelection: nil				menu: #codePaneMenu:shifted:.	window addMorph: conditionsPane frame: self conditionsPaneFrame.	window addMorph: (PluggableTextMorph 				on: self class				text: #jokerHelp				accept: nil				readSelection: nil				menu: nil)		frame: self commentPaneFrame.	window addMorph: ((PluggableButtonMorph 				on: self				getState: #canSearch				action: #searchAndOpenEditor)				label: 'Search';				onColor: self defaultBackgroundColor lighter					offColor: self defaultBackgroundColor darker)		frame: self searchButtonFrame.	window addMorph: self methodCheckBoxPane frame: self methodCheckBoxFrame.	^window! !!FinderTool methodsFor: 'initialization' stamp: 'nk 3/5/2005 16:54'!defaultExpressionSearchString	^'`@Expression halt'! !!FinderTool methodsFor: 'initialization' stamp: 'nk 3/5/2005 16:58'!defaultMethodSearchString	^'`methodName: `@args	| `@temps |	^`@Expression'! !!FinderTool methodsFor: 'initialization' stamp: 'nk 3/5/2005 16:58'!defaultSearchString	^self searchMethods ifTrue: [ self defaultMethodSearchString ] ifFalse: [ self defaultExpressionSearchString ].! !!FinderTool methodsFor: 'accessing' stamp: 'nk 1/6/2004 12:56'!foundEnvironment	^foundEnvironment! !!FinderTool methodsFor: 'accessing' stamp: 'nk 1/6/2004 12:56'!foundEnvironment: anObject	foundEnvironment := anObject! !!FinderTool methodsFor: 'initialization' stamp: 'nk 3/5/2005 16:55'!initialize	conditionString := 'true'.	self searchEnvironment: BrowserEnvironment new.	searchMethods := false.	searchString := self defaultSearchString.! !!FinderTool methodsFor: 'accessing' stamp: 'nk 2/25/2005 10:36'!labelString	^self class name, ' on ', self searchEnvironment printString! !!FinderTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:29'!methodCheckBoxFrame	^0.5 @ 0.9 corner: 1 @ 1! !!FinderTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:53'!methodCheckBoxPane	^(AlignmentMorph newRow)		cellInset: 4;		listCentering: #center;		wrapCentering: #center;		addMorph: ((UpdatingThreePhaseButtonMorph checkBox)					target: self;					getSelector: #searchMethods;					actionSelector: #toggleSearchMethods);		addMorph: (TextMorph new contentsAsIs: 'Search Entire Methods' translated);		yourself! !!FinderTool methodsFor: 'user interface' stamp: 'nk 2/27/2005 15:43'!openAsMorph	"self new openAsMorph"	| window |	window := self createMorphicWindow.	self changed: #canSearch.	window		center: Display center;		extent: 100 @ 100.	window openInWorld.	^window! !!FinderTool methodsFor: 'actions' stamp: 'nk 2/24/2005 14:42'!search	| env |	self dependents 		do: [:dep | (dep respondsTo: #accept) ifTrue: [dep hasUnacceptedEdits ifTrue: [ dep accept]]].	([ self searchEnabled ] on: Error do: [ :ex | ex return: false ])		ifFalse: [ ^self inform: 'bad search string' ].	Cursor wait showWhile: 			[ env := (self searchFor: searchString asString				when: (self createConditionBlock ifNil: [^self flash])).				self foundEnvironment: env ]! !!FinderTool methodsFor: 'actions' stamp: 'nk 2/24/2005 14:41'!searchAndOpenEditor	self search.	self foundEnvironment ifNotNilDo: [ :env | env openEditor ]! !!FinderTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:16'!searchButtonFrame	^0 @ 0.9 corner: 0.5 @ 1! !!FinderTool methodsFor: 'testing' stamp: 'nk 3/5/2005 16:43'!searchEnabled	^self searchMethods 		ifTrue: [(RBParser parseRewriteMethod: searchString) notNil]		ifFalse: [(RBParser parseRewriteExpression: searchString) notNil]! !!FinderTool methodsFor: 'accessing' stamp: 'dvf 9/27/2001 18:40'!searchEnvironment	^searchEnvironment! !!FinderTool methodsFor: 'accessing' stamp: 'nk 2/25/2005 10:35'!searchEnvironment: anObject	searchEnvironment := anObject.	foundEnvironment := nil.	self changed: #relabel.! !!FinderTool methodsFor: 'actions' stamp: 'nk 3/5/2005 16:41'!searchFor: pattern when: conditionalBlock 	| newEnv searches selector |	newEnv := SelectorEnvironment onEnvironment: BrowserEnvironment new.	searches := Set new.	selector := self searchMethods				ifTrue: [#replaceMethod:withValueFrom:when:]				ifFalse: [#replace:withValueFrom:when:].	searchEnvironment classesAndSelectorsDo: 			[:currentClass :currentSelector | 			| methodTree |			searchClass := currentClass.			methodTree := currentClass parseTreeFor: currentSelector.			methodTree ifNotNil: 					[(ParseTreeRewriter new 						perform: selector						with: pattern						with: 							[:tree | 							searches 								add: ((currentClass sourceCodeAt: currentSelector) copyFrom: tree start										to: tree stop).							newEnv addClass: currentClass selector: currentSelector.							tree]						with: conditionalBlock) executeTree: methodTree]].	searchClass := nil.	newEnv searchStrings: searches.	^newEnv! !!FinderTool methodsFor: 'accessing' stamp: 'nk 3/5/2005 16:19'!searchMethods	^searchMethods! !!FinderTool methodsFor: 'accessing' stamp: 'nk 3/5/2005 16:19'!searchMethods: anObject	searchMethods := anObject! !!FinderTool methodsFor: 'accessing' stamp: 'nk 3/1/2005 07:32'!searchPatternString	^searchString! !!FinderTool methodsFor: 'accessing' stamp: 'dvf 9/22/2001 15:42'!searchString	^searchString! !!FinderTool methodsFor: 'accessing' stamp: 'nk 3/1/2005 07:33'!searchString: aString	searchString := aString.	foundEnvironment := nil.	self changed: #searchPatternString.	^true! !!FinderTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 12:59'!searchStringPaneFrame	^0 @ 0 corner: 1.0 @ 0.2! !!FinderTool methodsFor: 'accessing' stamp: 'nk 3/5/2005 16:56'!toggleSearchMethods	| wasDefault |	wasDefault := self searchString = self defaultSearchString.	searchMethods := searchMethods not.	wasDefault ifTrue: [self searchString: self defaultSearchString]! !!RewriteTool commentStamp: 'nk 2/25/2005 10:59' prior: 0!This tool searches for code matching the pattern in the top pane that satisfies the condition in the second pane, and lets you replace the found code patterns with the replacement pattern in the bottom pane.You will be shown the potential changes to the code, and you can choose which of them to actually use.You may use Jokers (explained below) defined in the top pane in the replacement text in the bottom pane. These will refer to whatever the corresponding Joker matched.So if you search for:	`@something foo: `@argsand replace it with:	`@something bar: `@argsthen every call to #foo: will be replaced by a call to #bar:.!!RewriteTool class methodsFor: 'class initialization' stamp: 'nk 2/25/2005 10:10'!initialize	TheWorldMenu registerOpenCommand: {'Rewrite Tool'. {self. #open}}.	self registerInFlapsRegistry.! !!RewriteTool class methodsFor: 'instance creation' stamp: 'nk 2/25/2005 10:59'!jokerHelp	^self comment, FinderTool comment! !!RewriteTool class methodsFor: 'class initialization' stamp: 'nk 2/25/2005 10:10'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(#RewriteTool #prototypicalToolWindow 'Rewrite Tool' 'For doing advanced edits to code' ) 						forFlapNamed: 'Tools']! !!RewriteTool class methodsFor: 'initialize-release' stamp: 'nk 2/25/2005 10:19'!unload	TheWorldMenu unregisterOpenCommandWithReceiver: self.	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 13:06'!commentPaneFrame	^0 @ 0.4 corner: 1 @ 0.7! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 13:03'!conditionsPaneFrame	^0 @ 0.2 corner: 1.0 @ 0.4! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 3/1/2005 07:36'!createMorphicWindow	| window replacementPane |	window := super createMorphicWindow.	replacementPane := PluggableTextMorph 				on: self				text: #replacementString				accept: #replacementString:				readSelection: nil				menu: #codePaneMenu:shifted:.	window addMorph: replacementPane frame: self replacementPaneFrame.	window addMorph: ((PluggableButtonMorph 				on: self				getState: nil				action: #replace)				label: 'Replace';				onColor: Color white offColor: Color lightGray)		frame: self replaceButtonFrame.	^window! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 2/23/2005 17:55'!fileOutSource: source onStream: stream forMethodNamed: methodName inCategory: protocol forClassNamed: className 	stream		nextPut: $!!;		nextPutAll: className;		nextPutAll: ' methodsFor: ''';		nextPutAll: protocol;		nextPutAll: ''' stamp: ';		print: Utilities changeStamp;		nextPut: $!!;		cr;		nextPutAll: (source copyReplaceAll: '!!' with: '!!!!');		nextPutAll: '!! !!'! !!RewriteTool methodsFor: 'initialization' stamp: 'nk 3/1/2005 07:33'!initialize	super initialize.	replacementString := self searchPatternString.! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:31'!methodCheckBoxFrame	^0.6 @ 0.9 corner: 1 @ 1! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 3/1/2005 07:33'!replace	| rewriteRule compiledMethod changes organizer |	self foundEnvironment ifNil: [ self search ].	rewriteRule := ParseTreeRewriter new.	rewriteRule replace: self searchPatternString asString		with: self replacementString asString.	changes := String streamContents: 					[:stream | 					stream						header;						timeStamp;						nextPutAll: '"This is the result of replacing';						cr;						nextPutAll: self searchString asString;						cr;						nextPutAll: 'with';						cr;						nextPutAll: self replacementString asString;						nextPutAll: '"!!'.					self foundEnvironment classesAndSelectorsDo: 							[:cls :sel | 							organizer := cls organization.							compiledMethod := cls compiledMethodAt: sel.							(rewriteRule canMatchMethod: compiledMethod) 								ifTrue: 									[(rewriteRule executeTree: compiledMethod parseTree) 										ifTrue: 											[stream cr.											self 												fileOutSource: rewriteRule tree printString												onStream: stream												forMethodNamed: sel												inCategory: (organizer categoryOfElement: sel)												forClassNamed: cls name]]]].	FileContentsBrowser browseStream: changes readStream		named: 'Prospective replacements'! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:31'!replaceButtonFrame	^0.3 @ 0.9 corner: 0.6 @ 1! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 2/23/2005 11:48'!replaceEnabled	^foundEnvironment notNil! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 13:06'!replacementPaneFrame	^0 @ 0.7 corner: 1.0 @ 0.9! !!RewriteTool methodsFor: 'accessing' stamp: 'nk 1/6/2004 13:07'!replacementString	^replacementString! !!RewriteTool methodsFor: 'accessing' stamp: 'nk 2/23/2005 13:35'!replacementString: anObject	replacementString := anObject.	self changed: #replacementString.	^true! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 3/5/2005 16:32'!searchButtonFrame	^0 @ 0.9 corner: 0.3 @ 1! !!RewriteTool methodsFor: 'user interface' stamp: 'nk 1/6/2004 13:03'!searchStringPaneFrame	^0 @ 0 corner: 1.0 @ 0.2! !!BasicLintRule class methodsFor: 'accessing'!addFilter: anEnvironment for: aString 	self filterDictionary at: aString put: anEnvironment copy! !!BasicLintRule class methodsFor: 'accessing'!filterDictionary	^FilterDictionary isNil 		ifTrue: [FilterDictionary := Dictionary new]		ifFalse: [FilterDictionary]! !!BasicLintRule class methodsFor: 'accessing'!filterDictionary: aDictionary 	FilterDictionary := aDictionary! !!BasicLintRule class methodsFor: 'accessing'!filterFor: aName 	^self filterDictionary at: aName ifAbsentPut: [SelectorEnvironment new]! !!BasicLintRule class methodsFor: 'accessing'!protocols	^#('bugs' 'possible bugs' 'unnecessary code' 'intention revealing' 'miscellaneous')! !!BasicLintRule class methodsFor: 'storing'!storeFiltersOn: aStream 	aStream		nextPut: $(;		nextPutAll: self name;		nextPutAll: ' filterDictionary: (Dictionary new'.	self filterDictionary keysAndValuesDo: 			[:key :value | 			aStream nextPutAll: ' at: '.			key storeOn: aStream.			aStream nextPutAll: ' put: '.			value storeOn: aStream.			aStream				nextPutAll: ';';				cr].	aStream		tab;		nextPutAll: 'yourself))'! !!BasicLintRule methodsFor: 'private'!defaultResultClass	^SelectorEnvironment! !!BasicLintRule methodsFor: 'accessing'!filteredResult	^(result 		& (self class filterDictionary at: self name ifAbsent: [result copyEmpty]) 				copy not)		label: result label;		yourself! !!BasicLintRule methodsFor: 'initialize-release'!initialize	super initialize.	openSymbol := #openWithFilters.	self resultClass: self defaultResultClass! !!BasicLintRule methodsFor: 'testing'!isEmpty	^self result isEmpty! !!BasicLintRule methodsFor: 'initialize-release'!openUsing: aSymbol 	openSymbol := aSymbol! !!BasicLintRule methodsFor: 'private' stamp: 'dvf 9/8/2001 20:00'!openWithFilters	| browser navigator menuItem filter |	self needsWork.	browser := self filteredResult openEditor.	navigator := browser navigator.	filter := navigator environment andedEnvironment environment.	(filter isClassEnvironment or: [filter isSelector]) 		ifTrue: 			[menuItem := MenuItem labeled: 'add filter for class'.			menuItem value: 					[(BasicLintRule filterFor: self name) addClass: navigator selectedClass.					filter addClass: navigator selectedClass.					navigator updateCategoryList].			navigator classMenu value addItemGroup: (Array with: menuItem).			navigator updateClassMenu].	filter isSelector 		ifTrue: 			[menuItem := MenuItem labeled: 'add filter for selector'.			menuItem value: 					[(BasicLintRule filterFor: self name) addClass: navigator selectedClass						selector: navigator selector.					filter addClass: navigator selectedClass selector: navigator selector.					navigator updateCategoryList].			navigator selectorMenu value addItemGroup: (Array with: menuItem).			navigator updateSelectorMenu].	^browser! !!BasicLintRule methodsFor: 'private' stamp: 'bh 5/9/2000 00:16'!openWithoutFilters	^self result openEditor! !!BasicLintRule methodsFor: 'accessing'!problemCount	^self result problemCount! !!BasicLintRule methodsFor: 'initialize-release'!resetResult	result := result copyEmpty.	result label: name! !!BasicLintRule methodsFor: 'accessing'!result	^(self class filterDictionary includesKey: self name) 		ifTrue: [self filteredResult]		ifFalse: [result]! !!BasicLintRule methodsFor: 'initialize-release'!result: aResult 	result := aResult copyEmpty! !!BasicLintRule methodsFor: 'initialize-release'!resultClass: aClass 	result := aClass new! !!BasicLintRule methodsFor: 'private' stamp: 'bh 5/9/2000 00:16'!viewResults	^self perform: openSymbol! !!BlockLintRule class methodsFor: 'possible bugs'!abstractClass	| detector subclassResponsibilitySymbol |	detector := self new.	detector name: 'References an abstract class'.	detector resultClass: ClassEnvironment.	subclassResponsibilitySymbol := 'subclassResponsibility' asSymbol.	detector classBlock: 			[:context :result | 			(context selectedClass whichSelectorsReferTo: subclassResponsibilitySymbol)				isEmpty ifFalse: 						[(context							uses: (Smalltalk associationAt: context selectedClass name ifAbsent: [nil]))								ifTrue: [result addClass: context selectedClass]]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs'!addRemoveDependents	| detector |	detector := self new.	detector resultClass: ClassEnvironment.	detector name: 'Number of addDependent: messages > removeDependent:'.	detector classBlock: 			[:context :result | 			| count |			count := 0.			((Set				withAll: (context selectedClass whichSelectorsReferTo: #addDependent:))					addAll: (context selectedClass whichSelectorsReferTo: #removeDependent:);				yourself) do: 					[:sel | 					(context selectedClass compiledMethodAt: sel) messagesDo: 							[:each | 							each == #addDependent: ifTrue: [count := count + 1].							each == #removeDependent: ifTrue: [count := count - 1]]].			count > 0 ifTrue: [result addClass: context selectedClass]].	^detector! !!BlockLintRule class methodsFor: 'miscellaneous'!badMessage	| detector badMessages |	detector := self new.	detector name: 'Sends "questionable" message'.	badMessages := self badSelectors.	detector classBlock: 			[:context :result | 			| selectors |			selectors := badMessages inject: Set new						into: 							[:set :each | 							set addAll: (context selectedClass whichSelectorsReferTo: each);								yourself].			selectors do: [:each | result addClass: context selectedClass selector: each].			selectors isEmpty ifFalse: [result searchStrings: badMessages]].	^detector! !!BlockLintRule class methodsFor: 'private'!badSelectors	^#(#become: #isKindOf: #changeClassToThatOf: #respondsTo: #isMemberOf: #performMethod: #performMethod:arguments: #performMethod:with: #performMethod:with:with: #performMethod:with:with:with: #allOwners #allOwnersWeakly: #firstOwner #instVarAt: #instVarAt:put: #nextInstance #nextObject #ownerAfter: #primBecome:  #halt)! !!BlockLintRule class methodsFor: 'possible bugs'!classInstVarNotInitialized	| detector |	detector := self new.	detector name: 'Has class instance variables but no initialize method'.	detector resultClass: ClassEnvironment.	detector classBlock: 		[:context :result | 		| definesVar class |		context selectedClass isMeta			ifTrue: 				[class := context selectedClass.				definesVar := false.				[definesVar or: [class isNil or: [class isMeta not]]]					whileFalse: 						[definesVar := class instVarNames isEmpty not.						class := class superclass].				(definesVar and: [(context selectedClass includesSelector: #initialize) not])					ifTrue: [result addClass: context selectedClass]]].	^detector! !!BlockLintRule class methodsFor: 'miscellaneous'!classNameInSelector	| detector |	detector := self new.	detector name: 'Redundant class name in selector'.	detector methodBlock: 			[:context :result | 			(context selectedClass isMeta and: 					[(context selector						indexOfSubCollection: context selectedClass soleInstance name						startingAt: 1) > 0])				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'unnecessary code'!classNotReferenced	| detector |	detector := self new.	detector name: 'Class not referenced'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			(context selectedClass isMeta				or: [context selectedClass subclasses isEmpty not])					ifFalse: 						[| assoc |						assoc := Smalltalk associationAt: context selectedClass name.						((context uses: assoc) or: [context uses: context selectedClass name])							ifFalse: 								[result addClass: context selectedClass;									addClass: context selectedClass class]]].	^detector! !!BlockLintRule class methodsFor: 'private'!classShouldNotOverride	^#(#== #class)! !!BlockLintRule class methodsFor: 'possible bugs'!collectionCopyEmpty	| detector |	detector := self new.	detector		name: 'Subclass of collection that has instance variable but doesn''t define copyEmpty'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			(context selectedClass isVariable 					and: [(context selectedClass includesSelector: #copyEmpty:) not 						and: [context selectedClass instVarNames isEmpty not							and: [context selectedClass inheritsFrom: Collection]]])				ifTrue: [result addClass: context selectedClass]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'nk 2/25/2005 11:37'!definesEqualNotHash	| detector |	detector := self new.	detector name: 'Defines = but not hash'.	detector rationale: 'If objects of a class redefine equality, then to work properly in hashed collections like Sets or Dictionaries they must also have a hash method that returns equal hashes for each pair of objects for which = returns true.'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			((context selectedClass includesSelector: #=)				and: [(context selectedClass includesSelector: #hash) not])				ifTrue: [result addClass: context selectedClass]].	^detector! !!BlockLintRule class methodsFor: 'private'!doesLiteralArrayContainComma: aLiteral 	aLiteral class == Array ifFalse: [^false].	(aLiteral includes: #,) ifTrue: [^true].	^aLiteral inject: false		into: [:sum :each | sum or: [self doesLiteralArrayContainComma: each]]! !!BlockLintRule class methodsFor: 'unnecessary code'!equivalentSuperclassMethods	| detector |	detector := self new.	detector name: 'Methods equivalently defined in superclass'.	detector methodBlock: 			[:context :result | 			context selectedClass superclass notNil ifTrue: 					[(context selectedClass superclass canUnderstand: context selector)						ifTrue: 							[(((context selectedClass superclass								whichClassIncludesSelector: context selector)									compiledMethodAt: context selector)									equivalentTo: context compiledMethod)									ifTrue: [result addClass: context selectedClass selector: context selector]]]].	^detector! !!BlockLintRule class methodsFor: 'unnecessary code'!implementedNotSent	| detector |	detector := self new.	detector name: 'Methods implemented but not sent'.	detector methodBlock: 			[:context :result | 			(context uses: context selector)				ifFalse: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'miscellaneous'!instVarInSubclasses	| detector |	detector := self new.	detector		name: 'Instance variables defined in all subclasses';		resultClass: VariableEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| subs |			subs := context selectedClass subclasses.			subs size > 1 				ifTrue: 					[| sels |					sels := Bag new.					subs do: [:each | sels addAll: each instVarNames].					sels asSet do: 							[:val | 							| count |							count := sels occurrencesOf: val.							count == subs size 								ifTrue: [result addClass: context selectedClass instanceVariable: val]]]].	^detector! !!BlockLintRule class methodsFor: 'unnecessary code'!justSendsSuper	| detector matcher |	detector := self new.	detector name: 'Method just sends super message'.	matcher := ParseTreeSearcher justSendsSuper.	detector methodBlock: 			[:context :result | 			(context parseTree isPrimitive not 				and: [matcher executeMethod: context parseTree initialAnswer: false]) 					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'md 8/2/2005 23:20'!literalArrayContainsComma	| detector |	detector := self new.	detector name: 'Literal array contains a #,'.	detector methodBlock: 			[:context :result | 			(context compiledMethod allLiterals inject: false				into: [:sum :each | sum or: [self doesLiteralArrayContainComma: each]]) 					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'md 8/2/2005 23:20'!literalArrayContainsSuspiciousTrueFalseOrNil	| detector searcher |	detector := self new.	detector 		name: 'Literal array contains a #true, #false, or #nil but the source doesn''t.'.	detector 		rationale: 'With ANSI changes, #(true false nil) now is equal to {true. false. nil} not {#true. #false. #nil} as it used to be.This may be a bug.'.	searcher := ParseTreeSearcher new.	searcher 		matches: '`{ :n | n isLiteral and: [ n token realValue isKindOf: Array ] }'		do: 			[:aNode :answer | 			answer 				addAll: (self literalTrueFalseOrNilSymbolsIn: aNode token realValue);				yourself].	detector methodBlock: 			[:context :result | 			| compiledLits parsedLits |			compiledLits := self 						literalTrueFalseOrNilSymbolsIn: context compiledMethod allLiterals.			compiledLits size > 0 				ifTrue: 					[parsedLits := OrderedCollection new.					searcher executeTree: context parseTree initialAnswer: parsedLits.					compiledLits size ~= parsedLits size 						ifTrue: 							[ result addClass: context selectedClass selector: context selector]]].	^detector! !!BlockLintRule class methodsFor: 'private' stamp: 'nk 3/4/2005 16:32'!literalTrueFalseOrNilSymbolsIn: aLiteral 	| retval |	aLiteral class == Array ifFalse: [^#()].	retval := OrderedCollection withAll: (aLiteral select: [:ea | ea isSymbol and: [#(#true #false #nil ) includes: ea]]).	aLiteral do: [ :each | retval addAll: (self literalTrueFalseOrNilSymbolsIn: each) ].	^retval.! !!BlockLintRule class methodsFor: 'private'!longMethodSize	^10! !!BlockLintRule class methodsFor: 'miscellaneous' stamp: 'bh 3/16/2000 12:06'!longMethods	| detector matcher |	detector := self new.	detector name: 'Long methods'.	matcher := ParseTreeSearcher new.	matcher matches: '`.Stmt'		do: 			[:aNode :answer | 			(aNode children inject: answer				into: [:sum :each | matcher executeTree: each initialAnswer: sum]) + 1].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: 0) 				>= self longMethodSize 					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'private'!metaclassShouldNotOverride	^#(#name #comment)! !!BlockLintRule class methodsFor: 'squeak bugs' stamp: 'nk 2/26/2005 10:05'!methodHasNoTimeStamp	| detector |	detector := self new.	detector name: 'Method has no timeStamp'.	detector rationale: 'For proper versioning, every method should have a timestamp.'.	detector methodBlock: 			[:context :result | 			context compiledMethod timeStamp isEmpty					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'squeak bugs' stamp: 'nk 2/26/2005 10:19'!methodSourceContainsLinefeeds	| detector |	detector := self new.	detector name: 'Method source contains linefeeds'.	detector rationale: 'Squeak code should not contain linefeed characters.'.	detector methodBlock: 			[:context :result | 			(context sourceCode includes: Character lf)					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'intention revealing'!missingSubclassResponsibility	| detector |	detector := self new.	detector		name: 'Method defined in all subclasses, but not in superclass';		resultClass: MultiEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| subs |			subs := context selectedClass subclasses.			subs size > 1 & context selectedClass isMeta not 				ifTrue: 					[| sels |					sels := Bag new.					subs do: [:each | sels addAll: each selectors].					sels asSet do: 							[:each | 							((sels occurrencesOf: each) == subs size 								and: [(context selectedClass canUnderstand: each) not]) 									ifTrue: 										[| envName |										envName := context selectedClass name , '>>' , each.										subs do: 												[:subClass | 												result 													addClass: subClass													selector: each													into: envName]]]]].	^detector! !!BlockLintRule class methodsFor: 'unnecessary code'!onlyReadOrWritten	| detector |	detector := self new.	detector		name: 'Instance variables not read AND written';		resultClass: VariableEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| isRead isWritten |					isRead := false.					isWritten := false.					allSubclasses detect: 							[:class | 							isRead ifFalse: [isRead := (class whichSelectorsRead: each) isEmpty not].							isWritten 								ifFalse: [isWritten := (class whichSelectorsAssign: each) isEmpty not].							isRead & isWritten]						ifNone: [result addClass: context selectedClass instanceVariable: each]]].	^detector! !!BlockLintRule class methodsFor: 'bugs'!overridesSpecialMessage	| detector |	detector := self new.	detector name: 'Overrides a "special" message'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			((context selectedClass isMeta				ifTrue: [self metaclassShouldNotOverride]				ifFalse: [self classShouldNotOverride]) detect: 						[:each | 						context selectedClass superclass notNil and: 								[(context selectedClass superclass canUnderstand: each)									and: [context selectedClass includesSelector: each]]]					ifNone: [nil]) notNil ifTrue: [result addClass: context selectedClass]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'nk 7/30/2004 12:18'!overridesSuper	| detector definer superMethod |	detector := self new.	detector name: 'Overrides super method without calling it'.	detector methodBlock: 			[:context :result | 			(context selectedClass isMeta not				and: [true "self superMessages includes: context selector"]) ifTrue: [					definer := context selectedClass superclass ifNotNilDo: [ :sc | sc whichClassIncludesSelector: context selector ].					definer ifNotNil: [ "super defines same method"						(context superMessages includes: context selector) ifFalse: [ "but I don't call it"							superMethod := (definer compiledMethodAt: context selector ifAbsent: []).							(superMethod isReturnSelf or: [ superMethod sendsSelector: #subclassResponsibility ])										ifFalse: [result addClass: context selectedClass selector: context selector] ]]]].	^detector! !!BlockLintRule class methodsFor: 'miscellaneous'!refersToClass	| detector |	detector := self new.	detector name: 'Refers to class name instead of "self class"'.	detector classBlock: 			[:context :result | 			| sels className |			className := (context selectedClass isMeta						ifTrue: [context selectedClass soleInstance]						ifFalse: [context selectedClass]) name.			sels := context selectedClass						whichSelectorsReferTo: (Smalltalk associationAt: className).			sels do: [:each | result addClass: context selectedClass selector: each].			sels isEmpty ifFalse: [result addSearchString: className]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'bh 4/2/2000 22:09'!returnsBooleanAndOther	| detector matcher |	detector := self new.	detector name: 'Returns a boolean and non boolean'.	matcher := ParseTreeSearcher new.	matcher matches: '^``@xObject'		do: 			[:aNode :answer | 			answer				add: aNode value;				yourself].	detector methodBlock: 			[:context :result | 			| hasBool hasSelf |			hasBool := false.			hasSelf := context parseTree lastIsReturn not.			(matcher executeTree: context parseTree initialAnswer: Set new) do: 					[:each | 					hasBool := hasBool or: 									[(each isLiteral and: [{true. false} includes: each value]) 										or: [each isMessage and: [#(#and: #or:) includes: each selector]]].					hasSelf := hasSelf or: 									[(each isVariable and: [each name = 'self']) 										or: [each isLiteral and: [({true. false} includes: each value) not]]]].			hasSelf & hasBool 				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs'!sendsDifferentSuper	| detector |	detector := self new.	detector name: 'Sends different super message'.	detector methodBlock: 			[:context :result | 			| message |			(message := context superMessages detect: [:each | each ~= context selector]						ifNone: [nil]) notNil ifTrue: 					[result addSearchString: message.					result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'bugs'!sentNotImplemented	| detector |	detector := self new.	detector name: 'Messages sent but not implemented'.	detector methodBlock: 			[:context :result | 			| message |			message := context messages detect: [:each | (context implements: each) not]						ifNone: [nil].			message isNil ifTrue: 					[message := context superMessages detect: 									[:each | 									context selectedClass superclass isNil										or: [(context selectedClass superclass canUnderstand: each) not]]								ifNone: [nil].					message isNil ifTrue: 							[message := context selfMessages										detect: [:each | (context selectedClass canUnderstand: each) not]										ifNone: [nil]]].			message notNil ifTrue: 					[result addSearchString: message.					result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'private'!subclassOf: aClass overrides: aSelector 	^(aClass subclasses detect: 			[:each | 			(each includesSelector: aSelector)				or: [self subclassOf: each overrides: aSelector]]		ifNone: [nil]) notNil! !!BlockLintRule class methodsFor: 'bugs'!subclassResponsibilityNotDefined	| detector subclassResponsibilitySymbol |	detector := self new.	detector name: 'Subclass responsibility not defined'.	subclassResponsibilitySymbol := 'subclassResponsibility' asSymbol.	detector classBlock: 			[:context :result | 			(context selectedClass whichSelectorsReferTo: subclassResponsibilitySymbol)				do: 					[:each | 					(context selectedClass withAllSubclasses detect: 							[:class | 							class subclasses isEmpty								and: [(class whichClassIncludesSelector: each) == context selectedClass]]						ifNone: [nil]) notNil						ifTrue: [result addClass: context selectedClass selector: each]]].	^detector! !!BlockLintRule class methodsFor: 'private'!superMessages	^#(#release #postCopy #postBuildWith: #preBuildWith: #postOpenWith: #noticeOfWindowClose: #initialize)! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'nk 7/30/2004 12:20'!superSends	| detector definer superMethod |	detector := self new.	detector name: 'Missing super sends in selected methods.'.	detector methodBlock: 			[:context :result | 			(context selectedClass isMeta not				and: [ self superMessages includes: context selector ]) ifTrue: [					definer := context selectedClass superclass ifNotNilDo: [ :sc | sc whichClassIncludesSelector: context selector ].					definer ifNotNil: [ "super defines same method"						(context superMessages includes: context selector) ifFalse: [ "but I don't call it"							superMethod := (definer compiledMethodAt: context selector ifAbsent: []).							(superMethod isReturnSelf or: [ superMethod sendsSelector: #subclassResponsibility ])										ifFalse: [result addClass: context selectedClass selector: context selector] ]]]].	^detector! !!BlockLintRule class methodsFor: 'squeak bugs' stamp: 'nk 7/30/2004 11:44'!superSendsNew	| detector matcher |	detector := self new.	detector name: 'Sends super new initialize'.	matcher := ParseTreeSearcher new.	matcher matchesAnyOf: #('super new initialize' '(super new: `@expr) initialize' 'self new initialize' '(self new: `@expr) initialize')		do: [ :aNode :answer | answer + 1 ].	detector methodBlock: [:context :result |		context selectedClass isMeta ifTrue: [			(matcher executeTree: context parseTree initialAnswer: 0) > 0 ifTrue: [ result addClass: context selectedClass selector: context selector]]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs'!tempVarOverridesInstVar	| detector matcher vars varName |	detector := self new.	detector name: 'Instance variable overridden by temporary variable'.	matcher := (ParseTreeSearcher new)				matchesArgument: '`xxxvar'					do: 						[:aNode :answer | 						answer or: 								[varName := aNode name.								vars includes: varName]];				yourself.	detector methodBlock: 			[:context :result | 			vars := context instVarNames.			(matcher executeTree: context parseTree initialAnswer: false) 				ifTrue: 					[result addClass: context selectedClass selector: context selector.					result addSearchString: varName]].	^detector! !!BlockLintRule class methodsFor: 'possible bugs' stamp: 'bh 3/16/2000 12:07'!tempsReadBeforeWritten	| detector |	detector := self new.	detector name: 'Temporaries read before written'.	detector methodBlock: 			[:context :result | 			(RBReadBeforeWrittenTester variablesReadBeforeWrittenIn: context parseTree) 				do: 					[:each | 					result addClass: context selectedClass selector: context selector.					result addSearchString: each]].	^detector! !!BlockLintRule class methodsFor: 'bugs'!undeclaredReference	| detector |	detector := self new.	detector name: 'References an undeclared variable'.	detector methodBlock: 			[:context :result | 			| undeclared |			undeclared := Undeclared associations detect: 							[:each | 							(context uses: each)								and: [context compiledMethod refersToLiteral: each]]						ifNone: [nil].			undeclared notNil ifTrue: 					[result addSearchString: undeclared key.					result addClass: context selectedClass selector: context selector]].	^detector! !!BlockLintRule class methodsFor: 'unnecessary code'!unreferencedVariables	| detector |	detector := self new.	detector		name: 'Variables not referenced';		resultClass: VariableEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					allSubclasses 						detect: [:class | (class whichSelectorsAccess: each) isEmpty not]						ifNone: [result addClass: context selectedClass instanceVariable: each]].			context selectedClass isMeta 				ifFalse: 					[context selectedClass classPool associationsDo: 							[:each | 							(context uses: each) 								ifFalse: [result addClass: context selectedClass classVariable: each key]]]].	^detector! !!BlockLintRule class methodsFor: 'bugs'!usesTrue	| detector trueBinding falseBinding |	detector := self new.	trueBinding := Smalltalk associationAt: #True.	falseBinding := Smalltalk associationAt: #False.	detector name: 'Uses True/False instead of true/false'.	detector methodBlock: 			[:context :result | 			| method |			method := context compiledMethod.			((method refersToLiteral: trueBinding)				or: [method refersToLiteral: falseBinding]) ifTrue: 						[result addClass: context selectedClass selector: context selector.						result searchStrings: #('True' 'False')]].	^detector! !!BlockLintRule class methodsFor: 'miscellaneous' stamp: 'bh 4/29/2000 23:31'!utilityMethods	| detector |	detector := self new.	detector name: 'Utility methods'.	self needsWork."	detector methodBlock: 			[:context :result | 			(context selectedClass isMeta | (context selector numArgs == 0) or: 					[(context protocols detect: 							[:each | 							(self utilityProtocols detect: [:protocol | protocol match: each]								ifNone: [nil]) notNil]						ifNone: [nil]) notNil]) 				ifFalse: 					[(self subclassOf: context selectedClass overrides: context selector) 						ifFalse: 							[(context superMessages isEmpty and: [context selfMessages isEmpty]) 								ifTrue: 									[(context selectedClass allInstVarNames 										, context selectedClass allClassVarNames asArray , #('self') 										detect: [:each | context parseTree references: each]										ifNone: [nil]) isNil 										ifTrue: [result addClass: context selectedClass selector: context selector]]]]]."	^detector! !!BlockLintRule class methodsFor: 'private'!utilityProtocols	"If a method is defined in one of these protocols, then don't check if its a utility method."	^#('*utilit*')! !!BlockLintRule class methodsFor: 'miscellaneous'!variableAssignedLiteral	| detector |	detector := self new.	detector		name: 'Variable is only assigned a single literal value';		resultClass: VariableEnvironment;		openUsing: #openWithoutFilters.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| defClass selector |					(allSubclasses inject: 0						into: 							[:sum :class | 							| sels |							sels := class whichSelectorsAssign: each.							sels size == 1 								ifTrue: 									[selector := sels asArray first.									defClass := class].							sum + sels size]) 							== 1 							ifTrue: 								[| tree searcher |								searcher := ParseTreeSearcher new.								searcher matches: each , ' := ``@object'									do: [:aNode :answer | answer isNil and: [aNode value isLiteral]].								tree := defClass parseTreeFor: selector.								tree notNil 									ifTrue: 										[(searcher executeTree: tree initialAnswer: nil) == true 											ifTrue: [result addClass: context selectedClass instanceVariable: each]]]]].	^detector! !!BlockLintRule class methodsFor: 'bugs' stamp: 'bh 5/1/2000 16:56'!variableNotDefined	| detector |	detector := self new.	detector name: 'Variable used, but not defined anywhere'.self needsWork."	detector methodBlock: [:context :result | context compiledMethod withAllBlockMethodsDo: [:each | each				literalsDo: [:lit | lit isVariableBinding						ifTrue: [((Smalltalk associationAt: lit key ifAbsent: [])								== lit or: [(Undeclared associationAt: lit key ifAbsent: [])									== lit])								ifFalse: [(context selectedClass fullBindingFor: lit key)										== lit										ifFalse: 											[result addClass: context selectedClass selector: context selector.											result addSearchString: lit key]]]]]]."	^ detector	! !!BlockLintRule class methodsFor: 'unnecessary code'!variableReferencedOnce	| detector |	detector := self new.	detector 		name: 'Variable referenced in only one method and always assigned first'.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| defClass selector |					(allSubclasses inject: 0						into: 							[:sum :class | 							| sels |							sels := class whichSelectorsAccess: each.							sels size == 1 								ifTrue: 									[selector := sels asArray first.									defClass := class].							sum + sels size]) 							== 1 							ifTrue: 								[| tree |								tree := defClass parseTreeFor: selector.								tree notNil 									ifTrue: 										[(RBReadBeforeWrittenTester isVariable: each writtenBeforeReadIn: tree) 											ifTrue: 												[result addClass: defClass selector: selector.												result addSearchString: each]]]]].	^detector! !!BlockLintRule methodsFor: 'accessing'!checkClass: aSmalllintContext 	^classBlock value: aSmalllintContext value: result! !!BlockLintRule methodsFor: 'accessing'!checkMethod: aSmalllintContext 	^methodBlock value: aSmalllintContext value: result! !!BlockLintRule methodsFor: 'initialize-release'!classBlock: aBlock	classBlock := aBlock! !!BlockLintRule methodsFor: 'initialize-release'!initialize	super initialize.	classBlock := [:context :aResult | ].	methodBlock := [:context :aResult | ]! !!BlockLintRule methodsFor: 'initialize-release'!methodBlock: aBlock	methodBlock := aBlock! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!asOrderedCollectionNotNeeded	^self 		createParseTreeRule: #('`@node addAll: `{:node | node isMessage and: [#(asOrderedCollection asArray) includes: node selector]}')		name: '#asOrderedCollection/#asArray not needed'! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!assignmentInBlock	^self createParseTreeRule: #(			'`@cursor showWhile: [| `@temps | `@.Statements1. `var := `@object]' 			'`@cursor showWhile: [| `@temps | `@.Statements1. ^`@object]' 			'[| `@temps | `@.Statements. `var := `@object] valueNowOrOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. ^`@object] valueNowOrOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. `var := `@object] valueOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. ^`@object] valueOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. `var := `@object] ensure: `@block' 			'[| `@temps | `@.Statements. ^`@object] ensure: `@block' 			'[| `@temps | `@.Statements. `var := `@object] ifCurtailed: `@block' 			'[| `@temps | `@.Statements. ^`@object] ifCurtailed: `@block' ) 		name: 'Unnecessary assignment or return in block'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!assignmentInIfTrue	^self createParseTreeRule: 			#('`@boolean 					ifTrue: [| `@temps1 | `@.Statements1. `var := `@object1] 					ifFalse: [| `@temps2 | `@.Statements2. `var := `@object2]' 			'`@boolean 					ifFalse: [| `@temps1 | `@.Statements1. `var := `@object1] 					ifTrue: [| `@temps2 | `@.Statements2. `var := `@object2]') 		name: 'Assignment to same variable and end of ifTrue:ifFalse: blocks'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!atIfAbsent	^self createParseTreeRule: 				#('`@object 						at: `@atArg 						ifAbsent: [| `@temps | `@.Statements. `@object at: `@atArg put: `@putArg]' 				'`@object 						at: `@atArg 						ifAbsent: [| `@temps | 								`@.Statements. 								`@object at: `@atArg put: `@putArg. 								`@.xStatements1. 								`@putArg]') 		name: 'Uses at:ifAbsent: instead of at:ifAbsentPut:'! !!ParseTreeLintRule class methodsFor: 'bugs'!booleanPrecedence	^self createParseTreeRule: 			#('`@object1 | `@object2 = `@object3'			'`@object1 | `@object2 == `@object3'			'`@object1 & `@object2 = `@object3'			'`@object1 & `@object2 == `@object3'			'`@object1 | `@object2 ~= `@object3'			'`@object1 | `@object2 ~~ `@object3'			'`@object1 & `@object2 ~= `@object3'			'`@object1 & `@object2 ~~ `@object3')		name: 'Uses A | B = C instead of A | (B = C)'! !!ParseTreeLintRule class methodsFor: 'squeak bugs' stamp: 'nk 3/4/2005 17:20'!codeCruftLeftInMethods	^(self createParseTreeRule: {				'`@whatever doOnlyOnce: `@stuff'.				'Transcript `@msg: `@args'.				'`@any halt'.				'true ifTrue: `@stuff'.				'`@any flag: `#lit'.				'`@any needsWork'.			}		name: 'Debugging code left in methods')		rationale: 'Halts, Transcript writes, doOnlyOnce:, etc. should not be left in production code.';		yourself! !!ParseTreeLintRule class methodsFor: 'intention revealing'!collectSelectNotUsed	^self 		createParseTreeRule: #('`{:node | node isMessage and: [(#(#select: #collect: #reject:) includes: node selector) and: [node isUsed not]]}')		name: 'Doesn''t use the result of a collect:/select:'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!collectionMessagesToExternalObject	| detector matcher |	detector := self new.	detector name: 'Sends add:/remove: to external collection'.	matcher := ParseTreeSearcher new.	matcher 		matchesAnyOf: (#(#add: #remove: #addAll: #removeAll:) collect: 					[:each | 					('(`@Object `@message: `@args) <1s> `@Arg' expandMacrosWith: each) 						asString])		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[((aNode receiver selector copyFrom: 1						to: (aNode receiver selector size min: 2)) ~= 'as' 						and: 							[| receiver |							receiver := aNode receiver receiver.							receiver isVariable not or: 									[((#('self' 'super') includes: receiver name) 										or: [Smalltalk includesKey: receiver name asSymbol]) not]]) 							ifTrue: [aNode]							ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'intention revealing'!collectionProtocol	^self createParseTreeRule: 			#('`@collection do: [:`each | | `@temps | `@.Statements1. `@object add: `@arg. `@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@blockTemps | 							`@.BlockStatements1. 							`@object add: `each. 							`@.BlockStatements2]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@blockTemps | 							`@.BlockStatements1. 							`@object add: `each. 							`@.BlockStatements2]. 					`@.Statements2]') 		name: 'Uses do: instead of collect: or select:''s'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!consistencyCheck	^self createParseTreeRule: 				#('`@object size == 0' 				'`@object size = 0' 				'`@object size > 0' 				'`@object size >= 1' 				'`@object == nil' 				'`@object = nil'				'`@collection at: 1'				'`@collection at: `@collection size') 		name: 'Uses "size = 0", "= nil",  or "at: 1" instead of "isEmpty",  "isNil", or "first"'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!contains	^self createParseTreeRule: 			#('(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) isNil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) notNil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) = nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) == nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) ~= nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) ~~ nil' 			'`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [| `@temps1 | `@.Statements2. ^`@anything]') 		name: 'Uses detect:ifNone: instead of contains:'! !!ParseTreeLintRule class methodsFor: 'private'!createMatcherFor: codeStrings method: aBoolean 	| matcher |	matcher := ParseTreeSearcher new.	aBoolean 		ifTrue: [matcher matchesAnyMethodOf: codeStrings do: [:aNode :answer | aNode]]		ifFalse: [matcher matchesAnyOf: codeStrings do: [:aNode :answer | aNode]].	^matcher! !!ParseTreeLintRule class methodsFor: 'instance creation'!createParseTreeRule: codeStrings method: aBoolean name: aName 	^(self new)		name: aName;		matcher: (self createMatcherFor: codeStrings method: aBoolean);		yourself! !!ParseTreeLintRule class methodsFor: 'instance creation'!createParseTreeRule: codeStrings name: aName 	^self 		createParseTreeRule: codeStrings		method: false		name: aName! !!ParseTreeLintRule class methodsFor: 'intention revealing'!detectContains	^self createParseTreeRule: 			#('`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^`each]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^`each]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^true]. 					`@.Statements2]' 			'`@Collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^true]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^false]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^false]. 					`@.Statements2]') 		name: 'Uses do: instead of contains: or detect:''s'! !!ParseTreeLintRule class methodsFor: 'unnecessary code'!endTrueFalse	| detector matcher |	detector := self new.	detector 		name: 'Check for same statements at end of ifTrue:ifFalse: blocks'.	matcher := (ParseTreeSearcher new)				matchesAnyOf: 						#('`@object 								ifTrue: [| `@temps1 | `@.Statements1. `.Statement] 								ifFalse: [| `@temps2 | `@.Statements2. `.Statement]' 						'`@object 								ifTrue: [| `@temps1 | `.Statement. `@.Statements1] 								ifFalse: [| `@temps2 | `.Statement. `@.Statements2]' 						'`@object 								ifFalse: [| `@temps1 | `@.Statements1. `.Statement] 								ifTrue: [| `@temps2 | `@.Statements2. `.Statement]' 						'`@object 								ifFalse: [| `@temps1 | `.Statement. `@.Statements1] 								ifTrue: [| `@temps2 | `.Statement. `@.Statement2]') 					do: 						[:aNode :answer | 						answer isNil 							ifTrue: 								[| node |								node := aNode arguments first body statements last.								(node isVariable and: [node = aNode arguments last body statements last]) 									ifTrue: [nil]									ifFalse: [aNode]]							ifFalse: [answer]];				yourself.	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'possible bugs'!equalNotUsed	^self 		createParseTreeRule: #('`{:node | node isMessage and: [node isUsed not and: [#(#= #== #~= #~~ #< #> #<= #>=) includes: node selector]]}')		name: 'Doesn''t use the result of a =, ~=, etc.'! !!ParseTreeLintRule class methodsFor: 'unnecessary code'!equalsTrue	| detector matcher |	detector := self new.	detector name: 'Unnecessary "= true"'.	matcher := (ParseTreeSearcher new)				matchesAnyOf: #('true' 'false')					do: 						[:aNode :answer | 						answer isNil 							ifTrue: 								[(aNode parent isMessage 									and: [#(#= #== #~= #~~) includes: aNode parent selector]) 										ifTrue: [aNode]										ifFalse: [nil]]							ifFalse: [answer]];				yourself.	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'unnecessary code'!extraBlock	^self 		createParseTreeRule: #('`{:node | node isMessage and: [node receiver isBlock and: [node parent isCascade not and: [#(#value #value: #value:value: #value:value:value: #valueWithArguments) includes: node selector]]]}')		name: 'Block immediately evaluated'! !!ParseTreeLintRule class methodsFor: 'possible bugs'!fileBlocks	^self createParseTreeRule: 				#('[| `@temps | 					`var := `@object.  					`@.statements] 							valueNowOrOnUnwindDo: 								[`var `@messages: `@args]' 				'[| `@temps | 					`var := `@object.  					`@.statements] 							valueOnUnwindDo: 								[`var `@messages: `@args]'				'[| `@temps | 					`var := `@object.  					`@.statements] 							ensure: 								[`var `@messages: `@args]' 				'[| `@temps | 					`var := `@object.  					`@.statements] 							ifCurtailed: 								[`var `@messages: `@args]') 		name: 'Assignment inside unwind blocks should be outside.'! !!ParseTreeLintRule class methodsFor: 'private' stamp: 'nk 7/30/2004 09:55'!genericPatternForSelector: sel	"	ParseTreeLintRule genericPatternForSelector: #a	ParseTreeLintRule genericPatternForSelector: #a:b:c:	"	^String streamContents: [ :s |		sel keywords withIndexDo: [ :k :i | s space; nextPutAll: k.			(k last = $:) ifTrue: [ s space; nextPutAll: '`@object'; print: i  ]]]! !!ParseTreeLintRule class methodsFor: 'intention revealing'!guardingClause	| detector matcher |	detector := self new.	detector name: 'Guarding clauses'.	matcher := ParseTreeSearcher new.	matcher 		matchesAnyMethodOf: 				#('`@MethodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifTrue: [| `@BlockTemps | `.Statement1. `.Statement2. `@.BStatements]' 			'`@MethodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifFalse: [| `@BlockTemps | `.Statement1. `.Statement2. `@.BStatements]')		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[aNode body statements last]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!ifTrueBlocks	^self 		createParseTreeRule: #(				'`@condition ifTrue: `{:node | node isBlock not} ifFalse: `@block' 				'`@condition ifTrue: `@block ifFalse: `{:node | node isBlock not}' 				'`@condition ifFalse: `{:node | node isBlock not} ifTrue: `@block' 				'`@condition ifFalse: `@block ifTrue: `{:node | node isBlock not}' 				'`@condition ifTrue: `{:node | node isBlock not}' 				'`@condition ifFalse: `{:node | node isBlock not}')		name: 'Non-blocks in ifTrue:/ifFalse: messages'! !!ParseTreeLintRule class methodsFor: 'intention revealing' stamp: 'bh 4/2/2000 22:14'!ifTrueReturns	| detector matcher |	detector := self new.	detector name: 'ifTrue:/ifFalse: returns instead of and:/or:''s'.	matcher := ParseTreeSearcher new.	matcher 		matchesAnyOf: 			#('| `@temps | ``@.Statements. ``@object ifTrue: [^``@value1]. ^``@value2' 			'| `@temps | ``@.Statements. ``@object ifFalse: [^``@value1]. ^``@value2')		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[| node |					node := (aNode statements at: aNode statements size - 1) arguments first 								body statements 								last value.	"``@value1"					((node isLiteral and: [{true. false} includes: node value]) or: 							[node := aNode statements last value.							node isLiteral and: [{true. false} includes: node value]]) 						ifTrue: [aNode]						ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'private'!isArrayOfCharacters: anArray 	anArray isEmpty ifTrue: [^false].	1 to: anArray size		do: [:each | (anArray at: each) class == Character ifFalse: [^false]].	^true! !!ParseTreeLintRule class methodsFor: 'private'!isSearchingLiteralExpression: aMessageNode 	| equalNode expressionNode |	equalNode := aMessageNode selector = #| 				ifTrue: [aMessageNode arguments first]				ifFalse: [aMessageNode receiver].	expressionNode := equalNode receiver isLiteral 				ifTrue: [equalNode arguments first]				ifFalse: [equalNode receiver].	^self isSearchingLiteralExpression: aMessageNode for: expressionNode! !!ParseTreeLintRule class methodsFor: 'private'!isSearchingLiteralExpression: aSearchingNode for: anObjectNode 	| argument arguments |	aSearchingNode isMessage ifFalse: [^false].	arguments := aSearchingNode arguments.	arguments size = 1 ifFalse: [^false].	argument := arguments first.	(#(#= #==) includes: aSearchingNode selector) 		ifTrue: 			[^(aSearchingNode receiver = anObjectNode 				and: [aSearchingNode arguments first isLiteral]) or: 						[aSearchingNode arguments first = anObjectNode 							and: [aSearchingNode receiver isLiteral]]].	aSearchingNode selector = #| 		ifTrue: 			[^(self isSearchingLiteralExpression: aSearchingNode receiver				for: anObjectNode) 					and: [self isSearchingLiteralExpression: argument for: anObjectNode]].	aSearchingNode selector = #or: ifFalse: [^false].	argument isBlock ifFalse: [^false].	argument body statements size = 1 ifFalse: [^false].	^(self isSearchingLiteralExpression: aSearchingNode receiver		for: anObjectNode) and: 				[self isSearchingLiteralExpression: argument body statements first					for: anObjectNode]! !!ParseTreeLintRule class methodsFor: 'intention revealing'!literalArrayCharacters	| detector matcher |	detector := self new.	detector name: 'Literal array contains only characters'.	matcher := ParseTreeSearcher new.	matcher matches: '`#literal'		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[(aNode value class == Array and: [self isArrayOfCharacters: aNode value]) 						ifTrue: [aNode]						ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'intention revealing'!minMax	| detector matcher |	detector := self new.	detector name: 'Uses ifTrue:/ifFalse: instead of min: or max:'.	matcher := ParseTreeSearcher new.	matcher 		matchesAnyOf: #('(`x `message: `@y) `ifTrue: [`x := `@y]' '(`@x `message: `@y) `ifTrue: [`@x] `ifFalse: [`@y]' '(`@x `message: `@y) `ifTrue: [`v := `@x] `ifFalse: [`v := `@y]')		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[((#(#ifTrue: #ifFalse: #ifTrue:ifFalse: #ifFalse:ifTrue:) 						includes: aNode selector) 							and: [#(#< #<= #> #>=) includes: aNode receiver selector]) 							ifTrue: [aNode]							ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'squeak bugs' stamp: 'nk 3/4/2005 17:46'!missingTranslationsInMenus	^(self createParseTreeRule: {				'`@menu add: `#label action: `#sym'.				'`@menu add: `#label selector: `#sym arguments: `@stuff'.				'`@menu add: `#label subMenu: `@stuff'.				'`@menu add: `#label subMenu: `@stuff target: `@targ selector: `#sel argumentList: `@args'.				'`@menu add: `#label target: `@targ action: `#sel'.				'`@menu add: `#label target: `@targ selector `#sel'.				'`@menu add: `#label target: `@targ selector `#sel argument: `@arg'.				'`@menu add: `#label target: `@targ selector `#sel arguments: `@arg'.				'`@menu addList: `{ :n | n isLiteral and: [ n token realValue anySatisfy: [ :row | (row isKindOf: Array) and: [ row first isLiteral ]]] }'.				'`@menu addTitle: `#label'.				'`@menu addTitle: `#label updatingSelector: `#sel updateTarget: `@targ'.				'`@menu addWithLabel: `#label enablement: `#esel action: `#sel'.				'`@menu addWithLabel: `#label enablementSelector: `#esel target: `@targ selector: `#sel argumentList: `@args'.				'`@menu balloonTextForLastItem: `#label'.				'`@menu labels: `#lit lines: `@lines selections: `@sels'.				'`@menu title: `#title'			}		name: 'Menus missing translations')		rationale: 'Literal strings shown to users in menus should be translated.';		yourself! !!ParseTreeLintRule class methodsFor: 'possible bugs' stamp: 'bh 4/2/2000 22:17'!missingYourself	^self 		createParseTreeRule: #('`{:node | node isMessage and: [node parent isCascade and: [node isDirectlyUsed and: [node selector ~~ #yourself]]]}')		name: 'Possible missing "; yourself"'! !!ParseTreeLintRule class methodsFor: 'possible bugs'!modifiesCollection	| detector matcher |	detector := self new.	detector name: 'Modifies collection while iterating over it'.	matcher := (ParseTreeSearcher new)				matchesAnyOf: 						#('`@object do: [:`each | | `@temps | ``@.Statements]' 						'`@object collect: [:`each | | `@temps | ``@.Statements]' 						'`@object select: [:`each | | `@temps | ``@.Statements]' 						'`@object reject: [:`each | | `@temps | ``@.Statements]' 						'`@object inject: `@value into: [:`sum :`each | | `@temps | ``@.Statements]')					do: 						[:aNode :answer | 						answer isNil 							ifTrue: 								[(self modifiesTree: aNode receiver in: aNode arguments last) 									ifTrue: [aNode]									ifFalse: [nil]]							ifFalse: [answer]];				yourself.	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'private'!modifiesTree: aCollectionTree in: aParseTree 	| notifier args |	notifier := ParseTreeSearcher new.	args := Array with: (RBVariableNode named: '`@object').	notifier 		matchesAnyTreeOf: (#(#add: #addAll: #remove: #removeAll:) collect: 					[:each | 					RBMessageNode 						receiver: aCollectionTree						selector: each						arguments: args])		do: [:aNode :answer | true].	^notifier executeTree: aParseTree initialAnswer: false! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!precedence	^self 		createParseTreeRule: #('`{:node | node isMessage and: [node hasParentheses not and: [#(#+ #-) includes: node selector]]} * `@C')		name: 'Inspect instances of "A + B * C" might be "A + (B * C)"'! !!ParseTreeLintRule class methodsFor: 'possible bugs'!returnInEnsure	| detector matcher returnMatcher |	detector := self new.	detector name: 'Contains a return in an ensure: block'.	returnMatcher := ParseTreeSearcher new.	returnMatcher matches: '^`@object' do: [:aNode :answer | true].	matcher := ParseTreeSearcher new.	matcher 		matchesAnyOf: #('``@rcv ensure: [| `@temps | ``@.Stmts]' 						'``@rcv valueNowOrOnUnwindDo: [| `@temps | ``@.Stmts]' 						'``@rcv ifCurtailed: [| `@temps | ``@.Stmts]' 						'``@rcv valueOnUnwindDo: [| `@temps | ``@.Stmts]')		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[(returnMatcher executeTree: aNode arguments first initialAnswer: false) 						ifTrue: [aNode]						ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'possible bugs'!returnsIfTrue	^self createParseTreeRule: 				#('^`@condition ifTrue: [| `@temps | `@.statements]' 				'^`@condition ifFalse: [| `@temps | `@.statements]') 		name: 'Returns value of ifTrue:/ifFalse: without ifFalse:/ifTrue: block'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!searchingLiteral	| detector matcher |	detector := self new.	detector name: 'Uses or''s instead of a searching literal'.	matcher := ParseTreeSearcher new.	matcher 		matchesAnyOf: #('``@object = `#literal or: [``@expression]' 						'``@object == `#literal or: [``@expression]' 						'`#literal = ``@object or: [``@expression]' 						'`#literal == ``@object or: [``@expression]' 						'``@expression | (``@object = `#literal)' 						'``@expression | (``@object == `#literal)' 						'``@expression | (`#literal = ``@object)' 						'``@expression | (`#literal == ``@object)')		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[(self isSearchingLiteralExpression: aNode) ifTrue: [aNode] ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'squeak bugs' stamp: 'nk 7/30/2004 19:09'!sendsDeprecatedMethodToGlobal	| nav patterns pattern wellKnownGlobals |	nav := SystemNavigation default.	patterns := OrderedCollection new.	wellKnownGlobals := IdentityDictionary new.	Smalltalk		keysAndValuesDo: [:k :v | v isBehavior				ifFalse: [(wellKnownGlobals						at: v class						ifAbsentPut: [Set new])						add: k]].	#(#deprecated: 'deprecated:explanation:' 'deprecated:block:' )		do: [:sym | (nav allCallsOn: sym)				do: [:mr | mr classIsMeta						ifTrue: [mr actualClass								withAllSubclassesDo: [:cls | patterns										add: (String												streamContents: [:s | s nextPutAll: cls theNonMetaClass name;																												nextPutAll: (self genericPatternForSelector: mr methodSymbol)])]]						ifFalse: [wellKnownGlobals								keysAndValuesDo: [:gcls :gnames | (gcls includesBehavior: mr actualClass)										ifTrue: [gnames												do: [:gname | pattern := String																streamContents: [:s | 																	s nextPutAll: gname.																	s																		nextPutAll: (self genericPatternForSelector: mr methodSymbol)]].											patterns add: pattern]]]]].	patterns add: 'self beep: `@object1';		 add: 'self beep'.	^ self createParseTreeRule: patterns name: 'Sends a deprecated message to a known global'! !!ParseTreeLintRule class methodsFor: 'bugs' stamp: 'nk 2/24/2005 15:04'!sendsUnknownMessageToGlobal	| detector matcher |	detector := self new.	detector name: 'Sends unknown message to global'.	matcher := ParseTreeSearcher new.	matcher 		matches: '`{:node :context | node isVariable and: [ Smalltalk includesKey: node name asSymbol ] } `@message: `@args'		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[| what |					what := Smalltalk at: aNode receiver name asSymbol.					(what notNil 						and: [what ~~ Preferences and: [(what respondsTo: aNode selector) not]]) 							ifTrue: [aNode]							ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'intention revealing'!sizeCheck	^self createParseTreeRule: (#(#do: #collect: #reject: #select:) collect: 					[:each | 					'`@object size > 0 ifTrue: [`@object ' , each						, ' [:`each | | `@temps | `@.Statements1]. `@.Statements2]'])				, (#(#do: #collect: #reject: #select:) collect: 							[:each | 							'`@object isEmpty ifFalse: [`@object ' , each								, ' [:`each | | `@temps | `@.Statements1]. `@.Statements2]'])		name: 'Unnecessary size check'! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!stringConcatenation	| detector matcher concatenationMatcher |	detector := self new.	detector name: 'String concatenation instead of streams'.	matcher := ParseTreeSearcher new.	concatenationMatcher := ParseTreeSearcher new.	concatenationMatcher matches: '`@receiver , `@argument'		do: [:aNode :answer | true].	matcher 		matchesAnyOf: 			#('``@collection do: [:`each | | `@temps | ``@.Statements]' 			'``@collection do: [:`each | | `@temps | ``@.Statements] separatedBy: [| `@temps1 | ``@.Statements1]' 			'``@number to: ``@endNumber do: [:`i | | `@temps | ``@.Statements]' 			'``@collection detect: [:`each | | `@temps | ``@.Statements]' 			'``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [| `@temps1 | ``@.Statements1]' 			'``@collection select: [:`each | | `@temps | ``@.Statements]' 			'``@collection inject: ``@value into: [:`each | | `@temps | ``@.Statements]')		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[(aNode arguments detect: 							[:each | 							each isBlock 								and: [concatenationMatcher executeTree: each initialAnswer: false]]						ifNone: [nil]) notNil 						ifTrue: [aNode]						ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'possible bugs'!threeElementPoint	| detector matcher |	detector := self new.	detector name: 'Possible three element point (e.g., x @ y + q @ r)'.	matcher := (ParseTreeSearcher new)				matches: '``@x @ ``@y'					do: 						[:aNode :answer | 						answer isNil 							ifTrue: 								[| current |								current := aNode parent.																[current isNil or: 										[current isMessage 											and: [current selector == #@ or: [current selector isInfix not]]]] 										whileFalse: [current := current parent].								(current isNil or: [current isMessage and: [current selector isInfix not]]) 									ifTrue: [nil]									ifFalse: [aNode]]							ifFalse: [answer]];				yourself.	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'intention revealing'!toDo	| detector matcher |	detector := self new.	detector name: 'Uses to:do: instead of do:, with:do: or timesRepeat:'.	matcher := ParseTreeSearcher new.	matcher 		matches: '1 to: ``@object size do: [:`each | | `@temps | `@.Statements]'		do: 			[:aNode :answer | 			answer isNil 				ifTrue: 					[| varName variableMatcher |					varName := aNode arguments last arguments first.	"`each"					variableMatcher := ParseTreeSearcher new.					variableMatcher matchesTree: varName						do: [:node :ans | ans and: [node parent isMessage and: [node parent selector == #at:]]].					(variableMatcher executeTree: aNode arguments last body initialAnswer: true) 						ifTrue: [aNode]						ifFalse: [nil]]				ifFalse: [answer]].	detector matcher: matcher.	^detector! !!ParseTreeLintRule class methodsFor: 'intention revealing'!toDoCollect	^self 		createParseTreeRule: #(			'| `@temps1 |			`@.Stmts1.			`collection := Array new: `@size.			`@.Stmts2.			1 to: `@size do: 					[:`i | 					| `@Btemps2 | 					`@.BStmts1. 					`collection at: `i put: `@obj.					`@.BStmt2].			`@.Stmts3'					"-------------"			 '| `@temps1 |			`@.Stmts1.			`collection := Array new: `@size.			`@.Stmts2.			1 to: `collection size do: 					[:`i | 					| `@Btemps2 | 					`@.BStmts1. 					`collection at: `i put: `@obj.					`@.BStmt2].			`@.Stmts3')		name: 'to:do: doesn''t use collect:'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!toDoWithIncrement	^self 		createParseTreeRule: #(				'`@i to: `@j do: [:`e | | `@temps | `@.Stmts. `x := `x + 1. `@.Stmts2]' 				'`@i to: `@j by: `@k do: [:`e | | `@temps | `@.Stmts. `x := `x + `@k. `@.Stmts2]')		name: 'to:do: loop also increments a counter'! !!ParseTreeLintRule class methodsFor: 'unnecessary code'!unnecessaryAssignment	^self 		createParseTreeRule: #('^`{:aNode | aNode isAssignment and: [(aNode whoDefines: aNode variable name) notNil]}')		name: 'Unnecessary assignment to a temporary variable'! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!unoptimizedAndOr	^self 		createParseTreeRule: #('(`@a and: `@b) and: `@c' '(`@a or: `@b) or: `@c')		name: 'Uses "(a and: [b]) and: [c]" instead of "a and: [b and: [c]]"'! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!unoptimizedToDo	^self createParseTreeRule: #('(`@a to: `@b) do: `@c')		name: 'Uses (to:)do: instead of to:do:'! !!ParseTreeLintRule class methodsFor: 'possible bugs'!usesAdd	^self 		createParseTreeRule: #('`{:node | node isMessage and: [(node selector == #add: or: [node selector == #addAll:]) and: [node isDirectlyUsed]]}')		name: 'Uses the result of an add: message'! !!ParseTreeLintRule class methodsFor: 'intention revealing'!whileTrue	^self createParseTreeRule: 			#('| `@temps | 				`@.Statements1. 				[`index <= `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index + 1].				`@.Statements2' 			'| `@temps | 				`@.Statements1. 				[`index < `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index + 1].				`@.Statements2'			'| `@temps | 				`@.Statements1. 				[`index >= `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index - 1].				`@.Statements2' 			'| `@temps | 				`@.Statements1. 				[`index > `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index - 1].				`@.Statements2') 		name: 'Uses whileTrue: instead of to:do:'! !!ParseTreeLintRule class methodsFor: 'miscellaneous'!yourselfNotUsed	^self createParseTreeRule: #('`{:node | node parent isUsed not} yourself')		name: 'Doesn''t use the result of a yourself message'! !!ParseTreeLintRule methodsFor: 'accessing'!checkMethod: aSmalllintContext 	(matcher canMatchMethod: aSmalllintContext compiledMethod) 		ifFalse: [^self].	(matcher executeTree: aSmalllintContext parseTree initialAnswer: nil) 		notNil 			ifTrue: 				[result addClass: aSmalllintContext selectedClass					selector: aSmalllintContext selector]! !!ParseTreeLintRule methodsFor: 'private'!defaultResultClass	^ParseTreeEnvironment! !!ParseTreeLintRule methodsFor: 'initialize-release'!matcher: aParseTreeMatcher	matcher := aParseTreeMatcher! !!ParseTreeLintRule methodsFor: 'initialize-release'!resetResult	result := ParseTreeEnvironment new.	result		label: self name;		matcher: matcher! !!CompositeLintRule class methodsFor: 'instance creation'!allRules	^self ruleFor: self protocol: 'all checks'! !!CompositeLintRule class methodsFor: 'all checks'!lintChecks	^self rules: (BasicLintRule protocols				collect: [:each | self ruleFor: BasicLintRule protocol: each])		name: 'Lint checks'! !!CompositeLintRule class methodsFor: 'all checks' stamp: 'nk 3/5/2005 15:54'!performAllTransformationsOn: anEnvironment	| transformations rc |	transformations := SmalllintChecker runRule: self transformations onEnvironment: anEnvironment.	transformations problemCount isZero ifTrue: [ ^self inform: 'none found!!' ].	rc := RefactoryChangeManager instance.	RefactoryChangeManager undoSize: (RefactoryChangeManager undoSize max: transformations changes size).	transformations changes do: [ :c | rc performChange: c ].	^self inform: ('{1} transformations performed' format: transformations problemCount)! !!CompositeLintRule class methodsFor: 'all checks' stamp: 'nk 3/5/2005 15:52'!previewAllTransformationsOn: anEnvironment	"	CompositeLintRule previewAllTransformationsOn: (BrowserEnvironment new forClasses: {RefactoryTestDataApp})	"	| transformations changes |	transformations := SmalllintChecker runRule: self transformations onEnvironment: anEnvironment.	transformations problemCount isZero ifTrue: [ ^self inform: 'none found!!' ].self halt.	changes := String streamContents: 					[:stream | 					stream						header;						timeStamp;						nextPutAll: '"Result of running all transformations"!!'.					transformations changes do: [ :ch | stream cr; print: ch  ]].	FileContentsBrowser browseStream: changes readStream		named: 'Prospective replacements'! !!CompositeLintRule class methodsFor: 'instance creation'!ruleFor: aClass protocol: aProtocol 	| allRules |	allRules := aClass withAllSubclasses inject: OrderedCollection new				into: 					[:sum :each | 					sum						addAll: ((BrowserEnvironment new selectorsFor: aProtocol asSymbol									in: each class) collect: [:selector | each perform: selector]);						yourself].	^self rules: (allRules asSortedCollection: [:a :b | a name < b name])		name: ((aProtocol asString copy)				at: 1 put: aProtocol first asUppercase;				yourself)! !!CompositeLintRule class methodsFor: 'instance creation'!rules: aCollection 	^self new rules: aCollection! !!CompositeLintRule class methodsFor: 'instance creation'!rules: aCollection name: aString 	^(self new) rules: aCollection;		name: aString;		yourself! !!CompositeLintRule class methodsFor: 'all checks'!transformations	^self ruleFor: TransformationRule protocol: 'transformations'! !!CompositeLintRule methodsFor: 'accessing' stamp: 'nk 3/5/2005 15:16'!changes	^rules gather: [ :r  | r changes ]! !!CompositeLintRule methodsFor: 'accessing'!checkClass: aSmalllintContext 	rules do: 			[:each | 			each checkClass: aSmalllintContext.			Processor yield]! !!CompositeLintRule methodsFor: 'accessing'!checkMethod: aSmalllintContext 	rules do: 			[:each | 			each checkMethod: aSmalllintContext.			Processor yield]! !!CompositeLintRule methodsFor: 'accessing'!failedRules	^rules inject: OrderedCollection new into: [:oc :each | oc addAll: each failedRules; yourself]! !!CompositeLintRule methodsFor: 'testing'!hasConflicts	^(rules detect: [:each | each hasConflicts] ifNone: [nil]) notNil! !!CompositeLintRule methodsFor: 'testing'!isComposite	^true! !!CompositeLintRule methodsFor: 'testing'!isEmpty	^(rules detect: [:each | each isEmpty not] ifNone: [nil]) isNil! !!CompositeLintRule methodsFor: 'accessing'!problemCount	^rules inject: 0 into: [:count :each | count + each problemCount]! !!CompositeLintRule methodsFor: 'initialize-release'!resetResult	rules do: [:each | each resetResult]! !!CompositeLintRule methodsFor: 'accessing'!rules	^rules! !!CompositeLintRule methodsFor: 'initialize-release'!rules: aCollection	rules := aCollection! !!CompositeLintRule methodsFor: 'private' stamp: 'bh 5/9/2000 00:17'!viewResults	rules do: [:each | each viewResults]! !!LintRule methodsFor: 'accessing' stamp: 'nk 3/5/2005 15:16'!changes	^#()! !!LintRule methodsFor: 'accessing'!checkClass: aSmalllintContext! !!LintRule methodsFor: 'accessing'!checkMethod: aSmalllintContext! !!LintRule methodsFor: 'printing'!displayName	| nameStream |	nameStream := WriteStream on: (String new: 64).	nameStream nextPutAll: self name;		nextPutAll: ' ['.	self problemCount printOn: nameStream.	nameStream nextPut: $].	^nameStream contents! !!LintRule methodsFor: 'private'!failedRules	^self isEmpty		ifTrue: [#()]		ifFalse: [Array with: self]! !!LintRule methodsFor: 'testing'!hasConflicts	^false! !!LintRule methodsFor: 'initialize-release'!initialize! !!LintRule methodsFor: 'testing'!isComposite	^false! !!LintRule methodsFor: 'testing'!isEmpty	self subclassResponsibility! !!LintRule methodsFor: 'accessing'!name	^name! !!LintRule methodsFor: 'accessing'!name: aString 	name := aString! !!LintRule methodsFor: 'printing'!printOn: aStream 	name isNil		ifTrue: [super printOn: aStream]		ifFalse: [aStream nextPutAll: name]! !!LintRule methodsFor: 'accessing'!problemCount	^self subclassResponsibility! !!LintRule methodsFor: 'accessing' stamp: 'nk 2/25/2005 11:35'!rationale	"Answer the rationale for this rule."	^rationale ifNil: [ ^'' ]! !!LintRule methodsFor: 'accessing' stamp: 'nk 2/25/2005 11:35'!rationale: anObject	rationale := anObject! !!LintRule methodsFor: 'initialize-release'!resetResult! !!LintRule methodsFor: 'accessing' stamp: 'nk 11/12/2002 13:11'!run	^SmalllintChecker runRule: self! !!LintRule methodsFor: 'accessing' stamp: 'nk 11/12/2002 13:11'!runOnEnvironment: anEnvironment 	^SmalllintChecker runRule: self onEnvironment: anEnvironment! !!LintRule methodsFor: 'private' stamp: 'bh 5/9/2000 00:17'!viewResults	self subclassResponsibility! !!TransformationRule class methodsFor: 'transformations'!assignmentInIfTrue	^self rewrite: #(			#('``@Boolean ifTrue: [`variable := ``@true] ifFalse: [`variable := ``@false]'			"->"			'`variable := ``@Boolean ifTrue: [``@true] ifFalse: [``@false]')			#('``@Boolean ifFalse: [`variable := ``@true] ifTrue: [`variable := ``@false]'			"->"			'`variable := ``@Boolean ifFalse: [``@true] ifTrue: [``@false]'))		methods: false		name: 'Move variable assignment outside of single statement ifTrue:ifFalse: blocks'! !!TransformationRule class methodsFor: 'transformations'!atIfAbsent	^self rewrite: #(			#('``@dictionary at: ``@key 					ifAbsent: [| `@temps | 							``@.Statements1.							``@dictionary at: ``@key put: ``@object.							``@.Statements2.							``@object]'			"->"			'``@dictionary at: ``@key					ifAbsentPut: [| `@temps |							``@.Statements1.							``@.Statements2.							``@object]')			#('``@dictionary at: ``@key					ifAbsent: [| `@temps |							``@.Statements.							``@dictionary at: ``@key put: ``@object]'			"->"			'``@dictionary at: ``@key					ifAbsentPut: [| `@temps |							``@.Statements.							``@object]'))		methods: false		name: 'at:ifAbsent: -> at:ifAbsentPut:'! !!TransformationRule class methodsFor: 'transformations'!betweenAnd	^self rewrite: #(			#('``@a >= ``@b and: [``@a <= ``@c]' "->" '``@a between: ``@b and: ``@c')			#('``@a >= ``@b & (``@a <= ``@c)' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a and: [``@a <= ``@c]' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a & (``@a <= ``@c)' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c and: [``@a >= ``@b]' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c & (``@a >= ``@b)' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a and: [``@a >= ``@b]' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a & (``@a >= ``@b)' "->" '``@a between: ``@b and: ``@c')			#('``@a >= ``@b and: [``@c >= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@a >= ``@b & (``@c >= ``@a)' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a and: [``@c >= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a & (``@c >= ``@a)' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c and: [``@b <= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c & (``@b <= ``@a)' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a and: [``@b <= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a & (``@b <= ``@a)' "->" '``@a between: ``@b and: ``@c'))		methods: false		name: '"a >= b and: [a <= c]" -> "a between: b and: c"'! !!TransformationRule class methodsFor: 'transformations'!cascadedNextPutAlls	^self		rewrite: #(			#('``@rcvr nextPutAll: ``@object1 , ``@object2'					"->"				'``@rcvr nextPutAll: ``@object1; nextPutAll: ``@object2')			#('``@rcvr show: ``@object1 , ``@object2'					"->"				'``@rcvr show: ``@object1; show: ``@object2'))		methods: false		name: 'Use cascaded nextPutAll:''s instead of #, in #nextPutAll:'! !!TransformationRule class methodsFor: 'transformations'!detectIfNone	^self rewrite: #(			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) isNil'				"->"	'(``@collection contains: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) = nil'				"->"	'(``@collection contains: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) == nil'				"->"	'(``@collection contains: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) notNil'				"->"	'``@collection contains: [:`each | | `@temps | ``@.Statements]')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) ~= nil'				"->"	'``@collection contains: [:`each | | `@temps | ``@.Statements]')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) ~~ nil'				"->"	'``@collection contains: [:`each | | `@temps | ``@.Statements]'))		methods: false		name: 'detect:ifNone: -> contains:'! !!TransformationRule class methodsFor: 'transformations'!equalNil	^self		rewrite: #(			#('``@object = nil'	"->"	'``@object isNil') 			#('``@object == nil'	"->"	'``@object isNil') 			#('``@object ~= nil'	"->"	'``@object notNil') 			#('``@object ~~ nil'	"->"	'``@object notNil'))		methods: false		name: '= nil -> isNil AND ~= nil -> notNil'! !!TransformationRule class methodsFor: 'transformations'!guardClause	^self		rewrite: #(			#('`@methodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifTrue: [| `@trueTemps | `.Statement1. `.Statement2. `@.Statements1]'			"->"			'`@methodName: `@args					| `@temps `@trueTemps |					`@.Statements.					`@condition ifFalse: [^self].					`.Statement1.					`.Statement2.					`@.Statements1') 			#('`@methodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifFalse: [| `@falseTemps | `.Statement1. `.Statement2. `@.Statements1]'			"->"			'`@methodName: `@args					| `@temps `@falseTemps |					`@.Statements.					`@condition ifTrue: [^self].					`.Statement1.					`.Statement2.					`@.Statements1'))		methods: true		name: 'Eliminate guarding clauses'! !!TransformationRule class methodsFor: 'accessing'!initializeRecursiveSelfRule	RecursiveSelfRule := ParseTreeSearcher new.	RecursiveSelfRule 		matchesAnyMethodOf: 			#('`@methodName: `@args | `@temps | self `@methodName: `@args1' 			'`@methodName: `@args | `@temps | ^self `@methodName: `@args1')		do: [:aNode :answer | true].	^RecursiveSelfRule! !!TransformationRule class methodsFor: 'transformations'!minMax	^self rewrite: #(			#('``@a < ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a min: ``@b')			#('``@a <= ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a min: ``@b')			#('``@a > ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a max: ``@b')			#('``@a >= ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a max: ``@b')			#('``@a < ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a max: ``@b')			#('``@a <= ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a max: ``@b')			#('``@a > ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a min: ``@b')			#('``@a >= ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a min: ``@b')			#('`a < ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('`a <= ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('`a < ``@b ifFalse: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('`a <= ``@b ifFalse: [`a := ``@b]'			"->"	'`a := `a min: ``@b')			#('`a > ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('`a >= ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('`a > ``@b ifFalse: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('`a >= ``@b ifFalse: [`a := ``@b]'			"->"	'`a := `a max: ``@b')			#('``@b < `a ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('``@b <= `a ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('``@b < `a ifFalse: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('``@b <= `a ifFalse: [`a := ``@b]'			"->"	'`a := `a max: ``@b')			#('``@b > `a ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('``@b >= `a ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('``@b > `a ifFalse: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('``@b >= `a ifFalse: [`a := ``@b]'			"->"	'`a := `a min: ``@b'))		methods: false		name: 'Rewrite ifTrue:ifFalse: using min:/max:'! !!TransformationRule class methodsFor: 'transformations'!notElimination	^self		rewrite: #(			#('``@object not not'	"->"	'``@object') 			#('``@object not ifTrue: ``@block' 	"->"	'``@object ifFalse: ``@block') 			#('``@object not ifFalse: ``@block'	"->"	'``@object ifTrue: ``@block') 			#('``@collection select: [:`each | | `@temps | ``@.Statements. ``@object not]'				"->"	'``@collection reject: [:`each | | `@temps | ``@.Statements. ``@object]')			#('``@collection reject: [:`each | | `@temps | ``@.Statements. ``@object not]'				"->"	'``@collection select: [:`each | | `@temps | ``@.Statements. ``@object]')			#('[| `@temps | ``@.Statements. ``@object not] whileTrue: ``@block'				"->"	'[| `@temps | ``@.Statements. ``@object] whileFalse: ``@block')			#('[| `@temps | ``@.Statements. ``@object not] whileFalse: ``@block'				"->"	'[| `@temps | ``@.Statements. ``@object] whileTrue: ``@block')			#('[| `@temps | ``@.Statements. ``@object not] whileTrue'				"->"	'[| `@temps | ``@.Statements. ``@object] whileFalse')			#('[| `@temps | ``@.Statements. ``@object not] whileFalse'				"->"	'[| `@temps | ``@.Statements. ``@object] whileTrue')			#('(``@a <= ``@b) not' "->" '``@a > ``@b')			#('(``@a < ``@b) not' "->" '``@a >= ``@b')			#('(``@a = ``@b) not' "->" '``@a ~= ``@b')			#('(``@a == ``@b) not' "->" '``@a ~~ ``@b')			#('(``@a ~= ``@b) not' "->" '``@a = ``@b')			#('(``@a ~~ ``@b) not' "->" '``@a == ``@b')			#('(``@a >= ``@b) not' "->" '``@a < ``@b')			#('(``@a > ``@b) not' "->" '``@a <= ``@b'))					methods: false		name: 'Eliminate unnecessary not''s'! !!TransformationRule class methodsFor: 'accessing'!recursiveSelfRule	^RecursiveSelfRule isNil 		ifTrue: [self initializeRecursiveSelfRule]		ifFalse: [RecursiveSelfRule]! !!TransformationRule class methodsFor: 'instance creation'!rewrite: stringArrays methods: aBoolean name: aName 	| rewriteRule |	rewriteRule := ParseTreeRewriter new.	stringArrays do: 			[:each | 			aBoolean 				ifTrue: [rewriteRule replaceMethod: each first with: each last]				ifFalse: [rewriteRule replace: each first with: each last]].	^(self new)		name: aName;		rewriteUsing: rewriteRule;		yourself! !!TransformationRule class methodsFor: 'transformations'!showWhileBlocks	^self		rewrite: #(			#('``@cursor showWhile: [| `@temps | ``@.Statements. `var := ``@object]'				"->"	'`var := ``@cursor showWhile: [| `@temps | ``@.Statements. ``@object]') 			#('``@cursor showWhile: [| `@temps | ``@.Statements. ^``@object]'				"->"	'^``@cursor showWhile: [| `@temps | ``@.Statements. ``@object]'))		methods: false		name: 'Move assignment out of showWhile: blocks'! !!TransformationRule class methodsFor: 'transformations'!superSends	^(self new)		name: 'Rewrite super messages to self messages when both refer to same method';		superSends;		yourself! !!TransformationRule class methodsFor: 'transformations' stamp: 'nk 3/5/2005 16:06'!translateLiteralsInMenus	^self 		rewrite: {				{					'`@menu add: `#label action: `#sym'.					'`@menu add: `#label translated action: `#sym'				}.				{					'`@menu add: `#label selector: `#sym arguments: `@stuff'.					'`@menu add: `#label translated selector: `#sym arguments: `@stuff'				}.				{					'`@menu add: `#label subMenu: `@stuff'.					'`@menu add: `#label translated subMenu: `@stuff'				}.				{					'`@menu add: `#label subMenu: `@stuff target: `@targ selector: `#sel argumentList: `@args'.					'`@menu add: `#label translated subMenu: `@stuff target: `@targ selector: `#sel argumentList: `@args'				}.				{					'`@menu add: `#label target: `@targ action: `#sel'.					'`@menu add: `#label translated target: `@targ action: `#sel'				}.				{					'`@menu add: `#label target: `@targ selector `#sel'.					'`@menu add: `#label translated target: `@targ selector `#sel'				}.				{					'`@menu add: `#label target: `@targ selector `#sel argument: `@arg'.					'`@menu add: `#label translated target: `@targ selector `#sel argument: `@arg'				}.				{					'`@menu add: `#label target: `@targ selector `#sel arguments: `@arg'.					'`@menu add: `#label translated target: `@targ selector `#sel arguments: `@arg'				}.				{					'`@menu addList: `{ :n | n isLiteral and: [ n token realValue anySatisfy: [ :row | (row isKindOf: Array) and: [ row first isLiteral ]]] }'.					'`@menu addTranslatedList: `{ :n :c | n }'				}.				{					'`@menu addTitle: `#label'.					'`@menu addTitle: `#label translated'				}.				{					'`@menu addTitle: `#label updatingSelector: `#sel updateTarget: `@targ'.					'`@menu addTitle: `#label translated updatingSelector: `#sel updateTarget: `@targ'				}.				{					'`@menu addWithLabel: `#label enablement: `#esel action: `#sel'.					'`@menu addWithLabel: `#label translated enablement: `#esel action: `#sel'				}.				{					'`@menu addWithLabel: `#label enablementSelector: `#esel target: `@targ selector: `#sel argumentList: `@args'.					'`@menu addWithLabel: `#label translated enablementSelector: `#esel target: `@targ selector: `#sel argumentList: `@args'				}.				{					'`@menu balloonTextForLastItem: `#label'.					'`@menu balloonTextForLastItem: `#label translated'				}.				{					'`@menu labels: `#lit lines: `@lines selections: `@sels'.					'`@menu labels: (`#lit collect: [ :l | l translated ]) lines: `@lines selections: `@sels'				}.				{					'`@menu title: `#title'.					'`@menu title: `#title translated'				}			}		methods: false		name: 'add translations to strings in menus'! !!TransformationRule class methodsFor: 'transformations'!unwindBlocks	^self		rewrite: #(			#('[| `@temps | ``@.Statements. `var := ``@object] valueNowOrOnUnwindDo: ``@block'				"->"	'`var := [| `@temps | ``@.Statements. ``@object] valueNowOrOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. ^``@object] valueNowOrOnUnwindDo: ``@block'				"->"	'^[| `@temps | ``@.Statements. ``@object] valueNowOrOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. `var := ``@object] valueOnUnwindDo: ``@block'				"->"	'`var := [| `@temps | ``@.Statements. ``@object] valueOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. ^``@object] valueOnUnwindDo: ``@block'				"->"	'^[| `@temps | ``@.Statements. ``@object] valueOnUnwindDo: ``@block'))		methods: false		name: 'Move assignment out of valueNowOrUnwindDo: blocks'! !!TransformationRule methodsFor: 'accessing' stamp: 'nk 3/5/2005 15:10'!changes	^builder changes! !!TransformationRule methodsFor: 'accessing'!checkMethod: aSmalllintContext 	(rewriteRule canMatchMethod: aSmalllintContext compiledMethod) 		ifFalse: [^self].	class := aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) 		ifTrue: 			[(self class recursiveSelfRule executeTree: rewriteRule tree				initialAnswer: false) 					ifFalse: 						[builder 							compile: rewriteRule tree printString							in: class							classified: aSmalllintContext protocol]]! !!TransformationRule methodsFor: 'testing'!hasConflicts	^true! !!TransformationRule methodsFor: 'testing'!isEmpty	^builder changes isEmpty! !!TransformationRule methodsFor: 'accessing'!problemCount	^builder problemCount! !!TransformationRule methodsFor: 'accessing'!resetResult	builder := CompositeRefactoryChange named: 'Some transformations'! !!TransformationRule methodsFor: 'initialize-release'!rewriteUsing: searchReplacer 	rewriteRule := searchReplacer.	self resetResult! !!TransformationRule methodsFor: 'rules'!superSends	| rule |	rule := ParseTreeRewriter new.	rule 		replace: 'super `@message: ``@args'		with: 'self `@message: ``@args'		when: 			[:aNode | 			(class withAllSubclasses 				detect: [:each | each includesSelector: aNode selector]				ifNone: [nil]) isNil].	self rewriteUsing: rule! !!TransformationRule methodsFor: 'private'!viewResults	"I reset the result so that we don't fill up memory with methods to compile in the builder."	builder inspect.	self resetResult! !!BasicLintRuleTest class methodsFor: 'possible bugs'!abstractClass	| detector subclassResponsibilitySymbol |	detector := self new.	detector name: 'References an abstract class'.	detector resultClass: ClassEnvironment.	subclassResponsibilitySymbol := 'subclassResponsibility' asSymbol.	detector classBlock: 			[:context :result | 			(context selectedClass whichSelectorsReferTo: subclassResponsibilitySymbol)				isEmpty ifFalse: 						[(context							uses: (Smalltalk associationAt: context selectedClass name ifAbsent: [nil]))								ifTrue: [result addClass: context selectedClass]]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!addRemoveDependents	| detector |	detector := self new.	detector resultClass: ClassEnvironment.	detector name: 'Number of addDependent: messages > removeDependent:'.	detector classBlock: 			[:context :result | 			| count |			count := 0.			((Set				withAll: (context selectedClass whichSelectorsReferTo: #addDependent:))					addAll: (context selectedClass whichSelectorsReferTo: #removeDependent:);				yourself) do: 					[:sel | 					(context selectedClass compiledMethodAt: sel) messagesDo: 							[:each | 							each == #addDependent: ifTrue: [count := count + 1].							each == #removeDependent: ifTrue: [count := count - 1]]].			count > 0 ifTrue: [result addClass: context selectedClass]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!assignmentInBlock	^self createParseTreeRule: #(			'`@cursor showWhile: [| `@temps | `@.Statements1. `var := `@object]' 			'`@cursor showWhile: [| `@temps | `@.Statements1. ^`@object]' 			'[| `@temps | `@.Statements. `var := `@object] valueNowOrOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. ^`@object] valueNowOrOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. `var := `@object] valueOnUnwindDo: `@block' 			'[| `@temps | `@.Statements. ^`@object] valueOnUnwindDo: `@block' ) 		name: 'Unnecessary assignment or return in block'! !!BasicLintRuleTest class methodsFor: 'intention revealing'!assignmentInIfTrue	^self createParseTreeRule: 			#('`@boolean 					ifTrue: [| `@temps1 | `@.Statements1. `var := `@object1] 					ifFalse: [| `@temps2 | `@.Statements2. `var := `@object2]' 			'`@boolean 					ifFalse: [| `@temps1 | `@.Statements1. `var := `@object1] 					ifTrue: [| `@temps2 | `@.Statements2. `var := `@object2]') 		name: 'Assignment to same variable and end of ifTrue:ifFalse: blocks'! !!BasicLintRuleTest class methodsFor: 'intention revealing'!atIfAbsent	^self createParseTreeRule: 				#('`@object 						at: `@atArg 						ifAbsent: [| `@temps | `@.Statements. `@object at: `@atArg put: `@putArg]' 				'`@object 						at: `@atArg 						ifAbsent: [| `@temps | 								`@.Statements. 								`@object at: `@atArg put: `@putArg. 								`@.xStatements1. 								`@putArg]') 		name: 'Uses at:ifAbsent: instead of at:ifAbsentPut:'! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!badMessage	| detector badMessages |	detector := self new.	detector name: 'Sends "questionable" message'.	badMessages := self badSelectors.	detector classBlock: 			[:context :result | 			| selectors |			selectors := badMessages inject: Set new						into: 							[:set :each | 							set addAll: (context selectedClass whichSelectorsReferTo: each);								yourself].			selectors do: [:each | result addClass: context selectedClass selector: each].			selectors isEmpty ifFalse: [result searchStrings: badMessages]].	^detector! !!BasicLintRuleTest class methodsFor: 'private'!badSelectors	^#(#become: #isKindOf: #changeClassToThatOf: #respondsTo: #isMemberOf: #performMethod: #performMethod:arguments: #performMethod:with: #performMethod:with:with: #performMethod:with:with:with: #allOwners #allOwnersWeakly: #firstOwner #instVarAt: #instVarAt:put: #nextInstance #nextObject #ownerAfter: #primBecome:  #halt)! !!BasicLintRuleTest class methodsFor: 'bugs'!booleanPrecedence	^self createParseTreeRule: 			#('`@object1 | `@object2 = `@object3'			'`@object1 | `@object2 == `@object3'			'`@object1 & `@object2 = `@object3'			'`@object1 & `@object2 == `@object3'			'`@object1 | `@object2 ~= `@object3'			'`@object1 | `@object2 ~~ `@object3'			'`@object1 & `@object2 ~= `@object3'			'`@object1 & `@object2 ~~ `@object3')		name: 'Uses A | B = C instead of A | (B = C)'! !!BasicLintRuleTest class methodsFor: 'private'!canCall: aSelector in: aClass from: anApplication 	| methodApp root |	(aClass canUnderstand: aSelector) ifFalse: [^false].	root := anApplication rootApplication.	methodApp := ((aClass whichClassIncludesSelector: aSelector) compiledMethodAt: aSelector)				application rootApplication.	^methodApp == root or: [root isBasedOn: methodApp]! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!classNameInSelector	| detector |	detector := self new.	detector name: 'Redundant class name in selector'.	detector methodBlock: 			[:context :result | 			(context selectedClass isMetaclass and: 					[(context selector						indexOfSubCollection: context selectedClass primaryInstance name						startingAt: 1) > 0])				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!classNotReferenced	| detector |	detector := self new.	detector name: 'Class not referenced'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			(context selectedClass isMetaclass				or: [context isApplication				or: [context selectedClass subclasses isEmpty not]])					ifFalse: 						[| assoc |						assoc := Smalltalk associationAt: context selectedClass name.						((context uses: assoc) or: [context uses: context selectedClass name])							ifFalse: 								[result addClass: context selectedClass;									addClass: context selectedClass class]]].	^detector! !!BasicLintRuleTest class methodsFor: 'private'!classShouldNotOverride	^#(#== #class)! !!BasicLintRuleTest class methodsFor: 'possible bugs'!collectionCopyEmpty	| detector |	detector := self new.	detector		name: 'Subclass of collection that has instance variable but doesn''t define copyEmpty'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			(context selectedClass isVariable 					and: [(context selectedClass includesSelector: #copyEmpty:) not 						and: [context selectedClass instVarNames isEmpty not							and: [context selectedClass inheritsFrom: Collection]]])				ifTrue: [result addClass: context selectedClass]].	^detector! !!BasicLintRuleTest class methodsFor: 'intention revealing'!collectionMessagesToExternalObject	| detector matcher |	detector := self new.	detector name: 'Sends add:/remove: to external collection'.	matcher := ParseTreeSearcher new.	matcher		addSearches: (#(#add: #remove: #addAll: #removeAll:)				collect: [:each | ('(`@Object `@message: `@args) <1s> `@Arg' expandMacrosWith: each) asString])					-> 						[:aNode :answer | 						answer or: 								[(aNode receiver selector copyFrom: 1 to: (aNode receiver selector size min: 2))									~= 'as' and: 											[| receiver |											receiver := aNode receiver receiver.											receiver isVariable not or: 													[((#('self' 'super') includes: receiver name)														or: [Smalltalk includesKey: receiver name asSymbol]) not]]]].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'intention revealing'!collectionProtocol	^self createParseTreeRule: 			#('`@collection do: [:`each | | `@temps | `@.Statements1. `@object add: `@arg. `@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@blockTemps | 							`@.BlockStatements1. 							`@object add: `each. 							`@.BlockStatements2]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@blockTemps | 							`@.BlockStatements1. 							`@object add: `each. 							`@.BlockStatements2]. 					`@.Statements2]') 		name: 'Uses do: instead of collect: or select:''s'! !!BasicLintRuleTest class methodsFor: 'intention revealing'!consistencyCheck	^self createParseTreeRule: 				#('`@object size == 0' 				'`@object size = 0' 				'`@object size > 0' 				'`@object size >= 1' 				'`@object == nil' 				'`@object = nil') 		name: 'Uses "size = 0" or "= nil" instead of "isEmpty" or "isNil"'! !!BasicLintRuleTest class methodsFor: 'intention revealing'!contains	^self createParseTreeRule: 			#('(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) isNil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) notNil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) = nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) == nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) ~= nil' 			'(`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [nil]) ~~ nil' 			'`@object detect: [:`each | | `@temps| `@.Statements] ifNone: [| `@temps1 | `@.Statements2. ^`@anything]') 		name: 'Uses detect:ifNone: instead of contains:'! !!BasicLintRuleTest class methodsFor: 'private'!createMatcherFor: codeStrings method: aBoolean 	| matcher |	matcher := ParseTreeSearcher new.	aBoolean		ifTrue: [matcher addMethodSearches: codeStrings -> [:aNode :answer | true]]		ifFalse: [matcher addSearches: codeStrings -> [:aNode :answer | true]].	^matcher! !!BasicLintRuleTest class methodsFor: 'instance creation'!createParseTreeRule: codeStrings method: aBoolean name: aName 	| detector matcher |	detector := self new.	detector name: aName.	matcher := self createMatcherFor: codeStrings method: aBoolean.	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'instance creation'!createParseTreeRule: codeStrings name: aName 	^self createParseTreeRule: codeStrings		method: false		name: aName! !!BasicLintRuleTest class methodsFor: 'possible bugs'!definesEqualNotHash	| detector |	detector := self new.	detector name: 'Defines = but not hash'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			((context selectedClass includesSelector: #=)				and: [(context selectedClass includesSelector: #hash) not])				ifTrue: [result addClass: context selectedClass]].	^detector! !!BasicLintRuleTest class methodsFor: 'intention revealing'!detectContains	^self createParseTreeRule: 			#('`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^`each]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^`each]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^true]. 					`@.Statements2]' 			'`@Collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^true]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifFalse: [| `@BlockTemps | `@.BlockStatements1. ^false]. 					`@.Statements2]' 			'`@collection do: [:`each | | `@temps | 					`@.Statements1. 					`@condition ifTrue: [| `@BlockTemps | `@.BlockStatements1.  ^false]. 					`@.Statements2]') 		name: 'Uses do: instead of contains: or detect:''s'! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!endTrueFalse	| detector matcher |	detector := self new.	detector name: 'Check for same statements at end of ifTrue:ifFalse: blocks'.	matcher := (ParseTreeSearcher new) addSearches: 				#('`@object 						ifTrue: [| `@temps1 | `@.Statements1. `.Statement] 						ifFalse: [| `@temps2 | `@.Statements2. `.Statement]' 				'`@object 						ifTrue: [| `@temps1 | `.Statement. `@.Statements1] 						ifFalse: [| `@temps2 | `.Statement. `@.Statements2]' 				'`@object 						ifFalse: [| `@temps1 | `@.Statements1. `.Statement] 						ifTrue: [| `@temps2 | `@.Statements2. `.Statement]' 				'`@object 						ifFalse: [| `@temps1 | `.Statement. `@.Statements1] 						ifTrue: [| `@temps2 | `.Statement. `@.Statement2]') 			-> [:aNode :answer | answer						or: 							[| node |							node := aNode arguments first body statements last.							(node isVariable and: [node = aNode arguments last body statements last]) not]]; yourself.	detector methodBlock: [:context :result | (matcher executeTree: context parseTree initialAnswer: false)			ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!equalsTrue	| detector matcher |	detector := self new.	detector name: 'Unnecessary "= true"'.	matcher := (ParseTreeSearcher new) addSearches: #('true' 'false') -> 								[:aNode :answer | 								answer or: 										[aNode parent isMessage											and: [#(#= #== #~= #~~) includes: aNode parent selector]]];				yourself.	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!equivalentSuperclassMethods	| detector |	detector := self new.	detector name: 'Methods equivalently defined in superclass'.	detector methodBlock: 			[:context :result | 			context selectedClass superclass notNil ifTrue: 					[(context selectedClass superclass canUnderstand: context selector)						ifTrue: 							[(((context selectedClass superclass								whichClassIncludesSelector: context selector)									compiledMethodAt: context selector)									equivalentTo: context compiledMethod)									ifTrue: [result addClass: context selectedClass selector: context selector]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!extraBlock	^self		createParseTreeRule: (#('value' 'value: `@value' 'value: `@value1 value: `@value2' 'value: `@value1 value: `value2 value: `@value3' 'valueWithArguments: `@values')				collect: [:each | '[:`@params | | `@temps | `@.statements] ' , each])		name: 'Block immediately evaluated'! !!BasicLintRuleTest class methodsFor: 'possible bugs'!fileBlocks	^self createParseTreeRule: 				#('[| `@temps | 					`var := `@object.  					`@.statements] 							valueNowOrOnUnwindDo: 								[`var `@messages: `@args]' 				'[| `@temps | 					`var := `@object.  					`@.statements] 							valueOnUnwindDo: 								[`var `@messages: `@args]') 		name: 'Assignment inside unwind blocks should be outside.'! !!BasicLintRuleTest class methodsFor: 'miscellaneous' stamp: 'bh 4/8/2000 19:05'!fullBlocks"skip this test in squeak.""	| detector |	detector := self new.	detector name: 'Method with full blocks'.	detector methodBlock: 			[:context :result | 			context compiledMethod withAllBlockMethodsDo: 					[:method | 					method needsHybridFrame						ifTrue: [result addClass: context selectedClass selector: context selector]]].	^detector"! !!BasicLintRuleTest class methodsFor: 'intention revealing'!guardingClause	^self		createParseTreeRule: 				#('`@MethodName: `@args 						| `@temps | 						`@.Statements. 						`@condition ifTrue: [| `@BlockTemps | `.Statement1. `.Statement2. `@.BStatements]' 				'`@MethodName: `@args 						| `@temps | 						`@.Statements. 						`@condition ifFalse: [| `@BlockTemps | `.Statement1. `.Statement2. `@.BStatements]')		method: true		name: 'Guarding clauses'! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!ifTrueBlocks	| detector matcher |	detector := self new.	detector name: 'Non-blocks in ifTrue:/ifFalse: messages'.	matcher := ParseTreeSearcher new.	matcher		addSearches: #('``@condition ifTrue: ``@block' '``@condition ifFalse: ``@block' '``@condition ifTrue: ``@block1 ifFalse: ``@block2' '``@condition ifFalse: ``@block1 ifTrue: ``@block2')				-> 					[:aNode :answer | 					answer or: 							[(aNode arguments detect: [:each | each isBlock not] ifNone: [nil]) notNil]].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'intention revealing' stamp: 'bh 4/3/2000 11:51'!ifTrueReturns	| detector matcher |	detector := self new.	detector name: 'ifTrue:/ifFalse: returns instead of and:/or:''s'.	matcher := ParseTreeSearcher new.	matcher addSearches:		#('| `@temps | ``@.Statements. ``@object ifTrue: [^``@value1]. ^``@value2' 		'| `@temps | ``@.Statements. ``@object ifFalse: [^``@value1]. ^``@value2') 			-> [:aNode :answer | answer				or: 					[| node |					node := (aNode statements at: aNode statements size - 1) arguments first body statements last value. "``@value1"					(node isLiteral and: [{true. false} includes: node value])						or: 							[node := aNode statements last value.							node isLiteral and: [{true. false} includes: node value]]]].	detector methodBlock: [:context :result | (matcher executeTree: context parseTree initialAnswer: false)			ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!implementedNotSent	| detector |	detector := self new.	detector name: 'Methods implemented but not sent'.	detector methodBlock: 			[:context :result | 			(context uses: context selector)				ifFalse: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!instVarInSubclasses	| detector |	detector := self new.	detector name: 'Instance variables defined in all subclasses'.	detector result: nil pullUpInstVar.	detector classBlock: 			[:context :result | 			| subs |			subs := context selectedClass subclasses.			subs size > 1 ifTrue: 					[| sels |					sels := Bag new.					subs do: [:each | sels addAll: each instVarNames].					sels asSet do: 							[:val | 							(sels occurrencesOf: val) == subs size								ifTrue: [result addInstVar: val for: context selectedClass]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!justSendsSuper	| detector matcher |	detector := self new.	detector name: 'Method just sends super message'.	matcher := ParseTreeSearcher justSendsSuper.	detector methodBlock: 			[:context :result | 			(context parseTree tag isNil				and: [matcher executeMethod: context parseTree initialAnswer: false])					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'private'!longMethodSize	^10! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!longMethods	| detector matcher |	detector := self new.	detector name: 'Long methods'.	matcher := ParseTreeSearcher new.	matcher		addSearch: '`.Stmt' -> 					[:aNode :answer | 					(aNode children inject: answer						into: [:sum :each | matcher executeTree: each initialAnswer: sum]) + 1].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: 0)				>= self longMethodSize					ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'private'!metaclassShouldNotOverride	^#(#name #comment)! !!BasicLintRuleTest class methodsFor: 'intention revealing'!minMax	| detector matcher |	detector := self new.	detector name: 'Uses ifTrue:/ifFalse: instead of min: or max:'.	matcher := ParseTreeSearcher new.	matcher		addSearches: #('(`x `message: `@y) `ifTrue: [`x := `@y]' '(`@x `message: `@y) `ifTrue: [`@x] `ifFalse: [`@y]')				-> 					[:aNode :answer | 					answer or: 							[(#(#ifTrue: #ifFalse: #ifTrue:ifFalse: #ifFalse:ifTrue:)								includes: aNode selector)									and: [#(#< #<= #> #>=) includes: aNode receiver selector]]].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'intention revealing'!missingSubclassResponsibility	| detector |	detector := self new.	detector name: 'Method defined in all subclasses, but not in superclass'.	detector resultClass: MultiEnvironment.	detector classBlock: 			[:context :result | 			| subs |			subs := context selectedClass subclasses.			subs size > 1 & context selectedClass isMetaclass not ifTrue: 					[| sels |					sels := Bag new.					subs do: [:each | sels addAll: each selectors].					sels asSet do: 							[:each | 							((sels occurrencesOf: each) == subs size								and: [(context selectedClass canUnderstand: each) not]) ifTrue: 										[| envName |										envName := context selectedClass name , '>>', each.										subs do: 												[:subClass | 												result addClass: subClass													selector: each													into: envName]]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!missingYourself	| detector matcher |	detector := self new.	detector name: 'Possible missing "; yourself"'.	matcher := ParseTreeSearcher new.	matcher		addSearch: '``@xobject `@messages: ``@args' -> 					[:aNode :answer | 					answer or: 							[aNode parent isCascade								and: [aNode isDirectlyUsed and: [aNode selector ~~ #yourself]]]].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs' stamp: 'nk 2/24/2005 13:31'!modifiesCollection	| detector addSearcher |	detector := self new.	detector name: 'Modifies collection while iterating over it'.	addSearcher := ParseTreeLintRule modifiesCollection.	detector methodBlock: 			[:context :result | 			addSearcher executeTree: context parseTree initialAnswer: false.			addSearcher answer 				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'private' stamp: 'nk 2/23/2005 16:09'!new	^super new! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!onlyReadOrWritten	| detector |	detector := self new.	detector name: 'Instance variables not read AND written'.	detector result: nil references.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| reads writes |					reads := false.					writes := false.					allSubclasses detect: 							[:class | 							reads ifFalse: [reads := (class whichSelectorsRead: each) isEmpty not].							writes ifFalse: [writes := (class whichSelectorsWrite: each) isEmpty not].							reads & writes]						ifNone: [result addInstVar: each for: context selectedClass]]].	^detector! !!BasicLintRuleTest class methodsFor: 'bugs'!overridesSpecialMessage	| detector |	detector := self new.	detector name: 'Overrides a "special" message'.	detector resultClass: ClassEnvironment.	detector classBlock: 			[:context :result | 			((context selectedClass isMetaclass				ifTrue: [self metaclassShouldNotOverride]				ifFalse: [self classShouldNotOverride]) detect: 						[:each | 						context selectedClass superclass notNil and: 								[(context selectedClass superclass canUnderstand: each)									and: [context selectedClass includesSelector: each]]]					ifNone: [nil]) notNil ifTrue: [result addClass: context selectedClass]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!precedence	| detector matcher |	detector := self new.	detector name: 'Inspect instances of "A + B * C" might be "A + (B * C)"'.	matcher := ParseTreeSearcher new.	matcher addSearches: #('``@A + ``@B * ``@C' '``@A - ``@B * ``@C')				-> [:aNode :answer | answer or: [aNode receiver parentheses isEmpty]].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'accessing'!protocols	^#('bugs' 'possible bugs' 'unnecessary code' 'intention revealing' 'miscellaneous')! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!refersToClass	| detector |	detector := self new.	detector name: 'Refers to class name instead of "self class"'.	detector classBlock: 			[:context :result | 			| sels className |			className := (context selectedClass isMetaclass						ifTrue: [context selectedClass primaryInstance]						ifFalse: [context selectedClass]) name.			sels := context selectedClass						whichSelectorsReferTo: (Smalltalk associationAt: className).			sels isEmpty ifFalse: 					[result addSearchString: className.					sels do: [:each | result addClass: context selectedClass selector: each]]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs' stamp: 'bh 4/3/2000 11:54'!returnsBooleanAndOther	| detector matcher |	detector := self new.	detector name: 'Returns a boolean and non boolean'.	matcher := ParseTreeSearcher new.	matcher addSearch: '^``@xObject' -> 					[:aNode :answer | 					answer add: aNode value;						yourself].	detector methodBlock: 			[:context :result | 			| hasBool hasSelf |			hasBool := false.			hasSelf := context parseTree lastIsReturn not.			(matcher executeTree: context parseTree initialAnswer: Set new) do: 					[:each | 					hasBool := hasBool or: 									[(each isLiteral and: [{true. false} includes: each value])										or: [each isMessage and: [#(#and: #or:) includes: each selector]]].					hasSelf := hasSelf or: 									[(each isVariable and: [each name = 'self'])										or: [each isLiteral and: [({true. false} includes: each value) not]]]].			hasSelf & hasBool				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!returnsIfTrue	^self createParseTreeRule: 				#('^`@condition ifTrue: [| `@temps | `@.statements]' 				'^`@condition ifFalse: [| `@temps | `@.statements]') 		name: 'Returns value of ifTrue:/ifFalse: without ifFalse:/ifTrue: block'! !!BasicLintRuleTest class methodsFor: 'possible bugs'!sendsDifferentSuper	| detector |	detector := self new.	detector name: 'Sends different super message'.	detector methodBlock: 			[:context :result | 			| message |			(message := context superMessages detect: [:each | each ~= context selector]						ifNone: [nil]) notNil ifTrue: 					[result addSearchString: message.					result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'bugs'!sentNotImplemented	| detector |	detector := self new.	detector name: 'Messages sent but not implemented'.	detector methodBlock: 			[:context :result | 			| message |			message := context messages detect: [:each | (context implements: each) not]						ifNone: [nil].			message isNil ifTrue: 					[message := context superMessages detect: 									[:each | 									context selectedClass superclass isNil										or: [(context selectedClass superclass canUnderstand: each) not]]								ifNone: [nil].					message isNil ifTrue: 							[message := context selfMessages										detect: [:each | (context selectedClass canUnderstand: each) not]										ifNone: [nil]]].			message notNil ifTrue: 					[result addSearchString: message.					result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!sentNotImplementedInApplication	| detector |	detector := self new.	detector name: 'Messages sent but not implemented in application'.	detector methodBlock: 			[:context :result | 			| message class block |			message := context messages						detect: [:each | (context isItem: each in: context application) not]						ifNone: [nil].			class := context selectedClass.			block := 					[:each | 					| app |					app := context application.					(self canCall: each						in: class						from: app) not].			message isNil ifTrue: [message := context selfMessages detect: block ifNone: [nil]].			message isNil ifTrue: 					[class := class superclass.					class isNil						ifTrue: 							[context superMessages isEmpty ifFalse: [message := context superMessages asArray first]]						ifFalse: [message := context superMessages detect: block ifNone: [nil]]].			message notNil ifTrue: 					[result addSearchString: message.					result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'intention revealing'!sizeCheck	^self createParseTreeRule: (#(#do: #collect: #reject: #select:) collect: 					[:each | 					'`@object size > 0 ifTrue: [`@object ' , each						, ' [:`each | | `@temps | `@.Statements1]. `@.Statements2]'])				, (#(#do: #collect: #reject: #select:) collect: 							[:each | 							'`@object isEmpty ifFalse: [`@object ' , each								, ' [:`each | | `@temps | `@.Statements1]. `@.Statements2]'])		name: 'Unnecessary size check'! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!stringConcatenation	| detector matcher concatenationMatcher |	detector := self new.	detector name: 'String concatenation instead of streams'.	matcher := ParseTreeSearcher new.	concatenationMatcher := ParseTreeSearcher new.	concatenationMatcher		addSearch: '`@receiver , `@argument' -> [:aNode :answer | true].	matcher		addSearches: #('``@collection do: [:`each | | `@temps | ``@.Statements]' '``@collection do: [:`each | | `@temps | ``@.Statements] separatedBy: [| `@temps1 | ``@.Statements1]' '``@number to: ``@endNumber do: [:`i | | `@temps | ``@.Statements]' '``@collection detect: [:`each | | `@temps | ``@.Statements]' '``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [| `@temps1 | ``@.Statements1]' '``@collection select: [:`each | | `@temps | ``@.Statements]' '``@collection inject: ``@value into: [:`each | | `@temps | ``@.Statements]')				-> 					[:aNode :answer | 					answer or: 							[(aNode arguments detect: 									[:each | 									each isBlock										and: [concatenationMatcher executeTree: each initialAnswer: false]]								ifNone: [nil]) notNil]].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'private'!subclassOf: aClass overrides: aSelector 	| subs |	subs := aClass subclasses.	1 to: subs size		do: 			[:i | 			| each |			each := subs at: i.			(each includesSelector: aSelector) ifTrue: [^true].			(self subclassOf: each overrides: aSelector) ifTrue: [^true]].	^false! !!BasicLintRuleTest class methodsFor: 'bugs'!subclassResponsibilityNotDefined	| detector subclassResponsibilitySymbol |	detector := self new.	subclassResponsibilitySymbol := 'subclassResponsibility' asSymbol.	detector name: 'Subclass responsibility not defined'.	detector classBlock: 			[:context :result | 			(context selectedClass whichSelectorsReferTo: subclassResponsibilitySymbol)				do: 					[:each | 					(context selectedClass withAllSubclasses detect: 							[:class | 							class subclasses isEmpty								and: [(class whichClassIncludesSelector: each) == context selectedClass]]						ifNone: [nil]) notNil						ifTrue: [result addClass: context selectedClass selector: each]]].	^detector! !!BasicLintRuleTest class methodsFor: 'private'!superMessages	^#(#release #postCopy #postBuildWith: #preBuildWith: #postOpenWith: #noticeOfWindowClose: #initialize)! !!BasicLintRuleTest class methodsFor: 'possible bugs'!superSends	| detector |	detector := self new.	detector name: 'Missing super sends'.	detector methodBlock: 			[:context :result | 			(context selectedClass isMetaclass not				and: [self superMessages includes: context selector]) ifTrue: 						[(context selectedClass superclass notNil							and: [context selectedClass superclass canUnderstand: context selector])								ifTrue: 									[(context superMessages includes: context selector)										ifFalse: [result addClass: context selectedClass selector: context selector]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!tempVarOverridesInstVar	| detector matcher vars varName |	detector := self new.	detector name: 'Instance variable overridden by temporary variable'.	matcher := (ParseTreeSearcher new) addArgumentSearch: '`xxxvar' -> 								[:aNode :answer | 								answer or: 										[varName := aNode name.										vars includes: varName]];				yourself.	detector methodBlock: 			[:context :result | 			vars := context instVarNames.			(matcher executeTree: context parseTree initialAnswer: false) ifTrue: 					[result addClass: context selectedClass selector: context selector.					result addSearchString: varName]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!tempsReadBeforeWritten	| detector |	detector := self new.	detector name: 'Temporaries read before written'.	detector methodBlock: 			[:context :result | 			| variables |			variables := ParseTreeSearcher nonBlockTempsIn: context parseTree.			variables isEmpty 				ifFalse: 					[(RBReadBeforeWrittenTester variablesReadBeforeWrittenIn: context parseTree) 						do: 							[:each | 							result addClass: context selectedClass selector: context selector.							result addSearchString: each]]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!threeElementPoint	| detector matcher |	detector := self new.	detector name: 'Possible three element point (e.g., x @ y + q @ r)'.	matcher := (ParseTreeSearcher new) addSearch: '``@x @ ``@y' -> 								[:aNode :answer | 								answer or: 										[| current |										current := aNode parent.										[current isNil or: 												[current isMessage													and: [current selector == #@ or: [current selector isInfix not]]]]											whileFalse: [current := current parent].										(current isNil or: [current isMessage and: [current selector isInfix not]])											not]];				yourself.	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'intention revealing'!toDo	| detector matcher |	detector := self new.	detector name: 'Uses to:do: instead of do:, with:do: or timesRepeat:'.	matcher := ParseTreeSearcher new.	matcher		addSearch: '1 to: ``@object size do: [:`each | | `@temps | `@.Statements]' -> 					[:aNode :answer | 					answer or: 							[| varName variableMatcher |							varName := aNode arguments last arguments first name. "`each"							variableMatcher := ParseTreeSearcher new.							variableMatcher addSearch: varName										-> [:node :ans | ans and: [node parent isMessage and: [node parent selector == #at:]]].							variableMatcher executeTree: aNode arguments last body initialAnswer: true]].	detector methodBlock: 			[:context :result | 			(matcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!unreferencedVariables	| detector |	detector := self new.	detector name: 'Variables not referenced'.	detector result: nil unreferenced.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					allSubclasses						detect: [:class | (class whichSelectorsAccess: each) isEmpty not]						ifNone: [result addInstVar: each for: context selectedClass]].			context selectedClass isMetaclass ifFalse: 					[context selectedClass classPool associationsDo: 							[:each | 							(context uses: each)								ifFalse: [result addClassVar: each key for: context selectedClass]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'possible bugs'!usesAdd	| detector addSearcher |	detector := self new.	detector name: 'Uses the result of an add: message'.	addSearcher := ParseTreeSearcher usesResultOfAdd.	detector methodBlock: 			[:context :result | 			(addSearcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest class methodsFor: 'bugs'!usesTrue	| detector trueBinding falseBinding |	detector := self new.	trueBinding := Smalltalk associationAt: #True.	falseBinding := Smalltalk associationAt: #False.	detector name: 'Uses True/False instead of true/false'.	detector methodBlock: 			[:context :result | 			| method |			method := context compiledMethod.			((method referencesLiteral: trueBinding)				or: [method referencesLiteral: falseBinding]) ifTrue: 						[result addClass: context selectedClass selector: context selector.						result searchStrings: #('True' 'False')]].	^detector! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!utilityMethods	| detector |	detector := self new.	detector name: 'Utility methods'.	detector methodBlock: 			[:context :result | 			(context selectedClass isMetaclass | (context selector numArgs == 0) or: 					[(context protocols detect: 							[:each | 							(self utilityProtocols detect: [:protocol | protocol match: each]								ifNone: [nil]) notNil]						ifNone: [nil]) notNil])				ifFalse: 					[(self subclassOf: context selectedClass overrides: context selector)						ifFalse: 							[(context superMessages isEmpty and: [context selfMessages isEmpty]) ifTrue: 									[(ParseTreeSearcher										references: context selectedClass allInstVarNames												, context selectedClass allClassVarNames asArray , #('self')										in: context parseTree) isEmpty										ifTrue: [result addClass: context selectedClass selector: context selector]]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'private'!utilityProtocols	"If a method is defined in one of these protocols, then don't check if its a utility method."	^#('*utilit*')! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!variableAssignedLiteral	| detector |	detector := self new.	detector name: 'Variable is only assigned a single literal value'.	detector result: nil references.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| defClass selector |					(allSubclasses inject: 0						into: 							[:sum :class | 							| sels |							sels := class whichSelectorsWrite: each.							sels size == 1 ifTrue: 									[selector := sels asArray first.									defClass := class].							sum + sels size])							== 1 ifTrue: 								[| tree searcher |								searcher := ParseTreeSearcher new.								searcher addSearch: (each , ' := ``@object')											-> [:aNode :answer | answer isNil and: [aNode value isLiteral]].								tree := defClass parseTreeFor: selector.								tree notNil ifTrue: 										[(searcher executeTree: tree initialAnswer: nil) == true											ifTrue: [result addInstVar: each for: context selectedClass]]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'unnecessary code'!variableReferencedOnce	| detector |	detector := self new.	detector 		name: 'Variable referenced in only one method and always assigned first'.	detector classBlock: 			[:context :result | 			| allSubclasses |			allSubclasses := context selectedClass withAllSubclasses.			context selectedClass instVarNames do: 					[:each | 					| defClass selector |					(allSubclasses inject: 0						into: 							[:sum :class | 							| sels |							sels := class whichSelectorsAccess: each.							sels size == 1 								ifTrue: 									[selector := sels asArray first.									defClass := class].							sum + sels size]) 							== 1 							ifTrue: 								[| tree |								tree := defClass parseTreeFor: selector.								tree notNil 									ifTrue: 										[(RBReadBeforeWrittenTester readBeforeWritten: (Array with: each) in: tree) 											isEmpty 												ifTrue: 													[result addClass: defClass selector: selector.													result addSearchString: each]]]]].	^detector! !!BasicLintRuleTest class methodsFor: 'intention revealing'!whileTrue	^self createParseTreeRule: 			#('| `@temps | 				`@.Statements1. 				[`index <= `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index + 1].				`@.Statements2' 			'| `@temps | 				`@.Statements1. 				[`index < `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index + 1].				`@.Statements2'			'| `@temps | 				`@.Statements1. 				[`index >= `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index - 1].				`@.Statements2' 			'| `@temps | 				`@.Statements1. 				[`index > `@stop] 					whileTrue: 						[| `@blockTemps | 						`@.BlockStmts1. 						`index := `index - 1].				`@.Statements2') 		name: 'Uses whileTrue: instead of to:do:'! !!BasicLintRuleTest class methodsFor: 'miscellaneous'!yourselfNotUsed	| detector addSearcher |	detector := self new.	detector name: 'Doesn''t use the result of a yourself message'.	addSearcher := ParseTreeSearcher new.	addSearcher addSearch: '`@object yourself'				-> [:aNode :answer | answer or: [aNode isUsed not]].	detector methodBlock: 			[:context :result | 			(addSearcher executeTree: context parseTree initialAnswer: false)				ifTrue: [result addClass: context selectedClass selector: context selector]].	^detector! !!BasicLintRuleTest methodsFor: 'accessing'!checkClass: aSmalllintContext 	^classBlock value: aSmalllintContext value: result! !!BasicLintRuleTest methodsFor: 'accessing'!checkMethod: aSmalllintContext 	^methodBlock value: aSmalllintContext value: result! !!BasicLintRuleTest methodsFor: 'initialize-release'!classBlock: aBlock	classBlock := aBlock testMethod1! !!BasicLintRuleTest methodsFor: 'accessing' stamp: 'bh 4/3/2000 10:19'!foobar	^#( true false )! !!BasicLintRuleTest methodsFor: 'initialize-release'!initialize	super initialize.	classBlock := [:context :aResult | ].	methodBlock := [:context :aResult | ].	self resultClass: SelectorEnvironment! !!BasicLintRuleTest methodsFor: 'testing'!isEmpty	^result isEmpty! !!BasicLintRuleTest methodsFor: 'initialize-release'!methodBlock: aBlock	methodBlock := aBlock! !!BasicLintRuleTest methodsFor: 'accessing'!problemCount	^result problemCount! !!BasicLintRuleTest methodsFor: 'initialize-release'!resetResult	result := result copyEmpty.	result label: name! !!BasicLintRuleTest methodsFor: 'accessing'!result	^result! !!BasicLintRuleTest methodsFor: 'initialize-release'!result: aResult 	result := aResult copyEmpty! !!BasicLintRuleTest methodsFor: 'initialize-release'!resultClass: aClass 	result := aClass new! !!BasicLintRuleTest methodsFor: 'private'!viewResults	result openEditor! !!CompositeLintRuleTest class methodsFor: 'instance creation'!allRules	^self ruleFor: self protocol: 'all checks'! !!CompositeLintRuleTest class methodsFor: 'all checks'!lintChecks	^self rules: (BasicLintRuleTest protocols				collect: [:each | self ruleFor: BasicLintRuleTest protocol: each])		name: 'Lint checks'! !!CompositeLintRuleTest class methodsFor: 'instance creation'!ruleFor: aClass protocol: aProtocol 	^self		rules: (((BrowserEnvironment new selectorsFor: aProtocol asSymbol in: aClass class)				collect: [:selector | aClass perform: selector])					asSortedCollection: [:a :b | a name < b name])		name: ((aProtocol asString copy) at: 1 put: aProtocol first asUppercase;				yourself)! !!CompositeLintRuleTest class methodsFor: 'instance creation'!rules: aCollection 	^self new rules: aCollection! !!CompositeLintRuleTest class methodsFor: 'instance creation'!rules: aCollection name: aString 	^(self new) rules: aCollection;		name: aString;		yourself! !!CompositeLintRuleTest class methodsFor: 'all checks'!transformations	^self ruleFor: TransformationRuleTest protocol: 'transformations'! !!CompositeLintRuleTest methodsFor: 'accessing'!checkClass: aSmalllintContext 	rules do: 			[:each | 			each checkClass: aSmalllintContext.			Processor yield]! !!CompositeLintRuleTest methodsFor: 'accessing'!checkMethod: aSmalllintContext 	rules do: 			[:each | 			each checkMethod: aSmalllintContext.			Processor yield]! !!CompositeLintRuleTest methodsFor: 'accessing'!failedRules	^rules inject: OrderedCollection new into: [:oc :each | oc addAll: each failedRules; yourself]! !!CompositeLintRuleTest methodsFor: 'testing'!hasConflicts	^(rules detect: [:each | each hasConflicts] ifNone: [nil]) notNil! !!CompositeLintRuleTest methodsFor: 'testing'!isComposite	^true! !!CompositeLintRuleTest methodsFor: 'testing'!isEmpty	^(rules detect: [:each | each isEmpty not] ifNone: [nil]) isNil! !!CompositeLintRuleTest methodsFor: 'accessing'!problemCount	^rules inject: 0 into: [:count :each | count + each problemCount]! !!CompositeLintRuleTest methodsFor: 'initialize-release'!resetResult	rules do: [:each | each resetResult]! !!CompositeLintRuleTest methodsFor: 'accessing'!rules	^rules! !!CompositeLintRuleTest methodsFor: 'initialize-release'!rules: aCollection	rules := aCollection! !!CompositeLintRuleTest methodsFor: 'private'!viewResults	rules do: [:each | each viewResults]! !!TransformationRuleTest class methodsFor: 'transformations'!assignmentInIfTrue	^self rewrite: #(			#('``@Boolean ifTrue: [`variable := ``@true] ifFalse: [`variable := ``@false]'			"->"			'`variable := ``@Boolean ifTrue: [``@true] ifFalse: [``@false]')			#('``@Boolean ifFalse: [`variable := ``@true] ifTrue: [`variable := ``@false]'			"->"			'`variable := ``@Boolean ifFalse: [``@true] ifTrue: [``@false]'))		methods: false		name: 'Move variable assignment outside of single statement ifTrue:ifFalse: blocks'! !!TransformationRuleTest class methodsFor: 'transformations'!atIfAbsent	^self rewrite: #(			#('``@dictionary at: ``@key 					ifAbsent: [| `@temps | 							``@.Statements1.							``@dictionary at: ``@key put: ``@object.							``@.Statements2.							``@object]'			"->"			'``@dictionary at: ``@key					ifAbsentPut: [| `@temps |							``@.Statements1.							``@.Statements2.							``@object]')			#('``@dictionary at: ``@key					ifAbsent: [| `@temps |							``@.Statements.							``@dictionary at: ``@key put: ``@object]'			"->"			'``@dictionary at: ``@key					ifAbsentPut: [| `@temps |							``@.Statements.							``@object]'))		methods: false		name: 'at:ifAbsent: -> at:ifAbsentPut:'! !!TransformationRuleTest class methodsFor: 'transformations'!betweenAnd	^self rewrite: #(			#('``@a >= ``@b and: [``@a <= ``@c]' "->" '``@a between: ``@b and: ``@c')			#('``@a >= ``@b & (``@a <= ``@c)' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a and: [``@a <= ``@c]' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a & (``@a <= ``@c)' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c and: [``@a >= ``@b]' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c & (``@a >= ``@b)' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a and: [``@a >= ``@b]' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a & (``@a >= ``@b)' "->" '``@a between: ``@b and: ``@c')			#('``@a >= ``@b and: [``@c >= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@a >= ``@b & (``@c >= ``@a)' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a and: [``@c >= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@b <= ``@a & (``@c >= ``@a)' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c and: [``@b <= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@a <= ``@c & (``@b <= ``@a)' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a and: [``@b <= ``@a]' "->" '``@a between: ``@b and: ``@c')			#('``@c >= ``@a & (``@b <= ``@a)' "->" '``@a between: ``@b and: ``@c'))		methods: false		name: '"a >= b and: [a <= c]" -> "a between: b and: c"'! !!TransformationRuleTest class methodsFor: 'transformations'!detectIfNone	^self rewrite: #(			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) isNil'				"->"	'(``@collection contains: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) = nil'				"->"	'(``@collection contains: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) == nil'				"->"	'(``@collection contains: [:`each | | `@temps | ``@.Statements]) not')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) notNil'				"->"	'``@collection contains: [:`each | | `@temps | ``@.Statements]')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) ~= nil'				"->"	'``@collection contains: [:`each | | `@temps | ``@.Statements]')			#('(``@collection detect: [:`each | | `@temps | ``@.Statements] ifNone: [nil]) ~~ nil'				"->"	'``@collection contains: [:`each | | `@temps | ``@.Statements]'))		methods: false		name: 'detect:ifNone: -> contains:'! !!TransformationRuleTest class methodsFor: 'transformations'!equalNil	^self		rewrite: #(			#('``@object = nil'	"->"	'``@object isNil') 			#('``@object == nil'	"->"	'``@object isNil') 			#('``@object ~= nil'	"->"	'``@object notNil') 			#('``@object ~~ nil'	"->"	'``@object notNil'))		methods: false		name: '= nil -> isNil AND ~= nil -> notNil'! !!TransformationRuleTest class methodsFor: 'transformations'!guardClause	^self		rewrite: #(			#('`@methodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifTrue: [| `@trueTemps | `.Statement1. `.Statement2. `@.Statements1]'			"->"			'`@methodName: `@args					| `@temps `@trueTemps |					`@.Statements.					`@condition ifFalse: [^self].					`.Statement1.					`.Statement2.					`@.Statements1') 			#('`@methodName: `@args 					| `@temps | 					`@.Statements. 					`@condition ifFalse: [| `@falseTemps | `.Statement1. `.Statement2. `@.Statements1]'			"->"			'`@methodName: `@args					| `@temps `@falseTemps |					`@.Statements.					`@condition ifTrue: [^self].					`.Statement1.					`.Statement2.					`@.Statements1'))		methods: true		name: 'Eliminate guarding clauses'! !!TransformationRuleTest class methodsFor: 'class initialization'!initializeAfterLoad1	RecursiveSelfRule := ParseTreeSearcher new.	RecursiveSelfRule		addMethodSearches: #('`@methodName: `@args | `@temps | self `@methodName: `@args' '`@methodName: `@args | `@temps | ^self `@methodName: `@args')				-> [:aNode :answer | true]! !!TransformationRuleTest class methodsFor: 'transformations'!minMax	^self rewrite: #(			#('``@a < ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a min: ``@b')			#('``@a <= ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a min: ``@b')			#('``@a > ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a max: ``@b')			#('``@a >= ``@b ifTrue: [``@a] ifFalse: [``@b]'	"->"	'``@a max: ``@b')			#('``@a < ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a max: ``@b')			#('``@a <= ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a max: ``@b')			#('``@a > ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a min: ``@b')			#('``@a >= ``@b ifTrue: [``@b] ifFalse: [``@a]'	"->"	'``@a min: ``@b')			#('`a < ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('`a <= ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('`a < ``@b ifFalse: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('`a <= ``@b ifFalse: [`a := ``@b]'			"->"	'`a := `a min: ``@b')			#('`a > ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('`a >= ``@b ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('`a > ``@b ifFalse: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('`a >= ``@b ifFalse: [`a := ``@b]'			"->"	'`a := `a max: ``@b')			#('``@b < `a ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('``@b <= `a ifTrue: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('``@b < `a ifFalse: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('``@b <= `a ifFalse: [`a := ``@b]'			"->"	'`a := `a max: ``@b')			#('``@b > `a ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('``@b >= `a ifTrue: [`a := ``@b]'				"->"	'`a := `a max: ``@b')			#('``@b > `a ifFalse: [`a := ``@b]'				"->"	'`a := `a min: ``@b')			#('``@b >= `a ifFalse: [`a := ``@b]'			"->"	'`a := `a min: ``@b'))		methods: false		name: 'Rewrite ifTrue:ifFalse: using min:/max:'! !!TransformationRuleTest class methodsFor: 'transformations'!notElimination	^self		rewrite: #(			#('``@object not not'	"->"	'``@object') 			#('``@object not ifTrue: ``@block' 	"->"	'``@object ifFalse: ``@block') 			#('``@object not ifFalse: ``@block'	"->"	'``@object ifTrue: ``@block') 			#('``@collection select: [:`each | | `@temps | ``@.Statements. ``@object not]'				"->"	'``@collection reject: [:`each | | `@temps | ``@.Statements. ``@object]')			#('``@collection reject: [:`each | | `@temps | ``@.Statements. ``@object not]'				"->"	'``@collection select: [:`each | | `@temps | ``@.Statements. ``@object]')			#('[| `@temps | ``@.Statements. ``@object not] whileTrue: ``@block'				"->"	'[| `@temps | ``@.Statements. ``@object] whileFalse: ``@block')			#('[| `@temps | ``@.Statements. ``@object not] whileFalse: ``@block'				"->"	'[| `@temps | ``@.Statements. ``@object] whileTrue: ``@block')			#('[| `@temps | ``@.Statements. ``@object not] whileTrue'				"->"	'[| `@temps | ``@.Statements. ``@object] whileFalse')			#('[| `@temps | ``@.Statements. ``@object not] whileFalse'				"->"	'[| `@temps | ``@.Statements. ``@object] whileTrue')			#('(``@a <= ``@b) not' "->" '``@a > ``@b')			#('(``@a < ``@b) not' "->" '``@a >= ``@b')			#('(``@a = ``@b) not' "->" '``@a ~= ``@b')			#('(``@a == ``@b) not' "->" '``@a ~~ ``@b')			#('(``@a ~= ``@b) not' "->" '``@a = ``@b')			#('(``@a ~~ ``@b) not' "->" '``@a == ``@b')			#('(``@a >= ``@b) not' "->" '``@a < ``@b')			#('(``@a > ``@b) not' "->" '``@a <= ``@b'))					methods: false		name: 'Eliminate unnecessary not''s'! !!TransformationRuleTest class methodsFor: 'class initialization'!nuke	RecursiveSelfRule := nil! !!TransformationRuleTest class methodsFor: 'instance creation'!rewrite: stringArrays methods: aBoolean name: aName 	| rewriteRule |	rewriteRule := ParseTreeRewriter new.	stringArrays do: 			[:each | 			aBoolean				ifTrue: [rewriteRule addMethodSearch: each first -> each last]				ifFalse: [rewriteRule addSearch: each first -> each last]].	^(self new) name: aName;		rewriteUsing: rewriteRule;		yourself! !!TransformationRuleTest class methodsFor: 'transformations'!showWhileBlocks	^self		rewrite: #(			#('``@cursor showWhile: [| `@temps | ``@.Statements. `var := ``@object]'				"->"	'`var := ``@cursor showWhile: [| `@temps | ``@.Statements. ``@object]') 			#('``@cursor showWhile: [| `@temps | ``@.Statements. ^``@object]'				"->"	'^``@cursor showWhile: [| `@temps | ``@.Statements. ``@object]'))		methods: false		name: 'Move assignment out of showWhile: blocks'! !!TransformationRuleTest class methodsFor: 'transformations'!superSends	^(self new)		name: 'Rewrite super messages to self messages when both refer to same method';		superSends;		yourself! !!TransformationRuleTest class methodsFor: 'transformations'!unwindBlocks	^self		rewrite: #(			#('[| `@temps | ``@.Statements. `var := ``@object] valueNowOrOnUnwindDo: ``@block'				"->"	'`var := [| `@temps | ``@.Statements. ``@object] valueNowOrOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. ^``@object] valueNowOrOnUnwindDo: ``@block'				"->"	'^[| `@temps | ``@.Statements. ``@object] valueNowOrOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. `var := ``@object] valueOnUnwindDo: ``@block'				"->"	'`var := [| `@temps | ``@.Statements. ``@object] valueOnUnwindDo: ``@block') 			#('[| `@temps | ``@.Statements. ^``@object] valueOnUnwindDo: ``@block'				"->"	'^[| `@temps | ``@.Statements. ``@object] valueOnUnwindDo: ``@block'))		methods: false		name: 'Move assignment out of valueNowOrUnwindDo: blocks'! !!TransformationRuleTest methodsFor: 'accessing'!checkMethod: aSmalllintContext 	class := aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)				ifFalse: 					[builder compile: rewriteRule tree printString						in: class						classified: aSmalllintContext protocols]]! !!TransformationRuleTest methodsFor: 'testing'!hasConflicts	^true! !!TransformationRuleTest methodsFor: 'testing'!isEmpty	^builder changes isEmpty! !!TransformationRuleTest methodsFor: 'accessing'!problemCount	^builder problemCount! !!TransformationRuleTest methodsFor: 'accessing'!resetResult	builder := CompositeRefactoryChange new! !!TransformationRuleTest methodsFor: 'initialize-release'!rewriteUsing: searchReplacer 	rewriteRule := searchReplacer.	self resetResult! !!TransformationRuleTest methodsFor: 'rules'!superSends	| rule |	rule := ParseTreeRewriter new.	rule addSearch: 'super `@message: ``@args'				-> (					[:aNode | 					(class withAllSubclasses						detect: [:each | each includesSelector: aNode selector]						ifNone: [nil]) isNil]							-> 'self `@message: ``@args').	self rewriteUsing: rule! !!TransformationRuleTest methodsFor: 'private'!viewResults	"I reset the result so that we don't fill up memory with methods to compile in the builder."	builder inspect.	self resetResult! !!LintRuleTest methodsFor: 'accessing'!checkClass: aSmalllintContext! !!LintRuleTest methodsFor: 'accessing'!checkMethod: aSmalllintContext! !!LintRuleTest methodsFor: 'accessing'!displayName	| nameStream |	nameStream := WriteStream on: (String new: 64).	nameStream nextPutAll: self name;		nextPutAll: ' ('.	self problemCount printOn: nameStream.	nameStream nextPut: $).	^nameStream contents! !!LintRuleTest methodsFor: 'private'!failedRules	^self isEmpty		ifTrue: [#()]		ifFalse: [Array with: self]! !!LintRuleTest methodsFor: 'testing'!hasConflicts	^false! !!LintRuleTest methodsFor: 'initialize-release'!initialize	name := ''! !!LintRuleTest methodsFor: 'testing'!isComposite	^false! !!LintRuleTest methodsFor: 'testing'!isEmpty	self subclassResponsibility! !!LintRuleTest methodsFor: 'testing' stamp: 'bh 4/3/2000 22:39'!junk	^RefactoryTestDataApp printString copyFrom: 1 to: CR! !!LintRuleTest methodsFor: 'accessing'!name	^name! !!LintRuleTest methodsFor: 'accessing'!name: aString 	name := aString! !!LintRuleTest methodsFor: 'accessing' stamp: 'bh 3/25/2000 02:00'!openEditor	| rules |	rules := self failedRules.	rules isEmpty ifTrue: [^self].	rules size == 1 ifTrue: [^rules first viewResults].	SmalllintResultEditor openOn: self label: name! !!LintRuleTest methodsFor: 'printing'!printOn: aStream 	name isNil		ifTrue: [super printOn: aStream]		ifFalse: [aStream nextPutAll: name]! !!LintRuleTest methodsFor: 'accessing'!problemCount	^self subclassResponsibility! !!LintRuleTest methodsFor: 'initialize-release'!resetResult! !!LintRuleTest methodsFor: 'accessing'!run	^Object printOn: self! !!LintRuleTest methodsFor: 'accessing'!runOnEnvironment: anEnvironment 	^Object printOn: self onEnvironment: anEnvironment! !!LintRuleTest methodsFor: 'private'!viewResults	self subclassResponsibility! !!RBAbstractClass class methodsFor: 'class initialization'!initialize	LookupSuperclass := Object new! !!RBAbstractClass methodsFor: 'comparing'!= aRBClass 	^self class = aRBClass class 		and: [self name = aRBClass name and: [self model = aRBClass model]]! !!RBAbstractClass methodsFor: 'variable accessing'!addInstanceVariable: aString 	self privateInstanceVariableNames add: aString.	model addInstanceVariable: aString to: self! !!RBAbstractClass methodsFor: 'method accessing'!addMethod: aRBMethod 	self newMethods at: aRBMethod selector put: aRBMethod.	removedMethods notNil 		ifTrue: [removedMethods remove: aRBMethod selector ifAbsent: []]! !!RBAbstractClass methodsFor: 'private'!addSubclass: aRBClass 	self subclasses add: aRBClass! !!RBAbstractClass methodsFor: 'accessing'!allClassVariableNames	^self subclassResponsibility! !!RBAbstractClass methodsFor: 'accessing'!allInstanceVariableNames	| sprClass |	sprClass := self superclass.	^sprClass isNil 		ifTrue: [self instanceVariableNames]		ifFalse: [sprClass allInstanceVariableNames , self instanceVariableNames]! !!RBAbstractClass methodsFor: 'accessing'!allPoolDictionaryNames	^self subclassResponsibility! !!RBAbstractClass methodsFor: 'method accessing'!allSelectors	| class selectors |	class := self.	selectors := Set new.	[class notNil] whileTrue: 			[selectors addAll: class selectors.			class := class superclass].	^selectors! !!RBAbstractClass methodsFor: 'accessing'!allSubclasses	| allSubclasses index |	index := 1.	allSubclasses := self subclasses asOrderedCollection.	[index <= allSubclasses size] whileTrue: 			[allSubclasses addAll: (allSubclasses at: index) subclasses.			index := index + 1].	^allSubclasses! !!RBAbstractClass methodsFor: 'accessing'!allSuperclasses	| supers sprClass |	supers := OrderedCollection new.	sprClass := self superclass.	[sprClass notNil] whileTrue: 			[supers add: sprClass.			sprClass := sprClass superclass].	^supers! !!RBAbstractClass methodsFor: 'method accessing' stamp: 'md 1/17/2006 14:17'!bindingOf: aString 	^self realClass classPool associationAt: aString asSymbol		ifAbsent: [self realClass classPool associationAt: aString asString ifAbsent: [nil]]! !!RBAbstractClass methodsFor: 'accessing'!classBinding	^Smalltalk associationAt: self name! !!RBAbstractClass methodsFor: 'method accessing'!compile: aString 	^self compile: aString		classified: (self protocolsFor: (RBParser parseMethodPattern: aString))! !!RBAbstractClass methodsFor: 'method accessing'!compile: aString classified: aSymbolCollection 	| change method |	change := model 				compile: aString				in: self				classified: aSymbolCollection.	method := RBMethod 				for: self				source: aString				selector: change selector.	self addMethod: method! !!RBAbstractClass methodsFor: 'method accessing'!compileTree: aBRMethodNode 	^self compileTree: aBRMethodNode		classified: (self protocolsFor: aBRMethodNode selector)! !!RBAbstractClass methodsFor: 'method accessing'!compileTree: aBRMethodNode classified: aSymbolCollection 	| method source |	source := aBRMethodNode formattedCode.	model 		compile: source		in: self		classified: aSymbolCollection.	method := RBMethod 				for: self				source: source				selector: aBRMethodNode selector."	method parseTree: aBRMethodNode."	self addMethod: method! !!RBAbstractClass methodsFor: 'testing'!definesClassVariable: aSymbol 	(self directlyDefinesClassVariable: aSymbol) ifTrue: [^true].	^self superclass notNil 		and: [self superclass definesClassVariable: aSymbol]! !!RBAbstractClass methodsFor: 'testing'!definesInstanceVariable: aString 	(self directlyDefinesInstanceVariable: aString) ifTrue: [^true].	^self superclass notNil 		and: [self superclass definesInstanceVariable: aString]! !!RBAbstractClass methodsFor: 'testing'!definesMethod: aSelector 	(self directlyDefinesMethod: aSelector) ifTrue: [^true].	^self superclass notNil and: [self superclass definesMethod: aSelector]! !!RBAbstractClass methodsFor: 'testing'!definesPoolDictionary: aSymbol 	(self directlyDefinesPoolDictionary: aSymbol) ifTrue: [^true].	^self inheritsPoolDictionaries and: 			[self superclass notNil 				and: [self superclass definesPoolDictionary: aSymbol]]! !!RBAbstractClass methodsFor: 'testing'!definesVariable: aVariableName 	^(self definesClassVariable: aVariableName) 		or: [self definesInstanceVariable: aVariableName]! !!RBAbstractClass methodsFor: 'testing'!directlyDefinesClassVariable: aString 	self subclassResponsibility! !!RBAbstractClass methodsFor: 'testing'!directlyDefinesInstanceVariable: aString 	^self instanceVariableNames includes: aString! !!RBAbstractClass methodsFor: 'testing'!directlyDefinesMethod: aSelector 	self isDefined 		ifTrue: 			[(self hasRemoved: aSelector) ifTrue: [^false].			(self realClass includesSelector: aSelector) ifTrue: [^true]].	^newMethods notNil and: [newMethods includesKey: aSelector]! !!RBAbstractClass methodsFor: 'testing'!directlyDefinesPoolDictionary: aString 	self subclassResponsibility! !!RBAbstractClass methodsFor: 'testing'!directlyDefinesVariable: aVariableName 	^(self directlyDefinesClassVariable: aVariableName) 		or: [self directlyDefinesInstanceVariable: aVariableName]! !!RBAbstractClass methodsFor: 'method accessing' stamp: 'bh 4/8/2000 18:58'!existingMethodsThatReferTo: aSymbol 	| existingMethods |	existingMethods := self realClass thoroughWhichSelectorsReferTo: aSymbol special:false byte:0.	(newMethods isNil and: [removedMethods isNil]) ifTrue: [^existingMethods].	^existingMethods 		reject: [:each | (self hasRemoved: each) or: [self newMethods includesKey: each]]! !!RBAbstractClass methodsFor: 'testing'!hasRemoved: aSelector 	^removedMethods notNil and: [removedMethods includes: aSelector]! !!RBAbstractClass methodsFor: 'comparing'!hash	^self name hash bitXor: self class hash! !!RBAbstractClass methodsFor: 'testing'!hierarchyDefinesClassVariable: aString 	(self definesClassVariable: aString) ifTrue: [^true].	^(self allSubclasses 		detect: [:each | each directlyDefinesClassVariable: aString]		ifNone: [nil]) notNil! !!RBAbstractClass methodsFor: 'testing'!hierarchyDefinesInstanceVariable: aString 	(self definesInstanceVariable: aString) ifTrue: [^true].	^(self allSubclasses 		detect: [:each | each directlyDefinesInstanceVariable: aString]		ifNone: [nil]) notNil! !!RBAbstractClass methodsFor: 'testing'!hierarchyDefinesMethod: aSelector 	(self definesMethod: aSelector) ifTrue: [^true].	^self subclassRedefines: aSelector! !!RBAbstractClass methodsFor: 'testing'!hierarchyDefinesPoolDictionary: aString 	(self definesPoolDictionary: aString) ifTrue: [^true].	^(self allSubclasses 		detect: [:each | each directlyDefinesPoolDictionary: aString]		ifNone: [nil]) notNil! !!RBAbstractClass methodsFor: 'testing'!hierarchyDefinesVariable: aString 	(self definesVariable: aString) ifTrue: [^true].	^(self allSubclasses 		detect: [:each | each directlyDefinesVariable: aString]		ifNone: [nil]) notNil! !!RBAbstractClass methodsFor: 'testing'!includesClass: aRBClass 	| currentClass |	currentClass := self.	[currentClass notNil and: [currentClass ~= aRBClass]] 		whileTrue: [currentClass := currentClass superclass].	^currentClass = aRBClass! !!RBAbstractClass methodsFor: 'testing'!inheritsPoolDictionaries	^false! !!RBAbstractClass methodsFor: 'initialize-release'!initialize	name := #'Unknown Class'! !!RBAbstractClass methodsFor: 'accessing'!instanceVariableNames	^self privateInstanceVariableNames copy! !!RBAbstractClass methodsFor: 'accessing'!instanceVariableNames: aCollectionOfStrings 	instanceVariableNames := aCollectionOfStrings asOrderedCollection! !!RBAbstractClass methodsFor: 'testing'!isAbstract	(self whichSelectorsReferToSymbol: #subclassResponsibility) isEmpty 		ifFalse: [^true].	model allReferencesToClass: self do: [:each | ^false].	^true! !!RBAbstractClass methodsFor: 'testing'!isDefined	^self realClass notNil! !!RBAbstractClass methodsFor: 'testing'!isMeta	self subclassResponsibility! !!RBAbstractClass methodsFor: 'accessing'!metaclass	^model metaclassNamed: self name! !!RBAbstractClass methodsFor: 'method accessing'!methodFor: aSelector 	^self newMethods at: aSelector		ifAbsent: 			[| compiledMethod class |			(self hasRemoved: aSelector) ifTrue: [^nil].			class := self realClass.			class isNil ifTrue: [^nil].			compiledMethod := class compiledMethodAt: aSelector ifAbsent: [nil].			compiledMethod isNil 				ifTrue: [nil]				ifFalse: 					[RBMethod 						for: self						fromMethod: compiledMethod						andSelector: aSelector]]! !!RBAbstractClass methodsFor: 'accessing'!model	^model! !!RBAbstractClass methodsFor: 'initialize-release'!model: aRBSmalltalk	model := aRBSmalltalk! !!RBAbstractClass methodsFor: 'accessing'!name	^name! !!RBAbstractClass methodsFor: 'accessing'!name: aSymbol 	name := aSymbol! !!RBAbstractClass methodsFor: 'accessing'!newMethods	^newMethods isNil 		ifTrue: [newMethods := IdentityDictionary new]		ifFalse: [newMethods]! !!RBAbstractClass methodsFor: 'accessing'!nonMetaclass	^model classNamed: self name! !!RBAbstractClass methodsFor: 'method accessing'!parseTreeFor: aSelector 	| class |	class := self whoDefinesMethod: aSelector.	class isNil ifTrue: [^nil].	^(class methodFor: aSelector) parseTree! !!RBAbstractClass methodsFor: 'accessing'!primaryInstance	^self nonMetaclass! !!RBAbstractClass methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: self name! !!RBAbstractClass methodsFor: 'private'!privateInstanceVariableNames	instanceVariableNames isNil 		ifTrue: 			[self isDefined 				ifTrue: [self instanceVariableNames: self realClass instVarNames]				ifFalse: [instanceVariableNames := OrderedCollection new]].	^instanceVariableNames! !!RBAbstractClass methodsFor: 'method accessing' stamp: 'jmb 1/23/2003 15:50'!protocolsFor: aSelector 	| change |	change := self isMeta 				ifTrue: [model changes changeForMetaclass: name selector: aSelector]				ifFalse: [model changes changeForClass: name selector: aSelector].	^change isNil 		ifTrue: 			[self isDefined 				ifTrue: 					[Array with: (BrowserEnvironment new whichProtocolIncludes: aSelector in: self realClass)]				ifFalse: [#(#accessing)]]		ifFalse: [change protocols]! !!RBAbstractClass methodsFor: 'accessing'!realClass	^realClass! !!RBAbstractClass methodsFor: 'accessing'!realClass: aClass 	realClass := aClass.	superclass isNil ifTrue: [superclass := LookupSuperclass]! !!RBAbstractClass methodsFor: 'variable accessing'!removeInstanceVariable: aString 	self privateInstanceVariableNames remove: aString.	model removeInstanceVariable: aString from: self! !!RBAbstractClass methodsFor: 'method accessing'!removeMethod: aSelector 	self newMethods removeKey: aSelector ifAbsent: [].	model removeMethod: aSelector from: self.	self removedMethods add: aSelector! !!RBAbstractClass methodsFor: 'accessing'!removeSubclass: aRBClass 	self subclasses remove: aRBClass ifAbsent: []! !!RBAbstractClass methodsFor: 'accessing'!removedMethods	^removedMethods isNil 		ifTrue: [removedMethods := Set new]		ifFalse: [removedMethods]! !!RBAbstractClass methodsFor: 'variable accessing'!renameInstanceVariable: oldName to: newName around: aBlock 	self privateInstanceVariableNames 		at: (self privateInstanceVariableNames indexOf: oldName asString)		put: newName asString.	model 		renameInstanceVariable: oldName		to: newName		in: self		around: aBlock! !!RBAbstractClass methodsFor: 'method accessing'!selectors	| selectors |	selectors := Set new.	selectors addAll: self newMethods keys.	self isDefined 		ifTrue: 			[selectors addAll: self realClass selectors.			removedMethods notNil 				ifTrue: [removedMethods do: [:each | selectors remove: each ifAbsent: []]]].	^selectors! !!RBAbstractClass methodsFor: 'accessing'!soleInstance	^self nonMetaclass! !!RBAbstractClass methodsFor: 'method accessing'!sourceCodeFor: aSelector 	| class |	class := self whoDefinesMethod: aSelector.	class isNil ifTrue: [^nil].	^(class methodFor: aSelector) source! !!RBAbstractClass methodsFor: 'printing'!storeOn: aStream 	aStream nextPutAll: self name! !!RBAbstractClass methodsFor: 'testing'!subclassRedefines: aSelector 	"Return true, if one of your subclasses redefines the method with name, aMethod"	self allSubclasses 		do: [:each | (each directlyDefinesMethod: aSelector) ifTrue: [^true]].	^false! !!RBAbstractClass methodsFor: 'accessing'!subclasses	^subclasses isNil 		ifTrue: 			[subclasses := self isDefined 						ifTrue: 							[(self realClass subclasses collect: [:each | model classFor: each]) 								asOrderedCollection]						ifFalse: [OrderedCollection new]]		ifFalse: [subclasses]! !!RBAbstractClass methodsFor: 'accessing'!superclass	^superclass == LookupSuperclass 		ifTrue: [model classFor: self realClass superclass]		ifFalse: [superclass]! !!RBAbstractClass methodsFor: 'private'!superclass: aRBClass 	self superclass notNil ifTrue: [self superclass removeSubclass: self].	superclass := aRBClass.	superclass notNil ifTrue: [superclass addSubclass: self].! !!RBAbstractClass methodsFor: 'variable accessing'!typeOfClassVariable: aSymbol 	^model classNamed: #Object! !!RBAbstractClass methodsFor: 'method accessing'!whichSelectorsReferToClass: aRBClass 	| selectors |	selectors := Set new.	self newMethods do: 			[:each | 			(each refersToClassNamed: aRBClass name) 				ifTrue: [selectors add: each selector]].	(self isDefined and: [aRBClass isDefined]) 		ifTrue: 			[selectors addAll: (self existingMethodsThatReferTo: aRBClass classBinding).			selectors addAll: (self existingMethodsThatReferTo: aRBClass name)].	^selectors! !!RBAbstractClass methodsFor: 'method accessing' stamp: 'md 1/17/2006 14:17'!whichSelectorsReferToClassVariable: aString 	| selectors |	selectors := Set new.	self newMethods 		do: [:each | (each refersToVariable: aString) ifTrue: [selectors add: each selector]].	self isDefined 		ifTrue: 			[| binding |			binding := self bindingOf: aString.			binding isNil ifTrue: [^selectors].			selectors addAll: ((self realClass whichSelectorsReferTo: binding) 						reject: [:each | self hasRemoved: each])].	^selectors! !!RBAbstractClass methodsFor: 'method accessing'!whichSelectorsReferToInstanceVariable: aString 	| selectors |	selectors := Set new.	self newMethods 		do: [:each | (each refersToVariable: aString) ifTrue: [selectors add: each selector]].	self isDefined 		ifTrue: 			[selectors addAll: ((self realClass whichSelectorsAccess: aString) 						reject: [:each | self hasRemoved: each])].	^selectors! !!RBAbstractClass methodsFor: 'method accessing'!whichSelectorsReferToSymbol: aSymbol 	| selectors |	selectors := Set new.	self newMethods 		do: [:each | (each refersToSymbol: aSymbol) ifTrue: [selectors add: each selector]].	self isDefined 		ifTrue: [selectors addAll: (self existingMethodsThatReferTo: aSymbol)].	^selectors! !!RBAbstractClass methodsFor: 'variable accessing'!whoDefinesClassVariable: aString 	| sprClass |	(self directlyDefinesClassVariable: aString) ifTrue: [^self].	sprClass := self superclass.	^sprClass isNil 		ifTrue: [nil]		ifFalse: [sprClass whoDefinesClassVariable: aString]! !!RBAbstractClass methodsFor: 'variable accessing'!whoDefinesInstanceVariable: aString 	| sprClass |	(self directlyDefinesInstanceVariable: aString) ifTrue: [^self].	sprClass := self superclass.	^sprClass isNil 		ifTrue: [nil]		ifFalse: [sprClass whoDefinesInstanceVariable: aString]! !!RBAbstractClass methodsFor: 'method accessing'!whoDefinesMethod: aSelector 	| sprClass |	(self directlyDefinesMethod: aSelector) ifTrue: [^self].	sprClass := self superclass.	^sprClass isNil 		ifTrue: [nil]		ifFalse: [sprClass whoDefinesMethod: aSelector]! !!RBAbstractClass methodsFor: 'accessing'!withAllSubclasses	^(self allSubclasses)		add: self;		yourself! !!RBAbstractClass methodsFor: 'accessing'!withAllSuperclasses	^(self allSuperclasses)		add: self;		yourself! !!RBClass class methodsFor: 'instance creation'!existingNamed: aSymbol 	^(self named: aSymbol)		realName: aSymbol;		yourself! !!RBClass class methodsFor: 'instance creation'!named: aSymbol 	^(self new)		name: aSymbol;		yourself! !!RBClass methodsFor: 'variable accessing'!addClassVariable: aString 	self privateClassVariableNames add: aString asSymbol.	model addClassVariable: aString to: self! !!RBClass methodsFor: 'variable accessing'!addPoolDictionary: aString 	self privatePoolDictionaryNames add: aString asSymbol.	model addPool: aString to: self! !!RBClass methodsFor: 'accessing'!allClassVariableNames	| sprClass |	sprClass := self superclass.	^sprClass isNil 		ifTrue: [self classVariableNames]		ifFalse: [sprClass allClassVariableNames , self classVariableNames]! !!RBClass methodsFor: 'accessing'!allPoolDictionaryNames	| sprClass |	sprClass := self superclass.	^sprClass isNil 		ifTrue: [self poolDictionaryNames]		ifFalse: [sprClass allPoolDictionaryNames , self poolDictionaryNames]! !!RBClass methodsFor: 'accessing' stamp: 'bh 11/8/2000 15:22'!category	^category isNil 		ifTrue: 			[self isDefined				ifTrue: [category := self realClass category]				ifFalse: [model environment whichCategoryIncludes: self name]]		ifFalse: [category]! !!RBClass methodsFor: 'accessing'!category: aSymbol 	category := aSymbol! !!RBClass methodsFor: 'accessing'!classVariableNames	^self privateClassVariableNames copy! !!RBClass methodsFor: 'accessing'!classVariableNames: aCollectionOfStrings 	classVariableNames := (aCollectionOfStrings 				collect: [:each | each asSymbol]) asOrderedCollection! !!RBClass methodsFor: 'accessing' stamp: 'bh 11/8/2000 14:38'!definitionString	| definitionStream |	definitionStream := WriteStream on: ''.	definitionStream		nextPutAll: self superclass printString;		nextPutAll: ' subclass: #';		nextPutAll: self name;		nextPutAll: '	instanceVariableNames: '''.	self instanceVariableNames do: 			[:each | 			definitionStream				nextPutAll: each;				nextPut: $ ].	definitionStream nextPutAll: '''	classVariableNames: '''.	self classVariableNames do: 			[:each | 			definitionStream				nextPutAll: each;				nextPut: $ ].	definitionStream nextPutAll: '''	poolDictionaries: '''.	self poolDictionaryNames do: 			[:each | 			definitionStream				nextPutAll: each;				nextPut: $ ].	definitionStream nextPutAll: '''	category: #'''.	definitionStream nextPutAll: self category asString.	definitionStream nextPut: $'.	^definitionStream contents! !!RBClass methodsFor: 'testing'!directlyDefinesClassVariable: aString 	^self classVariableNames includes: aString asSymbol! !!RBClass methodsFor: 'testing'!directlyDefinesPoolDictionary: aString 	^self poolDictionaryNames includes: aString asSymbol! !!RBClass methodsFor: 'testing'!isMeta	^false! !!RBClass methodsFor: 'accessing'!nonMetaclass	^self! !!RBClass methodsFor: 'accessing'!poolDictionaryNames	^self privatePoolDictionaryNames copy! !!RBClass methodsFor: 'accessing'!poolDictionaryNames: aCollectionOfStrings 	poolDictionaryNames := (aCollectionOfStrings 				collect: [:each | each asSymbol]) asOrderedCollection! !!RBClass methodsFor: 'private'!privateClassVariableNames	(self isDefined and: [classVariableNames isNil]) 		ifTrue: [self classVariableNames: self realClass classVarNames].	^classVariableNames! !!RBClass methodsFor: 'private'!privatePoolDictionaryNames	(self isDefined and: [poolDictionaryNames isNil]) 		ifTrue: 			[self poolDictionaryNames: (self realClass sharedPools 						collect: [:each | Smalltalk keyAtValue: each])].	^poolDictionaryNames! !!RBClass methodsFor: 'initialize-release'!realName: aSymbol 	self realClass: (Smalltalk at: aSymbol)! !!RBClass methodsFor: 'variable accessing'!removeClassVariable: aString 	self privateClassVariableNames remove: aString asSymbol.	model removeClassVariable: aString from: self! !!RBClass methodsFor: 'variable accessing'!removePoolDictionary: aString 	self privatePoolDictionaryNames remove: aString asSymbol! !!RBClass methodsFor: 'variable accessing'!renameClassVariable: oldName to: newName around: aBlock 	self privateClassVariableNames 		at: (self privateClassVariableNames indexOf: oldName asSymbol)		put: newName asSymbol.	model 		renameClassVariable: oldName		to: newName		in: self		around: aBlock! !!RBClass methodsFor: 'accessing'!sharedPools	^self allPoolDictionaryNames 		collect: [:each | Smalltalk at: each asSymbol ifAbsent: [Dictionary new]]! !!RBMetaclass class methodsFor: 'instance creation'!existingNamed: aSymbol 	^(self named: aSymbol)		realName: aSymbol;		yourself! !!RBMetaclass class methodsFor: 'instance creation'!named: aSymbol 	^(self new)		name: aSymbol;		yourself! !!RBMetaclass methodsFor: 'accessing'!allClassVariableNames	^self nonMetaclass allClassVariableNames! !!RBMetaclass methodsFor: 'accessing'!allPoolDictionaryNames	^self nonMetaclass allPoolDictionaryNames! !!RBMetaclass methodsFor: 'testing'!directlyDefinesClassVariable: aString 	^self nonMetaclass directlyDefinesClassVariable: aString! !!RBMetaclass methodsFor: 'testing'!directlyDefinesPoolDictionary: aString 	^self nonMetaclass directlyDefinesPoolDictionary: aString! !!RBMetaclass methodsFor: 'testing'!isMeta	^true! !!RBMetaclass methodsFor: 'accessing'!metaclass	^self! !!RBMetaclass methodsFor: 'printing'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' class'! !!RBMetaclass methodsFor: 'initialize-release'!realName: aSymbol 	self realClass: (Smalltalk at: aSymbol) class! !!RBMetaclass methodsFor: 'printing'!storeOn: aStream 	super storeOn: aStream.	aStream nextPutAll: ' class'! !!RBAbstractCondition methodsFor: 'logical operations'!& aCondition 	^RBConjunctiveCondition new left: self right: aCondition! !!RBAbstractCondition methodsFor: 'checking'!check	self subclassResponsibility! !!RBAbstractCondition methodsFor: 'accessing'!errorBlock	^self errorBlockFor: false! !!RBAbstractCondition methodsFor: 'private'!errorBlockFor: aBoolean 	^nil! !!RBAbstractCondition methodsFor: 'private'!errorMacro	^errorMacro isNil		ifTrue: ['unknown']		ifFalse: [errorMacro]! !!RBAbstractCondition methodsFor: 'private'!errorMacro: aString 	errorMacro := aString! !!RBAbstractCondition methodsFor: 'accessing'!errorString	^self errorStringFor: false! !!RBAbstractCondition methodsFor: 'private'!errorStringFor: aBoolean	^self errorMacro expandMacrosWith: aBoolean! !!RBAbstractCondition methodsFor: 'logical operations'!not	^RBNegationCondition on: self! !!RBAbstractCondition methodsFor: 'logical operations'!| aCondition 	"(A | B) = (A not & B not) not"	^(self not & aCondition not) not! !!RBCondition class methodsFor: 'instance creation'!canUnderstand: aSelector in: aClass	^self new		type: (Array with: #understandsSelector with: aClass with: aSelector)		block: [aClass definesMethod: aSelector]		errorString: aClass printString , ' <1?:does not >understand<1?s:> ' , aSelector printString! !!RBCondition class methodsFor: 'utilities'!checkClassVarName: aName in: aClass 	| string |	aName isString ifFalse: [^false].	string := aName asString.	(self reservedNames includes: string) ifTrue: [^false].	string isEmpty ifTrue: [^false].	string first isUppercase ifFalse: [^false].	^RBScanner isVariable: string! !!RBCondition class methodsFor: 'utilities'!checkInstanceVariableName: aName in: aClass 	| string |	aName isString ifFalse: [^false].	string := aName asString.	string isEmpty ifTrue: [^false].	(self reservedNames includes: string) ifTrue: [^false].	string first isUppercase ifTrue: [^false].	^RBScanner isVariable: string! !!RBCondition class methodsFor: 'utilities'!checkMethodName: aName in: aClass 	^aName isString and: [RBScanner isSelector: aName]! !!RBCondition class methodsFor: 'instance creation'!definesClassVariable: aString in: aClass 	^self new 		type: (Array 				with: #definesClassVar				with: aClass				with: aString)		block: [aClass definesClassVariable: aString]		errorString: aClass printString 				, ' <1?:does not >define<1?s:> class variable ' , aString! !!RBCondition class methodsFor: 'instance creation'!definesInstanceVariable: aString in: aClass 	^self new 		type: (Array 				with: #definesInstVar				with: aClass				with: aString)		block: [aClass definesInstanceVariable: aString]		errorString: aClass printString 				, ' <1?:does not >define<1?s:> instance variable ' , aString! !!RBCondition class methodsFor: 'instance creation'!definesSelector: aSelector in: aClass 	^self new		type: (Array with: #definesSelector with: aClass with: aSelector)		block: [aClass directlyDefinesMethod: aSelector]		errorString: aClass printString , ' <1?:does not >define<1?s:> ' , aSelector printString! !!RBCondition class methodsFor: 'instance creation'!definesTempVar: aString in: aClass ignoreClass: subclass 	| condition |	condition := self new.	condition 		type: (Array with: #definesTempVarIgnoring with: aClass with: aString with: subclass)		block: 			[| method |			method := self 						methodDefiningTemporary: aString						in: aClass						ignore: [:class :aSelector | class includesClass: subclass].			method notNil 				ifTrue: 					[condition errorMacro: method printString , ' defines variable ' , aString].			method notNil]		errorString: aClass printString 				, ' <1?:does not >define<1?s:> temporary variable ' , aString.	^condition! !!RBCondition class methodsFor: 'instance creation'!definesTemporaryVariable: aString in: aClass 	| condition |	condition := self new.	condition 		type: (Array with: #definesTempVar with: aClass with: aString)		block: 			[| method |			method := self 						methodDefiningTemporary: aString						in: aClass						ignore: [:class :selector | false].			method notNil 				ifTrue: 					[condition errorMacro: method printString , ' defines variable ' , aString].			method notNil]		errorString: aClass printString 				, ' <1?:does not >define<1?s:> temporary variable ' , aString.	^condition! !!RBCondition class methodsFor: 'instance creation'!directlyDefinesClassVariable: aString in: aClass 	^self new 		type: (Array with: #directlyDefinesClassVar with: aClass with: aString)		block: [aClass directlyDefinesClassVariable: aString]		errorString: aClass printString 				, ' <1?:does not >directly define<1?s:> class variable ' , aString! !!RBCondition class methodsFor: 'instance creation'!directlyDefinesInstanceVariable: aString in: aClass 	^self new 		type: (Array with: #directlyDefinesInstanceVariable with: aClass with: aString)		block: [aClass directlyDefinesInstanceVariable: aString]		errorString: aClass printString 				, ' <1?:does not >directly define<1?s:> instance variable ' , aString! !!RBCondition class methodsFor: 'instance creation'!empty	"Returns an empty condition"	^self new 		type: (Array with: #empty)		block: [true]		errorString: 'Empty'! !!RBCondition class methodsFor: 'instance creation'!hasSubclasses: aClass	^self new		type: (Array with: #hasSubclasses with: aClass)		block: [aClass subclasses isEmpty not]		errorString: aClass printString , ' has <1?:no >subclasses'! !!RBCondition class methodsFor: 'instance creation'!hasSuperclass: aClass 	^self new 		type: (Array with: #hasSuperclass with: aClass)		block: [aClass superclass isNil not]		errorString: aClass printString , ' has <1?a:no> superclass'! !!RBCondition class methodsFor: 'instance creation'!hierarchyOf: aClass canUnderstand: aSelector	^self new		type: (Array with: #hierarchyUnderstandsSelector with: aClass with: aSelector)		block: [aClass hierarchyDefinesMethod: aSelector]		errorString: aClass printString , ' <1?or a subclass:and all subclasses do not> understand<1?s:> ' , aSelector printString! !!RBCondition class methodsFor: 'instance creation'!hierarchyOf: aClass definesVariable: aString 	^self new 		type: (Array 				with: #hierarchyDefinesInstVar				with: aClass				with: aString)		block: [aClass hierarchyDefinesVariable: aString]		errorString: aClass printString 				, ' or one of its subclasses <1?:does not >define<1?s:> variable ' 					, aString! !!RBCondition class methodsFor: 'instance creation'!hierarchyOf: aClass referencesInstanceVariable: aString 	^self new 		type: (Array 				with: #hierarchyReferencesInstVar				with: aClass				with: aString)		block: 			[(aClass withAllSubclasses 				detect: [:each | (each whichSelectorsReferToInstanceVariable: aString) isEmpty not]				ifNone: [nil]) notNil]		errorString: aClass printString 				, ' or subclass <1?:does not >reference<1?s:> instance variable ' , aString! !!RBCondition class methodsFor: 'instance creation'!isAbstractClass: aClass 	^self new 		type: (Array with: #IsAbstractClass with: aClass)		block: [aClass isAbstract]		errorString: aClass printString , ' is <1?:not >an abstract class'! !!RBCondition class methodsFor: 'instance creation'!isClass: anObject	^self new		type: (Array with: #IsClass with: anObject)		block: [anObject isBehavior]		errorString: anObject printString , ' is <1?:not >a behavior'! !!RBCondition class methodsFor: 'instance creation'!isEmptyClass: anObject 	^self new type: (Array with: #IsEmptyClass with: anObject)		block: 			[anObject classVariableNames isEmpty				and: [anObject instanceVariableNames isEmpty and: [anObject selectors isEmpty]]]		errorString: anObject printString , ' is <1?:not > empty'! !!RBCondition class methodsFor: 'instance creation'!isGlobal: aString in: aRBSmalltalk 	^self new 		type: (Array with: #isGlobal with: aString)		block: [aRBSmalltalk includesGlobal: aString asSymbol]		errorString: aString , ' is <1?:not >a class or global variable'! !!RBCondition class methodsFor: 'instance creation'!isImmediateSubclass: subclass of: superClass	^self new		type: (Array with: #immediateSubclass with: superClass with: subclass)		block: [subclass superclass = superClass]		errorString: subclass printString , ' is <1?:not >an immediate subclass of ' , superClass printString! !!RBCondition class methodsFor: 'instance creation'!isMetaclass: anObject 	^self new type: (Array with: #IsMetaclass with: anObject)		block: [anObject isMeta]		errorString: anObject printString , ' is <1?:not >a metaclass'! !!RBCondition class methodsFor: 'instance creation'!isSymbol: aString	^self new		type: (Array with: #isSymbol with: aString)		block: [aString isSymbol]		errorString: aString , ' is <1?:not >a symbol'! !!RBCondition class methodsFor: 'instance creation'!isValidClassName: aString	^self new		type: (Array with: #validClassName with: aString)		block: [self validClassName: aString]		errorString: aString , ' is <1?:not >a valid class name'! !!RBCondition class methodsFor: 'instance creation'!isValidClassVarName: aString for: aClass	^self new		type: (Array with: #validClassVarName with: aString with: aClass)		block: [self checkClassVarName: aString in: aClass]		errorString: aString , ' is <1?:not >a valid class variable name'! !!RBCondition class methodsFor: 'instance creation'!isValidInstanceVariableName: aString for: aClass 	^self new 		type: (Array 				with: #validInstVarName				with: aString				with: aClass)		block: [self checkInstanceVariableName: aString in: aClass]		errorString: aString , ' is <1?:not >a valid instance variable name'! !!RBCondition class methodsFor: 'instance creation'!isValidMethodName: aString for: aClass	^self new		type: (Array with: #validMethodName with: aString with: aClass)		block: [self checkMethodName: aString in: aClass]		errorString: aString printString , ' is <1?:not >a valid method name'! !!RBCondition class methodsFor: 'utilities'!methodDefiningTemporary: aString in: aClass ignore: aBlock 	| searcher method |	searcher := ParseTreeSearcher new.	method := nil.	"Shut-up the warning"	searcher matches: aString do: [:aNode :answer | ^method].	aClass withAllSubclasses do: 			[:class | 			class selectors do: 					[:each | 					(aBlock value: class value: each) 						ifFalse: 							[| parseTree |							method := class methodFor: each.							parseTree := class parseTreeFor: each.							parseTree notNil ifTrue: [searcher executeTree: parseTree]]]].	^nil! !!RBCondition class methodsFor: 'instance creation'!referencesInstanceVariable: aString in: aClass 	^self new 		type: (Array with: #referencesInstVar with: aClass with: aString)		block: [(aClass whichSelectorsReferToInstanceVariable: aString) isEmpty not]		errorString: aClass printString 				, ' <1?:does not >reference<1?s:> instance variable ' , aString! !!RBCondition class methodsFor: 'utilities'!reservedNames	^#('self' 'true' 'false' 'nil' 'thisContext' 'super')! !!RBCondition class methodsFor: 'instance creation'!subclassesOf: aClass referToSelector: aSelector 	^self new 		type: (Array 				with: #subclassReferences				with: aClass				with: aSelector)		block: 			[(aClass subclasses detect: 					[:each | 					(each selectors detect: 							[:sel | 							| tree |							tree := each parseTreeFor: sel.							tree notNil and: [tree superMessages includes: aSelector]]						ifNone: [nil]) notNil]				ifNone: [nil]) notNil]		errorString: '<1?:no:a> subclass of ' , aClass printString , ' refers to ' 				, aSelector printString! !!RBCondition class methodsFor: 'utilities'!validClassName: aString 	"Class names and class variable names have the same restrictions"	^self checkClassVarName: aString in: self! !!RBCondition class methodsFor: 'instance creation'!withBlock: aBlock	^self new withBlock: aBlock! !!RBCondition class methodsFor: 'instance creation'!withBlock: aBlock errorString: aString 	^self new type: #unknown		block: aBlock		errorString: aString! !!RBCondition methodsFor: 'checking'!check	^block value! !!RBCondition methodsFor: 'initialize-release'!errorBlock: anObject	errorBlock := anObject! !!RBCondition methodsFor: 'accessing'!errorBlockFor: aBoolean	^errorBlock! !!RBCondition methodsFor: 'printing' stamp: 'bh 4/10/2001 16:51'!printOn: aStream 	aStream nextPutAll: type asString! !!RBCondition methodsFor: 'initialize-release' stamp: 'dvf 11/24/2001 13:14'!type: aSymbol block: aBlock errorString: aString 	self needsWork.  "replaced value with fixTemps. This should simulate closures well enough, we hope."	type := aSymbol.	block := aBlock fixTemps.	self errorMacro: aString! !!RBCondition methodsFor: 'initialize-release'!withBlock: aBlock 	block := aBlock.	type := #(#generic)! !!RBConjunctiveCondition methodsFor: 'checking'!check	left check		ifFalse: 			[failed := #leftFailed.			^false].	right check		ifFalse: 			[failed := #rightFailed.			^false].	^true! !!RBConjunctiveCondition methodsFor: 'private'!errorBlockFor: aBoolean 	^aBoolean		ifTrue: [nil]		ifFalse: 			[failed == #leftFailed ifTrue: [left errorBlock] ifFalse: [right errorBlock]]! !!RBConjunctiveCondition methodsFor: 'private'!errorMacro	^errorMacro isNil		ifTrue: [self longMacro]		ifFalse: [super errorMacro]! !!RBConjunctiveCondition methodsFor: 'private'!errorStringFor: aBoolean 	^aBoolean		ifTrue: [self neitherFailed]		ifFalse: [self perform: failed]! !!RBConjunctiveCondition methodsFor: 'initialize-release'!left: aCondition right: aCondition2 	left := aCondition.	right := aCondition2.	failed := #unknownFailed! !!RBConjunctiveCondition methodsFor: 'private'!leftFailed	^left errorStringFor: false! !!RBConjunctiveCondition methodsFor: 'private'!longMacro	^'(' , left errorMacro , ') <1?AND:OR> (' , right errorMacro , ')'! !!RBConjunctiveCondition methodsFor: 'private'!neitherFailed	^(left errorStringFor: true) , ' AND ' , (right errorStringFor: true)! !!RBConjunctiveCondition methodsFor: 'printing' stamp: 'bh 4/10/2001 16:52'!printOn: aStream 	aStream nextPutAll: left asString;		nextPutAll: ' & ';		nextPutAll: right asString! !!RBConjunctiveCondition methodsFor: 'private'!rightFailed	^right errorStringFor: false! !!RBConjunctiveCondition methodsFor: 'private'!unknownFailed	^(left errorStringFor: false) , ' OR ' , (right errorStringFor: false)! !!RBNegationCondition class methodsFor: 'instance creation'!on: aCondition	^self new condition: aCondition! !!RBNegationCondition methodsFor: 'checking'!check	^condition check not! !!RBNegationCondition methodsFor: 'initialize-release'!condition: aCondition 	condition := aCondition.	self errorMacro: condition errorMacro! !!RBNegationCondition methodsFor: 'private'!errorBlockFor: aBoolean 	^condition errorBlockFor: aBoolean not! !!RBNegationCondition methodsFor: 'private'!errorStringFor: aBoolean 	^condition errorStringFor: aBoolean not! !!RBNegationCondition methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: 'NOT ';		print: condition! !!RBMethod class methodsFor: 'instance creation'!for: aRBClass fromMethod: aCompiledMethod andSelector: aSymbol 	^(self new)		modelClass: aRBClass;		method: aCompiledMethod;		selector: aSymbol;		yourself! !!RBMethod class methodsFor: 'instance creation'!for: aRBClass source: aString selector: aSelector 	^(self new)		modelClass: aRBClass;		selector: aSelector;		source: aString;		yourself! !!RBMethod methodsFor: 'private'!literal: anObject containsReferenceTo: aSymbol 	anObject = aSymbol ifTrue: [^true].	anObject class = Array ifFalse: [^false].	anObject 		do: [:each | (self literal: each containsReferenceTo: aSymbol) ifTrue: [^true]].	^false! !!RBMethod methodsFor: 'accessing'!method	^compiledMethod! !!RBMethod methodsFor: 'accessing'!method: aCompiledMethod 	compiledMethod := aCompiledMethod! !!RBMethod methodsFor: 'accessing'!modelClass	^class! !!RBMethod methodsFor: 'accessing'!modelClass: aRBClass	class := aRBClass! !!RBMethod methodsFor: 'accessing'!parseTree	^RBParser parseMethod: self source onError: [:str :pos | ^nil]! !!RBMethod methodsFor: 'printing'!printOn: aStream 	class printOn: aStream.	aStream		nextPutAll: '>>';		nextPutAll: self selector! !!RBMethod methodsFor: 'testing'!refersToClassNamed: aSymbol 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: aSymbol asString do: [:node :answer | true].	^(searcher executeTree: self parseTree initialAnswer: false) 		or: [self refersToSymbol: aSymbol]! !!RBMethod methodsFor: 'testing' stamp: 'dvf 9/17/2001 00:46'!refersToSymbol: aSymbol 	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: aSymbol printString do: [:node :answer | true];		matches: '`#literal'			do: [:node :answer | answer or: [self literal: node value containsReferenceTo: aSymbol]].	(RBScanner isSelector: aSymbol) 		ifTrue: 			[searcher 				matches: '`@object ' , (ParseTreeSearcher buildSelectorString: aSymbol)				do: [:node :answer | true]].	^searcher executeTree: self parseTree initialAnswer: false! !!RBMethod methodsFor: 'testing'!refersToVariable: aString 	| searcher tree |	tree := self parseTree.	((tree defines: aString) or: [tree body defines: aString]) 		ifTrue: [^false].	searcher := ParseTreeSearcher new.	searcher		matches: aString do: [:node :answer | true];		matches: '[:`@vars | | `@temps | `@.Stmts]'			do: 				[:node :answer | 				answer or: 						[((node defines: aString) or: [node body defines: aString]) not 							and: [searcher executeTree: node body initialAnswer: false]]].	^searcher executeTree: self parseTree initialAnswer: false! !!RBMethod methodsFor: 'accessing'!selector	^selector! !!RBMethod methodsFor: 'accessing'!selector: aSymbol 	selector := aSymbol! !!RBMethod methodsFor: 'accessing' stamp: 'dvf 11/8/2003 15:02'!source	^source isNil 		ifTrue: [source := (class realClass sourceCodeAt: selector) string]		ifFalse: [source]! !!RBMethod methodsFor: 'accessing'!source: aString 	source := aString! !!RBMethodName class methodsFor: 'instance creation'!selector: aSymbol arguments: stringCollection 	^(self new)		selector: aSymbol;		arguments: stringCollection;		yourself! !!RBMethodName methodsFor: 'accessing'!arguments	^arguments! !!RBMethodName methodsFor: 'accessing'!arguments: nameCollection 	arguments := nameCollection.	self changed: #arguments! !!RBMethodName methodsFor: 'testing'!isValid	^(RBCondition checkMethodName: self selector in: self class) 		and: [self selector numArgs == self arguments size]! !!RBMethodName methodsFor: 'accessing'!moveArgument: aName before: anotherName 	arguments remove: aName ifAbsent: [^self].	arguments add: aName before: anotherName.	self changed: #arguments! !!RBMethodName methodsFor: 'accessing'!selector	^selector! !!RBMethodName methodsFor: 'accessing'!selector: aSymbol 	selector := aSymbol.	self changed: #selector! !!RBNamespace class methodsFor: 'instance creation'!onEnvironment: aBrowserEnvironment 	^(self new)		environment: aBrowserEnvironment;		yourself! !!RBNamespace methodsFor: 'private-changes'!addChangeToClass: aRBClass 	^changedClasses at: aRBClass name		put: (Array with: aRBClass nonMetaclass with: aRBClass metaclass)! !!RBNamespace methodsFor: 'private-changes'!addClassVariable: aString to: aRBClass 	^changes addClassVariable: aString to: aRBClass! !!RBNamespace methodsFor: 'private-changes'!addInstanceVariable: aString to: aRBClass 	^changes addInstanceVariable: aString to: aRBClass! !!RBNamespace methodsFor: 'private-changes'!addPool: aString to: aRBClass 	^changes addPool: aString to: aRBClass! !!RBNamespace methodsFor: 'accessing'!allClassesDo: aBlock 	| seen evalBlock |	seen := Set new.	evalBlock := 			[:each | 			seen add: each first name.			aBlock				value: each first;				value: each last].	newClasses do: evalBlock.	changedClasses do: evalBlock.	environment classesDo: 			[:each | 			each isMeta 				ifFalse: 					[((seen includes: each name) or: [self hasRemoved: (self classNameFor: each)]) 						ifFalse: 							[| class |							class := self classFor: each.							aBlock								value: class;								value: class metaclass]]]! !!RBNamespace methodsFor: 'accessing'!allImplementorsOf: aSelector 	^implementorsCache at: aSelector		ifAbsentPut: [self privateImplementorsOf: aSelector]! !!RBNamespace methodsFor: 'accessing'!allReferencesTo: aSymbol do: aBlock 	(sendersCache at: aSymbol		ifAbsentPut: 			[| refs |			refs := OrderedCollection new.			self allClassesDo: 					[:each | 					(each whichSelectorsReferToSymbol: aSymbol) 						do: [:sel | refs add: (each methodFor: sel)]].			refs]) 			do: aBlock! !!RBNamespace methodsFor: 'accessing'!allReferencesToClass: aRBClass do: aBlock 	self allClassesDo: 			[:each | 			(each whichSelectorsReferToClass: aRBClass) 				do: [:sel | aBlock value: (each methodFor: sel)]]! !!RBNamespace methodsFor: 'private-changes'!changeClass: aRBClass 	changedClasses at: aRBClass name		put: (Array with: aRBClass nonMetaclass with: aRBClass metaclass).	self flushCaches! !!RBNamespace methodsFor: 'accessing'!changes	^changes! !!RBNamespace methodsFor: 'accessing-classes' stamp: 'md 2/27/2006 00:51'!classFor: aBehavior 	| nonMetaclass class |	aBehavior isNil ifTrue: [^nil].	nonMetaclass := aBehavior isMeta 				ifTrue: [aBehavior soleInstance]				ifFalse: [aBehavior].	class := aBehavior isMeta 		ifTrue: [self metaclassNamed: nonMetaclass name]		ifFalse: [self classNamed: nonMetaclass name].	^class ifNil: [nonMetaclass].! !!RBNamespace methodsFor: 'private'!classNameFor: aBehavior 	^(aBehavior isMeta ifTrue: [aBehavior soleInstance] ifFalse: [aBehavior]) 		name! !!RBNamespace methodsFor: 'accessing-classes' stamp: 'md 2/27/2006 00:55'!classNamed: aSymbol 	| class index classes |	aSymbol isNil ifTrue: [^nil].	(self hasRemoved: aSymbol) ifTrue: [^nil].	(newClasses includesKey: aSymbol) 		ifTrue: [^(newClasses at: aSymbol) first].	(changedClasses includesKey: aSymbol) 		ifTrue: [^(changedClasses at: aSymbol) first].	(class := environment at: aSymbol ifAbsent: [nil]) isBehavior 		ifTrue: 			[classes := self createNewClassFor: class.			^class isMeta ifTrue: [classes last] ifFalse: [classes first]].	(class := environment at: aSymbol ifAbsent: [nil]) isTrait 		ifTrue: 			[classes := self createNewClassFor: class.			^classes first].	index := aSymbol 				indexOfSubCollection: ' class'				startingAt: 1				ifAbsent: [^nil].	class := self classNamed: (aSymbol copyFrom: 1 to: index - 1) asSymbol.	^class isNil ifTrue: [nil] ifFalse: [class metaclass]! !!RBNamespace methodsFor: 'private-changes'!compile: aString in: aRBClass classified: aSymbol 	| change |	change := changes 				compile: aString				in: aRBClass				classified: aSymbol.	self flushCaches.	^change! !!RBNamespace methodsFor: 'accessing-classes'!createNewClassFor: aBehavior 	| nonMeta meta className |	className := (aBehavior isMeta 				ifTrue: [aBehavior soleInstance]				ifFalse: [aBehavior]) name.	nonMeta := (RBClass existingNamed: className)				model: self;				yourself.	meta := (RBMetaclass existingNamed: className)				model: self;				yourself.	^changedClasses at: className put: (Array with: nonMeta with: meta)! !!RBNamespace methodsFor: 'changes'!defineClass: aString 	| change newClass newClassName |	change := changes defineClass: aString.	newClassName := change changeClassName.	newClass := self classNamed: newClassName.	newClass isNil 		ifTrue: 			[| newMetaclass |			removedClasses				remove: newClassName ifAbsent: [];				remove: newClassName , ' class' ifAbsent: [].			newClass := RBClass named: newClassName.			newMetaclass := RBMetaclass named: newClassName.			newClass model: self.			newMetaclass model: self.			newClasses at: newClassName put: (Array with: newClass with: newMetaclass)].	newClass superclass: (self classNamed: change superclassName).	newClass superclass isNil 		ifTrue: 			[self rootClasses add: newClass.			newClass metaclass superclass: (self classFor: Object class superclass)]		ifFalse: [newClass metaclass superclass: newClass superclass metaclass].	newClass instanceVariableNames: change instanceVariableNames.	newClass classVariableNames: change classVariableNames.	newClass poolDictionaryNames: change poolDictionaryNames.	newClass category: change category.	^change! !!RBNamespace methodsFor: 'accessing'!environment	^environment! !!RBNamespace methodsFor: 'accessing'!environment: aBrowserEnvironment 	environment := aBrowserEnvironment! !!RBNamespace methodsFor: 'private-changes'!flushCaches	implementorsCache := IdentityDictionary new.	sendersCache := IdentityDictionary new! !!RBNamespace methodsFor: 'private'!hasCreatedClassFor: aBehavior 	| className |	className := self classNameFor: aBehavior.	^(newClasses includesKey: className) 		or: [changedClasses includesKey: className]! !!RBNamespace methodsFor: 'testing'!hasRemoved: aSymbol 	^removedClasses includes: aSymbol! !!RBNamespace methodsFor: 'testing'!includesClassNamed: aSymbol 	^(self classNamed: aSymbol) notNil! !!RBNamespace methodsFor: 'testing'!includesGlobal: aSymbol 	(self hasRemoved: aSymbol) ifTrue: [^false].	(self includesClassNamed: aSymbol) ifTrue: [^true].	environment at: aSymbol ifAbsent: [^false].	^true! !!RBNamespace methodsFor: 'initialize-release'!initialize	changes := CompositeRefactoryChange new.	environment := BrowserEnvironment new.	newClasses := IdentityDictionary new.	changedClasses := IdentityDictionary new.	removedClasses := Set new.	implementorsCache := IdentityDictionary new.	sendersCache := IdentityDictionary new! !!RBNamespace methodsFor: 'accessing-classes'!metaclassNamed: aSymbol 	| class |	aSymbol isNil ifTrue: [^nil].	(self hasRemoved: aSymbol) ifTrue: [^nil].	(newClasses includesKey: aSymbol) ifTrue: [^(newClasses at: aSymbol) last].	(changedClasses includesKey: aSymbol) 		ifTrue: [^(changedClasses at: aSymbol) last].	(class := environment at: aSymbol ifAbsent: [nil]) isBehavior 		ifTrue: [^(self createNewClassFor: class) last].	^nil! !!RBNamespace methodsFor: 'accessing'!name	^changes name! !!RBNamespace methodsFor: 'accessing'!name: aString	^changes name: aString! !!RBNamespace methodsFor: 'private-changes'!performChange: aCompositeRefactoryChange around: aBlock 	| oldChanges |	changes addChange: aCompositeRefactoryChange.	oldChanges := changes.	changes := aCompositeRefactoryChange.	aBlock ensure: [changes := oldChanges].	^aCompositeRefactoryChange! !!RBNamespace methodsFor: 'private'!privateImplementorsOf: aSelector 	| classes |	classes := Set new.	self allClassesDo: 			[:each | 			(each directlyDefinesMethod: aSelector) ifTrue: [classes add: each]].	^classes! !!RBNamespace methodsFor: 'changes'!removeClass: aRBClass 	self removeClassNamed: aRBClass name! !!RBNamespace methodsFor: 'changes'!removeClassNamed: aSymbol 	(self classNamed: aSymbol) subclasses 		do: [:each | self removeClassNamed: each name].	removedClasses		add: aSymbol;		add: aSymbol , ' class'.	newClasses removeKey: aSymbol ifAbsent: [].	changedClasses removeKey: aSymbol ifAbsent: [].	self flushCaches.	^changes removeClassNamed: aSymbol! !!RBNamespace methodsFor: 'private-changes'!removeClassVariable: aString from: aRBClass 	^changes removeClassVariable: aString from: aRBClass! !!RBNamespace methodsFor: 'private-changes'!removeInstanceVariable: aString from: aRBClass 	^changes removeInstanceVariable: aString from: aRBClass! !!RBNamespace methodsFor: 'private-changes'!removeMethod: aSelector from: aRBClass 	self flushCaches.	^changes removeMethod: aSelector from: aRBClass! !!RBNamespace methodsFor: 'changes'!renameClass: aRBClass to: aSymbol around: aBlock 	| change value dict |	change := RenameClassChange rename: aRBClass name to: aSymbol.	self performChange: change around: aBlock.	self flushCaches.	dict := (newClasses includesKey: aSymbol) 				ifTrue: [newClasses]				ifFalse: [changedClasses].	removedClasses		add: aRBClass name;		add: aRBClass name , ' class'.	value := dict at: aRBClass name.	dict removeKey: aRBClass name.	dict at: aSymbol put: value.	value first name: aSymbol.	value last name: aSymbol.	value first subclasses do: [:each | each superclass: value first].	value last subclasses do: [:each | each superclass: value last].	^change! !!RBNamespace methodsFor: 'private-changes'!renameClassVariable: oldName to: newName in: aRBClass around: aBlock 	^self performChange: (RenameClassVariableChange 				rename: oldName				to: newName				in: aRBClass)		around: aBlock! !!RBNamespace methodsFor: 'private-changes'!renameInstanceVariable: oldName to: newName in: aRBClass around: aBlock 	^self performChange: (RenameInstanceVariableChange 				rename: oldName				to: newName				in: aRBClass)		around: aBlock! !!RBNamespace methodsFor: 'changes'!reparentClasses: aRBClassCollection to: newClass 	aRBClassCollection do: 			[:aClass | 			self defineClass: (self replaceClassNameIn: aClass definitionString						to: newClass name)]! !!RBNamespace methodsFor: 'private-changes'!replaceClassNameIn: definitionString to: aSymbol 	| parseTree |	parseTree := RBParser parseExpression: definitionString.	parseTree receiver: (RBVariableNode named: aSymbol).	^parseTree formattedCode! !!RBNamespace methodsFor: 'accessing' stamp: 'bh 4/3/2000 15:47'!rootClasses	rootClasses isNil 		ifTrue: 			[rootClasses := OrderedCollection new.			Class rootsOfTheWorld do: 					[:each | 					| class |					class := self classFor: each.					(class notNil "and: [class superclass isNil] <- it's protoObject, not nil.") 						ifTrue: [rootClasses add: class]]].	^rootClasses! !!RBNamespace methodsFor: 'accessing-classes'!whichCategoryIncludes: aSymbol	^self environment whichCategoryIncludes: aSymbol! !!ReceiverAndSelector class methodsFor: 'as yet unclassified' stamp: 'bh 11/4/2000 23:59'!forReceiver:anObject andSelector:aSymbol	^self new initializeReceiver:anObject andSelector:aSymbol.! !!ReceiverAndSelector methodsFor: 'as yet unclassified' stamp: 'bh 11/5/2000 00:00'!initializeReceiver:anObject andSelector:aSymbol	receiver := anObject.	selector := aSymbol.! !!ReceiverAndSelector methodsFor: 'as yet unclassified' stamp: 'bh 11/5/2000 00:01'!value	^receiver perform: selector.! !!ReceiverAndSelector methodsFor: 'as yet unclassified' stamp: 'bh 11/5/2000 00:01'!value: firstArgument	^receiver perform: selector with: firstArgument.! !!ReceiverAndSelector methodsFor: 'as yet unclassified' stamp: 'bh 11/5/2000 00:01'!value: firstArgument value: secondArgument	^receiver perform: selector with: firstArgument with: secondArgument.! !!AbstractVariablesRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk abstractVariablesIn: aBRProgramNode from: fromBehavior toAll: behaviorCollection 	^self 		model: aRBSmalltalk		abstractVariablesIn: aBRProgramNode		from: fromBehavior		toAll: behaviorCollection		ignoring: nil! !!AbstractVariablesRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk abstractVariablesIn: aBRProgramNode from: fromBehavior toAll: behaviorCollection ignoring: aVariableName 	^(self new)		model: aRBSmalltalk;		abstractVariablesIn: aBRProgramNode			from: fromBehavior			toAll: behaviorCollection			ignoring: aVariableName;		yourself! !!AbstractVariablesRefactoring methodsFor: 'transforming'!abstractClassVariable: aString 	| refactoring rewriter nonMetaClass |	nonMetaClass := fromClass nonMetaclass.	refactoring := CreateAccessorsForVariableRefactoring 				model: self model				variable: aString				class: nonMetaClass				classVariable: true.	self performComponentRefactoring: refactoring.	rewriter := ParseTreeRewriter new.	fromClass isMeta 		ifTrue: 			[rewriter				replace: aString , ' := ``@object'					with: ('self <1s> ``@object' expandMacrosWith: refactoring setterMethod);				replace: aString with: 'self ' , refactoring getterMethod]		ifFalse: 			[rewriter				replace: aString , ' := ``@object'					with: ('self class <1s> ``@object' 							expandMacrosWith: refactoring setterMethod);				replace: aString with: 'self class ' , refactoring getterMethod].	(rewriter executeTree: tree) ifTrue: [tree := rewriter tree]! !!AbstractVariablesRefactoring methodsFor: 'transforming'!abstractClassVariables	| variables |	classVarReaders isEmpty & classVarWriters isEmpty ifTrue: [^self].	variables := Set new.	variables		addAll: classVarReaders;		addAll: classVarWriters.	variables do: [:each | self abstractClassVariable: each]! !!AbstractVariablesRefactoring methodsFor: 'transforming'!abstractInstanceVariable: aString 	| refactoring rewriter |	refactoring := CreateAccessorsForVariableRefactoring 				model: self model				variable: aString				class: fromClass				classVariable: false.	self performComponentRefactoring: refactoring.	rewriter := ParseTreeRewriter new.	rewriter		replace: aString , ' := ``@object'			with: ('self <1s> ``@object' expandMacrosWith: refactoring setterMethod);		replace: aString with: 'self ' , refactoring getterMethod.	(rewriter executeTree: tree) ifTrue: [tree := rewriter tree]! !!AbstractVariablesRefactoring methodsFor: 'transforming'!abstractInstanceVariables	| variables |	instVarReaders isEmpty & instVarWriters isEmpty ifTrue: [^self].	variables := Set new.	variables		addAll: instVarReaders;		addAll: instVarWriters.	variables do: [:each | self abstractInstanceVariable: each]! !!AbstractVariablesRefactoring methodsFor: 'initialize-release'!abstractVariablesIn: aBRProgramNode from: fromBehavior toAll: behaviorCollection ignoring: aVariableName 	| poolRefactoring |	tree := aBRProgramNode.	fromClass := self classObjectFor: fromBehavior.	toClasses := behaviorCollection 				collect: [:each | self classObjectFor: each].	ignore := aVariableName.	poolRefactoring := ExpandReferencedPoolsRefactoring 				model: self model				forMethod: tree				fromClass: fromClass				toClasses: toClasses.	self performComponentRefactoring: poolRefactoring.	self computeVariablesToAbstract! !!AbstractVariablesRefactoring methodsFor: 'transforming'!classVariableNames	| nonMetaClass |	nonMetaClass := fromClass nonMetaclass.	^(nonMetaClass allClassVariableNames collect: [:each | each asString]) asSet! !!AbstractVariablesRefactoring methodsFor: 'transforming'!computeVariablesToAbstract	| searcher |	instVarReaders := Set new.	instVarWriters := Set new.	classVarReaders := Set new.	classVarWriters := Set new.	searcher := ParseTreeSearcher new.	searcher		matches: '`var := ``@anything'			do: [:aNode :answer | self processAssignmentNode: aNode];		matches: '`var' do: [:aNode :answer | self processReferenceNode: aNode].	searcher executeTree: tree.	self removeDefinedClassVariables! !!AbstractVariablesRefactoring methodsFor: 'testing'!hasVariablesToAbstract	^(instVarReaders isEmpty 		& instVarWriters isEmpty 		& classVarReaders isEmpty 		& classVarWriters isEmpty) 		not! !!AbstractVariablesRefactoring methodsFor: 'transforming'!instanceVariableNames	^fromClass allInstanceVariableNames asSet! !!AbstractVariablesRefactoring methodsFor: 'accessing'!parseTree	^tree! !!AbstractVariablesRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition empty! !!AbstractVariablesRefactoring methodsFor: 'transforming'!processAssignmentNode: aNode 	| varName |	varName := aNode variable name.	ignore = varName ifTrue: [^self].	(aNode whoDefines: varName) notNil ifTrue: [^self].	(self instanceVariableNames includes: varName) 		ifTrue: [instVarWriters add: varName].	(self classVariableNames includes: varName) 		ifTrue: [classVarWriters add: varName]! !!AbstractVariablesRefactoring methodsFor: 'transforming'!processReferenceNode: aNode 	| varName |	varName := aNode name.	ignore = varName ifTrue: [^self].	(aNode whoDefines: varName) notNil ifTrue: [^self].	(self instanceVariableNames includes: varName) 		ifTrue: [instVarReaders add: varName].	(self classVariableNames includes: varName) 		ifTrue: [classVarReaders add: varName]! !!AbstractVariablesRefactoring methodsFor: 'transforming'!removeDefinedClassVariables	| selectionBlock nonMetaClass |	nonMetaClass := fromClass nonMetaclass.	selectionBlock := 			[:varName | 			(toClasses detect: 					[:each | 					((each nonMetaclass) 						includesClass: (nonMetaClass whoDefinesClassVariable: varName)) not]				ifNone: [nil]) notNil].	classVarReaders := classVarReaders select: selectionBlock.	classVarWriters := classVarWriters select: selectionBlock! !!AbstractVariablesRefactoring methodsFor: 'transforming'!transform	self hasVariablesToAbstract 		ifTrue: 			[self 				refactoringWarning: 'This method has direct variable references which<n>will need to be converted to getter/setters.' 						expandMacros].	self abstractInstanceVariables.	self abstractClassVariables! !!AddClassRefactoring class methodsFor: 'instance creation'!addClass: aName superclass: aClass subclasses: aCollection category: aSymbol	^self new		addClass: aName		superclass: aClass		subclasses: aCollection		category: aSymbol! !!AddClassRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk addClass: aName superclass: aClass subclasses: aCollection category: aSymbol 	^(self new)		model: aRBSmalltalk;		addClass: aName			superclass: aClass			subclasses: aCollection			category: aSymbol;		yourself! !!AddClassRefactoring methodsFor: 'initialize-release'!addClass: aName superclass: aClass subclasses: aCollection category: aSymbol 	self className: aName.	superclass := self classObjectFor: aClass.	subclasses := aCollection collect: [:each | self classObjectFor: each].	category := aSymbol! !!AddClassRefactoring methodsFor: 'preconditions'!preconditions	| cond |	cond := ((RBCondition isMetaclass: superclass) 				errorMacro: 'Superclass must not be a metaclass') not.	cond := subclasses inject: cond				into: 					[:sub :each | 					sub 						& ((RBCondition isMetaclass: each) 								errorMacro: 'Subclass must <1?not :>be a metaclass') not 							& (RBCondition isImmediateSubclass: each of: superclass)].	^cond & (RBCondition isValidClassName: className) 		& (RBCondition isGlobal: className in: self model) not 			& (RBCondition isSymbol: category) 			& ((RBCondition withBlock: [category isEmpty not]) 					errorMacro: 'Invalid category name')! !!AddClassRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' addClass: #';		nextPutAll: className;		nextPutAll: ' superclass: '.	superclass storeOn: aStream.	aStream nextPutAll: ' subclasses: '.	subclasses asArray storeOn: aStream.	aStream nextPutAll: ' category: '.	category storeOn: aStream.	aStream nextPut: $)! !!AddClassRefactoring methodsFor: 'transforming' stamp: 'bh 4/10/2001 14:25'!transform	(self model)		defineClass: ('<1p> subclass: #<2s> instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: <3p>' 					expandMacrosWith: superclass					with: className					with: category asString);		reparentClasses: subclasses to: (self model classNamed: className asSymbol)! !!ChildrenToSiblingsRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk name: aClassName class: aClass subclasses: subclassCollection 	^(self new)		model: aRBSmalltalk;		name: aClassName			class: aClass			subclasses: subclassCollection;		yourself! !!ChildrenToSiblingsRefactoring class methodsFor: 'instance creation'!name: aClassName class: aClass subclasses: subclassCollection 	^(self new)		name: aClassName			class: aClass			subclasses: subclassCollection;		yourself! !!ChildrenToSiblingsRefactoring methodsFor: 'private-accessing'!abstractSuperclass	^self model classNamed: className asSymbol! !!ChildrenToSiblingsRefactoring methodsFor: 'transforming'!addSuperclass	self performComponentRefactoring: (AddClassRefactoring 				model: self model				addClass: className				superclass: parent superclass				subclasses: (Array with: parent)				category: parent category)! !!ChildrenToSiblingsRefactoring methodsFor: 'transforming'!changeIsKindOfReferences	| replacer |	replacer := ParseTreeRewriter new.	replacer replace: '``@object isKindOf: ' , parent name		with: '``@object isKindOf: ' , className.	self convertAllReferencesToClass: parent using: replacer! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!computeSubclassSupersOf: aClass 	| selectors |	selectors := Set new.	aClass subclasses do: 			[:each | 			each selectors 				do: [:sel | selectors addAll: (each parseTreeFor: sel) superMessages]].	^selectors! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!createSubclassResponsibilityFor: aSelector in: aClass 	| source |	(aClass superclass definesMethod: aSelector) ifTrue: [^self].	source := self subclassResponsibilityFor: aSelector in: aClass.	source isNil ifTrue: [^self].	aClass superclass compile: source		classified: (aClass protocolsFor: aSelector)! !!ChildrenToSiblingsRefactoring methodsFor: 'initialize-release'!name: aClassName class: aClass subclasses: subclassCollection 	className := aClassName asSymbol.	parent := self model classFor: aClass.	subclasses := subclassCollection 				collect: [:each | self model classFor: each]! !!ChildrenToSiblingsRefactoring methodsFor: 'preconditions'!preconditions	^subclasses 		inject: ((RBCondition isMetaclass: parent) 				errorMacro: 'Superclass must not be a metaclass') not 				& (RBCondition isValidClassName: className) 					& (RBCondition isGlobal: className in: self model) not		into: 			[:sub :each | 			sub 				& ((RBCondition isMetaclass: each) 						errorMacro: 'Subclass must <1?not :>be a metaclass') not 					& (RBCondition isImmediateSubclass: each of: parent)]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-variables'!pullUpClassInstanceVariables	| newSuperclass |	newSuperclass := self abstractSuperclass metaclass.	parent metaclass instanceVariableNames do: 			[:each | 			self performComponentRefactoring: (PullUpInstanceVariableRefactoring 						model: self model						variable: each						class: newSuperclass)]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-variables'!pullUpClassVariables	| newSuperclass |	newSuperclass := self abstractSuperclass.	parent classVariableNames do: 			[:each | 			self performComponentRefactoring: (PullUpClassVariableRefactoring 						model: self model						variable: each						class: newSuperclass)]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-variables'!pullUpInstanceVariables	| newSuperclass |	newSuperclass := self abstractSuperclass.	parent instanceVariableNames do: 			[:each | 			self performComponentRefactoring: (PullUpInstanceVariableRefactoring 						model: self model						variable: each						class: newSuperclass)]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-variables'!pullUpPoolVariables	"Don't remove the pool variables from the subclass since they might be referenced there."	| newSuperclass |	newSuperclass := self abstractSuperclass.	parent poolDictionaryNames 		do: [:each | newSuperclass addPoolDictionary: each]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!pushUp: aSelector in: aClass 	| source |	source := aClass sourceCodeFor: aSelector.	source isNil 		ifFalse: 			[aClass superclass compile: source				classified: (aClass protocolsFor: aSelector)]! !!ChildrenToSiblingsRefactoring methodsFor: 'transforming'!pushUpMethods	self pushUpMethodsFrom: parent.	self pushUpMethodsFrom: parent metaclass! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!pushUpMethodsFrom: aClass 	| selectorsToPushUp |	selectorsToPushUp := self selectorsToPushUpFrom: aClass.	aClass selectors do: 			[:each | 			(selectorsToPushUp includes: each) 				ifTrue: [self pushUp: each in: aClass]				ifFalse: [self createSubclassResponsibilityFor: each in: aClass]].	selectorsToPushUp do: [:each | aClass removeMethod: each]! !!ChildrenToSiblingsRefactoring methodsFor: 'transforming'!pushUpVariables	self pullUpInstanceVariables.	self pullUpClassInstanceVariables.	self pullUpClassVariables.	self pullUpPoolVariables! !!ChildrenToSiblingsRefactoring methodsFor: 'transforming'!reparentSubclasses	self model reparentClasses: subclasses to: self abstractSuperclass! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!selectorsToPushUpFrom: aClass 	| superSelectors |	superSelectors := self computeSubclassSupersOf: aClass.	^aClass selectors select: 			[:each | 			(superSelectors includes: each) or: [self shouldPushUp: each from: aClass]]! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!shouldPushUp: aSelector from: aClass 	^((aClass isMeta 		ifTrue: [subclasses collect: [:each | each metaclass]]		ifFalse: [subclasses]) 			detect: [:each | (each directlyDefinesMethod: aSelector) not]			ifNone: [nil]) notNil! !!ChildrenToSiblingsRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' name: #';		nextPutAll: className;		nextPutAll: ' class: '.	parent storeOn: aStream.	aStream nextPutAll: ' subclasses: '.	subclasses asArray storeOn: aStream.	aStream nextPut: $)! !!ChildrenToSiblingsRefactoring methodsFor: 'private-methods'!subclassResponsibilityFor: aSelector in: aClass 	| methodNode position source |	source := aClass sourceCodeFor: aSelector.	methodNode := RBParser parseMethod: source onError: [:err :pos | ^nil].	position := methodNode arguments isEmpty 				ifTrue: [methodNode selectorParts last stop]				ifFalse: [methodNode arguments last stop].	^'<1s><n><t>self subclassResponsibility' 		expandMacrosWith: (source copyFrom: 1 to: position)! !!ChildrenToSiblingsRefactoring methodsFor: 'transforming'!transform	self		addSuperclass;		pushUpVariables;		pushUpMethods;		changeIsKindOfReferences;		reparentSubclasses! !!ClassRefactoring class methodsFor: 'instance creation'!className: aName	^self new className: aName! !!ClassRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk className: aName 	^(self new)		model: aRBSmalltalk;		className: aName;		yourself! !!ClassRefactoring methodsFor: 'initialize-release'!className: aName	className := aName! !!RenameClassRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk rename: aClass to: aNewName 	^(self new)		model: aRBSmalltalk;		className: aClass name newName: aNewName;		yourself! !!RenameClassRefactoring class methodsFor: 'instance creation'!rename: aClass to: aNewName	^self new className: aClass name newName: aNewName! !!RenameClassRefactoring methodsFor: 'initialize-release'!className: aName newName: aNewName 	className := aName asSymbol.	class := self model classNamed: className.	newName := aNewName asSymbol! !!RenameClassRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition withBlock: [class notNil and: [class isMeta not]]		errorString: className , ' is not a valid class name') 			& (RBCondition isValidClassName: newName) 			& (RBCondition isGlobal: newName in: self model) not! !!RenameClassRefactoring methodsFor: 'transforming'!renameReferences	| replacer |	replacer := (ParseTreeRewriter replaceLiteral: className with: newName)				replace: className with: newName;				replaceArgument: newName					withValueFrom: 						[:aNode | 						self 							refactoringError: newName , ' already exists within the reference scope'];				yourself.	self model allReferencesToClass: class		do: 			[:method | 			(method modelClass hierarchyDefinesVariable: newName) 				ifTrue: 					[self refactoringError: newName , ' is already defined in hierarchy of ' 								, method modelClass printString].			self 				convertMethod: method selector				for: method modelClass				using: replacer]! !!RenameClassRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' rename: '.	class storeOn: aStream.	aStream		nextPutAll: ' to: #';		nextPutAll: newName;		nextPut: $)! !!RenameClassRefactoring methodsFor: 'transforming'!transform	self model 		renameClass: class		to: newName		around: [self renameReferences]! !!ExpandReferencedPoolsRefactoring class methodsFor: 'instance creation'!forMethod: aParseTree fromClass: aClass toClasses: classCollection 	^(self new)		forMethod: aParseTree			fromClass: aClass			toClasses: classCollection;		yourself! !!ExpandReferencedPoolsRefactoring class methodsFor: 'instance creation'!model: aRBNamespace forMethod: aParseTree fromClass: aClass toClasses: classCollection 	^(self new)		model: aRBNamespace;		forMethod: aParseTree			fromClass: aClass			toClasses: classCollection;		yourself! !!ExpandReferencedPoolsRefactoring methodsFor: 'transforming'!computePoolsToMove	| poolVariables searcher |	poolVariables := self poolVariableNamesFor: fromClass.	pools := Set new.	searcher := ParseTreeSearcher new.	searcher matches: '`var'		do: 			[:aNode :answer | 			| varName pool |			varName := aNode name.			(aNode whoDefines: varName) isNil 				ifTrue: 					[(poolVariables includes: varName) 						ifTrue: 							[pool := self whichPoolDefines: varName.							pool notNil ifTrue: [pools add: pool]]]].	searcher executeTree: parseTree! !!ExpandReferencedPoolsRefactoring methodsFor: 'initialize-release'!forMethod: aParseTree fromClass: aClass toClasses: classCollection 	fromClass := self model classFor: aClass.	parseTree := aParseTree.	toClasses := classCollection collect: [:each | self model classFor: each]! !!ExpandReferencedPoolsRefactoring methodsFor: 'testing'!hasPoolsToMove	^pools isEmpty not! !!ExpandReferencedPoolsRefactoring methodsFor: 'transforming'!movePool: aSymbol toClass: aClass 	| nonMetaClass |	nonMetaClass := aClass nonMetaclass.	(nonMetaClass definesPoolDictionary: aSymbol) 		ifFalse: [nonMetaClass addPoolDictionary: aSymbol]! !!ExpandReferencedPoolsRefactoring methodsFor: 'transforming'!movePoolVariables	pools 		do: [:poolDict | toClasses do: [:each | self movePool: poolDict toClass: each]]! !!ExpandReferencedPoolsRefactoring methodsFor: 'transforming'!poolVariableNamesIn: poolName 	^(Smalltalk at: poolName ifAbsent: [Dictionary new]) keys 		collect: [:name | name asString]! !!ExpandReferencedPoolsRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition empty! !!ExpandReferencedPoolsRefactoring methodsFor: 'transforming'!transform	self computePoolsToMove.	self hasPoolsToMove 		ifTrue: 			[self 				refactoringWarning: 'This method contains references to pools<n>which may need to be moved.' 						expandMacros].	self movePoolVariables! !!ExpandReferencedPoolsRefactoring methodsFor: 'transforming'!whichPoolDefines: varName 	| currentClass |	currentClass := fromClass.	[currentClass isNil] whileFalse: 			[currentClass allPoolDictionaryNames 				do: [:each | ((self poolVariableNamesIn: each) includes: varName) ifTrue: [^each]].			currentClass := currentClass superclass].	^nil! !!AddMethodRefactoring class methodsFor: 'instance creation'!addMethod: aString toClass: aClass inProtocols: protocolList 	^self new addMethod: aString		toClass: aClass		inProtocols: protocolList! !!AddMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk addMethod: aString toClass: aClass inProtocols: protocolList 	^(self new)		model: aRBSmalltalk;		addMethod: aString			toClass: aClass			inProtocols: protocolList;		yourself! !!AddMethodRefactoring methodsFor: 'initialize-release'!addMethod: aString toClass: aClass inProtocols: protocolList 	class := self classObjectFor: aClass.	source := aString.	protocols := protocolList! !!AddMethodRefactoring methodsFor: 'preconditions'!preconditions	| selector method |	method := RBParser parseMethod: source				onError: 					[:string :position | 					^RBCondition 						withBlock: [self refactoringError: 'The sources could not be parsed']].	selector := method selector.	selector isNil ifTrue: [self refactoringError: 'Invalid source.'].	^(RBCondition canUnderstand: selector in: class) not! !!AddMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' addMethod: ''';		nextPutAll: source;		nextPutAll: ''' toClass: '.	class storeOn: aStream.	aStream nextPutAll: ' inProtocols: '.	protocols storeOn: aStream.	aStream nextPut: $)! !!AddMethodRefactoring methodsFor: 'transforming'!transform	class compile: source classified: protocols! !!AddParameterRefactoring class methodsFor: 'instance creation'!addParameterToMethod: aSelector in: aClass newSelector: newSelector initializer: init 	^self new addParameterToMethod: aSelector		in: aClass		newSelector: newSelector		initializer: init! !!AddParameterRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk addParameterToMethod: aSelector in: aClass newSelector: newSelector initializer: init 	^(self new)		model: aRBSmalltalk;		addParameterToMethod: aSelector			in: aClass			newSelector: newSelector			initializer: init;		yourself! !!AddParameterRefactoring methodsFor: 'initialize-release' stamp: 'md 3/15/2006 17:28'!addParameterToMethod: aSelector in: aClass newSelector: newSel initializer: init 	self 		renameMethod: aSelector		in: aClass		to: newSel		permutation: (1 to: newSel numArgs).	initializer := init! !!AddParameterRefactoring methodsFor: 'preconditions'!checkSendersAccessTo: name 	| violatorClass |	(#('self' 'super') includes: name) ifTrue: [^self].	violatorClass := self senders 				detect: [:each | (self canReferenceVariable: name in: each) not]				ifNone: [nil].	violatorClass notNil 		ifTrue: 			[self refactoringError: ('<1s> doesn''t appear to be defined in <2p>' 						expandMacrosWith: name						with: violatorClass)]! !!AddParameterRefactoring methodsFor: 'preconditions'!checkVariableReferencesIn: aParseTree 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: '`var'		do: 			[:aNode :answer | 			| name |			name := aNode name.			(aNode whoDefines: name) isNil ifTrue: [self checkSendersAccessTo: name]].	searcher executeTree: aParseTree! !!AddParameterRefactoring methodsFor: 'private'!modifyImplementorParseTree: parseTree in: aClass 	| name newArg allTempVars |	allTempVars := parseTree allDefinedVariables.	name := self safeVariableNameFor: aClass temporaries: allTempVars.	newArg := RBVariableNode named: name.	parseTree arguments: parseTree arguments , (Array with: newArg).	super modifyImplementorParseTree: parseTree in: aClass! !!AddParameterRefactoring methodsFor: 'preconditions'!myConditions	^RBCondition withBlock: 			[oldSelector numArgs + 1 = newSelector numArgs 				ifFalse: 					[self refactoringError: newSelector printString 								, ' doesn''t have the proper number of arguments.'].			self verifyInitializationExpression.			true]! !!AddParameterRefactoring methodsFor: 'private'!newSelectorString	| stream keywords |	stream := WriteStream on: String new.	keywords := newSelector keywords.	1 to: keywords size		do: 			[:i | 			stream nextPutAll: (keywords at: i).			i == keywords size 				ifTrue: 					[stream						nextPut: $(;						nextPutAll: initializer;						nextPut: $)]				ifFalse: 					[stream						nextPutAll: ' ``@arg';						nextPutAll: i printString].			stream nextPut: $ ].	^stream contents! !!AddParameterRefactoring methodsFor: 'private'!parseTreeRewriter	| rewriteRule oldString newString |	rewriteRule := ParseTreeRewriter new.	oldString := self buildSelectorString: oldSelector.	newString := self newSelectorString.	rewriteRule replace: '``@object ' , oldString		with: '``@object ' , newString.	^rewriteRule! !!AddParameterRefactoring methodsFor: 'private'!safeVariableNameFor: aClass temporaries: allTempVars 	| baseString i newString |	newString := baseString := 'anObject'.	i := 0.		[(allTempVars includes: newString) 		or: [aClass definesInstanceVariable: newString]] 			whileTrue: 				[i := i + 1.				newString := baseString , i printString].	^newString! !!AddParameterRefactoring methodsFor: 'private'!senders	senders isNil 		ifTrue: 			[senders := Set new.			self model allReferencesTo: oldSelector				do: [:each | senders add: each modelClass]].	^senders! !!AddParameterRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' addParameterToMethod: #';		nextPutAll: oldSelector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' newSelector: #';		nextPutAll: newSelector;		nextPutAll: ' initializer: ''';		nextPutAll: initializer;		nextPutAll: ''')'! !!AddParameterRefactoring methodsFor: 'preconditions'!verifyInitializationExpression	| tree |	tree := RBParser parseExpression: initializer				onError: 					[:msg :index | 					self refactoringError: 'Illegal initialization code because:.' , msg].	tree isValue 		ifFalse: 			[self 				refactoringError: 'The initialization code cannot be a return node or a list of statements'].	self checkVariableReferencesIn: tree! !!ChangeMethodNameRefactoring methodsFor: 'testing'!hasPermutedArguments	oldSelector numArgs = newSelector numArgs ifFalse: [^true].	1 to: oldSelector numArgs		do: [:i | (permutation at: i) = i ifFalse: [^true]].	^false! !!ChangeMethodNameRefactoring methodsFor: 'private'!implementors	implementors isNil 		ifTrue: [implementors := self model allImplementorsOf: oldSelector].	^implementors! !!ChangeMethodNameRefactoring methodsFor: 'testing'!implementorsCanBePrimitives	^false! !!ChangeMethodNameRefactoring methodsFor: 'private'!modifyImplementorParseTree: parseTree in: aClass 	| oldArgs |	oldArgs := parseTree arguments.	parseTree arguments: (permutation collect: [:each | oldArgs at: each]).	parseTree selector: newSelector! !!ChangeMethodNameRefactoring methodsFor: 'preconditions'!myConditions	^self subclassResponsibility! !!ChangeMethodNameRefactoring methodsFor: 'accessing'!newSelector	^newSelector! !!ChangeMethodNameRefactoring methodsFor: 'private'!parseTreeRewriter	| rewriteRule oldString newString |	rewriteRule := ParseTreeRewriter new.	oldString := self buildSelectorString: oldSelector.	newString := self buildSelectorString: newSelector				withPermuteMap: permutation.	rewriteRule replace: '``@object ' , oldString		with: '``@object ' , newString.	^rewriteRule! !!ChangeMethodNameRefactoring methodsFor: 'preconditions'!preconditions	"This refactoring only preserves behavior if all implementors are renamed."	| conditions |	conditions := self myConditions 				& (RBCondition definesSelector: oldSelector in: class) 					& (RBCondition isValidMethodName: newSelector for: class).	conditions := self implementors inject: conditions				into: 					[:condition :each | 					condition & (RBCondition hierarchyOf: each canUnderstand: newSelector) not].	^conditions 		& (RBCondition withBlock: 					[self implementors size > 1 						ifTrue: 							[self refactoringWarning: ('This will modify all <1p> implementors.' 										expandMacrosWith: self implementors size)].					true])! !!ChangeMethodNameRefactoring methodsFor: 'transforming'!removeRenamedImplementors	self implementors do: [:each | each removeMethod: oldSelector]! !!ChangeMethodNameRefactoring methodsFor: 'transforming'!renameImplementors	self implementors do: 			[:each | 			| parseTree |			parseTree := each parseTreeFor: oldSelector.			parseTree isNil 				ifTrue: [self refactoringError: 'Could not parse source code.'].			self implementorsCanBePrimitives 				ifFalse: 					[parseTree isPrimitive 						ifTrue: 							[self refactoringError: ('<1p>''s implementation of #<2s> is a primitive' 										expandMacrosWith: each										with: oldSelector)]].			self modifyImplementorParseTree: parseTree in: each.			each compileTree: parseTree classified: (each protocolsFor: oldSelector)]! !!ChangeMethodNameRefactoring methodsFor: 'transforming'!renameMessageSends	self convertAllReferencesTo: oldSelector using: self parseTreeRewriter! !!ChangeMethodNameRefactoring methodsFor: 'initialize-release' stamp: 'md 3/15/2006 17:27'!renameMethod: aSelector in: aClass to: newSel permutation: aMap 	oldSelector := aSelector asSymbol.	newSelector := newSel asSymbol.	class := self classObjectFor: aClass.	permutation := aMap! !!ChangeMethodNameRefactoring methodsFor: 'transforming'!transform	self renameImplementors.	self renameMessageSends.	oldSelector == newSelector ifTrue: [^self].	self removeRenamedImplementors! !!InlineParameterRefactoring class methodsFor: 'instance creation'!inlineParameter: aString in: aClass selector: aSelector 	^self new 		inlineParameter: aString		in: aClass		selector: aSelector! !!InlineParameterRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk inlineParameter: aString in: aClass selector: aSelector 	^(self new)		model: aRBSmalltalk;		inlineParameter: aString			in: aClass			selector: aSelector;		yourself! !!InlineParameterRefactoring methodsFor: 'private'!allExpressionsToInline	| coll |	coll := Set new.	self model allReferencesTo: oldSelector		do: 			[:each | 			| tree |			tree := each parseTree.			tree notNil ifTrue: [coll addAll: (self expressionsToInlineFrom: tree)]].	^coll asOrderedCollection! !!InlineParameterRefactoring methodsFor: 'private'!expressionsToInlineFrom: aTree 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: '``@obj ' , (self buildSelectorString: oldSelector)		do: 			[:aNode :answer | 			answer				add: (aNode arguments at: parameterIndex);				yourself].	^searcher executeTree: aTree initialAnswer: OrderedCollection new! !!InlineParameterRefactoring methodsFor: 'initialize-release'!inlineParameter: aString in: aClass selector: aSelector	oldSelector := aSelector.	class := self classObjectFor: aClass.	argument := aString! !!InlineParameterRefactoring methodsFor: 'transforming'!modifyImplementorParseTree: parseTree in: aClass 	| node assignment |	node := (parseTree arguments at: parameterIndex) copy.	parseTree body addTemporaryNamed: node name.	assignment := RBAssignmentNode variable: node copy value: expressions first.	parseTree body addNodeFirst: assignment.	super modifyImplementorParseTree: parseTree in: aClass! !!InlineParameterRefactoring methodsFor: 'preconditions'!myConditions	self getNewSelector.	expressions := self allExpressionsToInline.	^(RBCondition definesSelector: oldSelector in: class) 		& ((RBCondition withBlock: [expressions isEmpty not]) 				errorMacro: 'No callers. Use Remove Method instead.') 			& ((RBCondition withBlock: [expressions size = 1]) 					errorMacro: 'All values passed as this argument must be identical.') 			& ((RBCondition withBlock: [expressions first isLiteral]) 					errorMacro: 'All values passed must be literal.')! !!InlineParameterRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' inlineParameter: ''';		nextPutAll: argument;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: oldSelector;		nextPut: $)! !!RemoveParameterRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk removeParameter: aString in: aClass selector: aSelector 	^(self new)		model: aRBSmalltalk;		removeParameter: aString			in: aClass			selector: aSelector;		yourself! !!RemoveParameterRefactoring class methodsFor: 'instance creation'!removeParameter: aString in: aClass selector: aSelector	^self new removeParameter: aString in: aClass selector: aSelector! !!RemoveParameterRefactoring methodsFor: 'private' stamp: 'md 8/2/2005 22:25'!computeNewSelector	| keywords stream |	oldSelector numArgs == 0 		ifTrue: [self refactoringError: 'This method contains no arguments'].	oldSelector isInfix 		ifTrue: [self refactoringError: 'Cannot remove parameters of infix selectors'].	keywords := oldSelector keywords asOrderedCollection.	keywords size = 1 ifTrue: [^(keywords first copyWithout: $:) asSymbol].	keywords removeAt: parameterIndex.	stream := WriteStream on: ''.	keywords do: [:each | stream nextPutAll: each].	^stream contents asSymbol! !!RemoveParameterRefactoring methodsFor: 'transforming'!getNewSelector	| tree |	(class directlyDefinesMethod: oldSelector)		ifFalse: [self refactoringError: 'Method doesn''t exist'].	tree := class parseTreeFor: oldSelector.	tree isNil ifTrue: [self refactoringError: 'Cannot parse sources'].	parameterIndex := tree argumentNames indexOf: argument ifAbsent: [self refactoringError: 'Select a parameter!!!!'].	permutation := (1 to: oldSelector numArgs)				copyWithout: parameterIndex.	newSelector := self computeNewSelector! !!RemoveParameterRefactoring methodsFor: 'transforming'!hasReferencesToTemporaryIn: each 	| tree |	tree := each parseTreeFor: oldSelector.	tree isNil ifTrue: [self refactoringError: 'Cannot parse sources.'].	^tree references: (tree argumentNames at: parameterIndex)! !!RemoveParameterRefactoring methodsFor: 'preconditions'!myConditions	| imps |	imps := self model allImplementorsOf: oldSelector.	self getNewSelector.	^imps inject: (RBCondition definesSelector: oldSelector in: class)		into: 			[:cond :each | 			cond 				& (RBCondition withBlock: [(self hasReferencesToTemporaryIn: each) not]						errorString: 'This argument is still referenced in atleast one implementor!!!!')]! !!RemoveParameterRefactoring methodsFor: 'initialize-release'!removeParameter: aString in: aClass selector: aSelector 	oldSelector := aSelector.	class := self classObjectFor: aClass.	argument := aString! !!RemoveParameterRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' removeParameter: ''';		nextPutAll: argument;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: oldSelector.	aStream nextPut: $)! !!RenameMethodRefactoring class methodsFor: 'instance creation' stamp: 'md 3/15/2006 17:29'!model: aRBSmalltalk renameMethod: aSelector in: aClass to: newSelector permutation: aMap 	^(self new)		model: aRBSmalltalk;		renameMethod: aSelector			in: aClass			to: newSelector			permutation: aMap;		yourself! !!RenameMethodRefactoring class methodsFor: 'instance creation' stamp: 'md 3/15/2006 17:26'!renameMethod: aSelector in: aClass to: newSelector permutation: aMap 	^self new renameMethod: aSelector		in: aClass		to: newSelector		permutation: aMap! !!RenameMethodRefactoring methodsFor: 'testing'!hasPermutedArguments	^hasPermutedArguments isNil 		ifTrue: [hasPermutedArguments := super hasPermutedArguments]		ifFalse: [hasPermutedArguments]! !!RenameMethodRefactoring methodsFor: 'testing'!implementorsCanBePrimitives	^self hasPermutedArguments not! !!RenameMethodRefactoring methodsFor: 'preconditions'!myConditions	^RBCondition withBlock: [oldSelector numArgs = newSelector numArgs]		errorString: newSelector printString 				, ' doesn''t have the correct number of arguments.'! !!RenameMethodRefactoring methodsFor: 'transforming'!parseTreeRewriter	| rewriteRule oldString newString |	oldString := self buildSelectorString: oldSelector.	newString := self buildSelectorString: newSelector				withPermuteMap: permutation.	rewriteRule := self hasPermutedArguments 				ifTrue: [ParseTreeRewriter new]				ifFalse: [ParseTreeRewriter replaceLiteral: oldSelector with: newSelector].	rewriteRule replace: '``@object ' , oldString		with: '``@object ' , newString.	^rewriteRule! !!RenameMethodRefactoring methodsFor: 'preconditions'!preconditions	| newCondition |	newCondition := (RBCondition withBlock: [newSelector = oldSelector]				errorString: 'The selectors are <1?:not >equivalent') & (RBCondition 							withBlock: [permutation asArray ~= (1 to: oldSelector numArgs) asArray]							errorString: 'The arguments are <1?:not >permuted').	^newCondition | super preconditions! !!RenameMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' renameMethod: #';		nextPutAll: oldSelector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' to: #';		nextPutAll: newSelector;		nextPutAll: ' permuation: '.	permutation storeOn: aStream.	aStream nextPut: $)! !!ExtractMethodRefactoring class methodsFor: 'instance creation'!extract: anInterval from: aSelector in: aClass 	^self new		extract: anInterval		from: aSelector		in: aClass! !!ExtractMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk extract: anInterval from: aSelector in: aClass 	^(self new)		model: aRBSmalltalk;		extract: anInterval			from: aSelector			in: aClass;		yourself! !!ExtractMethodRefactoring methodsFor: 'transforming'!checkAssignments: variableNames 	| node outsideVars removeAssigned |	removeAssigned := variableNames copy.	node := self placeholderNode.	outsideVars := variableNames 				select: [:each | (node whoDefines: each) references: each].	outsideVars size == 1 		ifTrue: [self checkSingleAssignment: outsideVars asArray first].	outsideVars size > 1 		ifTrue: 			[self refactoringError: 'Cannot extract assignment without all references.'].	removeAssigned removeAll: outsideVars.	(RBReadBeforeWrittenTester readBeforeWritten: removeAssigned		in: extractedParseTree) isEmpty 		ifFalse: 			[self refactoringError: 'Cannot extract assignment if read before written.'].	removeAssigned 		do: [:each | (node whoDefines: each) removeTemporaryNamed: each].	self createTemporariesInExtractedMethodFor: variableNames! !!ExtractMethodRefactoring methodsFor: 'transforming'!checkReturn	needsReturn := self placeholderNode isUsed.	extractedParseTree containsReturn ifFalse: [^self].	extractedParseTree lastIsReturn ifTrue: [^self].	(modifiedParseTree isLast: self placeholderNode) 		ifFalse: 			[self refactoringError: 'Couldn''t extract code since it contains a return.'].	self checkSelfReturns! !!ExtractMethodRefactoring methodsFor: 'transforming'!checkSelfReturns	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: '^self' do: [:aNode :answer | answer];		matches: '^`@anything' do: [:aNode :answer | true].	(searcher executeTree: extractedParseTree initialAnswer: false) 		ifTrue: [self placeholderNode asReturn]! !!ExtractMethodRefactoring methodsFor: 'transforming'!checkSingleAssignment: varName 	((RBReadBeforeWrittenTester isVariable: varName		readBeforeWrittenIn: extractedParseTree) 			or: [extractedParseTree containsReturn]) 			ifTrue: 				[self 					refactoringError: 'Cannot extract assignments to temporaries without all references'].	extractedParseTree 		addNode: (RBReturnNode value: (RBVariableNode named: varName)).	modifiedParseTree := ParseTreeRewriter 				replace: self methodDelimiter				with: varName , ' := ' , self methodDelimiter				in: modifiedParseTree! !!ExtractMethodRefactoring methodsFor: 'transforming'!checkSpecialExtractions	| node |	node := self placeholderNode parent.	node isNil ifTrue: [^self].	(node isAssignment and: [node variable = self placeholderNode]) ifTrue: 			[self refactoringError: 'Cannot extract left hand side of an assignment'].	node isCascade ifTrue: 			[self refactoringError: 'Cannot extract first message of a cascaded message']! !!ExtractMethodRefactoring methodsFor: 'transforming'!checkTemporaries	| temps accesses assigned |	temps := self remainingTemporaries.	accesses := temps select: [:each | extractedParseTree references: each].	assigned := accesses select: [:each | extractedParseTree assigns: each].	assigned isEmpty ifFalse: [self checkAssignments: assigned].	^parameters := (accesses asOrderedCollection)				removeAll: assigned;				yourself! !!ExtractMethodRefactoring methodsFor: 'transforming'!createTemporariesInExtractedMethodFor: assigned 	assigned do: [:each | extractedParseTree body addTemporaryNamed: each]! !!ExtractMethodRefactoring methodsFor: 'transforming' stamp: 'bh 5/10/2000 21:58'!existingSelector	"Try to find an existing method instead of creating a new one"	^class allSelectors detect: [:each | self isMethodEquivalentTo: each]		ifNone: [nil]! !!ExtractMethodRefactoring methodsFor: 'initialize-release'!extract: anInterval from: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	extractionInterval := anInterval! !!ExtractMethodRefactoring methodsFor: 'transforming' stamp: 'dvf 9/29/2001 17:58'!extractMethod	| parseTree isSequence extractCode subtree newCode |	extractCode := self getExtractedSource.	extractedParseTree := RBParser parseExpression: extractCode				onError: [:string :pos | self refactoringError: 'Invalid source to extract - ', string].	extractedParseTree isNil 		ifTrue: [self refactoringError: 'Invalid source to extract'].	(extractedParseTree isSequence 		and: [extractedParseTree statements isEmpty]) 			ifTrue: [self refactoringError: 'Select some code to extract'].	isSequence := extractedParseTree isSequence 				or: [extractedParseTree isReturn].	extractedParseTree := RBMethodNode 				selector: #value				arguments: #()				body: (extractedParseTree isSequence 						ifTrue: [extractedParseTree]						ifFalse: 							[RBSequenceNode temporaries: #()								statements: (OrderedCollection with: extractedParseTree)]).	extractedParseTree body temporaries isEmpty not 		ifTrue: [extractedParseTree body temporaries: #()].	extractedParseTree source: extractCode.	parseTree := class parseTreeFor: selector.	parseTree isNil 		ifTrue: [self refactoringError: 'Could not parse ' , selector printString].	subtree := isSequence 				ifTrue: 					[ParseTreeSearcher 						treeMatchingStatements: extractedParseTree body formattedCode						in: parseTree]				ifFalse: [ParseTreeSearcher treeMatching: extractCode in: parseTree].	subtree isNil 		ifTrue: [self refactoringError: 'Could not extract code from method'].	newCode := self methodDelimiter.	isSequence 		ifTrue: 			[| stmts |			stmts := extractedParseTree body statements.			stmts isEmpty 				ifFalse: 					[stmts last isAssignment 						ifTrue: 							[| name |							name := stmts last variable name.							(self shouldExtractAssignmentTo: name) 								ifFalse: 									[newCode := '<1s> := <2s>' expandMacrosWith: name with: newCode.									stmts at: stmts size put: stmts last value]]]].	modifiedParseTree := isSequence 				ifTrue: 					[ParseTreeRewriter 						replaceStatements: subtree formattedCode						with: newCode						in: parseTree						onInterval: extractionInterval]				ifFalse: 					[ParseTreeRewriter 						replace: subtree formattedCode						with: newCode						in: parseTree						onInterval: extractionInterval]! !!ExtractMethodRefactoring methodsFor: 'transforming'!getExtractedSource	| source |	source := class sourceCodeFor: selector.	((extractionInterval first between: 1 and: source size) 		and: [extractionInterval last between: 1 and: source size]) 			ifFalse: [self refactoringError: 'Invalid interval'].	^source copyFrom: extractionInterval first to: extractionInterval last! !!ExtractMethodRefactoring methodsFor: 'transforming'!getNewMethodName	| newSelector methodName newMethodName |	methodName := RBMethodName new.	methodName arguments: parameters.		[newMethodName := self requestMethodNameFor: methodName.	newMethodName isNil 		ifTrue: [self refactoringError: 'Did not extract code'].	newSelector := newMethodName selector.	(self checkMethodName: newSelector in: class) 		ifFalse: 			[self refactoringWarning: newSelector , ' is not a valid selector name.'.			newSelector := nil].	(class hierarchyDefinesMethod: newSelector asSymbol) 		ifTrue: 			[(self shouldOverride: newSelector in: class) ifFalse: [newSelector := nil]].	newSelector isNil] 			whileTrue: [].	parameters := newMethodName arguments asOrderedCollection.	^newSelector asSymbol! !!ExtractMethodRefactoring methodsFor: 'transforming'!isMethodEquivalentTo: aSelector 	selector == aSelector ifTrue: [^false].	aSelector numArgs ~~ parameters size ifTrue: [^false].	(self isParseTreeEquivalentTo: aSelector) ifFalse: [^false].	self reorderParametersToMatch: aSelector.	^true! !!ExtractMethodRefactoring methodsFor: 'transforming'!isParseTreeEquivalentTo: aSelector 	| tree definingClass |	definingClass := class whoDefinesMethod: aSelector.	tree := definingClass parseTreeFor: aSelector.	tree isNil ifTrue: [^false].	tree isPrimitive ifTrue: [^false].	(tree body equalTo: extractedParseTree body		exceptForVariables: (tree arguments collect: [:each | each name])) 			ifFalse: [^false].	(definingClass = class or: 			[(tree superMessages detect: 					[:each | 					(class superclass whichClassIncludesSelector: aSelector) 						~= (definingClass superclass whichClassIncludesSelector: each)]				ifNone: [nil]) isNil]) 		ifFalse: [^false].	^self shouldUseExistingMethod: aSelector! !!ExtractMethodRefactoring methodsFor: 'transforming'!methodDelimiter	^'#''place.holder.for.method'''! !!ExtractMethodRefactoring methodsFor: 'transforming'!nameNewMethod: aSymbol 	| args newSend |	args := parameters collect: [:parm | RBVariableNode named: parm].	extractedParseTree arguments: args asArray.	extractedParseTree selector: aSymbol.	aSymbol numArgs = 0 		ifTrue: 			[modifiedParseTree := ParseTreeRewriter 						replace: self methodDelimiter						with: 'self ' , aSymbol asString						in: modifiedParseTree.			^self].	newSend := WriteStream on: ''.	aSymbol keywords with: parameters		do: 			[:key :arg | 			newSend				nextPutAll: key asString;				nextPut: $ ;				nextPutAll: arg asString;				nextPut: $ ].	modifiedParseTree := ParseTreeRewriter 				replace: self methodDelimiter				with: 'self ' , newSend contents				in: modifiedParseTree! !!ExtractMethodRefactoring methodsFor: 'transforming'!placeholderNode	| node |	node := ParseTreeSearcher treeMatching: self methodDelimiter				in: modifiedParseTree.	node isNil ifTrue: [self refactoringError: 'Cannot extract code'].	^node! !!ExtractMethodRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition withBlock: 					[self extractMethod.					self checkSpecialExtractions.					self checkReturn.					needsReturn ifTrue: [extractedParseTree addReturn].					self checkTemporaries.					true])! !!ExtractMethodRefactoring methodsFor: 'transforming'!remainingTemporaries	| temps |	temps := modifiedParseTree allDefinedVariables asSet.	extractedParseTree allDefinedVariables 		do: [:each | temps remove: each ifAbsent: []].	^temps! !!ExtractMethodRefactoring methodsFor: 'transforming'!reorderParametersToMatch: aSelector 	| tree dictionary |	tree := class parseTreeFor: aSelector.	dictionary := Dictionary new.	tree body equalTo: extractedParseTree body withMapping: dictionary.	parameters := tree arguments collect: 					[:each | 					dictionary at: each name						ifAbsent: 							[self 								refactoringError: 'An internal error occured, please report this error.']]! !!ExtractMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' extract: '.	extractionInterval storeOn: aStream.	aStream		nextPutAll: ' from: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!ExtractMethodRefactoring methodsFor: 'transforming' stamp: 'bh 5/10/2000 21:56'!transform	| existingSelector |	existingSelector := self existingSelector.	self nameNewMethod: (existingSelector isNil 				ifTrue: [self getNewMethodName]				ifFalse: [existingSelector]).	existingSelector isNil 		ifTrue: 			[class compileTree: extractedParseTree				classified: (class protocolsFor: selector)].	class compileTree: modifiedParseTree! !!ExtractMethodToComponentRefactoring class methodsFor: 'instance creation'!extract: anInterval from: aSelector in: aClass 	^self new		extract: anInterval		from: aSelector		in: aClass! !!ExtractMethodToComponentRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk extract: anInterval from: aSelector in: aClass 	^(self new)		model: aRBSmalltalk;		extract: anInterval			from: aSelector			in: aClass;		yourself! !!ExtractMethodToComponentRefactoring methodsFor: 'initialize-release'!extract: anInterval from: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	extractionInterval := anInterval! !!ExtractMethodToComponentRefactoring methodsFor: 'transforming'!extractMethod	| refactoring |	refactoring := ExtractMethodRefactoring 				model: self model				extract: extractionInterval				from: selector				in: class.	refactoring setOption: #methodName		toUse: 			[:ref :methodName | 			extractedMethodSelector := ref 						uniqueMethodNameFor: methodName arguments size.			methodName				selector: extractedMethodSelector;				yourself].	self performComponentRefactoring: refactoring! !!ExtractMethodToComponentRefactoring methodsFor: 'transforming'!inlineForwarder	| refactoring |	refactoring := InlineAllSendersRefactoring 				model: self model				sendersOf: extractedMethodSelector				in: class.	refactoring setOption: #inlineExpression toUse: [:ref :string | true].	self performComponentRefactoring: refactoring! !!ExtractMethodToComponentRefactoring methodsFor: 'transforming'!moveMethod	| variable refactoring |	variable := self selectVariableToMoveMethodTo: extractedMethodSelector				class: class.	variable isNil ifTrue: [self refactoringError: 'Did not extract method'].	refactoring := MoveMethodRefactoring 				model: self model				selector: extractedMethodSelector				class: class				variable: variable.	self performComponentRefactoring: refactoring! !!ExtractMethodToComponentRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition empty! !!ExtractMethodToComponentRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' extract: '.	extractionInterval storeOn: aStream.	aStream		nextPutAll: ' from: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!ExtractMethodToComponentRefactoring methodsFor: 'transforming'!transform	self		extractMethod;		moveMethod;		inlineForwarder! !!ExtractToTemporaryRefactoring class methodsFor: 'instance creation'!extract: anInterval to: aString from: aSelector in: aClass 	^self new 		extract: anInterval		to: aString		from: aSelector		in: aClass! !!ExtractToTemporaryRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk extract: anInterval to: aString from: aSelector in: aClass 	^(self new)		model: aRBSmalltalk;		extract: anInterval			to: aString			from: aSelector			in: aClass;		yourself! !!ExtractToTemporaryRefactoring methodsFor: 'preconditions'!checkVariableName	(class whoDefinesInstanceVariable: newVariableName) notNil 		ifTrue: 			[self refactoringError: ('<1p> defines an instance variable named <2s>' 						expandMacrosWith: class						with: newVariableName)].	(class whoDefinesClassVariable: newVariableName) notNil 		ifTrue: 			[self refactoringError: ('<1p> defines a class variabled named <2s>' 						expandMacrosWith: class						with: newVariableName)].	(self parseTree allDefinedVariables includes: newVariableName) 		ifTrue: 			[self refactoringError: ('<1s> is already a temporary variable name' 						expandMacrosWith: newVariableName)]! !!ExtractToTemporaryRefactoring methodsFor: 'transforming'!compileNewMethod	class compileTree: self parseTree! !!ExtractToTemporaryRefactoring methodsFor: 'transforming'!constructAssignmentFrom: aNode 	| valueNode |	valueNode := RBVariableNode named: newVariableName.	^RBAssignmentNode variable: valueNode value: aNode! !!ExtractToTemporaryRefactoring methodsFor: 'initialize-release'!extract: anInterval to: aString from: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	sourceInterval := anInterval.	newVariableName := aString! !!ExtractToTemporaryRefactoring methodsFor: 'transforming'!insertTemporary	| node statementNode |	node := self parseTree whichNodeIsContainedBy: sourceInterval.	(node notNil and: [node isValue]) 		ifFalse: [self refactoringError: 'Cannot assign to non-value nodes'].	statementNode := node statementNode.	node replaceWith: (RBVariableNode named: newVariableName).	(statementNode parent)		addNode: (self constructAssignmentFrom: node)			before: (node == statementNode 					ifTrue: [RBVariableNode named: newVariableName]					ifFalse: [statementNode]);		addTemporaryNamed: newVariableName! !!ExtractToTemporaryRefactoring methodsFor: 'private-accessing'!parseTree	parseTree isNil 		ifTrue: 			[parseTree := class parseTreeFor: selector.			parseTree isNil ifTrue: [self refactoringError: 'Could not parse method']].	^parseTree! !!ExtractToTemporaryRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition isValidInstanceVariableName: newVariableName for: class) 			& (RBCondition withBlock: 						[self verifySelectedInterval.						self checkVariableName.						true])! !!ExtractToTemporaryRefactoring methodsFor: 'private-accessing'!selectedSource	| source |	source := class sourceCodeFor: selector.	source isNil ifTrue: [self refactoringError: 'Couldn''t find sources'].	((sourceInterval first between: 1 and: source size) 		and: [sourceInterval last between: 1 and: source size]) 			ifFalse: [self refactoringError: 'Invalid interval'].	^source copyFrom: sourceInterval first to: sourceInterval last! !!ExtractToTemporaryRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' extract: '.	sourceInterval storeOn: aStream.	aStream		nextPutAll: ' to: ''';		nextPutAll: newVariableName;		nextPutAll: ''' from: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!ExtractToTemporaryRefactoring methodsFor: 'transforming'!transform	self		insertTemporary;		compileNewMethod! !!ExtractToTemporaryRefactoring methodsFor: 'preconditions'!verifySelectedInterval	| selectedParseTree selectedSources |	selectedSources := self selectedSource.	selectedParseTree := RBParser parseExpression: selectedSources				onError: [:message :position | self refactoringError: 'Invalid selection'].	selectedParseTree isSequence 		ifTrue: [self refactoringError: 'Cannot assign temp to multiple statements']! !!InlineAllSendersRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk sendersOf: aSelector in: aClass 	^(self new)		model: aRBSmalltalk;		sendersOf: aSelector in: aClass;		yourself! !!InlineAllSendersRefactoring class methodsFor: 'instance creation'!sendersOf: aSelector in: aClass 	^self new sendersOf: aSelector in: aClass! !!InlineAllSendersRefactoring methodsFor: 'transforming'!checkInlinedMethods	numberReplaced = 0 		ifTrue: [self refactoringError: 'Could not inline any senders']! !!InlineAllSendersRefactoring methodsFor: 'transforming'!inlineMessagesInClass: aClass andSelector: aSelector 	| messagesToInline previousCountOfMessages |	previousCountOfMessages := 4294967295.	"Some really large number > # of initial self sends."		[messagesToInline := self 				numberOfSelfSendsIn: (aClass parseTreeFor: aSelector).	messagesToInline > 0 and: [previousCountOfMessages > messagesToInline]] 			whileTrue: 				[| node |				previousCountOfMessages := messagesToInline.				node := self selfSendIn: (aClass parseTreeFor: aSelector).				self onError: 						[self performComponentRefactoring: (InlineMethodRefactoring 									model: self model									inline: node sourceInterval									inMethod: aSelector									forClass: aClass).						numberReplaced := numberReplaced + 1]					do: []].	numberNotReplaced := numberNotReplaced + messagesToInline! !!InlineAllSendersRefactoring methodsFor: 'transforming'!inlineSelfSends	class withAllSubclasses do: 			[:each | 			| selectors |			selectors := each selectors.			selectors remove: selector ifAbsent: [].			selectors do: [:sel | self inlineMessagesInClass: each andSelector: sel]]! !!InlineAllSendersRefactoring methodsFor: 'transforming'!messagePattern	^'self ' , (self buildSelectorString: selector)! !!InlineAllSendersRefactoring methodsFor: 'accessing'!messagesNotReplaced	^numberNotReplaced! !!InlineAllSendersRefactoring methodsFor: 'transforming'!numberOfSelfSendsIn: aParseTree 	| search |	search := ParseTreeSearcher new.	search matches: self messagePattern do: [:aNode :answer | answer + 1].	^search executeTree: aParseTree initialAnswer: 0! !!InlineAllSendersRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition canUnderstand: selector in: class! !!InlineAllSendersRefactoring methodsFor: 'transforming'!removeMethod	self onError: 			[self performComponentRefactoring: (RemoveMethodRefactoring 						model: self model						removeMethods: (Array with: selector)						from: class)]		do: []! !!InlineAllSendersRefactoring methodsFor: 'transforming'!selfSendIn: aTree 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: self messagePattern do: [:aNode :answer | ^aNode].	^searcher executeTree: aTree initialAnswer: nil! !!InlineAllSendersRefactoring methodsFor: 'initialize-release'!sendersOf: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	numberReplaced := numberNotReplaced := 0! !!InlineAllSendersRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' sendersOf: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!InlineAllSendersRefactoring methodsFor: 'transforming'!transform	self		inlineSelfSends;		removeMethod;		checkInlinedMethods! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!abstractVariableReferences	| refactoring |	refactoring := AbstractVariablesRefactoring 				model: self model				abstractVariablesIn: inlineParseTree				from: inlineClass				toAll: (Array with: class).	self performComponentRefactoring: refactoring.	inlineParseTree := refactoring parseTree! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!addArgumentToSelector: aSymbol 	^aSymbol isInfix 		ifTrue: [#value:value:]		ifFalse: [(aSymbol , 'value:') asSymbol]! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!addSelfReferenceToInlineParseTree	| variableName rewriter newArguments |	variableName := self newNameForSelf.	rewriter := ParseTreeRewriter rename: 'self' to: variableName.	(rewriter executeTree: inlineParseTree) 		ifTrue: [inlineParseTree := rewriter tree].	newArguments := inlineParseTree arguments asOrderedCollection.	newArguments addFirst: (RBVariableNode named: variableName).	inlineParseTree		arguments: newArguments;		selector: (self addArgumentToSelector: inlineParseTree selector).	sourceMessage receiver replaceWith: (RBVariableNode named: variableName)! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!addSelfReferenceToSourceMessage	| newArguments |	newArguments := sourceMessage arguments asOrderedCollection.	newArguments addFirst: sourceMessage receiver copy.	sourceMessage		arguments: newArguments;		selector: (self addArgumentToSelector: sourceMessage selector)! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!checkSuperMessages	inlineParseTree superMessages isEmpty 		ifFalse: 			[self 				refactoringError: 'Cannot inline method since it sends a super message']! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!findSelectedMessage	sourceParseTree := class parseTreeFor: sourceSelector.	sourceParseTree isNil 		ifTrue: [self refactoringError: 'Could not parse sources'].	sourceMessage := sourceParseTree whichNodeIsContainedBy: sourceInterval.	sourceMessage isNil 		ifTrue: 			[self 				refactoringError: 'The selection doesn''t appear to be a message send'].	sourceMessage isCascade 		ifTrue: [sourceMessage := sourceMessage messages last].	sourceMessage isMessage 		ifFalse: 			[self 				refactoringError: 'The selection doesn''t appear to be a message send']! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!inlineClass	| imps |	inlineClass notNil ifTrue: [^inlineClass].	imps := (self model allImplementorsOf: self inlineSelector) 				asOrderedCollection.	imps size = 1 ifTrue: [^inlineClass := imps first].	imps isEmpty 		ifTrue: 			[self 				refactoringError: 'Nobody defines a method named ' , self inlineSelector].	inlineClass := self requestImplementorToInline: imps.	inlineClass isNil 		ifTrue: [self refactoringError: 'No implementor selected'].	^inlineClass! !!InlineMethodFromComponentRefactoring methodsFor: 'testing'!isOverridden	^(self inlineClass allSubclasses 		detect: [:each | each directlyDefinesMethod: self inlineSelector]		ifNone: [nil]) notNil! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!newNameForSelf	| variableName index originalName nonMetaClass |	nonMetaClass := inlineClass nonMetaclass.	variableName := originalName := (nonMetaClass name first isVowel 						ifTrue: ['an']						ifFalse: ['a']) , nonMetaClass name.	index := 1.		[variableName := self safeVariableNameBasedOn: variableName.	inlineParseTree allDefinedVariables includes: variableName] 			whileTrue: 				[variableName := originalName , index printString.				index := index + 1].	^variableName! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!renameSelfReferences	self addSelfReferenceToSourceMessage.	self addSelfReferenceToInlineParseTree.! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!safeVariableNameBasedOn: aString 	"Creates an unused variable name containing aString"	| baseString newString i allTempVars |	allTempVars := inlineParseTree allTemporaryVariables.	baseString := aString copy.	baseString at: 1 put: baseString first asLowercase.	newString := baseString.	i := 0.		[(allTempVars includes: newString) 		or: [class definesInstanceVariable: newString]] 			whileTrue: 				[i := i + 1.				newString := baseString , i printString].	^newString! !!InlineMethodFromComponentRefactoring methodsFor: 'transforming'!transform	self abstractVariableReferences.	self renameSelfReferences.	super transform! !!InlineMethodRefactoring class methodsFor: 'instance creation'!inline: anInterval inMethod: aSelector forClass: aClass 	^self new 		inline: anInterval		inMethod: aSelector		forClass: aClass! !!InlineMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk inline: anInterval inMethod: aSelector forClass: aClass 	^(self new)		model: aRBSmalltalk;		inline: anInterval			inMethod: aSelector			forClass: aClass;		yourself! !!InlineMethodRefactoring methodsFor: 'transforming'!addSelfReturn	inlineParseTree addSelfReturn! !!InlineMethodRefactoring methodsFor: 'transforming'!addTemporary: sourceNode assignedTo: replacementNode 	| newName |	newName := self renameConflictingTemporary: sourceNode name.	(inlineParseTree body)		addTemporaryNamed: newName;		addNodeFirst: (RBAssignmentNode variable: (RBVariableNode named: newName)					value: replacementNode)! !!InlineMethodRefactoring methodsFor: 'transforming'!checkSuperMessages	self inlineClass = class ifTrue: [^self].	self inlineClass superclass isNil ifTrue: [^self].	inlineParseTree superMessages do: 			[:each | 			(self inlineClass superclass whoDefinesMethod: each) 				= (class superclass whoDefinesMethod: each) 					ifFalse: 						[self 							refactoringError: ('Cannot inline method since it sends a super message <1s> that is overriden' 									expandMacrosWith: each)]]! !!InlineMethodRefactoring methodsFor: 'transforming'!compileMethod	class compileTree: sourceParseTree! !!InlineMethodRefactoring methodsFor: 'transforming'!findSelectedMessage	sourceParseTree := class parseTreeFor: sourceSelector.	sourceParseTree isNil 		ifTrue: [self refactoringError: 'Could not parse sources'].	sourceMessage := sourceParseTree whichNodeIsContainedBy: sourceInterval.	sourceMessage isNil 		ifTrue: 			[self 				refactoringError: 'The selection doesn''t appear to be a message send'].	sourceMessage isCascade 		ifTrue: [sourceMessage := sourceMessage messages last].	sourceMessage isMessage 		ifFalse: 			[self 				refactoringError: 'The selection doesn''t appear to be a message send'].	(sourceMessage receiver isVariable 		and: [#('self' 'super') includes: sourceMessage receiver name]) 			ifFalse: [self refactoringError: 'Cannot inline non-self messages']! !!InlineMethodRefactoring methodsFor: 'testing'!hasMultipleReturns	"Do we have multiple returns? If the last statement isn't a return, then we have an implicit return of self."	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: '^``@object'		do: 			[:aNode :hasAReturn | 			hasAReturn ifTrue: [^true].			true].	searcher executeTree: inlineParseTree		initialAnswer: inlineParseTree lastIsReturn not.	^false! !!InlineMethodRefactoring methodsFor: 'initialize-release'!inline: anInterval inMethod: aSelector forClass: aClass 	sourceSelector := aSelector.	class := self classObjectFor: aClass.	sourceInterval := anInterval! !!InlineMethodRefactoring methodsFor: 'transforming'!inlineClass	^inlineClass isNil 		ifTrue: 			[inlineClass := (sourceMessage receiver name = 'super' 						ifTrue: [class superclass]						ifFalse: [class]) whoDefinesMethod: self inlineSelector]		ifFalse: [inlineClass]! !!InlineMethodRefactoring methodsFor: 'transforming'!inlineSelector	sourceMessage isNil ifTrue: [self findSelectedMessage].	^sourceMessage selector! !!InlineMethodRefactoring methodsFor: 'transforming'!inlineSourceReplacing: aParseTree 	| statements nodeUnderSequence |	statements := inlineParseTree body statements.	(statements size > 1 and: [aParseTree isEvaluatedFirst not]) 		ifTrue: 			[self 				refactoringWarning: 'To inline this method, we need to move some of its statements before the original message send.<n>This could change the order of execution, which can change the behavior.<n>Do you want to proceed?' 						expandMacros].	nodeUnderSequence := aParseTree.	[nodeUnderSequence parent isSequence] 		whileFalse: [nodeUnderSequence := nodeUnderSequence parent].	(nodeUnderSequence parent)		addNodes: (statements copyFrom: 1 to: (statements size - 1 max: 0))			before: nodeUnderSequence;		addTemporariesNamed: inlineParseTree body temporaryNames.	aParseTree parent replaceNode: aParseTree		withNode: (statements isEmpty 				ifTrue: [RBVariableNode named: 'self']				ifFalse: [statements last])! !!InlineMethodRefactoring methodsFor: 'transforming'!insertInlinedMethod	| node |	node := sourceMessage.	self moveComments.	node parent isCascade 		ifTrue: 			[self rewriteCascadedMessage.			node := node parent].	node parent isReturn 		ifTrue: [node := node parent]		ifFalse: [self removeReturns].	self replaceArguments.	self inlineSourceReplacing: node.	sourceParseTree removeDeadCode.	self removeEmptyIfTrues.	self removeImmediateBlocks! !!InlineMethodRefactoring methodsFor: 'testing'!isOverridden	^(class allSubclasses detect: [:each | each directlyDefinesMethod: self inlineSelector]		ifNone: [nil]) notNil! !!InlineMethodRefactoring methodsFor: 'testing'!isPrimitive	^inlineParseTree isPrimitive! !!InlineMethodRefactoring methodsFor: 'transforming'!moveComments	inlineParseTree nodesDo: 			[:each | 			each 				comments: (each comments collect: 							[:anInterval | 							| start stop source |							source := sourceParseTree source.							start := source size + 1.							source := source 										, (inlineParseTree source copyFrom: anInterval first to: anInterval last).							stop := source size.							sourceParseTree source: source.							start to: stop])]! !!InlineMethodRefactoring methodsFor: 'transforming'!normalizeIfTrues	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: '| `@temps | ``@.s1. ``@boolean ifTrue: [| `@t1 | ``@.Stmts1. ^`@r1]. ``@.s2. ^``@r2'			with: '| `@temps | ``@.s1. ``@boolean ifTrue: [| `@t1 | ``@.Stmts1. ^`@r1] ifFalse: [``@.s2. ^``@r2]';		replace: '| `@temps | ``@.s1. ``@boolean ifFalse: [| `@t1 | ``@.Stmts1. ^`@r1]. ``@.s2. ^``@r2'			with: '| `@temps | ``@.s1. ``@boolean ifTrue: [``@.s2. ^``@r2] ifFalse: [| `@t1 | ``@.Stmts1. ^`@r1]'.	[rewriter executeTree: inlineParseTree] 		whileTrue: [inlineParseTree := rewriter tree]! !!InlineMethodRefactoring methodsFor: 'transforming'!normalizeReturns	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ^``@r1] ifFalse: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ^``@r1] ifTrue: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ^``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]'			with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ^``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]'			with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '``@boolean ifTrue: [| `@t1 | `@.Stmts1. ^``@r1] ifFalse: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';		replace: '``@boolean ifFalse: [| `@t1 | `@.Stmts1. ^``@r1] ifTrue: [| `@t2 | `@.Stmts2. ^``@r2]'			with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]'.	[rewriter executeTree: inlineParseTree] 		whileTrue: [inlineParseTree := rewriter tree]! !!InlineMethodRefactoring methodsFor: 'transforming'!parseInlineMethod	self inlineClass isNil 		ifTrue: 			[self 				refactoringError: ('<1p> or its superclasses don''t contain method <2s>' 						expandMacrosWith: class						with: self inlineSelector)].	inlineParseTree := self inlineClass parseTreeFor: self inlineSelector.	inlineParseTree isNil 		ifTrue: [self refactoringError: 'Could not parse sources'].	inlineParseTree lastIsReturn ifFalse: [inlineParseTree addSelfReturn]! !!InlineMethodRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: sourceSelector in: class) 		& (RBCondition withBlock: 					[self findSelectedMessage.					self isOverridden 						ifTrue: 							[self 								refactoringWarning: ('<1p>>><2s> is overriden. Do you want to inline it anyway?' 										expandMacrosWith: self inlineClass										with: self inlineSelector)].					self parseInlineMethod.					self isPrimitive 						ifTrue: [self refactoringError: 'Cannot inline primitives'].					self checkSuperMessages.					self rewriteInlinedTree.					(sourceMessage parent isReturn or: [self hasMultipleReturns not]) 						ifFalse: 							[self 								refactoringError: 'Cannot inline method since it contains multiple returns that cannot be rewritten'].					true])! !!InlineMethodRefactoring methodsFor: 'transforming'!removeEmptyIfTrues	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: '``@boolean ifTrue: [] ifFalse: [| `@temps | ``@.Stmts]'			with: '``@boolean ifFalse: [|`@temps | ``@.Stmts]';		replace: '``@boolean ifFalse: [] ifTrue: [| `@temps | ``@.Stmts]'			with: '``@boolean ifTrue: [|`@temps | ``@.Stmts]';		replace: '``@boolean ifTrue: [| `@temps | ``@.Stmts] ifFalse: []'			with: '``@boolean ifTrue: [|`@temps | ``@.Stmts]';		replace: '``@boolean ifFalse: [| `@temps | ``@.Stmts] ifTrue: []'			with: '``@boolean ifFalse: [|`@temps | ``@.Stmts]'.	(rewriter executeTree: sourceParseTree) 		ifTrue: [sourceParseTree := rewriter tree]! !!InlineMethodRefactoring methodsFor: 'transforming'!removeImmediateBlocks	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter 		replace: '[``.object] value'		with: '``.object'		when: [:aNode | aNode parent isCascade not].	rewriter 		replace: '| `@temps | ``@.Stmts1. [| `@bTemps | ``@.bStmts] value. ``@.Stmts2'		with: '| `@temps `@bTemps | ``@.Stmts1. ``@.bStmts. ``@.Stmts2'.	(rewriter executeTree: sourceParseTree) 		ifTrue: [sourceParseTree := rewriter tree]! !!InlineMethodRefactoring methodsFor: 'transforming'!removeReturns	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter replace: '^``@object' with: '``@object'.	(rewriter executeTree: inlineParseTree) 		ifTrue: [inlineParseTree := rewriter tree]! !!InlineMethodRefactoring methodsFor: 'transforming'!renameConflictingTemporaries	inlineParseTree allDefinedVariables 		do: [:each | self renameConflictingTemporary: each]! !!InlineMethodRefactoring methodsFor: 'transforming'!renameConflictingTemporary: aName 	| allNames newName index seqNode |	allNames := (Set new)				addAll: inlineParseTree allDefinedVariables;				yourself.	allNames remove: aName ifAbsent: [].	seqNode := sourceMessage.	[seqNode isSequence] whileFalse: [seqNode := seqNode parent].	allNames addAll: seqNode allDefinedVariables.	"Add those variables defined in blocks. This might cause a few 													variables to be renamed that don't need to be, but this should be safe."	newName := aName.	index := 0.		[(sourceMessage whoDefines: newName) notNil or: 			[(class hierarchyDefinesVariable: newName) or: [allNames includes: newName]]] 			whileTrue: 				[index := index + 1.				newName := aName , index printString].	newName = aName ifFalse: [self renameTemporary: aName to: newName].	^newName! !!InlineMethodRefactoring methodsFor: 'transforming'!renameTemporary: oldName to: newName 	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replace: oldName with: newName;		replaceArgument: oldName with: newName.	(rewriter executeTree: inlineParseTree) 		ifTrue: [inlineParseTree := rewriter tree]! !!InlineMethodRefactoring methodsFor: 'transforming'!replaceArgument: sourceNode with: replacementNode 	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter replaceTree: sourceNode withTree: replacementNode.	(rewriter executeTree: inlineParseTree body) 		ifTrue: [inlineParseTree body: rewriter tree]! !!InlineMethodRefactoring methodsFor: 'transforming'!replaceArguments	sourceMessage arguments reverse with: inlineParseTree arguments reverse		do: 			[:replacement :source | 			(replacement isImmediate 				or: [self shouldInlineExpression: replacement formattedCode]) 					ifTrue: [self replaceArgument: source with: replacement]					ifFalse: [self addTemporary: source assignedTo: replacement]]! !!InlineMethodRefactoring methodsFor: 'transforming'!rewriteCascadedMessage	| index messages |	messages := sourceMessage parent messages.	index := (1 to: messages size) 				detect: [:i | sourceMessage == (messages at: i)]				ifNone: [0].	inlineParseTree body addNodesFirst: (messages copyFrom: 1 to: index - 1).	self removeReturns.	inlineParseTree body 		addNodes: (messages copyFrom: index + 1 to: messages size).	inlineParseTree addReturn! !!InlineMethodRefactoring methodsFor: 'transforming'!rewriteInlinedTree	sourceMessage parent isReturn 		ifTrue: 			[(sourceParseTree isLast: sourceMessage parent) 				ifFalse: [self addSelfReturn]]		ifFalse: 			[self				writeGuardClauses;				normalizeIfTrues;				normalizeReturns;				addSelfReturn]! !!InlineMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' inline: '.	sourceInterval storeOn: aStream.	aStream		nextPutAll: ' inMethod: #';		nextPutAll: sourceSelector;		nextPutAll: ' forClass: '.	class storeOn: aStream.	aStream nextPut: $)! !!InlineMethodRefactoring methodsFor: 'transforming'!transform	self		renameConflictingTemporaries;		insertInlinedMethod;		compileMethod! !!InlineMethodRefactoring methodsFor: 'transforming'!writeGuardClauses	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter		replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2. ^`@r2'			with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1] ifFalse: [`@.s2. ^`@r2]';		replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2. ^`@r2'			with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [`@.s2. ^`@r2] ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]';		replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2'			with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1] ifFalse: [`@.s2. ^self]';		replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2'			with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [`@.s2. ^self] ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]'.	[rewriter executeTree: inlineParseTree] 		whileTrue: [inlineParseTree := rewriter tree]! !!InlineTemporaryRefactoring class methodsFor: 'instance creation'!inline: anInterval from: aSelector in: aClass 	^self new 		inline: anInterval		from: aSelector		in: aClass! !!InlineTemporaryRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk inline: anInterval from: aSelector in: aClass 	^(self new)		model: aRBSmalltalk;		inline: anInterval			from: aSelector			in: aClass;		yourself! !!InlineTemporaryRefactoring methodsFor: 'transforming'!compileMethod	class compileTree: sourceTree! !!InlineTemporaryRefactoring methodsFor: 'testing'!hasOnlyOneAssignment	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: assignmentNode variable name , ' := ``@object'		do: [:aNode :answer | answer + 1].	^(searcher executeTree: definingNode initialAnswer: 0) == 1! !!InlineTemporaryRefactoring methodsFor: 'initialize-release'!inline: anInterval from: aSelector in: aClass 	class := self classObjectFor: aClass.	selector := aSelector.	sourceInterval := anInterval! !!InlineTemporaryRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition withBlock: 					[self verifySelectedInterval.					true])! !!InlineTemporaryRefactoring methodsFor: 'transforming'!replaceAssignment	assignmentNode parent isSequence 		ifTrue: [assignmentNode parent removeNode: assignmentNode]		ifFalse: [assignmentNode replaceWith: assignmentNode value]! !!InlineTemporaryRefactoring methodsFor: 'transforming'!replaceReferences	| rewriter |	rewriter := ParseTreeRewriter new.	rewriter replaceTree: assignmentNode variable		withTree: assignmentNode value.	definingNode removeTemporaryNamed: assignmentNode variable name.	rewriter executeTree: definingNode! !!InlineTemporaryRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' inline: '.	sourceInterval storeOn: aStream.	aStream		nextPutAll: ' from: #';		nextPutAll: selector;		nextPutAll: ' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!InlineTemporaryRefactoring methodsFor: 'transforming'!transform	self		replaceAssignment;		replaceReferences;		compileMethod! !!InlineTemporaryRefactoring methodsFor: 'preconditions'!verifySelectedInterval	sourceTree := class parseTreeFor: selector.	sourceTree isNil ifTrue: [self refactoringError: 'Could not parse source'].	assignmentNode := sourceTree whichNodeIsContainedBy: sourceInterval.	assignmentNode isAssignment 		ifFalse: 			[self refactoringError: 'The selected node is not an assignment statement'].	definingNode := assignmentNode whoDefines: assignmentNode variable name.	self hasOnlyOneAssignment 		ifFalse: 			[self refactoringError: 'There are multiple assignments to the variable'].	(RBReadBeforeWrittenTester isVariable: assignmentNode variable name		writtenBeforeReadIn: definingNode) 			ifFalse: 				[self 					refactoringError: 'The variable is possible read before it is assigned']! !!MethodRefactoring methodsFor: 'private'!buildSelectorString: aSelector 	aSelector numArgs = 0 ifTrue: [^aSelector].	^self buildSelectorString: aSelector		withPermuteMap: (1 to: aSelector numArgs)! !!MethodRefactoring methodsFor: 'private'!buildSelectorString: aSelector withPermuteMap: anIntegerCollection 	| stream keywords |	aSelector numArgs == 0 ifTrue: [^aSelector asString].	stream := WriteStream on: String new.	keywords := aSelector keywords.	keywords with: anIntegerCollection		do: 			[:each :i | 			stream				nextPutAll: each;				nextPutAll: ' ``@arg';				nextPutAll: i printString;				nextPut: $ ].	^stream contents! !!MoveMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk selector: aSymbol class: aClass variable: aVariableName 	^(self new)		model: aRBSmalltalk;		selector: aSymbol			class: aClass			variable: aVariableName;		yourself! !!MoveMethodRefactoring class methodsFor: 'instance creation'!selector: aSymbol class: aClass variable: aVariableName 	^(self new)		selector: aSymbol			class: aClass			variable: aVariableName;		yourself! !!MoveMethodRefactoring methodsFor: 'transforming'!abstractVariables	self performComponentRefactoring: self abstractVariablesRefactoring.	parseTree := self abstractVariablesRefactoring parseTree! !!MoveMethodRefactoring methodsFor: 'transforming'!abstractVariablesRefactoring	^AbstractVariablesRefactoring 		model: self model		abstractVariablesIn: parseTree		from: class		toAll: moveToClasses		ignoring: variable! !!MoveMethodRefactoring methodsFor: 'transforming'!addSelfReturn	self hasOnlySelfReturns ifTrue: [^self].	parseTree addSelfReturn! !!MoveMethodRefactoring methodsFor: 'private'!buildParseTree	parseTree := (class parseTreeFor: selector) copy.	parseTree isNil ifTrue: [self refactoringError: 'Could not parse method']! !!MoveMethodRefactoring methodsFor: 'preconditions'!checkAssignmentsToVariable	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: variable , ' := `@object' do: [:aNode :answer | true].	(searcher executeTree: parseTree initialAnswer: false) 		ifTrue: 			[self refactoringError: ('Cannot move the method into <1s> since it is assigned' 						expandMacrosWith: variable)]! !!MoveMethodRefactoring methodsFor: 'preconditions'!checkForPrimitiveMethod	parseTree isPrimitive 		ifTrue: [self refactoringError: 'Cannot move primitive methods']! !!MoveMethodRefactoring methodsFor: 'preconditions'!checkForSuperReferences	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: 'super `@message: `@args' do: [:aNode :answer | true].	(searcher executeTree: parseTree initialAnswer: false) 		ifTrue: 			[self refactoringError: 'Cannot move the method since it has a super message send.']! !!MoveMethodRefactoring methodsFor: 'preconditions'!checkTemporaryVariableNames	| varNames |	varNames := parseTree allDefinedVariables.	selfVariableName notNil ifTrue: [varNames add: selfVariableName].	varNames do: 			[:name | 			moveToClasses do: 					[:each | 					(self canReferenceVariable: name in: each) 						ifTrue: 							[self refactoringError: ('<1p> already defines a variable called <2s>' 										expandMacrosWith: each										with: name)]]]! !!MoveMethodRefactoring methodsFor: 'transforming'!compileDelagatorMethod	| statementNode delegatorNode tree |	delegatorNode := RBMessageNode 				receiver: (RBVariableNode named: variable)				selectorParts: parseTree selectorParts				arguments: (parseTree argumentNames collect: 							[:each | 							RBVariableNode 								named: (each = selfVariableName ifTrue: ['self'] ifFalse: [each])]).	self hasOnlySelfReturns 		ifFalse: [delegatorNode := RBReturnNode value: delegatorNode].	statementNode := RBSequenceNode temporaries: #()				statements: (Array with: delegatorNode).	(tree := class parseTreeFor: selector) body: statementNode.	class compileTree: tree! !!MoveMethodRefactoring methodsFor: 'transforming'!compileNewMethods	moveToClasses 		do: [:each | each compileTree: parseTree classified: (class protocolsFor: selector)]! !!MoveMethodRefactoring methodsFor: 'transforming'!getArgumentNameForSelf	self needsToReplaceSelfReferences ifFalse: [^self].		[selfVariableName := self requestSelfArgumentName.	(self checkInstanceVariableName: selfVariableName in: class) 		ifTrue: 			[self verifyTemporaryVariableDoesNotOverride 				ifFalse: 					[self 						refactoringWarning: 'The variable is already defined in one of the classes you''re moving the method to.<n>Try another?' 								expandMacros.					selfVariableName := nil]]		ifFalse: 			[self 				refactoringWarning: 'The variable name is not a valid Smalltalk temporary variable name<n>Try again?' 						expandMacros.			selfVariableName := nil].	selfVariableName isNil] 			whileTrue: []! !!MoveMethodRefactoring methodsFor: 'private-accessing'!getClassForGlobalOrClassVariable	| definingClass type |	definingClass := class whoDefinesClassVariable: variable.	definingClass isNil 		ifTrue: 			[type := self model classNamed: variable.			type isNil ifTrue: [type := self model classNamed: #Object]]		ifFalse: [type := definingClass typeOfClassVariable: variable].	moveToClasses := self selectVariableTypesFrom: (Array with: type)				selected: (Array with: type).	moveToClasses isNil ifTrue: [self refactoringError: 'Method not moved']! !!MoveMethodRefactoring methodsFor: 'private-accessing'!getClassesForInstanceVariable	| definingClass typer types |	definingClass := class whoDefinesInstanceVariable: variable.	typer := RefactoryTyper newFor: self model.	typer runOn: definingClass.	types := typer typesFor: variable.	types isEmpty 		ifTrue: [types := OrderedCollection with: (self model classNamed: #Object)].	moveToClasses := self selectVariableTypesFrom: types				selected: (typer guessTypesFor: variable).	moveToClasses isNil ifTrue: [self refactoringError: 'Method not moved']! !!MoveMethodRefactoring methodsFor: 'private-accessing'!getClassesForTemporaryVariable	| types |	types := RefactoryTyper 				typesFor: variable				in: parseTree				model: self model.	types isEmpty 		ifTrue: [types := OrderedCollection with: (self model classNamed: #Object)].	moveToClasses := self selectVariableTypesFrom: types selected: types.	moveToClasses isNil ifTrue: [self refactoringError: 'Method not moved']! !!MoveMethodRefactoring methodsFor: 'private-accessing'!getClassesToMoveTo	self isMovingToArgument 		ifTrue: [self getClassesForTemporaryVariable]		ifFalse: 			[self isMovingToInstVar 				ifTrue: [self getClassesForInstanceVariable]				ifFalse: [self getClassForGlobalOrClassVariable]].	moveToClasses isEmpty 		ifTrue: [self refactoringError: 'No classes selected, method not moved.']! !!MoveMethodRefactoring methodsFor: 'preconditions' stamp: 'rr 3/16/2004 15:14'!getNewMethodName	"rr 3/16/2004 15:12 : changed the code	to really remove the variable which	the extracted selector is moved to,	as in the new location it is now the	self pseudo-argument.		The previous version was only removing	it from the arguments, which was causing	a bug."	| newSelector parameters alreadyDefined methodName newMethodName |	self removeArgument.	parameters := parseTree argumentNames asOrderedCollection.	"parameters remove: variable ifAbsent: []."	self needsToReplaceSelfReferences 		ifTrue: [parameters add: selfVariableName].	methodName := RBMethodName selector: (self uniqueMethodNameFor: parameters size) arguments: parameters.		[newMethodName := self requestMethodNameFor: methodName.	newMethodName isNil ifTrue: [self refactoringError: 'Did not move method'].	newMethodName isValid 		ifTrue: [newSelector := newMethodName selector]		ifFalse: [self refactoringWarning: 'Invalid method name'].	parameters := newMethodName arguments.	(self checkMethodName: newSelector in: class) 		ifFalse: 			[self refactoringWarning: newSelector , ' is not a valid selector name.'.			newSelector := nil].	alreadyDefined := moveToClasses 				detect: [:each | each hierarchyDefinesMethod: newSelector]				ifNone: [nil].	alreadyDefined notNil 		ifTrue: 			[self 				refactoringWarning: ('<1s> is already defined by <2p> or a super/subclass<n>Try another?' 						expandMacrosWith: newSelector						with: alreadyDefined).			newSelector := nil].	newSelector isNil] 			whileTrue: [].	parseTree		arguments: (parameters collect: [:each | RBVariableNode named: each]) 					asArray;		selector: newSelector! !!MoveMethodRefactoring methodsFor: 'transforming'!hasOnlySelfReturns	^hasOnlySelfReturns isNil 		ifTrue: 			[| searcher |			searcher := ParseTreeSearcher new.			searcher				matches: '^self' do: [:aNode :answer | answer];				matches: '^`@object' do: [:aNode :answer | false].			hasOnlySelfReturns := searcher executeTree: parseTree initialAnswer: true]		ifFalse: [hasOnlySelfReturns]! !!MoveMethodRefactoring methodsFor: 'testing'!hasSelfReferences	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: 'self' do: [:aNode :answer | true].	self hasOnlySelfReturns 		ifTrue: [searcher matches: '^self' do: [:aNode :answer | answer]].	^searcher executeTree: parseTree initialAnswer: false! !!MoveMethodRefactoring methodsFor: 'testing'!isMovingToArgument	^(parseTree arguments collect: [:each | each name]) includes: variable! !!MoveMethodRefactoring methodsFor: 'testing'!isMovingToInstVar	^self isMovingToArgument not 		and: [(class whoDefinesInstanceVariable: variable) notNil]! !!MoveMethodRefactoring methodsFor: 'testing'!needsToReplaceSelfReferences	^self hasSelfReferences 		or: [self abstractVariablesRefactoring hasVariablesToAbstract]! !!MoveMethodRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition withBlock: 					[self buildParseTree.					self checkForPrimitiveMethod.					self checkForSuperReferences.					self checkAssignmentsToVariable.					self getClassesToMoveTo.					self getArgumentNameForSelf.					self checkTemporaryVariableNames.					self getNewMethodName.					true])! !!MoveMethodRefactoring methodsFor: 'transforming' stamp: 'rr 3/16/2004 15:15'!removeArgument	"Removes the excess argument if any.	This argument is the variable which is	referenced by self in the classes the	method is moved to. "	| removeIndex |	removeIndex := parseTree argumentNames indexOf: variable.	removeIndex = 0 ifFalse: 		[parseTree arguments: ((parseTree arguments asOrderedCollection)  									removeAt: removeIndex; yourself) asArray.		parseTree selectorParts: ((parseTree selectorParts asOrderedCollection) 									removeAt: removeIndex; yourself) asArray].! !!MoveMethodRefactoring methodsFor: 'transforming' stamp: 'dvf 10/13/2001 23:19'!replaceSelfReferences	| replacer |	self needsToReplaceSelfReferences ifTrue: [		replacer := ParseTreeRewriter new.		replacer replace: 'self' with: selfVariableName.		self hasOnlySelfReturns ifTrue: 			[replacer replace: '^self' with: '^self'].		replacer executeTree: parseTree.		parseTree := replacer tree].! !!MoveMethodRefactoring methodsFor: 'transforming'!replaceVariableReferences	| replacer |	replacer := ParseTreeRewriter new.	replacer replace: variable with: 'self'.	replacer executeTree: parseTree.	parseTree := replacer tree! !!MoveMethodRefactoring methodsFor: 'initialize-release'!selector: aSymbol class: aClass variable: aVariableName 	selector := aSymbol.	class := self classObjectFor: aClass.	variable := aVariableName! !!MoveMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: selector;		nextPutAll: ' class: '.	class storeOn: aStream.	aStream		nextPutAll: ' variable: ''';		nextPutAll: variable;		nextPutAll: ''')'! !!MoveMethodRefactoring methodsFor: 'transforming'!transform	self		abstractVariables;		addSelfReturn;		replaceSelfReferences;		replaceVariableReferences;		compileNewMethods;		compileDelagatorMethod! !!MoveMethodRefactoring methodsFor: 'transforming'!verifyTemporaryVariableDoesNotOverride	(parseTree allDefinedVariables includes: selfVariableName) 		ifTrue: [^false].	moveToClasses 		do: [:each | (each definesVariable: selfVariableName) ifTrue: [^false]].	^true! !!MoveVariableDefinitionRefactoring class methodsFor: 'instance creation'!bindTight: anInterval in: aClass selector: aSelector 	^self new		class: aClass		selector: aSelector		interval: anInterval! !!MoveVariableDefinitionRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk bindTight: anInterval in: aClass selector: aSelector 	^(self new)		model: aRBSmalltalk;		class: aClass			selector: aSelector			interval: anInterval;		yourself! !!MoveVariableDefinitionRefactoring methodsFor: 'transforming'!checkNodes: sequenceNodes 	(sequenceNodes 		detect: [:each | RBReadBeforeWrittenTester isVariable: name readBeforeWrittenIn: each]		ifNone: [nil]) notNil 		ifTrue: [^false].	sequenceNodes do: 			[:each | 			(self usesDirectly: each body) 				ifTrue: [blockNodes add: each]				ifFalse: 					[(self checkNodes: (self subblocksIn: each body)) 						ifFalse: [blockNodes add: each]]].	^true! !!MoveVariableDefinitionRefactoring methodsFor: 'transforming'!checkParseTree	| node |	blockNodes := OrderedCollection new.	node := self whichVariableNode: parseTree				inInterval: interval				name: name.	node isNil		ifTrue: [self refactoringError: 'Unable to locate node in parse tree'].	definingNode := node whoDefines: name.	definingNode isNil		ifTrue: [self refactoringError: 'Cannot locate variable definition'].	definingNode isSequence		ifFalse: [self refactoringError: 'Variable is an argument'].	(self usesDirectly: definingNode)		ifTrue: [self refactoringError: 'Variable already bound tightly as possible'].	(self checkNodes: (self subblocksIn: definingNode))		ifFalse: [self refactoringError: 'Variable is possibly read before written']! !!MoveVariableDefinitionRefactoring methodsFor: 'initialize-release'!class: aClass selector: aSelector interval: anInterval 	interval := anInterval.	class := self classObjectFor: aClass.	selector := aSelector! !!MoveVariableDefinitionRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition withBlock: 					[| methodSource |					interval first <= interval last 						ifFalse: [self refactoringError: 'Invalid variable name'].					methodSource := class sourceCodeFor: selector.					methodSource size >= interval last 						ifFalse: [self refactoringError: 'Invalid range for variable'].					name := methodSource copyFrom: interval first to: interval last.					(self checkInstanceVariableName: name in: class) 						ifFalse: 							[self 								refactoringError: name , ' does not seem to be a valid variable name.'].					parseTree := class parseTreeFor: selector.					self checkParseTree.					true])! !!MoveVariableDefinitionRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' bindTight: '.	interval storeOn: aStream.	aStream nextPutAll: ' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: selector.	aStream nextPut: $)! !!MoveVariableDefinitionRefactoring methodsFor: 'transforming'!subblocksIn: aParseTree 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: '[:`@blockTemps | | `@temps | `@.Statements]'		do: 			[:aNode :answer | 			(aNode references: name)				ifTrue: [answer add: aNode].			answer].	^searcher executeTree: aParseTree initialAnswer: OrderedCollection new! !!MoveVariableDefinitionRefactoring methodsFor: 'transforming'!transform	definingNode removeTemporaryNamed: name.	blockNodes do: [:each | each body addTemporaryNamed: name].	class compileTree: parseTree! !!MoveVariableDefinitionRefactoring methodsFor: 'transforming'!usesDirectly: aParseTree 	| searcher |	searcher := ParseTreeSearcher new.	searcher		matches: '[:`@args | | `@temps | `@.Statements]'			do: [:aNode :answer | answer];		matches: name do: [:aNode :answer | true].	^searcher executeTree: aParseTree initialAnswer: false! !!PushDownMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk pushDown: selectorCollection from: aClass 	^(self new)		model: aRBSmalltalk;		pushDown: selectorCollection from: aClass;		yourself! !!PushDownMethodRefactoring class methodsFor: 'instance creation'!pushDown: selectorCollection from: aClass 	^self new pushDown: selectorCollection from: aClass! !!PushDownMethodRefactoring methodsFor: 'preconditions'!preconditions	| condition |	condition := selectors inject: RBCondition empty				into: 					[:cond :each | 					cond & (RBCondition definesSelector: each in: class) 						& (RBCondition subclassesOf: class referToSelector: each) not].	^condition & (RBCondition isAbstractClass: class)! !!PushDownMethodRefactoring methodsFor: 'transforming'!pushDown: aSelector 	| code protocols refactoring |	code := class sourceCodeFor: aSelector.	protocols := class protocolsFor: aSelector.	refactoring := ExpandReferencedPoolsRefactoring 				model: self model				forMethod: (class parseTreeFor: aSelector)				fromClass: class				toClasses: class subclasses.	self performComponentRefactoring: refactoring.	class subclasses do: 			[:each | 			(each directlyDefinesMethod: aSelector) 				ifFalse: [each compile: code classified: protocols]]! !!PushDownMethodRefactoring methodsFor: 'initialize-release'!pushDown: selectorCollection from: aClass 	class := self classObjectFor: aClass.	selectors := selectorCollection! !!PushDownMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' pushDown: '.	selectors asArray storeOn: aStream.	aStream nextPutAll: ' from: '.	class storeOn: aStream.	aStream nextPut: $)! !!PushDownMethodRefactoring methodsFor: 'transforming'!transform	selectors do: [:each | self pushDown: each].	selectors do: [:each | class removeMethod: each]! !!PushUpMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk pushUp: selectorCollection from: aClass 	^(self new)		model: aRBSmalltalk;		pushUp: selectorCollection from: aClass;		yourself! !!PushUpMethodRefactoring class methodsFor: 'instance creation'!pushUp: selectorCollection from: aClass 	^self new pushUp: selectorCollection from: aClass! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkBackReferencesTo: aSelector 	| definingClass pushUpParseTree |	definingClass := class superclass whoDefinesMethod: aSelector.	definingClass isNil ifTrue: [^self].	pushUpParseTree := class parseTreeFor: aSelector.	class superclass allSubclasses do: 			[:each | 			each selectors do: 					[:sel | 					| parseTree |					parseTree := each parseTreeFor: sel.					(parseTree notNil and: 							[(parseTree superMessages includes: aSelector) 								and: [definingClass == (each whoDefinesMethod: aSelector)]]) 						ifTrue: 							[removeDuplicates := true.							(aSelector == sel 								and: [parseTree equalTo: pushUpParseTree exceptForVariables: #()]) 									ifFalse: 										[self 											refactoringError: ('Cannot push up <1s> since it would override the method defined in <2p>' 													expandMacrosWith: aSelector													with: definingClass)]]]]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkClassVars	selectors do: [:each | self checkClassVarsFor: each]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkClassVarsFor: aSelector 	class nonMetaclass classVariableNames do: 			[:each | 			((class whichSelectorsReferToClassVariable: each) includes: aSelector) 				ifTrue: 					[self refactoringError: ('<1p> refers to <2s> which is defined in <3p>' 								expandMacrosWith: aSelector								with: each								with: class)]]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkInstVars	selectors do: [:each | self checkInstVarsFor: each]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkInstVarsFor: aSelector 	class instanceVariableNames do: 			[:each | 			((class whichSelectorsReferToInstanceVariable: each) includes: aSelector) ifTrue: 					[self						refactoringError: ('<1p> refers to <2s> which is defined in <3p>' expandMacrosWith: aSelector								with: each								with: class)]]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkSiblingSuperSendsFrom: aRBClass 	aRBClass selectors do: 			[:each | 			| tree |			tree := aRBClass parseTreeFor: each.			tree notNil 				ifTrue: 					[tree superMessages do: 							[:aSelector | 							(selectors includes: aSelector) 								ifTrue: 									[| definer |									definer := aRBClass superclass whoDefinesMethod: aSelector.									(definer notNil and: [class includesClass: definer]) 										ifTrue: 											[self 												refactoringError: ('Cannot push up <1s> since <2p>>><3s> sends a super message to it.' 														expandMacrosWith: aSelector														with: aRBClass														with: each)]]]]].	aRBClass allSubclasses do: [:each | self checkSiblingSuperSendsFrom: each]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkSuperMessages	self checkSuperSendsFromPushedUpMethods.	self checkSuperSendsFromSiblings! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkSuperSendsFromPushedUpMethods	selectors do: 			[:each | 			| parseTree |			parseTree := class parseTreeFor: each.			(parseTree superMessages 				detect: [:sup | class superclass directlyDefinesMethod: sup]				ifNone: [nil]) notNil 				ifTrue: 					[self 						refactoringError: ('Cannot push up <1s> since it sends a super message that is defined in the superclass.' 								expandMacrosWith: each)]]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkSuperSendsFromSiblings	| siblings |	siblings := class superclass subclasses reject: [:each | each = class].	siblings do: [:aRBClass | self checkSiblingSuperSendsFrom: aRBClass]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!checkSuperclass	| overrideSelectors |	overrideSelectors := selectors 				select: [:each | class superclass definesMethod: each].	overrideSelectors := overrideSelectors reject: 					[:each | 					| myTree superTree |					myTree := class parseTreeFor: each.					superTree := class superclass parseTreeFor: each.					superTree equalTo: myTree exceptForVariables: #()].	overrideSelectors isEmpty ifTrue: [^self].	class superclass isAbstract 		ifFalse: 			[self refactoringError: ('Non-abstract class <2p> already defines <1p>' 						expandMacrosWith: overrideSelectors asArray first						with: class superclass)].	overrideSelectors do: [:each | self checkBackReferencesTo: each]! !!PushUpMethodRefactoring methodsFor: 'private'!copyDownMethod: aSelector 	| oldProtocol oldSource superclassDefiner subclasses refactoring |	superclassDefiner := class superclass whoDefinesMethod: aSelector.	superclassDefiner isNil ifTrue: [^self].	oldSource := superclassDefiner sourceCodeFor: aSelector.	oldSource isNil 		ifTrue: 			[self 				refactoringError: ('Source code for <1s> superclass method not available' 						expandMacrosWith: aSelector)].	oldProtocol := superclassDefiner protocolsFor: aSelector.	subclasses := class superclass subclasses 				reject: [:each | each directlyDefinesMethod: aSelector].	subclasses isEmpty ifTrue: [^self].	((superclassDefiner parseTreeFor: aSelector) superMessages 		detect: [:each | superclassDefiner directlyDefinesMethod: each]		ifNone: [nil]) notNil 		ifTrue: 			[self 				refactoringError: ('Cannot push up <1s> since we must copy down the superclass method in <2p><n>to the other subclasses, and the superclass method sends a super message which is overriden.' 						expandMacrosWith: aSelector						with: superclassDefiner)].	self 		refactoringWarning: 'Do you want to copy down the superclass method to the classes that don''t define ' 				, aSelector.	refactoring := ExpandReferencedPoolsRefactoring 				model: self model				forMethod: (superclassDefiner parseTreeFor: aSelector)				fromClass: superclassDefiner				toClasses: subclasses.	self performComponentRefactoring: refactoring.	subclasses do: [:each | each compile: oldSource classified: oldProtocol]! !!PushUpMethodRefactoring methodsFor: 'transforming'!copyDownMethods	selectors do: [:each | self copyDownMethod: each]! !!PushUpMethodRefactoring methodsFor: 'preconditions'!preconditions	^(selectors inject: (RBCondition hasSuperclass: class)		into: [:cond :each | cond & (RBCondition definesSelector: each in: class)]) 			& (RBCondition withBlock: 						[self checkInstVars.						self checkClassVars.						self checkSuperclass.						self checkSuperMessages.						true])! !!PushUpMethodRefactoring methodsFor: 'transforming'!pushUp: aSelector 	| source refactoring |	source := class sourceCodeFor: aSelector.	source isNil 		ifTrue: [self refactoringError: 'Source for method not available'].	refactoring := ExpandReferencedPoolsRefactoring 				model: self model				forMethod: (class parseTreeFor: aSelector)				fromClass: class				toClasses: (Array with: class superclass).	self performComponentRefactoring: refactoring.	class superclass compile: source		classified: (class protocolsFor: aSelector)! !!PushUpMethodRefactoring methodsFor: 'initialize-release'!pushUp: selectorCollection from: aClass 	class := self classObjectFor: aClass.	selectors := selectorCollection.	removeDuplicates := false! !!PushUpMethodRefactoring methodsFor: 'transforming'!pushUpMethods	selectors do: [:each | self pushUp: each]! !!PushUpMethodRefactoring methodsFor: 'transforming'!removeDuplicateMethods	selectors do: [:each | self removeDuplicatesOf: each]! !!PushUpMethodRefactoring methodsFor: 'transforming'!removeDuplicatesOf: aSelector 	| tree |	tree := class superclass parseTreeFor: aSelector.	class superclass allSubclasses do: 			[:each | 			((each directlyDefinesMethod: aSelector) and: 					[(tree equalTo: (each parseTreeFor: aSelector) exceptForVariables: #()) 						and: [(each superclass whoDefinesMethod: aSelector) == class superclass]]) 				ifTrue: 					[removeDuplicates 						ifFalse: 							[removeDuplicates := true.							self 								refactoringWarning: 'Do you want to remove duplicate subclass methods?'].					each removeMethod: aSelector]]! !!PushUpMethodRefactoring methodsFor: 'transforming'!removePushedUpMethods	selectors do: [:each | class removeMethod: each]! !!PushUpMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' pushUp: '.	selectors asArray storeOn: aStream.	aStream nextPutAll: ' from: '.	class storeOn: aStream.	aStream nextPut: $)! !!PushUpMethodRefactoring methodsFor: 'transforming'!transform	self		copyDownMethods;		pushUpMethods;		removePushedUpMethods;		removeDuplicateMethods! !!RemoveMethodRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk removeMethods: selectorCollection from: aClass 	^(self new)		model: aRBSmalltalk;		removeMethods: selectorCollection from: aClass;		yourself! !!RemoveMethodRefactoring class methodsFor: 'instance creation'!removeMethods: selectorCollection from: aClass	^self new removeMethods: selectorCollection from: aClass! !!RemoveMethodRefactoring methodsFor: 'preconditions'!checkReferencesToAnyOf: aSelectorCollection 	aSelectorCollection do: 			[:each | 			self model allReferencesTo: each				do: 					[:aRBMethod | 					(aSelectorCollection includes: aRBMethod selector) 						ifFalse: 							[self 								refactoringError: ('Possible call to <2s> in <1p><n>Browse references?' 										expandMacrosWith: aRBMethod modelClass										with: each)								with: [self openBrowserOn: (BrowserEnvironment new referencesTo: each)]]]]! !!RemoveMethodRefactoring methodsFor: 'preconditions'!checkReferencesToSuperSendsToAnyOf: superMessages 	[superMessages isEmpty] whileFalse: 			[self 				refactoringWarning: ('Although <1s> is equivalent to a superclass method,<n>it contains a super send so it might modify behavior.' 						expandMacrosWith: superMessages first).			superMessages remove: superMessages first]! !!RemoveMethodRefactoring methodsFor: 'preconditions'!checkSuperMethods	| superMessages nonSupers |	nonSupers := OrderedCollection new.	superMessages := OrderedCollection new.	(selectors reject: [:each | self justSendsSuper: each]) do: 			[:each | 			(self superclassEquivalentlyDefines: each) 				ifTrue: 					[(class parseTreeFor: each) superMessages isEmpty 						ifFalse: [superMessages add: each]]				ifFalse: [nonSupers add: each]].	nonSupers isEmpty & superMessages isEmpty ifTrue: [^self].	self checkReferencesToAnyOf: nonSupers.	self checkReferencesToSuperSendsToAnyOf: superMessages! !!RemoveMethodRefactoring methodsFor: 'preconditions'!justSendsSuper: aSelector 	| matcher parseTree superclass |	matcher := ParseTreeSearcher justSendsSuper.	parseTree := class parseTreeFor: aSelector.	(matcher executeTree: parseTree initialAnswer: false) ifFalse: [^false].	parseTree lastIsReturn ifTrue: [^true].	superclass := class superclass whichClassIncludesSelector: aSelector.	superclass isNil ifTrue: [^true].	"Since there isn't a superclass that implements the message, we can 								 delete it since it would be an error anyway."	parseTree := superclass parseTreeFor: aSelector.	matcher := ParseTreeSearcher new.	matcher matches: '^``@object'		do: 			[:aNode :answer | 			answer				add: aNode value;				yourself].	matcher executeTree: parseTree initialAnswer: Set new.	^(matcher answer 		detect: [:each | (each isVariable and: [each name = 'self']) not]		ifNone: [nil]) isNil! !!RemoveMethodRefactoring methodsFor: 'preconditions'!preconditions	^(selectors inject: RBCondition empty		into: [:cond :each | cond & (RBCondition definesSelector: each in: class)]) 			& (RBCondition withBlock: 						[self checkSuperMethods.						true])! !!RemoveMethodRefactoring methodsFor: 'initialize-release'!removeMethods: selectorCollection from: aClass 	class := self classObjectFor: aClass.	selectors := selectorCollection! !!RemoveMethodRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' removeMethods: '.	selectors asArray storeOn: aStream.	aStream nextPutAll: ' from: '.	class storeOn: aStream.	aStream nextPut: $)! !!RemoveMethodRefactoring methodsFor: 'preconditions'!superclassEquivalentlyDefines: aSelector 	| superTree myTree |	class superclass isNil ifTrue: [^false].	superTree := class superclass parseTreeFor: aSelector.	myTree := class parseTreeFor: aSelector.	(superTree isNil or: [myTree isNil]) ifTrue: [^false].	^superTree equalTo: myTree exceptForVariables: #()! !!RemoveMethodRefactoring methodsFor: 'transforming'!transform	selectors do: [:each | class removeMethod: each]! !!RenameTemporaryRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk renameTemporaryFrom: anInterval to: newName in: aClass selector: aSelector 	^(self new)		model: aRBSmalltalk;		class: aClass			selector: aSelector			interval: anInterval			newName: newName;		yourself! !!RenameTemporaryRefactoring class methodsFor: 'instance creation'!renameTemporaryFrom: anInterval to: newName in: aClass selector: aSelector 	^self new		class: aClass		selector: aSelector		interval: anInterval		newName: newName! !!RenameTemporaryRefactoring methodsFor: 'initialize-release'!class: aClass selector: aSelector interval: anInterval newName: aString 	class := self classObjectFor: aClass.	selector := aSelector.	interval := anInterval.	newName := aString! !!RenameTemporaryRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition isValidInstanceVariableName: newName for: class) 			& (RBCondition definesInstanceVariable: newName in: class) not 			& (RBCondition definesClassVariable: newName in: class) not 			& (RBCondition withBlock: 						[| methodSource |						interval first > interval last 							ifTrue: [self refactoringError: 'Invalid variable name'].						methodSource := class sourceCodeFor: selector.						methodSource size >= interval last 							ifFalse: [self refactoringError: 'Invalid range for variable'].						oldName := methodSource copyFrom: interval first to: interval last.						true])! !!RenameTemporaryRefactoring methodsFor: 'tranforming'!renameNode: aParseTree 	(aParseTree whoDefines: newName) notNil 		ifTrue: [self refactoringError: newName , ' is already defined'].	(aParseTree allDefinedVariables includes: newName) 		ifTrue: [self refactoringError: newName , ' is already defined'].	(ParseTreeRewriter rename: oldName to: newName) executeTree: aParseTree! !!RenameTemporaryRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' renameTemporaryFrom: '.	interval storeOn: aStream.	aStream		nextPutAll: ' to: ''';		nextPutAll: newName;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: selector.	aStream nextPut: $)! !!RenameTemporaryRefactoring methodsFor: 'tranforming'!transform	| definingNode variableNode |	parseTree := class parseTreeFor: selector.	variableNode := self 				whichVariableNode: parseTree				inInterval: interval				name: oldName.	(variableNode isNil or: [variableNode isVariable not]) 		ifTrue: [self refactoringError: oldName , ' isn''t a valid variable'].	variableNode name = oldName 		ifFalse: [self refactoringError: 'Invalid selection'].	definingNode := variableNode whoDefines: oldName.	definingNode isNil 		ifTrue: [self refactoringError: oldName , ' isn''t defined by the method'].	self renameNode: definingNode.	class compileTree: parseTree! !!TemporaryToInstanceVariableRefactoring class methodsFor: 'instance creation'!class: aClass selector: aSelector variable: aVariableName 	^self new 		class: aClass		selector: aSelector		variable: aVariableName! !!TemporaryToInstanceVariableRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk class: aClass selector: aSelector variable: aVariableName 	^(self new)		model: aRBSmalltalk;		class: aClass			selector: aSelector			variable: aVariableName;		yourself! !!TemporaryToInstanceVariableRefactoring methodsFor: 'preconditions'!checkForValidTemporaryVariable	| parseTree |	parseTree := class parseTreeFor: selector.	(parseTree allTemporaryVariables includes: temporaryVariableName) 		ifFalse: 			[self refactoringError: temporaryVariableName 						, ' isn''t a valid temporary variable name'].	(parseTree allArgumentVariables includes: temporaryVariableName) 		ifTrue: 			[self refactoringError: temporaryVariableName , ' is a block parameter'].	(RBReadBeforeWrittenTester isVariable: temporaryVariableName		readBeforeWrittenIn: parseTree) 			ifTrue: 				[self 					refactoringWarning: ('<1s> is read before it is written.<n>Proceed anyway?' 							expandMacrosWith: temporaryVariableName)]! !!TemporaryToInstanceVariableRefactoring methodsFor: 'initialize-release'!class: aClass selector: aSelector variable: aVariableName 	class := self classObjectFor: aClass.	selector := aSelector.	temporaryVariableName := aVariableName! !!TemporaryToInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition definesSelector: selector in: class) 		& (RBCondition hierarchyOf: class				definesVariable: temporaryVariableName asString) not 			& (RBCondition withBlock: 						[self checkForValidTemporaryVariable.						true])! !!TemporaryToInstanceVariableRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' class: '.	class storeOn: aStream.	aStream		nextPutAll: ' selector: #';		nextPutAll: selector;		nextPutAll: ' variable: ''';		nextPutAll: temporaryVariableName;		nextPut: $'.	aStream nextPut: $)! !!TemporaryToInstanceVariableRefactoring methodsFor: 'transforming'!transform	| parseTree matcher protocols |	parseTree := class parseTreeFor: selector.	parseTree isNil ifTrue: [self refactoringError: 'Could not parse method'].	protocols := class protocolsFor: selector.	class removeMethod: selector.	class addInstanceVariable: temporaryVariableName.	(matcher := ParseTreeRewriter removeTemporaryNamed: temporaryVariableName) 		executeTree: parseTree.	class compileTree: matcher tree classified: protocols! !!Refactoring class methodsFor: '-- all --' stamp: 'nk 2/23/2005 14:34'!initializeRefactoringOptions	"self initializeRefactoringOptions"	RefactoringOptions := IdentityDictionary new.	RefactoringOptions		at: #implementorToInline		put: [:ref :imps | ChooserMorph				choose: 'Which implementation should be inlined?'				multipleSelect: false				fromList: imps				values: imps				cancel: []];				at: #methodName		put: [:ref :methodName | MethodNameEditor modalEditorForMethodName: methodName];				at: #selfArgumentName		put: [:ref | ref request: 'Enter name for argument to refer to "self" in extracted method'];				at: #selectVariableToMoveTo		put: [:ref :class :selector | 			| parseTree nameList ignoreList | 			parseTree := class parseTreeFor: selector.			parseTree isNil				ifTrue: [parseTree := RBMethodNode								selector: #value								body: (RBSequenceNode statements: #())].			nameList := OrderedCollection new.			nameList add: '---- Arguments ----';				 addAll: parseTree argumentNames asSortedCollection;				 add: '---- Instance Variables ----'.			ignoreList := OrderedCollection with: 1 with: nameList size.			nameList addAll: class allInstanceVariableNames asSortedCollection.			nameList at: (PopUpMenu labelArray: nameList lines: #()) startUp];				at: #variableTypes		put: [:ref :types :selected | ChooserMorph				choose: 'Choose types'				multipleSelect: true				fromList: types				values: types				cancel: []				initialSelections: selected];				at: #extractAssignment		put: [:ref :varName | ref				confirm: ('Do you want to extract the assignment of <1s><n>at the end of selection?' expandMacrosWith: varName)];				at: #inlineExpression		put: [:ref :string | ref				confirm: ('Do you want to inline "<1s>"? If not, it will be assigned as a temporary.' expandMacrosWith: string)];				at: #alreadyDefined		put: [:ref :cls :selector | ref				confirm: ('<1s> is already defined in the <2p> hierarchy.<n>Extracting it to an existing selector may change behavior.<n>Do you wish to use <1s> anyway?' expandMacrosWith: selector with: cls)];				at: #useExistingMethod		put: [:ref :selector | ref confirm: 'Use existing method ' , selector , ' instead of creating new method?'];				at: #openBrowser		put: [:ref :env | env openEditor]! !!Refactoring class methodsFor: 'accessing signal'!preconditionSignal	^RefactoringError , RefactoringWarning! !!Refactoring class methodsFor: 'accessing'!refactoringOptions	RefactoringOptions isNil ifTrue: [self initializeRefactoringOptions].	^RefactoringOptions! !!Refactoring class methodsFor: 'accessing'!setDefaultOption: aSymbol to: aBlock 	self refactoringOptions at: aSymbol put: aBlock! !!Refactoring methodsFor: 'utilities'!associationForClassVariable: aName in: aClass ifAbsent: aBlock 	^aClass realClass classPool associationAt: aName asSymbol		ifAbsent: [aClass realClass classPool associationAt: aName asString ifAbsent: aBlock]! !!Refactoring methodsFor: 'testing'!canReferenceVariable: aString in: aClass 	(aClass definesVariable: aString) ifTrue: [^true].	(self model includesGlobal: aString asSymbol) ifTrue: [^true].	^(self poolVariableNamesFor: aClass) includes: aString! !!Refactoring methodsFor: 'accessing'!changes	^self model changes! !!Refactoring methodsFor: 'support'!checkClass: aRBClass selector: aSelector using: aMatcher 	| parseTree |	parseTree := aRBClass parseTreeFor: aSelector.	parseTree notNil ifTrue: [aMatcher executeTree: parseTree].	^aMatcher answer! !!Refactoring methodsFor: 'utilities'!checkInstanceVariableName: aName in: aClass 	^RBCondition checkInstanceVariableName: aName in: aClass! !!Refactoring methodsFor: 'utilities'!checkMethodName: aName in: aClass 	^RBCondition checkMethodName: aName in: aClass! !!Refactoring methodsFor: 'preconditions'!checkPreconditions	| conditions block |	conditions := self preconditions.	conditions check 		ifFalse: 			[block := conditions errorBlock.			block notNil 				ifTrue: [self refactoringError: conditions errorString with: block]				ifFalse: [self refactoringError: conditions errorString]]! !!Refactoring methodsFor: 'private'!classObjectFor: anObject 	anObject isBehavior ifTrue: [^self model classFor: anObject].	anObject isSymbol ifTrue: [^self model classNamed: anObject].	^anObject! !!Refactoring methodsFor: 'support'!convertAllReferencesTo: aSymbol using: searchReplacer 	self model allReferencesTo: aSymbol		do: 			[:method | 			self 				convertMethod: method selector				for: method modelClass				using: searchReplacer]! !!Refactoring methodsFor: 'support'!convertAllReferencesToClass: aRBClass using: searchReplacer 	self model allReferencesToClass: aRBClass		do: 			[:method | 			self 				convertMethod: method selector				for: method modelClass				using: searchReplacer]! !!Refactoring methodsFor: 'support'!convertClasses: classSet select: aBlock using: searchReplacer 	classSet do: 			[:aClass | 			(aBlock value: aClass) do: 					[:selector | 					self 						convertMethod: selector						for: aClass						using: searchReplacer]]! !!Refactoring methodsFor: 'support'!convertMethod: selector for: aClass using: searchReplacer 	"Convert the parse tree for selector using the searchReplacer. If a	change is made then compile it into the changeBuilder."	| parseTree |	parseTree := aClass parseTreeFor: selector.	parseTree isNil ifTrue: [^self].	(searchReplacer executeTree: parseTree) 		ifTrue: [aClass compileTree: searchReplacer tree]! !!Refactoring methodsFor: 'accessing'!copyOptionsFrom: aDictionary 	| dict |	dict := self options.	dict == self class refactoringOptions 		ifTrue: [^self options: aDictionary copy].	dict keysAndValuesDo: 			[:key :value | 			value == (self class refactoringOptions at: key) 				ifTrue: [dict at: key put: (aDictionary at: key)]].	self options: dict! !!Refactoring methodsFor: 'transforming'!defaultEnvironment	^BrowserEnvironment new! !!Refactoring methodsFor: 'transforming'!execute	self primitiveExecute.	RefactoringManager instance addRefactoring: self! !!Refactoring methodsFor: 'initialize-release'!initialize! !!Refactoring methodsFor: 'transforming'!model	^model isNil 		ifTrue: 			[model := (RBNamespace onEnvironment: self defaultEnvironment)						name: self printString;						yourself]		ifFalse: [model]! !!Refactoring methodsFor: 'initialize-release'!model: aRBNamespace 	model := aRBNamespace! !!Refactoring methodsFor: 'private'!onError: aBlock do: errorBlock 	^aBlock on: self class preconditionSignal		do: 			[:ex | 			errorBlock value.			ex return: nil]! !!Refactoring methodsFor: 'requests'!openBrowserOn: anEnvironment 	^(self options at: #openBrowser) value: self value: anEnvironment! !!Refactoring methodsFor: 'accessing'!options	^options isNil ifTrue: [self class refactoringOptions] ifFalse: [options]! !!Refactoring methodsFor: 'accessing'!options: aDictionary 	options := aDictionary! !!Refactoring methodsFor: 'transforming'!performComponentRefactoring: aRefactoring 	aRefactoring copyOptionsFrom: self options.	aRefactoring primitiveExecute! !!Refactoring methodsFor: 'utilities'!poolVariableNamesFor: aClass 	| pools |	pools := Set new.	aClass withAllSuperclasses do: 			[:each | 			each allPoolDictionaryNames do: 					[:pool | 					pools addAll: ((Smalltalk at: pool asSymbol) keys 								collect: [:name | name asString])]].	^pools! !!Refactoring methodsFor: 'preconditions'!preconditions	self subclassResponsibility! !!Refactoring methodsFor: 'private'!primitiveExecute	self checkPreconditions.	self transform! !!Refactoring methodsFor: 'private' stamp: 'md 8/2/2005 23:35'!refactoringError: aString 	RefactoringError signal: aString! !!Refactoring methodsFor: 'private'!refactoringError: aString with: aBlock 	RefactoringError raiseSignal: aString with: aBlock! !!Refactoring methodsFor: 'private' stamp: 'md 8/2/2005 23:35'!refactoringWarning: aString 	RefactoringWarning signal: aString! !!Refactoring methodsFor: 'requests' stamp: 'rr 3/26/2004 10:16'!request: aString	^FillInTheBlank request: aString! !!Refactoring methodsFor: 'requests'!requestImplementorToInline: implementorsCollection 	^(self options at: #implementorToInline) value: self		value: implementorsCollection! !!Refactoring methodsFor: 'requests' stamp: 'dvf 9/8/2001 19:32'!requestMethodNameFor: aMethodName 	^(self options at: #methodName) value: self value: aMethodName! !!Refactoring methodsFor: 'requests'!requestSelfArgumentName	^(self options at: #selfArgumentName) value: self! !!Refactoring methodsFor: 'utilities'!safeMethodNameFor: aClass basedOn: aString 	"Creates an unused method name containing aString"	| baseString newString hasParam i |	baseString := aString copy.	baseString at: 1 put: baseString first asLowercase.	newString := baseString.	hasParam := newString last = $:.	hasParam 		ifTrue: [baseString := newString copyFrom: 1 to: newString size - 1].	i := 0.	[aClass hierarchyDefinesMethod: newString asSymbol] whileTrue: 			[i := i + 1.			newString := baseString , i printString 						, (hasParam ifTrue: [':'] ifFalse: [''])].	^newString asSymbol! !!Refactoring methodsFor: 'requests'!selectVariableToMoveMethodTo: aSelector class: aClass 	^(self options at: #selectVariableToMoveTo) 		value: self		value: aClass		value: aSelector! !!Refactoring methodsFor: 'requests' stamp: 'rr 3/15/2004 11:48'!selectVariableTypesFrom: initialTypeCollection selected: selectedTypeCollection 	"Temporary workaround to get something usable here,	which will avoid entering the emergency evaluator too..."		"^(self options at: #variableTypes) 		value: self		value: initialTypeCollection		value: selectedTypeCollection"	| init classes |	init := ''.	initialTypeCollection do: [:each | init := init, each asString, Character space asString].	classes := FillInTheBlank request: 'Here are the types found by the RefactoryTyper.	Since you are smarter than it, you can edit the list to add or remove 	relevant classes at your will' initialAnswer: init.	^ (classes findTokens: Character space asString) collect: 		[:each | self model classFor: (Smalltalk at: each withBlanksTrimmed asSymbol)].	! !!Refactoring methodsFor: 'accessing'!setOption: aSymbol toUse: aBlock 	| dict |	dict := self options.	dict == self class refactoringOptions ifTrue: [dict := dict copy].	dict at: aSymbol put: aBlock.	self options: dict! !!Refactoring methodsFor: 'requests'!shouldExtractAssignmentTo: aString 	^(self options at: #extractAssignment) value: self value: aString! !!Refactoring methodsFor: 'requests'!shouldInlineExpression: aString 	^(self options at: #inlineExpression) value: self value: aString! !!Refactoring methodsFor: 'requests'!shouldOverride: aSelector in: aClass 	^(self options at: #alreadyDefined) 		value: self		value: aClass		value: aSelector! !!Refactoring methodsFor: 'requests'!shouldUseExistingMethod: aSelector 	^(self options at: #useExistingMethod) value: self value: aSelector! !!Refactoring methodsFor: 'transforming'!transform	self subclassResponsibility! !!Refactoring methodsFor: 'private'!uniqueMethodNameFor: anInteger 	| before after index name |	before := 'a'.	after := ''.	anInteger timesRepeat: [after := after , 'z:'].	index := 0.		[name := before , index printString , after.	(Symbol findInterned: name) notNil] 			whileTrue: [index := index + 1].	^name asSymbol! !!Refactoring methodsFor: 'utilities'!whichVariableNode: aParseTree inInterval: anInterval name: aName 	| matcher block |	matcher := ParseTreeSearcher new.	block := 			[:aNode :answer | 			(aNode intersectsInterval: anInterval) ifTrue: [aNode] ifFalse: [answer]].	matcher		matches: aName do: block;		matchesArgument: aName do: block.	^matcher executeTree: aParseTree initialAnswer: nil! !!RemoveClassRefactoring class methodsFor: 'instance creation'!classNames: aClassNameCollection 	^self new classNames: aClassNameCollection! !!RemoveClassRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk classNames: aClassNameCollection 	^(self new)		model: aRBSmalltalk;		classNames: aClassNameCollection;		yourself! !!RemoveClassRefactoring methodsFor: 'initialize-release'!classNames: aClassNameCollection 	classNames := aClassNameCollection! !!RemoveClassRefactoring methodsFor: 'preconditions'!hasReferencesTo: aSymbol 	| literal |	literal := Smalltalk associationAt: aSymbol.	BrowserEnvironment new classesDo: 			[:each | 			(classNames 				includes: (each isMeta ifTrue: [each soleInstance] ifFalse: [each]) name) 					ifFalse: 						[(each whichSelectorsReferTo: literal) isEmpty ifFalse: [^true].						(each whichSelectorsReferTo: aSymbol) isEmpty ifFalse: [^true]]].	^false! !!RemoveClassRefactoring methodsFor: 'preconditions'!preconditions	^classNames inject: RBCondition empty		into: 			[:sum :each | 			| aClass |			aClass := self model classNamed: each asSymbol.			aClass isNil ifTrue: [self refactoringError: 'No such class'].			sum 				& (((RBCondition isMetaclass: aClass) 						errorMacro: 'Cannot remove just the metaclass') not 						& ((RBCondition withBlock: [(self hasReferencesTo: each asSymbol) not])								errorMacro: each , ' is referenced.<n>Browse references?';								errorBlock: 										[self openBrowserOn: (BrowserEnvironment new 													referencesTo: (Smalltalk associationAt: each ifAbsent: [each]))];								yourself) 							& ((RBCondition hasSubclasses: aClass) not 									| ((RBCondition isEmptyClass: aClass) 											& ((RBCondition withBlock: [aClass superclass notNil])													errorMacro: 'Cannot remove top level class<n>when it has subclasses';													yourself))))]! !!RemoveClassRefactoring methodsFor: 'transforming'!removeClasses	classNames do: [:each | self model removeClassNamed: each]! !!RemoveClassRefactoring methodsFor: 'transforming'!reparentSubclasses	classNames do: 			[:each | 			| class |			class := self model classNamed: each.			self model reparentClasses: class subclasses copy to: class superclass]! !!RemoveClassRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' classNames: '.	classNames asArray storeOn: aStream.	aStream nextPut: $)! !!RemoveClassRefactoring methodsFor: 'transforming'!transform	self		reparentSubclasses;		removeClasses! !!SplitClassRefactoring class methodsFor: 'instance creation'!class: class instanceVariables: instVars newClassName: className referenceVariableName: newVariable 	^(self new)		class: class			instanceVariables: instVars			newClassName: className			referenceVariableName: newVariable;		yourself! !!SplitClassRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk class: class instanceVariables: instVars newClassName: className referenceVariableName: newVariable 	^(self new)		model: aRBSmalltalk;		class: class			instanceVariables: instVars			newClassName: className			referenceVariableName: newVariable;		yourself! !!SplitClassRefactoring methodsFor: 'private-transforming'!abstractReferenceTo: each 	| setterMethod replacer accessorRef getterMethod |	accessorRef := CreateAccessorsForVariableRefactoring 				variable: each				class: newClass				classVariable: false.	self performComponentRefactoring: accessorRef.	getterMethod := accessorRef getterMethod.	setterMethod := accessorRef setterMethod.	replacer := ParseTreeRewriter 				variable: each				getter: getterMethod				setter: setterMethod				receiver: referenceVariableName.	self 		convertClasses: class withAllSubclasses		select: [:aClass | aClass whichSelectorsReferToInstanceVariable: each]		using: replacer.	self performComponentRefactoring: (RemoveInstanceVariableRefactoring 				remove: each				from: class)! !!SplitClassRefactoring methodsFor: 'transforming'!abstractVariableReferences	instanceVariables do: [:each | self abstractReferenceTo: each]! !!SplitClassRefactoring methodsFor: 'private-transforming'!addClass	self performComponentRefactoring: (AddClassRefactoring 				model: self model				addClass: newClassName				superclass: Object				subclasses: #()				category: class category).	newClass := self model classNamed: newClassName! !!SplitClassRefactoring methodsFor: 'private-transforming'!addInstanceVariables	instanceVariables do: 			[:each | 			self performComponentRefactoring: (AddInstanceVariableRefactoring 						model: self model						variable: each						class: newClass)]! !!SplitClassRefactoring methodsFor: 'initialize-release'!class: aClass instanceVariables: instVars newClassName: className referenceVariableName: newVariable 	class := self model classFor: aClass.	instanceVariables := instVars.	newClassName := className.	referenceVariableName := newVariable! !!SplitClassRefactoring methodsFor: 'transforming'!createNewClass	self		addClass;		addInstanceVariables! !!SplitClassRefactoring methodsFor: 'transforming'!createReference	self performComponentRefactoring: (AddInstanceVariableRefactoring 				variable: referenceVariableName				class: class)! !!SplitClassRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isValidClassName: newClassName) 		& (RBCondition isGlobal: newClassName in: self model) not 			& (RBCondition isValidInstanceVariableName: referenceVariableName for: class) 			& (RBCondition hierarchyOf: class definesVariable: referenceVariableName) 					not 			& (RBCondition isGlobal: referenceVariableName in: self model) not 			& (RBCondition definesTemporaryVariable: referenceVariableName in: class) 					not! !!SplitClassRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' class: '.	class storeOn: aStream.	aStream nextPutAll: ' instanceVariables: '.	instanceVariables asArray storeOn: aStream.	aStream		nextPutAll: ' newClassName: #';		nextPutAll: newClassName;		nextPutAll: ' referenceVariableName: ''';		nextPutAll: referenceVariableName;		nextPutAll: ''')'! !!SplitClassRefactoring methodsFor: 'transforming'!transform	self		createNewClass;		createReference;		abstractVariableReferences! !!AbstractClassVariableRefactoring methodsFor: 'transforming'!abstractClassReferences	| replacer |	replacer := ParseTreeRewriter 				variable: variableName				getter: self accessorsRefactoring getterMethod				setter: self accessorsRefactoring setterMethod.	self 		convertClasses: class metaclass withAllSubclasses		select: 			[:aClass | 			(aClass whichSelectorsReferToClassVariable: variableName) reject: 					[:each | 					aClass == class metaclass and: 							[each == self accessorsRefactoring getterMethod 								or: [each == self accessorsRefactoring setterMethod]]]]		using: replacer! !!AbstractClassVariableRefactoring methodsFor: 'transforming'!abstractInstanceReferences	| replacer |	replacer := ParseTreeRewriter 				classVariable: variableName				getter: self accessorsRefactoring getterMethod				setter: self accessorsRefactoring setterMethod.	self 		convertClasses: class withAllSubclasses		select: [:aClass | aClass whichSelectorsReferToClassVariable: variableName]		using: replacer! !!AbstractClassVariableRefactoring methodsFor: 'private-accessing'!accessorsRefactoring	^accessorsRefactoring isNil 		ifTrue: 			[accessorsRefactoring := CreateAccessorsForVariableRefactoring 						model: self model						variable: variableName asString						class: class						classVariable: true]		ifFalse: [accessorsRefactoring]! !!AbstractClassVariableRefactoring methodsFor: 'transforming'!createAccessors	self performComponentRefactoring: self accessorsRefactoring! !!AbstractClassVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isMetaclass: class) not 		& (RBCondition directlyDefinesClassVariable: variableName asSymbol in: class) 			& ((RBCondition withBlock: 						[(#(#Object #Behavior #ClassDescription #Class) includes: class name) not]) 					errorMacro: 'This refactoring does not work for Object, Behavior, ClassDescription, or Class')! !!AbstractClassVariableRefactoring methodsFor: 'transforming'!transform	self createAccessors.	self abstractInstanceReferences.	self abstractClassReferences! !!AbstractInstanceVariableRefactoring methodsFor: 'transforming'!abstractReferences	| replacer |	replacer := ParseTreeRewriter 				variable: variableName				getter: self accessorsRefactoring getterMethod				setter: self accessorsRefactoring setterMethod.	self 		convertClasses: class withAllSubclasses		select: 			[:aClass | 			(aClass whichSelectorsReferToInstanceVariable: variableName) reject: 					[:each | 					aClass == class and: 							[each == self accessorsRefactoring getterMethod 								or: [each == self accessorsRefactoring setterMethod]]]]		using: replacer! !!AbstractInstanceVariableRefactoring methodsFor: 'private-accessing'!accessorsRefactoring	^accessorsRefactoring isNil 		ifTrue: 			[accessorsRefactoring := CreateAccessorsForVariableRefactoring 						model: self model						variable: variableName						class: class						classVariable: false]		ifFalse: [accessorsRefactoring]! !!AbstractInstanceVariableRefactoring methodsFor: 'transforming'!createAccessors	self performComponentRefactoring: self accessorsRefactoring! !!AbstractInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition directlyDefinesInstanceVariable: variableName in: class! !!AbstractInstanceVariableRefactoring methodsFor: 'transforming'!transform	self createAccessors.	self abstractReferences! !!AddClassVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isMetaclass: class) not 		& (RBCondition isValidClassVarName: variableName for: class) 			& (RBCondition hierarchyOf: class definesVariable: variableName asString) 					not 			& (RBCondition isGlobal: variableName in: self model) not! !!AddClassVariableRefactoring methodsFor: 'transforming'!transform	class addClassVariable: variableName! !!AddInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isValidInstanceVariableName: variableName for: class) 		& (RBCondition hierarchyOf: class definesVariable: variableName) not 			& (RBCondition isGlobal: variableName in: self model) not! !!AddInstanceVariableRefactoring methodsFor: 'transforming'!transform	class addInstanceVariable: variableName! !!CreateAccessorsForVariableRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk variable: aVarName class: aClass classVariable: aBoolean 	^(self 		model: aRBSmalltalk		variable: aVarName		class: aClass)		classVariable: aBoolean;		yourself! !!CreateAccessorsForVariableRefactoring class methodsFor: 'instance creation'!variable: aVarName class: aClass classVariable: aBoolean 	^(self variable: aVarName class: aClass)		classVariable: aBoolean; yourself! !!CreateAccessorsForVariableRefactoring methodsFor: 'initialize-release'!classVariable: aBoolean 	classVariable := aBoolean! !!CreateAccessorsForVariableRefactoring methodsFor: 'transforming'!createGetterAccessor	getterMethod := self findGetterMethod.	getterMethod isNil ifTrue: [getterMethod := self defineGetterMethod]! !!CreateAccessorsForVariableRefactoring methodsFor: 'transforming'!createSetterAccessor	setterMethod := self findSetterMethod.	setterMethod isNil ifTrue: [setterMethod := self defineSetterMethod]! !!CreateAccessorsForVariableRefactoring methodsFor: 'transforming'!defineGetterMethod	| selector definingClass |	definingClass := self definingClass.	selector := self safeMethodNameFor: definingClass				basedOn: variableName asString.	definingClass 		compile: ('<1s><n><t>^<2s>' expandMacrosWith: selector with: variableName)		classified: #(#accessing).	^selector! !!CreateAccessorsForVariableRefactoring methodsFor: 'transforming'!defineSetterMethod	| selector definingClass string |	definingClass := self definingClass.	string := self needsReturnForSetter 				ifTrue: ['<1s> anObject<n><t>^<2s> := anObject']				ifFalse: ['<1s> anObject<n><t><2s> := anObject'].	selector := self safeMethodNameFor: definingClass				basedOn: variableName asString , ':'.	definingClass 		compile: (string expandMacrosWith: selector with: variableName)		classified: #accessing.	^selector! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!definingClass	^classVariable ifTrue: [class metaclass] ifFalse: [class]! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!findGetterMethod	| definingClass matcher |	definingClass := self definingClass.	matcher := ParseTreeSearcher getterMethod: variableName.	^self possibleGetterSelectors detect: 			[:each | 			(self 				checkClass: definingClass				selector: each				using: matcher) notNil 				and: [(definingClass subclassRedefines: each) not]]		ifNone: [nil]! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!findSetterMethod	| definingClass matcher |	definingClass := self definingClass.	matcher := self needsReturnForSetter 				ifTrue: [ParseTreeSearcher returnSetterMethod: variableName]				ifFalse: [ParseTreeSearcher setterMethod: variableName].	^self possibleSetterSelectors detect: 			[:each | 			(self 				checkClass: definingClass				selector: each				using: matcher) notNil 				and: [(definingClass subclassRedefines: each) not]]		ifNone: [nil]! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!getterMethod	^getterMethod! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!methodsReferencingVariable	^classVariable 		ifTrue: [self definingClass whichSelectorsReferToClassVariable: variableName]		ifFalse: 			[self definingClass whichSelectorsReferToInstanceVariable: variableName]! !!CreateAccessorsForVariableRefactoring methodsFor: 'testing'!needsReturnForSetter	needsReturn isNil 		ifTrue: 			[needsReturn := self 						usesAssignmentOf: variableName						in: class						classVariable: classVariable].	^needsReturn! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!possibleGetterSelectors	^self methodsReferencingVariable select: [:each | each numArgs == 0]! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!possibleSetterSelectors	^self methodsReferencingVariable select: [:each | each numArgs == 1]! !!CreateAccessorsForVariableRefactoring methodsFor: 'preconditions'!preconditions	^classVariable 		ifTrue: [RBCondition definesClassVariable: variableName asSymbol in: class]		ifFalse: [RBCondition definesInstanceVariable: variableName in: class]! !!CreateAccessorsForVariableRefactoring methodsFor: 'private-accessing'!setterMethod	^setterMethod! !!CreateAccessorsForVariableRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' variable: '.	variableName storeOn: aStream.	aStream nextPutAll: ' class: '.	class storeOn: aStream.	aStream nextPutAll: ' classVariable: '.	classVariable storeOn: aStream.	aStream nextPut: $)! !!CreateAccessorsForVariableRefactoring methodsFor: 'transforming'!transform	self		createGetterAccessor;		createSetterAccessor! !!CreateAccessorsForVariableRefactoring methodsFor: 'testing'!usesAssignmentOf: aString in: aClass classVariable: isClassVar 	| matcher definingClass |	matcher := ParseTreeSearcher new.	matcher		answer: false;		matches: aString , ' := ``@object'			do: [:aNode :answer | answer or: [aNode isUsed]].	definingClass := isClassVar ifTrue: [aClass nonMetaclass] ifFalse: [aClass].	^(definingClass withAllSubclasses , (isClassVar 				ifTrue: [definingClass metaclass withAllSubclasses]				ifFalse: [#()]) 		detect: 			[:each | 			((isClassVar 				ifTrue: [each whichSelectorsReferToClassVariable: aString]				ifFalse: [each whichSelectorsReferToInstanceVariable: aString]) detect: 						[:sel | 						self 							checkClass: each							selector: sel							using: matcher]					ifNone: [nil]) notNil]		ifNone: [nil]) notNil! !!ProtectInstanceVariableRefactoring methodsFor: 'private-accessing'!getterSetterMethods	| matcher |	matcher := ParseTreeSearcher new.	matcher		answer: Set new;		matchesAnyMethodOf: (Array 					with: '`method ^' , variableName					with: ('`method: `arg <1s> := `arg' expandMacrosWith: variableName)					with: ('`method: `arg ^<1s> := `arg' expandMacrosWith: variableName))			do: 				[:aNode :answer | 				(class subclassRedefines: aNode selector) 					ifFalse: [answer add: aNode selector].				answer].	(class whichSelectorsReferToInstanceVariable: variableName) do: 			[:each | 			self 				checkClass: class				selector: each				using: matcher].	^matcher answer! !!ProtectInstanceVariableRefactoring methodsFor: 'transforming'!inline: aSelector 	self onError: 			[self performComponentRefactoring: (InlineAllSendersRefactoring 						model: self model						sendersOf: aSelector						in: class)]		do: []! !!ProtectInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition definesInstanceVariable: variableName in: class! !!ProtectInstanceVariableRefactoring methodsFor: 'transforming'!transform	self setOption: #inlineExpression toUse: [:ref :string | true].	self getterSetterMethods do: [:each | self inline: each]! !!PullUpClassVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isMetaclass: class) not! !!PullUpClassVariableRefactoring methodsFor: 'private-accessing'!subclassDefiningVariable	| subclasses |	subclasses := class allSubclasses 				select: [:each | each directlyDefinesClassVariable: variableName].	subclasses isEmpty 		ifTrue: 			[self refactoringError: 'Could not find a class defining ' , variableName].	subclasses size > 1 		ifTrue: [self refactoringError: 'Multiple subclasses define ' , variableName].	^subclasses asArray first! !!PullUpClassVariableRefactoring methodsFor: 'transforming'!transform	| subclass |	subclass := self subclassDefiningVariable.	subclass removeClassVariable: variableName.	class addClassVariable: variableName! !!PullUpInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	^RBCondition withBlock: 			[(class hierarchyDefinesInstanceVariable: variableName) 				ifFalse: [self refactoringError: 'No subclass defines ' , variableName].			(class subclasses 				detect: [:each | (each directlyDefinesInstanceVariable: variableName) not]				ifNone: [nil]) notNil 				ifTrue: 					[self 						refactoringWarning: 'Not all subclasses have an instance variable named ' 								, variableName , '.'].			true]! !!PullUpInstanceVariableRefactoring methodsFor: 'transforming'!transform	class allSubclasses do: 			[:each | 			(each directlyDefinesInstanceVariable: variableName) 				ifTrue: [each removeInstanceVariable: variableName]].	class addInstanceVariable: variableName! !!PushDownClassVariableRefactoring methodsFor: 'preconditions' stamp: 'rr 3/11/2004 22:03'!findDestinationClass	| classVarName classes classVar cond |	classVarName := variableName asSymbol.	classVar := class realClass classPool associationAt: classVarName.	cond := [:eachClass | ((eachClass allCallsOn: classVar) 							select: [:eachRef | eachRef actualClass = eachClass])  isEmpty].	classes := class withAllSubclasses reject: [:each | (cond value: each realClass) 												and: [cond value: each realClass class]].	destinationClass := classes isEmpty ifTrue: [nil] ifFalse: [classes asOrderedCollection  first].	classes do: 			[:each | 			(destinationClass includesClass: each) 				ifTrue: [destinationClass := each]				ifFalse: 					[(each includesClass: destinationClass) 						ifFalse: [self signalMultipleReferenceError]]].	destinationClass = class ifTrue: [self signalStillReferencedError].	^destinationClass! !!PushDownClassVariableRefactoring methodsFor: 'preconditions'!preconditions	"Preconditions are that only one subclass refers to the class variable."	^(RBCondition definesClassVariable: variableName in: class) 		& (RBCondition withBlock: 					[self findDestinationClass.					true])! !!PushDownClassVariableRefactoring methodsFor: 'preconditions'!signalMultipleReferenceError	self signalReferenceError: ('Multiple subclasses reference <1s>' 				expandMacrosWith: variableName)! !!PushDownClassVariableRefactoring methodsFor: 'preconditions'!signalReferenceError: errorString 	class realClass isNil 		ifTrue: [self refactoringError: errorString]		ifFalse: 			[| classVarName error |			error := '<1s><n>Browse references?' expandMacrosWith: errorString.			classVarName := variableName asSymbol.			self refactoringError: error				with: 					[self 						openBrowserOn: (VariableEnvironment referencesToClassVariable: classVarName								in: class realClass)]]! !!PushDownClassVariableRefactoring methodsFor: 'preconditions'!signalStillReferencedError	self signalReferenceError: ('<1p> has references to <2s>' 				expandMacrosWith: class				with: variableName)! !!PushDownClassVariableRefactoring methodsFor: 'transforming'!transform	class removeClassVariable: variableName.	destinationClass isNil ifTrue: [^self].	destinationClass addClassVariable: variableName! !!PushDownInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	| references |	references := RBCondition referencesInstanceVariable: variableName				in: class.	class realClass isNil 		ifTrue: 			[references 				errorMacro: ('<1s> is referenced.' expandMacrosWith: variableName)]		ifFalse: 			[references				errorMacro: ('<1s> is referenced.<n>Browse references?' 							expandMacrosWith: variableName);				errorBlock: 						[self openBrowserOn: (BrowserEnvironment new instVarRefsTo: variableName									in: class realClass)]].	^(RBCondition definesInstanceVariable: variableName in: class) 		& references not! !!PushDownInstanceVariableRefactoring methodsFor: 'transforming'!transform	class removeInstanceVariable: variableName.	class subclasses do: 			[:each | 			(each withAllSubclasses detect: 					[:aClass | 					(aClass whichSelectorsReferToInstanceVariable: variableName) isEmpty not]				ifNone: [nil]) notNil 				ifTrue: [each addInstanceVariable: variableName]]! !!RemoveClassVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isMetaclass: class) not 		& (RBCondition definesClassVariable: variableName in: class) 			& (RBCondition withBlock: 						[| block |						block := 								[:each | 								(each whichSelectorsReferToClassVariable: variableName) isEmpty 									ifFalse: 										[class realClass isNil 											ifTrue: 												[self 													refactoringError: ('<1s> is referenced.' expandMacrosWith: variableName)]											ifFalse: 												[self refactoringError: ('<1s> is referenced.<n>Browse references?' 															expandMacrosWith: variableName)													with: 														[self 															openBrowserOn: (VariableEnvironment referencesToClassVariable: variableName																	in: class realClass)]]]].						class withAllSubclasses do: block.						class metaclass withAllSubclasses do: block.						true])! !!RemoveClassVariableRefactoring methodsFor: 'transforming'!transform	class removeClassVariable: variableName! !!RemoveInstanceVariableRefactoring class methodsFor: 'as yet unclassified' stamp: 'rr 3/11/2004 11:06'!remove: variable from: class	^ self variable: variable class:  class! !!RemoveInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	| references |	references := RBCondition hierarchyOf: class				referencesInstanceVariable: variableName.	class realClass isNil 		ifTrue: 			[references 				errorMacro: ('<1s> is referenced.' expandMacrosWith: variableName)]		ifFalse: 			[references				errorMacro: ('<1s> is referenced.<n>Browse references?' 							expandMacrosWith: variableName);				errorBlock: 						[self openBrowserOn: (BrowserEnvironment new instVarRefsTo: variableName									in: class realClass)]].	^(RBCondition definesInstanceVariable: variableName asString in: class) 		& references not! !!RemoveInstanceVariableRefactoring methodsFor: 'transforming'!transform	class removeInstanceVariable: variableName! !!RenameClassVariableRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk rename: aVarName to: aName in: aClass 	^(self new)		model: aRBSmalltalk;		rename: aVarName			to: aName			in: aClass;		yourself! !!RenameClassVariableRefactoring class methodsFor: 'instance creation'!rename: aVarName to: aName in: aClass	^self new		rename: aVarName		to: aName		in: aClass! !!RenameClassVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isMetaclass: class) not 		& (RBCondition isValidClassVarName: newName asString for: class) 			& (RBCondition definesClassVariable: variableName asString in: class) 			& (RBCondition hierarchyOf: class definesVariable: newName asString) not 			& (RBCondition isGlobal: newName asString in: self model) not! !!RenameClassVariableRefactoring methodsFor: 'initialize-release'!rename: aVarName to: aName in: aClass	self variable: aVarName class: aClass.	newName := aName! !!RenameClassVariableRefactoring methodsFor: 'transforming'!renameReferences	| replacer subclasses |	replacer := ParseTreeRewriter 				rename: variableName				to: newName				handler: 					[self 						refactoringError: ('<1s> is already defined as a method or block temporary <n> variable in this class or one of its subclasses' 								expandMacrosWith: newName)].	subclasses := class withAllSubclasses asSet.	subclasses addAll: class metaclass withAllSubclasses.	self 		convertClasses: subclasses		select: [:aClass | aClass whichSelectorsReferToClassVariable: variableName]		using: replacer! !!RenameClassVariableRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' rename: ''';		nextPutAll: variableName;		nextPutAll: ''' to: ''';		nextPutAll: newName;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!RenameClassVariableRefactoring methodsFor: 'transforming'!transform	class 		renameClassVariable: variableName		to: newName		around: [self renameReferences]! !!RenameInstanceVariableRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk rename: aVarName to: aName in: aClass 	^(self new)		model: aRBSmalltalk;		rename: aVarName			to: aName			in: aClass;		yourself! !!RenameInstanceVariableRefactoring class methodsFor: 'instance creation'!rename: aVarName to: aName in: aClass	^self new		rename: aVarName		to: aName		in: aClass! !!RenameInstanceVariableRefactoring methodsFor: 'preconditions'!preconditions	^(RBCondition isValidInstanceVariableName: newName for: class) 		& (RBCondition definesInstanceVariable: variableName in: class) 			& (RBCondition hierarchyOf: class definesVariable: newName) not 			& (RBCondition isGlobal: newName in: self model) not! !!RenameInstanceVariableRefactoring methodsFor: 'initialize-release'!rename: aVarName to: aName in: aClass	self variable: aVarName class: aClass.	newName := aName! !!RenameInstanceVariableRefactoring methodsFor: 'transforming'!renameReferences	| replacer |	replacer := ParseTreeRewriter 				rename: variableName				to: newName				handler: 					[self 						refactoringError: ('<1s> is already defined as a method or block temporary <n> variable in this class or one of its subclasses' 								expandMacrosWith: newName)].	self 		convertClasses: class withAllSubclasses		select: [:aClass | aClass whichSelectorsReferToInstanceVariable: variableName]		using: replacer! !!RenameInstanceVariableRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' rename: ''';		nextPutAll: variableName;		nextPutAll: ''' to: ''';		nextPutAll: newName;		nextPutAll: ''' in: '.	class storeOn: aStream.	aStream nextPut: $)! !!RenameInstanceVariableRefactoring methodsFor: 'transforming'!transform	class 		renameInstanceVariable: variableName		to: newName		around: [self renameReferences]! !!VariableRefactoring class methodsFor: 'instance creation'!model: aRBSmalltalk variable: aVarName class: aClass 	^(self new)		model: aRBSmalltalk;		variable: aVarName class: aClass;		yourself! !!VariableRefactoring class methodsFor: 'instance creation'!variable: aVarName class: aClass	^self new variable: aVarName class: aClass! !!VariableRefactoring methodsFor: 'printing'!storeOn: aStream 	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' variable: '.	variableName storeOn: aStream.	aStream nextPutAll: ' class: '.	class storeOn: aStream.	aStream nextPut: $)! !!VariableRefactoring methodsFor: 'initialize-release'!variable: aVarName class: aClass 	class := self classObjectFor: aClass.	variableName := aVarName! !!RefactoringManager class methodsFor: 'instance creation'!instance	Instance isNil		ifTrue:			[Instance := self basicNew.			Instance initialize].	^Instance! !!RefactoringManager class methodsFor: 'instance creation'!new	^self shouldNotImplement! !!RefactoringManager class methodsFor: 'public access'!nuke	Instance notNil ifTrue: [Instance release].	Instance := nil! !!RefactoringManager class methodsFor: 'parcel load/unload/save'!preUnloadActionFor: aParcel	^RefactoringManager nuke! !!RefactoringManager methodsFor: 'public access'!addRefactoring: aRefactoring 	RefactoryChangeManager instance performChange: aRefactoring changes.	refactorings add: aRefactoring class name! !!RefactoringManager methodsFor: 'initialize-release'!initialize	refactorings := Bag new! !!RefactoringManager methodsFor: 'printing'!printOn: aStream 	aStream nextPutAll: '#		Refactoring';		cr;		nextPutAll: '---		-----------------------------------------------';		cr.	refactorings asSet asSortedCollection do: 			[:name | 			aStream nextPutAll: (refactorings occurrencesOf: name) printString;				nextPutAll: '		';				nextPutAll: name;				cr]! !!CompositeRefactoryChange class methodsFor: 'instance creation'!named: aString 	^(self new)		name: aString;		yourself! !!CompositeRefactoryChange methodsFor: 'comparing'!= aRefactoryBuilder 	self class = aRefactoryBuilder class ifFalse: [^false].	changes size = aRefactoryBuilder changes size ifFalse: [^false].	changes with: aRefactoryBuilder changes		do: [:each :change | each = change ifFalse: [^false]].	^true! !!CompositeRefactoryChange methodsFor: 'accessing'!addChange: aRefactoryChange 	changes add: aRefactoryChange.	^aRefactoryChange! !!CompositeRefactoryChange methodsFor: 'accessing'!addChangeFirst: aRefactoryChange 	changes addFirst: aRefactoryChange.	^aRefactoryChange! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!addClassVariable: variableName to: aClass 	^self addChange: (AddClassVariableChange add: variableName to: aClass)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!addInstanceVariable: variableName to: aClass 	^self addChange: (AddInstanceVariableChange add: variableName to: aClass)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!addPool: aPoolVariable to: aClass 	^self addChange: (AddPoolVariableChange add: aPoolVariable to: aClass)! !!CompositeRefactoryChange methodsFor: 'accessing'!changeForClass: aRBClass selector: aSelector 	changes reverseDo: 			[:each | 			| change |			change := each changeForClass: aRBClass selector: aSelector.			change notNil ifTrue: [^change]].	^nil! !!CompositeRefactoryChange methodsFor: 'accessing'!changeForMetaclass: aSymbol selector: aSelector 	changes reverseDo: 			[:each | 			| change |			change := each changeForMetaclass: aSymbol selector: aSelector.			change notNil ifTrue: [^change]].	^nil! !!CompositeRefactoryChange methodsFor: 'private-inspector accessing'!changes	^changes! !!CompositeRefactoryChange methodsFor: 'private-inspector accessing'!changes: aCollection 	changes := aCollection! !!CompositeRefactoryChange methodsFor: 'accessing'!changesSize	^changes inject: 0 into: [:sum :each | sum + each changesSize]! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!compile: source in: class 	^self addChange: (AddMethodChange compile: source in: class)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!compile: source in: class classified: aProtocol 	^self addChange: (AddMethodChange 				compile: source				in: class				classified: aProtocol)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!defineClass: aString 	^self addChange: (AddClassChange definition: aString)! !!CompositeRefactoryChange methodsFor: 'printing'!displayString	^super displayString asText allBold! !!CompositeRefactoryChange methodsFor: 'private'!executeNotifying: aBlock 	| undos undo |	undos := changes collect: [:each | each executeNotifying: aBlock].	undo := self copy.	undo changes: undos reverse.	^undo! !!CompositeRefactoryChange methodsFor: 'private'!flattenOnto: aCollection 	changes do: [:each | each flattenOnto: aCollection]! !!CompositeRefactoryChange methodsFor: 'comparing'!hash	^changes size! !!CompositeRefactoryChange methodsFor: 'initialize-release'!initialize	super initialize.	changes := OrderedCollection new! !!CompositeRefactoryChange methodsFor: 'user interface' stamp: 'bh 11/8/2000 13:45'!inspect	"CompositeRefactoryChangeInspector openOn: self"	self needsWork.	^super inspect.! !!CompositeRefactoryChange methodsFor: 'copying'!postCopy	super postCopy.	changes := changes collect: [:each | each copy]! !!CompositeRefactoryChange methodsFor: 'printing' stamp: 'dvf 9/16/2001 00:56'!printOn: aStream 	name ifNotNil: [aStream nextPutAll: name] ifNil: [aStream nextPutAll: 'a CompositeRefactoringChange']! !!CompositeRefactoryChange methodsFor: 'accessing'!problemCount	^self changesSize! !!CompositeRefactoryChange methodsFor: 'private-inspector accessing'!removeChange: aChange 	changes remove: aChange ifAbsent: []! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!removeClass: aClass 	^self addChange: (RemoveClassChange removeClassName: aClass name)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!removeClassNamed: aSymbol 	self addChange: (RemoveClassChange removeClassName: aSymbol)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!removeClassVariable: variableName from: aClass 	^self 		addChange: (RemoveClassVariableChange remove: variableName from: aClass)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!removeInstanceVariable: variableName from: aClass 	^self 		addChange: (RemoveInstanceVariableChange remove: variableName from: aClass)! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!removeMethod: aSelector from: aClass 	^self addChange: (RemoveMethodChange remove: aSelector from: aClass)! !!CompositeRefactoryChange methodsFor: 'accessing'!renameChangesForClass: aClassName to: newClassName 	^(self copy)		changes: (self changes 					collect: [:each | each renameChangesForClass: aClassName to: newClassName]);		yourself! !!CompositeRefactoryChange methodsFor: 'refactory-changes'!renameClass: class to: newName 	^self addChange: (RenameClassChange rename: class name to: newName)! !!RenameClassChange class methodsFor: 'instance creation'!rename: oldString to: newString 	^(self new)		rename: oldString to: newString;		yourself! !!RenameClassChange methodsFor: 'comparing'!= aRenameClassChange 	super = aRenameClassChange ifFalse: [^false].	^oldName = aRenameClassChange oldName 		and: [newName = aRenameClassChange newName]! !!RenameClassChange methodsFor: 'accessing'!changeClass	^Smalltalk at: oldName asSymbol ifAbsent: [Smalltalk at: newName asSymbol]! !!RenameClassChange methodsFor: 'private'!executeNotifying: aBlock 	| undos |	self changeClass rename: newName.	undos := changes collect: 					[:each | 					(each renameChangesForClass: oldName asSymbol to: newName asSymbol) 						executeNotifying: aBlock].	^(self copy)		changes: undos reverse;		rename: newName to: oldName;		yourself! !!RenameClassChange methodsFor: 'private'!flattenOnto: aCollection 	aCollection 		add: (self copy changes: (changes inject: OrderedCollection new						into: 							[:sum :each | 							each flattenOnto: sum.							sum]))! !!RenameClassChange methodsFor: 'private'!newName	^newName! !!RenameClassChange methodsFor: 'private'!oldName	^oldName! !!RenameClassChange methodsFor: 'initialize-release'!rename: oldString to: newString 	oldName := oldString.	newName := newString! !!RenameClassChange methodsFor: 'accessing'!renameChangesForClass: aClassName to: newClassName 	| change |	change := super renameChangesForClass: aClassName to: newClassName.	oldName asSymbol == aClassName 		ifTrue: [change rename: newClassName to: newName].	^change! !!RenameClassVariableChange methodsFor: 'private'!addNewVariable	(AddClassVariableChange add: newName to: self changeClass) execute! !!RenameClassVariableChange methodsFor: 'private'!copyOldValuesToNewVariable	| oldValue |	oldValue := self changeClass classPool at: oldName ifAbsent: [].	self changeClass classPool at: newName asSymbol put: oldValue! !!RenameClassVariableChange methodsFor: 'private'!removeOldVariable	(RemoveClassVariableChange remove: oldName from: self changeClass) execute! !!RenameInstanceVariableChange methodsFor: 'private'!addNewVariable	(AddInstanceVariableChange add: newName to: self changeClass) execute! !!RenameInstanceVariableChange methodsFor: 'private'!copyOldValuesToNewVariable	| newIndex oldIndex |	oldIndex := self changeClass allInstVarNames indexOf: oldName asString.	newIndex := self changeClass allInstVarNames indexOf: newName asString.	self changeClass withAllSubclasses do: 			[:each | 			each allInstances 				do: [:inst | inst instVarAt: newIndex put: (inst instVarAt: oldIndex)]]! !!RenameInstanceVariableChange methodsFor: 'private'!removeOldVariable	(RemoveInstanceVariableChange remove: oldName from: self changeClass) 		execute! !!RenameVariableChange class methodsFor: 'instance creation'!rename: oldName to: newName in: aClass 	^(self new)		oldName: oldName;		newName: newName;		changeClass: aClass;		yourself! !!RenameVariableChange methodsFor: 'comparing'!= aRenameVariableChange 	self class = aRenameVariableChange class ifFalse: [^false].	^className = aRenameVariableChange changeClassName and: 			[isMeta = aRenameVariableChange isMeta and: 					[oldName = aRenameVariableChange oldName 						and: [newName = aRenameVariableChange newName]]]! !!RenameVariableChange methodsFor: 'private'!addNewVariable	self subclassResponsibility! !!RenameVariableChange methodsFor: 'accessing'!changeClass	| class |	class := Smalltalk at: self changeClassName ifAbsent: [^nil].	^isMeta ifTrue: [class class] ifFalse: [class]! !!RenameVariableChange methodsFor: 'accessing'!changeClass: aBehavior 	isMeta := aBehavior isMeta.	className := isMeta 				ifTrue: [aBehavior soleInstance name]				ifFalse: [aBehavior name]! !!RenameVariableChange methodsFor: 'accessing'!changeClassName	^className! !!RenameVariableChange methodsFor: 'accessing'!changeClassName: aSymbol 	className := aSymbol.	isMeta isNil ifTrue: [isMeta := false]! !!RenameVariableChange methodsFor: 'printing'!changeString	^'Rename ' , oldName , ' to ' , newName! !!RenameVariableChange methodsFor: 'private'!copyOldValuesToNewVariable	self subclassResponsibility! !!RenameVariableChange methodsFor: 'printing'!displayClassName	^isMeta 		ifTrue: [self changeClassName , ' class']		ifFalse: [self changeClassName asString]! !!RenameVariableChange methodsFor: 'private'!executeNotifying: aBlock 	| undo |	self addNewVariable.	self copyOldValuesToNewVariable.	undo := super executeNotifying: aBlock.	undo		oldName: newName;		newName: oldName.	self removeOldVariable.	^undo! !!RenameVariableChange methodsFor: 'comparing'!hash	^(self changeClassName hash bitXor: self oldName hash) 		bitXor: self newName hash! !!RenameVariableChange methodsFor: 'private'!isMeta	^isMeta! !!RenameVariableChange methodsFor: 'accessing'!newName	^newName! !!RenameVariableChange methodsFor: 'private'!newName: aString 	newName := aString! !!RenameVariableChange methodsFor: 'accessing'!oldName	^oldName! !!RenameVariableChange methodsFor: 'private'!oldName: aString	oldName := aString! !!RenameVariableChange methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self displayString! !!RenameVariableChange methodsFor: 'private'!removeOldVariable	self subclassResponsibility! !!RefactoryChange methodsFor: 'accessing'!changeForClass: aRBClass selector: aSelector 	^nil! !!RefactoryChange methodsFor: 'accessing'!changeForMetaclass: aSymbol selector: aSelector 	^nil! !!RefactoryChange methodsFor: 'printing'!changeString	^self class name! !!RefactoryChange methodsFor: 'accessing'!changes	^Array with: self! !!RefactoryChange methodsFor: 'accessing'!changesSize	^1! !!RefactoryChange methodsFor: 'copying' stamp: 'bh 3/16/2000 23:27'!copy	^(super copy)		postCopy;		yourself! !!RefactoryChange methodsFor: 'printing'!displayString	^name isNil ifTrue: [self changeString] ifFalse: [name]! !!RefactoryChange methodsFor: 'performing-changes'!execute	^self executeNotifying: []! !!RefactoryChange methodsFor: 'private'!executeNotifying: aBlock 	self subclassResponsibility! !!RefactoryChange methodsFor: 'private' stamp: 'dvf 9/21/2003 16:35'!flattenOnto: aCollection 	aCollection add: self! !!RefactoryChange methodsFor: 'private'!flattenedChanges	| changes |	changes := OrderedCollection new.	self flattenOnto: changes.	^changes! !!RefactoryChange methodsFor: 'initialize-release'!initialize! !!RefactoryChange methodsFor: 'user interface' stamp: 'bh 5/8/2000 21:13'!inspect	^((CompositeRefactoryChange new)		changes: (Array with: self);		yourself) inspect! !!RefactoryChange methodsFor: 'accessing'!name	^name isNil ifTrue: [self changeString] ifFalse: [name]! !!RefactoryChange methodsFor: 'initialize-release'!name: aString	name := aString! !!RefactoryChange methodsFor: 'copying' stamp: 'dvf 9/21/2003 16:35'!postCopy	^self! !!RefactoryChange methodsFor: 'accessing'!renameChangesForClass: aClassName to: newClassName 	"We're in the middle of performing a rename operation. If we stored 	the class name, we need to change the class name to the new 	name to perform the compiles."	self subclassResponsibility! !!AddClassChange class methodsFor: 'instance creation' stamp: 'bh 11/8/2000 13:51'!definition: aString 	^self new definition: aString! !!AddClassChange methodsFor: 'comparing'!= anAddClassChange 	self class = anAddClassChange class ifFalse: [^false].	^definition = anAddClassChange definition! !!AddClassChange methodsFor: 'converting'!asUndoOperation	| class |	class := Smalltalk at: self changeClassName ifAbsent: [nil].	^class isBehavior 		ifTrue: [AddClassChange definition: class definition]		ifFalse: [RemoveClassChange removeClassName: self changeClassName]! !!AddClassChange methodsFor: 'accessing'!category	category isNil ifTrue: [self fillOutDefinition].	^category! !!AddClassChange methodsFor: 'accessing'!changeClassName	className isNil ifTrue: [self fillOutDefinition].	^className! !!AddClassChange methodsFor: 'printing'!changeString	^'Define ' , self displayClassName! !!AddClassChange methodsFor: 'accessing'!classVariableNames	classVariableNames isNil ifTrue: [self fillOutDefinition].	^classVariableNames! !!AddClassChange methodsFor: 'private'!controller	^nil! !!AddClassChange methodsFor: 'private'!definingSuperclass	^self class! !!AddClassChange methodsFor: 'private'!definition	^definition! !!AddClassChange methodsFor: 'initialize-release'!definition: aString 	definition := aString! !!AddClassChange methodsFor: 'private'!fillOutDefinition	| parseTree |	parseTree := RBParser parseExpression: definition				onError: [:str :pos | ^self parseDefinitionError].	parseTree isMessage ifFalse: [^self parseDefinitionError].	(self isValidSubclassCreationMessage: parseTree) 		ifFalse: [^self parseDefinitionError].	superclassName := parseTree receiver isVariable 				ifTrue: [parseTree receiver name asSymbol]				ifFalse: [parseTree receiver value].	className := parseTree arguments first value.	instanceVariableNames := self namesIn: (parseTree arguments at: 2) value.	classVariableNames := self namesIn: (parseTree arguments at: 3) value.	poolDictionaryNames := self namesIn: (parseTree arguments at: 4) value.	category := parseTree arguments size < 5 				ifTrue: [#Unknown]				ifFalse: [(parseTree arguments at: 5) value asSymbol]! !!AddClassChange methodsFor: 'comparing'!hash	^definition hash! !!AddClassChange methodsFor: 'initialize-release'!initialize	super initialize.	isMeta := false! !!AddClassChange methodsFor: 'accessing'!instanceVariableNames	instanceVariableNames isNil ifTrue: [self fillOutDefinition].	^instanceVariableNames! !!AddClassChange methodsFor: 'testing' stamp: 'bh 11/8/2000 12:29'!isValidMessageName: aMessageNode 	^#("#subclass:instanceVariableNames:classVariableNames:poolDictionaries:" #subclass:instanceVariableNames:classVariableNames:poolDictionaries:category: "#variableByteSubclass:classVariableNames:poolDictionaries:" #variableByteSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category: "#variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:" #variableSubclass:instanceVariableNames:classVariableNames:poolDictionaries:category:) 		includes: aMessageNode selector! !!AddClassChange methodsFor: 'testing'!isValidSubclassCreationMessage: aMessageNode 	(aMessageNode receiver isVariable or: [aMessageNode receiver isLiteral]) 		ifFalse: [^false].	(self isValidMessageName: aMessageNode) ifFalse: [^false].	^(aMessageNode arguments detect: [:each | each isLiteral not] ifNone: [nil]) 		isNil! !!AddClassChange methodsFor: 'private'!namesIn: aString 	| names stream nameStream |	names := OrderedCollection new.	stream := ReadStream on: aString.		[stream skipSeparators.	stream atEnd] whileFalse: 				[nameStream := WriteStream on: (String new: 10).				[stream atEnd or: [stream peek isSeparator]] 					whileFalse: [nameStream nextPut: stream next].				names add: nameStream contents].	^names! !!AddClassChange methodsFor: 'private'!parseDefinitionError	className := #'Unknown Class'.	instanceVariableNames := #().	classVariableNames := #().	poolDictionaryNames := #()! !!AddClassChange methodsFor: 'accessing'!poolDictionaryNames	poolDictionaryNames isNil ifTrue: [self fillOutDefinition].	^poolDictionaryNames! !!AddClassChange methodsFor: 'private'!primitiveExecute	^self definingSuperclass subclassDefinerClass 		evaluate: definition		notifying: self controller		logged: true! !!AddClassChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: definition;		nextPut: $!!! !!AddClassChange methodsFor: 'accessing'!superclassName	className isNil ifTrue: [self fillOutDefinition].	^superclassName! !!InteractiveAddClassChange class methodsFor: 'instance creation'!definition: aString for: aController 	^(self definition: aString)		controller: aController;		yourself! !!InteractiveAddClassChange methodsFor: 'private'!controller	^controller! !!InteractiveAddClassChange methodsFor: 'private'!controller: aController 	controller := aController! !!InteractiveAddClassChange methodsFor: 'accessing'!definedClass	^definedClass! !!InteractiveAddClassChange methodsFor: 'private'!primitiveExecute	definedClass := super primitiveExecute! !!AddMethodChange class methodsFor: 'instance creation'!compile: aString in: aClass 	^self new class: aClass source: aString! !!AddMethodChange class methodsFor: 'instance creation'!compile: aString in: aBehavior classified: aProtocol 	^self new 		class: aBehavior		protocol: aProtocol		source: aString! !!AddMethodChange methodsFor: 'comparing'!= anAddMethodChange 	super = anAddMethodChange ifFalse: [^false].	^self parseTree = anAddMethodChange parseTree! !!AddMethodChange methodsFor: 'converting'!asUndoOperation	^(self changeClass includesSelector: self selector) 		ifTrue: 			[| oldProtocol |			oldProtocol := BrowserEnvironment new whichProtocolIncludes: self selector						in: self changeClass.			oldProtocol isNil ifTrue: [oldProtocol := #accessing].			AddMethodChange 				compile: (self methodSourceFor: self selector)				in: self changeClass				classified: oldProtocol]		ifFalse: [RemoveMethodChange remove: selector from: self changeClass]! !!AddMethodChange methodsFor: 'accessing'!changeForClass: aSymbol selector: aSelector 	^(isMeta not and: [self selector = aSelector and: [className = aSymbol]])		ifTrue: [self]		ifFalse: [nil]! !!AddMethodChange methodsFor: 'accessing'!changeForMetaclass: aSymbol selector: aSelector 	^(isMeta and: [self selector = aSelector and: [className = aSymbol]])		ifTrue: [self]		ifFalse: [nil]! !!AddMethodChange methodsFor: 'printing'!changeString	^self displayClassName , '>>' , self selector! !!AddMethodChange methodsFor: 'initialize-release'!class: aClass protocol: aProtocol source: aString 	self changeClass: aClass.	self protocols: aProtocol.	source := aString! !!AddMethodChange methodsFor: 'initialize-release'!class: aClass source: aString 	self changeClass: aClass.	source := aString.	self protocols: (BrowserEnvironment new whichProtocolIncludes: self selector in: aClass)! !!AddMethodChange methodsFor: 'private'!controller	^nil! !!AddMethodChange methodsFor: 'comparing'!hash	^self parseTree hash! !!AddMethodChange methodsFor: 'private'!parseTree	^RBParser parseMethod: source onError: [:str :pos | ^nil]! !!AddMethodChange methodsFor: 'private'!primitiveExecute	^self changeClass 		compile: source		classified: self protocol		notifying: self controller! !!AddMethodChange methodsFor: 'printing' stamp: 'nk 3/5/2005 15:51'!printOn: aStream 	aStream		nextPut: $!!;		nextPutAll: self displayClassName;		nextPutAll: ' methodsFor: ''';		nextPutAll: self protocol;		nextPutAll: ''' stamp: ';		print: Utilities changeStamp;		nextPut: $!!;		cr;		nextPutAll: (source copyReplaceAll: '!!' with: '!!!!');		nextPutAll: '!! !!'! !!AddMethodChange methodsFor: 'accessing'!protocol	^self protocols first! !!AddMethodChange methodsFor: 'accessing'!protocols	^protocols! !!AddMethodChange methodsFor: 'initialize-release'!protocols: aCollection 	protocols := aCollection isString 				ifTrue: [Array with: aCollection]				ifFalse: [aCollection].	protocols isNil ifTrue: [protocols := #(#accessing)]! !!AddMethodChange methodsFor: 'accessing'!selector	selector isNil 		ifTrue: 			[selector := RBParser parseMethodPattern: source.			selector isNil ifTrue: [selector := #unknown]].	^selector! !!InteractiveAddMethodChange class methodsFor: 'instance creation'!compile: aString in: aBehavior classified: aProtocol for: aController 	^(self 		compile: aString		in: aBehavior		classified: aProtocol)		controller: aController;		yourself! !!InteractiveAddMethodChange class methodsFor: 'instance creation'!compile: aString in: aClass for: aController 	^(self compile: aString in: aClass)		controller: aController;		yourself! !!InteractiveAddMethodChange methodsFor: 'private'!controller	^controller! !!InteractiveAddMethodChange methodsFor: 'private'!controller: aController 	controller := aController! !!InteractiveAddMethodChange methodsFor: 'accessing'!definedSelector	^definedSelector! !!InteractiveAddMethodChange methodsFor: 'private'!primitiveExecute	^definedSelector := super primitiveExecute! !!RefactoryClassChange methodsFor: 'comparing'!= aRefactoryClassChange 	self class = aRefactoryClassChange class ifFalse: [^false].	^className = aRefactoryClassChange changeClassName 		and: [isMeta = aRefactoryClassChange isMeta]! !!RefactoryClassChange methodsFor: 'converting'!asUndoOperation	^self subclassResponsibility! !!RefactoryClassChange methodsFor: 'accessing'!changeClass	| class |	class := Smalltalk at: self changeClassName ifAbsent: [^nil].	^isMeta ifTrue: [class class] ifFalse: [class]! !!RefactoryClassChange methodsFor: 'accessing'!changeClass: aBehavior 	isMeta := aBehavior isMeta.	className := isMeta 				ifTrue: [aBehavior soleInstance name]				ifFalse: [aBehavior name]! !!RefactoryClassChange methodsFor: 'accessing'!changeClassName	^className! !!RefactoryClassChange methodsFor: 'accessing'!changeClassName: aSymbol 	className := aSymbol.	isMeta isNil ifTrue: [isMeta := false]! !!RefactoryClassChange methodsFor: 'printing'!changeString	^self displayClassName! !!RefactoryClassChange methodsFor: 'printing'!displayClassName	^isMeta 		ifTrue: [self changeClassName , ' class']		ifFalse: [self changeClassName asString]! !!RefactoryClassChange methodsFor: 'private'!executeNotifying: aBlock 	| undo |	undo := self asUndoOperation.	undo name: self name.	self primitiveExecute.	aBlock value.	^undo! !!RefactoryClassChange methodsFor: 'comparing'!hash	^self changeClassName hash! !!RefactoryClassChange methodsFor: 'private'!isMeta	^isMeta! !!RefactoryClassChange methodsFor: 'accessing'!methodSourceFor: aSymbol 	(self changeClass includesSelector: aSymbol) ifFalse: [^nil].	^self changeClass sourceCodeAt: aSymbol! !!RefactoryClassChange methodsFor: 'private'!primitiveExecute	^self subclassResponsibility! !!RefactoryClassChange methodsFor: 'printing'!printOn: aStream	aStream nextPutAll: self displayString! !!RefactoryClassChange methodsFor: 'accessing'!renameChangesForClass: aClassName to: newClassName 	self changeClassName == aClassName 		ifTrue: 			[^(self copy)				changeClassName: newClassName;				yourself].	^self! !!AddClassVariableChange methodsFor: 'converting'!asUndoOperation	^RemoveClassVariableChange remove: variable from: self changeClass! !!AddClassVariableChange methodsFor: 'printing'!changeString	^'Add class variable named, <1s>, from <2s>' 		expandMacrosWith: variable		with: self displayClassName! !!AddClassVariableChange methodsFor: 'private'!changeSymbol	^#addClassVarName:! !!AddClassVariableChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' addClassVarNamed: ';		nextPutAll: variable;		nextPut: $!!! !!AddClassVariableChange methodsFor: 'private'!variable	^variable asSymbol! !!AddInstanceVariableChange methodsFor: 'converting'!asUndoOperation	^RemoveInstanceVariableChange remove: variable from: self changeClass! !!AddInstanceVariableChange methodsFor: 'printing'!changeString	^'Add instance variable named, <1s>, from <2s>' 		expandMacrosWith: variable		with: self displayClassName! !!AddInstanceVariableChange methodsFor: 'private'!changeSymbol	^#addInstVarName:! !!AddInstanceVariableChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' addInstVarNamed: ';		nextPutAll: variable;		nextPut: $!!! !!AddPoolVariableChange methodsFor: 'converting'!asUndoOperation	^RemovePoolVariableChange remove: variable from: self changeClass! !!AddPoolVariableChange methodsFor: 'private' stamp: 'nk 7/31/2004 09:22'!changeObject	| dictionary |	dictionary := variable isString 				ifTrue: [Smalltalk classNamed: variable]				ifFalse: [variable].	^dictionary! !!AddPoolVariableChange methodsFor: 'printing'!changeString	^'Add pool variable named, <1s>, from <2s>' 		expandMacrosWith: self variable		with: self displayClassName! !!AddPoolVariableChange methodsFor: 'private'!changeSymbol	^#addSharedPool:! !!AddPoolVariableChange methodsFor: 'private'!changesFileTemplate	^'<1p> <2s> <3s>'! !!AddPoolVariableChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' addSharedPool: ';		nextPutAll: self variable;		nextPut: $!!! !!AddPoolVariableChange methodsFor: 'private'!variable	^variable isString 		ifTrue: [variable]		ifFalse: 			[Smalltalk keyAtValue: variable ifAbsent: [self error: 'Cannot find value']]! !!RefactoryVariableChange class methodsFor: 'instance creation'!add: aVariable to: aBehavior 	"This should only be called on the Add*Change subclasses, 	but is here so we don't need to copy it to all subclasses"	^self new class: aBehavior variable: aVariable! !!RefactoryVariableChange class methodsFor: 'instance creation'!remove: aVariable from: aBehavior 	"This should only be called on the Remove*Change subclasses, 	but is here so we don't need to copy it to all subclasses"	^self new class: aBehavior variable: aVariable! !!RefactoryVariableChange methodsFor: 'comparing'!= aRefactoryVariableChange 	^super = aRefactoryVariableChange 		and: [variable = aRefactoryVariableChange variable]! !!RefactoryVariableChange methodsFor: 'private'!changeObject	^self variable! !!RefactoryVariableChange methodsFor: 'private'!changeSymbol	self subclassResponsibility! !!RefactoryVariableChange methodsFor: 'private'!changesFileTemplate	^'<1p> <2s> <3p>'! !!RefactoryVariableChange methodsFor: 'initialize-release'!class: aBehavior variable: aString 	self changeClass: aBehavior.	variable := aString! !!RefactoryVariableChange methodsFor: 'comparing'!hash	^self class hash bitXor: variable hash! !!RefactoryVariableChange methodsFor: 'private' stamp: 'bh 4/29/2000 18:16'!primitiveExecute	| changeSymbol |	changeSymbol := self changeSymbol.	self changeClass perform: changeSymbol with: self changeObject.	self needsWork. "the following is to handle a VW bug.  Is it also a problem for Squeak?"	"ChangeSet current changeClass: self changeClass.	SourceFileManager default logChange: (self changesFileTemplate			expandMacrosWith: self changeClass			with: changeSymbol			with: self variable)"! !!RefactoryVariableChange methodsFor: 'private'!variable	^variable! !!RemoveClassVariableChange methodsFor: 'converting'!asUndoOperation	^AddClassVariableChange add: variable to: self changeClass! !!RemoveClassVariableChange methodsFor: 'printing'!changeString	^'Remove class variable named, <1s>, from <2s>' 		expandMacrosWith: variable		with: self displayClassName! !!RemoveClassVariableChange methodsFor: 'private'!changeSymbol	^#removeClassVarName:! !!RemoveClassVariableChange methodsFor: 'private' stamp: 'md 8/2/2005 23:36'!primitiveExecute	[super primitiveExecute] on: Notification do: [:ex | ex resume] ! !!RemoveClassVariableChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' removeClassVarNamed: ';		nextPutAll: variable;		nextPut: $!!! !!RemoveClassVariableChange methodsFor: 'private'!variable	^variable asSymbol! !!RemoveInstanceVariableChange methodsFor: 'converting'!asUndoOperation	^AddInstanceVariableChange add: variable to: self changeClass! !!RemoveInstanceVariableChange methodsFor: 'printing'!changeString	^'Remove instance variable named, <1s>, from <2s>' 		expandMacrosWith: variable		with: self displayClassName! !!RemoveInstanceVariableChange methodsFor: 'private'!changeSymbol	^#removeInstVarName:! !!RemoveInstanceVariableChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' removeInstVarNamed: ';		nextPutAll: variable;		nextPut: $!!! !!RemovePoolVariableChange methodsFor: 'converting'!asUndoOperation	^AddPoolVariableChange add: variable to: self changeClass! !!RemovePoolVariableChange methodsFor: 'private'!changeObject	| dictionary |	dictionary := variable isString 				ifTrue: [Smalltalk at: variable asSymbol]				ifFalse: [variable].	^dictionary! !!RemovePoolVariableChange methodsFor: 'printing'!changeString	^'Remove pool variable named, <1s>, from <2s>' 		expandMacrosWith: self variable		with: self displayClassName! !!RemovePoolVariableChange methodsFor: 'private'!changeSymbol	^#removeSharedPool:! !!RemovePoolVariableChange methodsFor: 'private'!changesFileTemplate	^'<1p> <2s> <3s>'! !!RemovePoolVariableChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' removeSharedPool: ';		nextPutAll: self variable;		nextPut: $!!! !!RemovePoolVariableChange methodsFor: 'private'!variable	^variable isString 		ifTrue: [variable]		ifFalse: 			[Smalltalk keyAtValue: variable ifAbsent: [self error: 'Cannot find value']]! !!RemoveClassChange class methodsFor: 'instance creation'!remove: aClass 	^self new changeClass: aClass! !!RemoveClassChange class methodsFor: 'instance creation'!removeClassName: aSymbol 	^self new changeClassName: aSymbol! !!RemoveClassChange methodsFor: 'converting'!asUndoOperation	| classChanges |	classChanges := CompositeRefactoryChange new.	self changeClass withAllSubclasses do: 			[:each | 			classChanges defineClass: each definition.			each class instVarNames 				do: [:varName | classChanges addInstanceVariable: varName to: each class].			each selectors 				do: [:selector | classChanges compile: (each sourceCodeAt: selector) in: each].			each class selectors 				do: [:selector | classChanges compile: (each class sourceCodeAt: selector) in: each class]].	^classChanges! !!RemoveClassChange methodsFor: 'printing'!changeString	^'Remove class ', self displayClassName! !!RemoveClassChange methodsFor: 'private'!primitiveExecute	self changeClass removeFromSystem! !!RemoveClassChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' removeFromSystem';		nextPut: $!!! !!RemoveMethodChange class methodsFor: 'instance creation'!remove: aSymbol from: aClass 	^(self new)		changeClass: aClass;		selector: aSymbol;		yourself! !!RemoveMethodChange methodsFor: 'comparing'!= aRemoveMethodChange 	super = aRemoveMethodChange ifFalse: [^false].	^selector = aRemoveMethodChange selector! !!RemoveMethodChange methodsFor: 'converting'!asUndoOperation	^AddMethodChange compile: (self methodSourceFor: selector)		in: self changeClass! !!RemoveMethodChange methodsFor: 'printing'!changeString	^'Remove method, #<1s>, from: <2s>' expandMacrosWith: selector		with: self displayClassName! !!RemoveMethodChange methodsFor: 'comparing'!hash	^selector hash! !!RemoveMethodChange methodsFor: 'private'!primitiveExecute	^self changeClass removeSelector: selector! !!RemoveMethodChange methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: self displayClassName;		nextPutAll: ' removeSelector: ';		nextPutAll: selector;		nextPut: $!!! !!RemoveMethodChange methodsFor: 'private'!selector	^selector! !!RemoveMethodChange methodsFor: 'initialize-release'!selector: aSymbol 	selector := aSymbol! !!RefactoryChangeManager class methodsFor: 'class initialization'!initialize	self nuke.	UndoSize := 5! !!RefactoryChangeManager class methodsFor: 'instance creation'!instance	Instance isNil 		ifTrue: 			[Instance := self basicNew.			Instance initialize].	^Instance! !!RefactoryChangeManager class methodsFor: 'instance creation'!new	^self shouldNotImplement! !!RefactoryChangeManager class methodsFor: 'public access'!nuke	Instance notNil ifTrue: [Instance release].	Instance := nil! !!RefactoryChangeManager class methodsFor: 'class initialization'!undoSize	^UndoSize! !!RefactoryChangeManager class methodsFor: 'class initialization'!undoSize: anInteger 	UndoSize := anInteger max: 0! !!RefactoryChangeManager methodsFor: 'public access'!addUndo: aRefactoringChange 	undo addLast: aRefactoringChange.	undo size > UndoSize ifTrue: [undo removeFirst].	redo := OrderedCollection new! !!RefactoryChangeManager methodsFor: 'private'!clearUndoRedoList	undo := OrderedCollection new.	redo := OrderedCollection new! !!RefactoryChangeManager methodsFor: 'initialize-release'!connectToChanges	ChangeSet addDependent: self! !!RefactoryChangeManager methodsFor: 'initialize-release'!disconnectFromChanges	ChangeSet removeDependent: self! !!RefactoryChangeManager methodsFor: 'testing'!hasRedoableOperations	^redo isEmpty not! !!RefactoryChangeManager methodsFor: 'testing'!hasUndoableOperations	^undo isEmpty not! !!RefactoryChangeManager methodsFor: 'public access'!ignoreChangesWhile: aBlock 	isPerformingRefactoring ifTrue: [^aBlock value].	isPerformingRefactoring := true.	aBlock ensure: [isPerformingRefactoring := false]! !!RefactoryChangeManager methodsFor: 'initialize-release'!initialize	undo := OrderedCollection new.	redo := OrderedCollection new.	isPerformingRefactoring := false.	self connectToChanges! !!RefactoryChangeManager methodsFor: 'public access'!performChange: aRefactoringChange 	self ignoreChangesWhile: [self addUndo: aRefactoringChange execute]! !!RefactoryChangeManager methodsFor: 'public access'!redoChange	^redo last! !!RefactoryChangeManager methodsFor: 'public access'!redoOperation	redo isEmpty ifTrue: [^self].	self ignoreChangesWhile: 			[| change |			change := redo removeLast.			undo add: change execute]! !!RefactoryChangeManager methodsFor: 'initialize-release'!release	super release.	self disconnectFromChanges! !!RefactoryChangeManager methodsFor: 'public access'!undoChange	^undo last! !!RefactoryChangeManager methodsFor: 'public access'!undoOperation	undo isEmpty ifTrue: [^self].	self ignoreChangesWhile: 			[| change |			change := undo removeLast.			redo add: change execute]! !!RefactoryChangeManager methodsFor: 'updating'!update: anAspectSymbol with: aParameter from: aSender 	| changeType |	(aSender == ChangeSet and: [isPerformingRefactoring not]) ifFalse: [^self].	anAspectSymbol == #reorganizeClass: ifTrue: [^self].	changeType := (anAspectSymbol isString 				ifTrue: [anAspectSymbol asString]				ifFalse: ['class']) asLowercase.	(changeType indexOfSubCollection: 'class' startingAt: 1) 		+ (changeType indexOfSubCollection: 'selector' startingAt: 1) > 0 		ifTrue: [self clearUndoRedoList]! !!RefactoryTestDataApp methodsFor: 'lint'!asOrderedCollectionNotNeeded	self foo addAll: (1 to: 10) asOrderedCollection! !!RefactoryTestDataApp methodsFor: 'lint'!assignmentInBlock	[^self printString] ensure: [self close]! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/5/2005 15:28'!assignmentInIfTrue	| variable |	self isVariable 		ifTrue: [variable := self]		ifFalse: [variable := self printString].	^variable! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'md 3/14/2006 16:47'!atIfAbsent	^ Smalltalk at: #MyTest		ifAbsent: 			[| collection |			collection := #().			Smalltalk at: #MyTest put: collection]! !!RefactoryTestDataApp methodsFor: 'lint'!badMessage	self become: String new! !!RefactoryTestDataApp methodsFor: 'lint'!booleanPrecedence	^true & 4 = 45! !!RefactoryTestDataApp methodsFor: 'test'!callFoo	^self testFoo: 5! !!RefactoryTestDataApp methodsFor: 'test'!callMethod	^self renameThisMethod: 5! !!RefactoryTestDataApp methodsFor: 'inline'!called: anObject on1: aBlock 	| each |	each := anObject printString.	Transcript		show: each;		cr.	aBlock value: each! !!RefactoryTestDataApp methodsFor: 'inline'!called: anObject on: aBlock 	Transcript		show: anObject printString;		cr.	aBlock value! !!RefactoryTestDataApp methodsFor: 'inline'!caller	| anObject |	anObject := 5.	self 		called: anObject + 1		on: [^anObject]! !!RefactoryTestDataApp methodsFor: 'inline'!caller1	| anObject |	anObject := 5.	self called: anObject + 1		on1: 			[:each | 			each printString.			^anObject]! !!RefactoryTestDataApp methodsFor: 'inline'!caller2	^(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)]! !!RefactoryTestDataApp methodsFor: 'lint'!collectSelectNotUsed	(1 to: 10) select: [:each | each = 4]! !!RefactoryTestDataApp methodsFor: 'lint'!collectionMessagesToExternalObject	self someObject collection remove: 10! !!RefactoryTestDataApp methodsFor: 'lint'!collectionProtocol	| newCollection |	newCollection := OrderedCollection new.	(1 to: 10) asOrderedCollection do: 			[:each | 			| new |			new := each * 2.			newCollection add: new].	^newCollection! !!RefactoryTestDataApp methodsFor: 'lint'!consistencyCheck	^(1 to: 10) at: 1! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/5/2005 15:28'!contains	^((1 to: 10) detect: [:each | each > 2] ifNone: [nil]) isNil! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/5/2005 16:49'!cruft	self halt! !!RefactoryTestDataApp methodsFor: 'lint'!detectContains	^(1 to: 10) do: [:each | each > 2 ifTrue: [^each]]! !!RefactoryTestDataApp methodsFor: 'lint'!endTrueFalse	self isVariable 		ifTrue: 			[self printString.			self isVariable printString]		ifFalse: 			[self printString.			^4]! !!RefactoryTestDataApp methodsFor: 'lint'!equalNotUsed	| string |	string = '' yourself.	(1 to: 10) do: [:i | string := i printString].	^string! !!RefactoryTestDataApp methodsFor: 'lint'!equalsTrue	^true == self! !!RefactoryTestDataApp methodsFor: 'test'!exampleCall	^self rename: 1 two: 2! !!RefactoryTestDataApp methodsFor: 'lint'!extraBlock	^[:arg | arg + 43] value: 45! !!RefactoryTestDataApp methodsFor: 'lint'!fileBlocks	| file |	^	[file := 'asdf' asFilename readStream.	file contents] ensure: [file close]! !!RefactoryTestDataApp methodsFor: 'inline'!foo: aValue	^(1 to: 10) inject: aValue into: [:sum :each | sum + each]! !!RefactoryTestDataApp methodsFor: 'lint'!fullBlocks	^[thisContext]! !!RefactoryTestDataApp methodsFor: 'lint'!guardingClause	self isSymbol 		ifFalse: 			[self printString.			self isSymbol printString]! !!RefactoryTestDataApp methodsFor: 'lint'!ifTrueReturns	self isSymbol ifFalse: [^true].	^false! !!RefactoryTestDataApp methodsFor: 'inline'!inlineComponent	| a |	a := 5.	^a class		superclass;		hasImmediateInstances;		yourself! !!RefactoryTestDataApp methodsFor: 'inline'!inlineFailed	| x y q |	x := 5.	y := 10.	q := x + 1 fooMax: y.	^q! !!RefactoryTestDataApp methodsFor: 'test'!inlineFoo: aBlock 	| bar baz asdf |	bar := aBlock value: self.	baz := bar + bar.	asdf := baz + bar.	^asdf! !!RefactoryTestDataApp methodsFor: 'test'!inlineJunk	| asdf |	asdf := self inlineFoo: 					[:each | 					| temp |					temp := each.					temp , temp].	^asdf foo: 			[:bar | 			| baz |			baz := bar.			baz * baz]! !!RefactoryTestDataApp methodsFor: 'inline'!inlineLast	5 = 3 ifTrue: [^self caller] ifFalse: [^self caller2]! !!RefactoryTestDataApp methodsFor: 'inline'!inlineMax	| x y q |	x := 5.	y := 10.	q := x + 1 max: y.	^q! !!RefactoryTestDataApp methodsFor: 'test'!inlineMethod	| temp |	temp := self				foo;				inlineMethod;				bar.	^temp! !!RefactoryTestDataApp methodsFor: 'test'!inlineParameterMethod: aSymbol	^aSymbol isSymbol! !!RefactoryTestDataApp methodsFor: 'inline'!inlineTemporary	| temp |	self isNil ifTrue: [temp := 4].	^temp! !!RefactoryTestDataApp methodsFor: 'lint'!isLiteral	^false! !!RefactoryTestDataApp methodsFor: 'lint'!justSendsSuper	super justSendsSuper! !!RefactoryTestDataApp methodsFor: 'lint'!literalArrayCharacters	^#($a $b $c) includes: $a! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/4/2005 14:52'!literalArrayWithTrueFalseOrNil	| a b c |	a := #(true false nil).	b := #(#true #false #nil).	c := {true. false. nil}.	^{a. b. c}! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/4/2005 16:40'!literalArrayWithTrueFalseOrNil2	| b c |	b := #(#true #false #nil).	c := #(#true (#true #false #nil) #false #nil).^b! !!RefactoryTestDataApp methodsFor: 'lint'!longMethods	self printString.	self printString.	self isVariable ifTrue: [self printString].	self isVariable ifTrue: [self printString].	self isVariable ifTrue: [self printString].	self isVariable ifTrue: [self printString]! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/5/2005 15:28'!minMax	"Bug in 3<5 ifTrue: [3]  ifFalse: [5]"^3<5 ifTrue: [3]  ifFalse: [5]"	| var |	var := 4.	var < 5 ifTrue: [var := 5].	^var"! !!RefactoryTestDataApp methodsFor: 'lint'!missingYourself	^(OrderedCollection new)		add: 1;		add: 2;		removeFirst! !!RefactoryTestDataApp methodsFor: 'lint'!modifiesCollection	| collection |	collection := (1 to: 10) asOrderedCollection.	collection do: [:each | each > 5 ifTrue: [collection remove: each]].	^collection! !!RefactoryTestDataApp methodsFor: 'test'!moveDefinition	| temp |	^(self collect: 			[:each | 			temp := each printString.			temp , temp]) 		select: 			[:each | 			temp := each size.			temp odd]! !!RefactoryTestDataApp methodsFor: 'inline'!multipleCalls	self caller2.	self caller2! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/5/2005 14:51'!noIsNil: arg	^arg = nil or: [ arg ~= nil ]! !!RefactoryTestDataApp methodsFor: 'test'!noMoveDefinition	| temp |	^(self collect: 			[:each | 			temp := each printString.			temp , temp]) 		select: [:each | temp := each size + temp]! !!RefactoryTestDataApp methodsFor: 'lint'!precedence	^self isArray ifFalse: [self block + 5 * 34] ifTrue: [self printString = 10]! !!RefactoryTestDataApp methodsFor: 'accessing'!referencesConditionFor: aClass 	| environment association |	^(RBCondition withBlock: 			[association := Smalltalk associationAt: aClass name						ifAbsent: [self refactoringError: 'Could not find class'].			environment := (self environment referencesTo: association) 						| (self environment referencesTo: aClass name).			environment isEmpty])		errorMacro: aClass , ' is referenced.<n>Browse references?';		errorBlock: [environment openEditor];		yourself! !!RefactoryTestDataApp methodsFor: 'lint'!refersToClass	^RefactoryTestDataApp! !!RefactoryTestDataApp methodsFor: 'lint'!release	self printString! !!RefactoryTestDataApp methodsFor: 'test'!rename: this two: argumentMethod	^self printString , this , argumentMethod! !!RefactoryTestDataApp methodsFor: 'test'!renameThisMethod: anArg	^self! !!RefactoryTestDataApp methodsFor: 'lint'!returnInEnsure	[self error: 'asdf'] ensure: [^4]! !!RefactoryTestDataApp methodsFor: 'lint'!returnsBooleanAndOther	self isVariable ifTrue: [^false].	self printString! !!RefactoryTestDataApp methodsFor: 'lint'!returnsIfTrue	^self isNil ifTrue: [4]! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'bh 4/2/2000 22:25'!searchingLiteral	^self printString = #a or: [#() = self printString | ( #() == self printString)]! !!RefactoryTestDataApp methodsFor: 'test'!selectorNotReferenced	^self selectorNotReferenced + 4! !!RefactoryTestDataApp methodsFor: 'test'!sendInlineParameterMethod	^self inlineParameterMethod: #(#asdf)! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 3/5/2005 15:28'!sendsDifferentSuper	super printString! !!RefactoryTestDataApp methodsFor: 'lint'!sizeCheck	self isEmpty		ifFalse: [self do: 					[:each | 					Transcript						show: each;						cr]]! !!RefactoryTestDataApp methodsFor: 'lint'!stringConcatenation	| string |	string := '' yourself.	(1 to: 10) do: [:i | string := string , i printString].	^string! !!RefactoryTestDataApp methodsFor: 'test'!symbolReference	^#(#renameThisMethod: #(4 #renameThisMethod:))! !!RefactoryTestDataApp methodsFor: 'lint'!tempVarOverridesInstVar	| temporaryVariable |	temporaryVariable := 4.	^temporaryVariable! !!RefactoryTestDataApp methodsFor: 'lint'!tempsReadBeforeWritten	| temp |	self isVariable ifTrue: [temp := 4].	^temp! !!RefactoryTestDataApp methodsFor: 'test'!testFoo: anObject	^self class + anObject! !!RefactoryTestDataApp methodsFor: 'test'!testMethod	^self class! !!RefactoryTestDataApp methodsFor: 'test'!testMethod1	^self testMethod1 		, ([:each | each testMethod1] value: #(#(#testMethod1) 2 #testMethod1))! !!RefactoryTestDataApp methodsFor: 'lint'!threeElementPoint	^5 @ 5 + 6 @ 6! !!RefactoryTestDataApp methodsFor: 'lint'!toDo	1 to: self size do: [:i | (self at: i) printString]! !!RefactoryTestDataApp methodsFor: 'lint'!toDoCollect	| array |	array := Array new: 10.	1 to: 10 do: [:i | array at: i put: i * i].	^array! !!RefactoryTestDataApp methodsFor: 'lint'!toDoWithIncrement	| counter |	counter := 0.	1 to: 10		by: 2		do: [:i | counter := counter + 2].	^counter! !!RefactoryTestDataApp methodsFor: 'lint'!usesAdd	^(1 to: 10) asOrderedCollection addAll: (11 to: 20)! !!RefactoryTestDataApp methodsFor: 'lint' stamp: 'nk 2/25/2005 16:50'!variableAssignedLiteral	temporaryVariable := #() ! !!RefactoryTestDataApp methodsFor: 'lint'!whileTrue	| i |	i := 1.	[i < self size] whileTrue: 			[(self at: i) printString.			i := i + 1]! !!RefactoryTestDataApp methodsFor: 'lint'!yourselfNotUsed	self		printString;		printString;		yourself! !!RefactoryTyper class methodsFor: 'instance creation'!newFor: aRBNamespace 	^(self new)		model: aRBNamespace;		yourself! !!RefactoryTyper class methodsFor: 'accessing'!typesFor: variableName in: aParseTree model: aRBSmalltalk 	| searcher messages |	searcher := ParseTreeSearcher new.	searcher matches: variableName , ' `@message: ``@args'		do: 			[:aNode :answer | 			answer				add: aNode selector;				yourself].	messages := searcher executeTree: aParseTree initialAnswer: Set new.	^(self new)		model: aRBSmalltalk;		findTypeFor: messages! !!RefactoryTyper methodsFor: 'printing'!collectionNameFor: aString 	^'-<1s>-' expandMacrosWith: aString! !!RefactoryTyper methodsFor: 'equivalence classes'!computeEquivalenceClassesForMethodsAndVars	| searcher |	bindings := Set new.	backpointers := Dictionary new.	class instanceVariableNames 		do: [:each | backpointers at: each put: (bindings add: (Set with: each))].	class withAllSubclasses do: 			[:sub | 			sub selectors 				do: [:each | backpointers at: each put: (bindings add: (Set with: each))]].	searcher := ParseTreeSearcher new.	searcher matches: '^``@object'		do: [:aNode :answer | self processNode: aNode value].	self executeSearch: searcher! !!RefactoryTyper methodsFor: 'selectors'!computeMessagesSentToVariables	| searcher |	variableMessages := Dictionary new.	class instanceVariableNames 		do: [:each | variableMessages at: each put: Set new].	searcher := ParseTreeSearcher new.	class instanceVariableNames do: 			[:each | 			| block |			block := 					[:aNode :answer | 					(variableMessages at: each ifAbsentPut: [Set new]) add: aNode selector.					self processCollectionMessagesFor: each in: aNode].			searcher matches: each , ' `@messageName: ``@args' do: block.			(backpointers at: each) do: 					[:sel | 					sel isSymbol 						ifTrue: 							[searcher 								matches: ('(self <1s>) `@messageName: ``@args' 										expandMacrosWith: (ParseTreeSearcher buildSelectorString: sel)) asString								do: block]]].	searcher answer: variableMessages.	self executeSearch: searcher! !!RefactoryTyper methodsFor: 'computing types'!computeTypes	variableMessages		keysAndValuesDo: [:key :value | variableTypes at: key put: (self findTypeFor: value)]! !!RefactoryTyper methodsFor: 'private'!executeSearch: searcher 	class withAllSubclasses do: 			[:each | 			each selectors do: 					[:sel | 					| parseTree |					methodName := sel.					parseTree := each parseTreeFor: sel.					parseTree notNil ifTrue: [searcher executeTree: parseTree]]]! !!RefactoryTyper methodsFor: 'computing types'!findTypeFor: selectorCollection 	^selectorCollection inject: model rootClasses		into: 			[:classes :each | 			self refineTypes: classes				with: (selectorLookup at: each ifAbsentPut: [self implementorsOf: each])]! !!RefactoryTyper methodsFor: 'assignments'!guessTypeFromAssignment: aNode 	| type set newType |	type := nil.	aNode value isAssignment 		ifTrue: 			[^self guessTypeFromAssignment: (RBAssignmentNode variable: aNode variable						value: aNode value value)].	aNode value isBlock ifTrue: [type := model classFor: [] class].	aNode value isLiteral 		ifTrue: 			[aNode value value isNil ifTrue: [^self].			type := model classFor: (self typeFor: aNode value value)].	aNode value isMessage 		ifTrue: 			[aNode value receiver isVariable 				ifTrue: [type := model classNamed: aNode value receiver name asSymbol].			aNode value selector == #asValue 				ifTrue: [type := model classNamed: #ValueHolder].			(#(#and: #or: #= #== #~= #~~ #<= #< #~~ #> #>=) 				includes: aNode value selector) ifTrue: [type := model classFor: Boolean]].	type isNil ifTrue: [^self].	set := variableTypes at: aNode variable name.	newType := set detect: [:each | type includesClass: each] ifNone: [nil].	newType isNil ifTrue: [^self].	newType = (model classFor: Object) ifTrue: [newType := type].	(bestGuesses at: aNode variable name ifAbsentPut: [Set new]) add: newType! !!RefactoryTyper methodsFor: 'accessing'!guessTypesFor: anInstVarName 	^bestGuesses at: anInstVarName ifAbsent: [self typesFor: anInstVarName]! !!RefactoryTyper methodsFor: 'accessing'!guessTypesFor: anInstVarName in: aClass 	class = aClass ifFalse: [self runOn: aClass].	^bestGuesses at: anInstVarName		ifAbsent: [self typesFor: anInstVarName in: aClass]! !!RefactoryTyper methodsFor: 'computing types'!implementorsOf: aSelector 	| classes |	classes := OrderedCollection new.	model rootClasses do: 			[:each | 			self 				implementorsOf: aSelector				in: each				storeIn: classes].	^classes! !!RefactoryTyper methodsFor: 'computing types'!implementorsOf: aSelector in: aClass storeIn: classes 	(aClass directlyDefinesMethod: aSelector) 		ifTrue: 			[classes add: aClass.			^self].	aClass subclasses do: 			[:each | 			self 				implementorsOf: aSelector				in: each				storeIn: classes]! !!RefactoryTyper methodsFor: 'initialize-release'!initialize	model := RBNamespace new.	class := model classFor: Object.	variableTypes := Dictionary new.	variableMessages := Dictionary new.	selectorLookup := IdentityDictionary new.	bestGuesses := Dictionary new! !!RefactoryTyper methodsFor: 'equivalence classes' stamp: 'rr 3/15/2004 14:06'!merge: aName 	"rr 3/15/2004 14:05 add: the ifAbsent: keyword in the last line, as I encountered a failing case"	| set1 set2 |	set1 := backpointers at: methodName ifAbsent: [nil].	set2 := backpointers at: aName ifAbsent: [nil].	(set1 isNil or: [set2 isNil or: [set1 == set2]]) ifTrue: [^self].	set1 addAll: set2.	set2 do: [:each | backpointers at: each put: set1].	bindings remove: set2 ifAbsent: [] ! !!RefactoryTyper methodsFor: 'private'!model	^model! !!RefactoryTyper methodsFor: 'private'!model: aRBSmalltalk	model := aRBSmalltalk! !!RefactoryTyper methodsFor: 'printing'!printOn: aStream 	aStream		nextPutAll: class name;		cr.	class instanceVariableNames do: 			[:each | 			aStream				tab;				nextPutAll: each;				tab;				nextPut: $<.			self printTypeFor: each on: aStream.			aStream				nextPut: $>;				cr]! !!RefactoryTyper methodsFor: 'printing'!printType: aClass for: aString on: aStream 	| name colTypes |	colTypes := #().	name := self collectionNameFor: aString.	(aClass includesClass: (model classFor: Collection))		ifTrue: [colTypes := self guessTypesFor: name].	colTypes isEmpty ifFalse: [aStream nextPut: $(].	aClass printOn: aStream.	colTypes isEmpty		ifFalse: 			[aStream nextPutAll: ' of: '.			colTypes size > 1 ifTrue: [aStream nextPut: $(].			self printTypeFor: name on: aStream.			colTypes size > 1 ifTrue: [aStream nextPut: $)]].	colTypes isEmpty ifFalse: [aStream nextPut: $)]! !!RefactoryTyper methodsFor: 'printing'!printTypeFor: aString on: aStream 	| types |	types := (self guessTypesFor: aString) 				asSortedCollection: [:a :b | a name < b name].	1 to: types size		do: 			[:i | 			i == 1 ifFalse: [aStream nextPutAll: ' | '].			self 				printType: (types at: i)				for: aString				on: aStream]! !!RefactoryTyper methodsFor: 'selectors-collections'!processCollectionFor: key messagesTo: aName in: aBlock 	| searcher |	searcher := ParseTreeSearcher new.	searcher matches: aName , ' `@message: ``@args'		do: 			[:aNode :answer | 			self processCollectionMessagesFor: key in: aNode.			answer				add: aNode selector;				yourself].	searcher executeTree: aBlock		initialAnswer: (variableMessages at: (self collectionNameFor: key)				ifAbsentPut: [Set new])! !!RefactoryTyper methodsFor: 'selectors-collections'!processCollectionMessagesFor: variableName in: aParseTree 	| parent block |	aParseTree isMessage ifFalse: [^self].	(#(#first #at: #last) includes: aParseTree selector) 		ifTrue: 			[parent := aParseTree parent.			(parent notNil and: [parent isMessage]) ifFalse: [^self].			aParseTree == parent receiver ifFalse: [^self].			(variableMessages at: (self collectionNameFor: variableName)				ifAbsentPut: [Set new]) add: parent selector.			self processCollectionMessagesFor: (self collectionNameFor: variableName)				in: parent].	(#(#do: #do:separatedBy: #collect: #reject: #select: #detect: #detect:ifNone:) 		includes: aParseTree selector) 			ifTrue: 				[block := aParseTree arguments first.				block isBlock ifFalse: [^self].				self 					processCollectionFor: variableName					messagesTo: block arguments first name					in: block].	#inject:into: == aParseTree selector 		ifTrue: 			[block := aParseTree arguments last.			block isBlock ifFalse: [^self].			self 				processCollectionFor: variableName				messagesTo: block arguments last name				in: block]! !!RefactoryTyper methodsFor: 'equivalence classes'!processNode: aNode 	(aNode isVariable and: [class instanceVariableNames includes: aNode name]) 		ifTrue: [^self merge: aNode name].	(aNode isMessage 		and: [aNode receiver isVariable and: [aNode receiver name = 'self']]) 			ifTrue: [^self merge: aNode selector].	aNode isAssignment 		ifTrue: 			[self				processNode: aNode value;				processNode: aNode variable].	(aNode isMessage and: 			[#(#ifTrue: #ifFalse: #ifTrue:ifFalse: #ifFalse:ifTrue:) 				includes: aNode selector]) 		ifTrue: 			[aNode arguments do: 					[:each | 					each isBlock 						ifTrue: 							[each body statements isEmpty 								ifFalse: [self processNode: each body statements last]]]]! !!RefactoryTyper methodsFor: 'computing types'!refineTypes: aClassCollection with: anotherClassCollection 	| classSet |	classSet := Set new.	aClassCollection do: 			[:each | 			anotherClassCollection do: 					[:cls | 					(cls includesClass: each) 						ifTrue: [classSet add: cls]						ifFalse: [(each includesClass: cls) ifTrue: [classSet add: each]]]].	^classSet! !!RefactoryTyper methodsFor: 'assignments'!refineTypesByLookingAtAssignments	| searcher needsSearch |	needsSearch := false.	searcher := ParseTreeSearcher new.	variableTypes keysAndValuesDo: 			[:key :value | 			(key first == $-) 				ifFalse: 					[needsSearch := true.					searcher matches: key , ' := ``@object'						do: [:aNode :answer | self guessTypeFromAssignment: aNode]]].	needsSearch ifTrue: [self executeSearch: searcher]! !!RefactoryTyper methodsFor: 'private'!rootClasses	^Class rootsOfTheWorld! !!RefactoryTyper methodsFor: 'accessing'!runOn: aClass 	variableTypes := Dictionary new.	variableMessages := Dictionary new.	bestGuesses := Dictionary new.	class := model classFor: aClass.	class instanceVariableNames isEmpty ifTrue: [^self].	self		selectedClass: aClass;		computeEquivalenceClassesForMethodsAndVars;		computeMessagesSentToVariables;		computeTypes;		refineTypesByLookingAtAssignments! !!RefactoryTyper methodsFor: 'accessing'!selectedClass: aClass 	class := model classFor: aClass! !!RefactoryTyper methodsFor: 'assignments' stamp: 'bh 4/3/2000 11:52'!typeFor: anObject 	'' class == anObject class ifTrue: [^String].	^( {true. false} includes: anObject) 		ifTrue: [Boolean]		ifFalse: [anObject class]! !!RefactoryTyper methodsFor: 'accessing'!typesFor: anInstVarName 	^variableTypes at: anInstVarName ifAbsent: [Set new]! !!RefactoryTyper methodsFor: 'accessing'!typesFor: anInstVarName in: aClass 	class = aClass ifFalse: [self runOn: aClass].	^variableTypes at: anInstVarName ifAbsent: [Set new]! !!SmalllintChecker class methodsFor: 'instance creation'!newWithContext	^(self new)		context: SmalllintContext new;		yourself! !!SmalllintChecker class methodsFor: 'instance creation' stamp: 'nk 11/12/2002 13:12'!runRule: aLintRule	(self new)		rule: aLintRule;		run.	^aLintRule! !!SmalllintChecker class methodsFor: 'instance creation'!runRule: aLintRule onEnvironment: aBrowserEnvironment 	(self new)		rule: aLintRule;		environment: aBrowserEnvironment;		run.	^aLintRule! !!SmalllintChecker methodsFor: 'private'!checkClass: aClass 	context selectedClass: aClass.	(environment definesClass: aClass) ifTrue: [rule checkClass: context]! !!SmalllintChecker methodsFor: 'private'!checkMethodsForClass: aClass 	^environment selectorsForClass: aClass		do: 			[:each | 			context selector: each.			rule checkMethod: context.			methodBlock value]! !!SmalllintChecker methodsFor: 'accessing'!context: aSmalllintContext 	context := aSmalllintContext! !!SmalllintChecker methodsFor: 'accessing'!environment: aBrowserEnvironment 	environment := aBrowserEnvironment! !!SmalllintChecker methodsFor: 'initialize-release'!initialize	methodBlock := [].	environment := SelectorEnvironment new.	context := SmalllintContext newNoCache! !!SmalllintChecker methodsFor: 'accessing'!methodBlock: aBlock 	methodBlock := aBlock! !!SmalllintChecker methodsFor: 'initialize-release'!release	context release.	super release! !!SmalllintChecker methodsFor: 'accessing'!rule: aLintRule 	rule := aLintRule! !!SmalllintChecker methodsFor: 'actions'!run	rule resetResult.	environment classesDo: 			[:aClass | 			self checkClass: aClass.			self checkMethodsForClass: aClass]! !!SmalllintContext class methodsFor: 'instance creation'!newNoCache	^self basicNew! !!SmalllintContext methodsFor: 'private' stamp: 'md 8/2/2005 23:19'!addLiteralsFor: aCompiledMethod 	aCompiledMethod literalsDo: [:literal | self checkLiteral: literal]! !!SmalllintContext methodsFor: 'private'!buildParseTree	| tree |	tree := self selectedClass parseTreeFor: self selector.	tree isNil ifTrue: [^RBParser parseMethod: 'method'].	^tree! !!SmalllintContext methodsFor: 'private'!checkLiteral: aLiteral 	(aLiteral isSymbol or: [aLiteral isVariableBinding])		ifTrue: [literals add: aLiteral]		ifFalse: 			[aLiteral class == Array				ifTrue: [aLiteral do: [:each | self checkLiteral: each]]]! !!SmalllintContext methodsFor: 'accessing'!compiledMethod	^compiledMethod notNil		ifTrue: [compiledMethod]		ifFalse: [compiledMethod := class compiledMethodAt: selector]! !!SmalllintContext methodsFor: 'private'!computeLiterals	literalSemaphore := Semaphore new.	literalProcess := [self primitiveComputeLiterals] fork! !!SmalllintContext methodsFor: 'private'!computeLiteralsForClass: aClass 	(selectors addAll: aClass selectors) do: 			[:sel | 			self computeLiteralsForSelector: sel in: aClass.			Processor yield]! !!SmalllintContext methodsFor: 'private'!computeLiteralsForSelector: aSelector in: aClass 	| method |	method := aClass compiledMethodAt: aSelector ifAbsent: [nil].	method isNil ifTrue: [^self].	self addLiteralsFor: method! !!SmalllintContext methodsFor: 'private'!computeMessages	| searcher |	selfMessages := Set new.	superMessages := Set new.	messages := Set new.	searcher := ParseTreeSearcher new.	searcher		matches: 'self `@message: ``@args'			do: [:aNode :answer | selfMessages add: aNode selector];		matches: 'super `@message: ``@args'			do: [:aNode :answer | superMessages add: aNode selector];		matches: '``@receiver `@message: ``@args'			do: [:aNode :answer | messages add: aNode selector].	searcher executeTree: self parseTree initialAnswer: nil! !!SmalllintContext methodsFor: 'testing'!implements: aSelector 	^self selectors includes: aSelector! !!SmalllintContext methodsFor: 'initialize-release'!initialize	self computeLiterals! !!SmalllintContext methodsFor: 'accessing'!instVarNames	^self selectedClass allInstVarNames! !!SmalllintContext methodsFor: 'testing'!isAbstract: aClass 	^(aClass isMeta or: 			[(self literals includes: aClass name)				or: [self literals includes: (Smalltalk associationAt: aClass name)]])		not! !!SmalllintContext methodsFor: 'accessing'!literals	literalSemaphore isNil		ifTrue: 			[literals isNil ifTrue: 					[self computeLiterals.					literalSemaphore wait]]		ifFalse: [literalSemaphore wait].	^literals! !!SmalllintContext methodsFor: 'accessing'!messages	messages isNil ifTrue: [self computeMessages].	^messages! !!SmalllintContext methodsFor: 'accessing'!parseTree	^parseTree isNil		ifTrue: [parseTree := self buildParseTree]		ifFalse: [parseTree]! !!SmalllintContext methodsFor: 'private' stamp: 'dvf 8/27/2003 14:35'!primitiveComputeLiterals	| semaphore |	literals := IdentitySet new: 25000.	literals addAll: self specialSelectors keys.	selectors := IdentitySet new.	SystemNavigation new allBehaviorsDo: [:aClass | self computeLiteralsForClass: aClass].	semaphore := literalSemaphore.	literalSemaphore := nil.	self signalProcesses: semaphore.	^literalProcess := nil! !!SmalllintContext methodsFor: 'accessing'!protocol	^self selectedClass whichCategoryIncludesSelector: self selector! !!SmalllintContext methodsFor: 'accessing'!protocols	^Array with: self protocol! !!SmalllintContext methodsFor: 'initialize-release'!release	literalProcess notNil ifTrue: [literalProcess terminate].	super release! !!SmalllintContext methodsFor: 'accessing'!selectedClass	^class! !!SmalllintContext methodsFor: 'accessing'!selectedClass: anObject 	class := anObject.	self selector: nil! !!SmalllintContext methodsFor: 'accessing'!selector	^selector! !!SmalllintContext methodsFor: 'accessing'!selector: anObject 	selector := anObject.	parseTree := compiledMethod := selfMessages := superMessages := messages := nil! !!SmalllintContext methodsFor: 'accessing'!selectors	literalSemaphore isNil		ifTrue: 			[selectors isNil ifTrue: 					[self computeLiterals.					literalSemaphore wait]]		ifFalse: [literalSemaphore wait].	^selectors! !!SmalllintContext methodsFor: 'accessing'!selfMessages	selfMessages isNil ifTrue: [self computeMessages].	^selfMessages! !!SmalllintContext methodsFor: 'private'!signalProcesses: aSemaphore 	aSemaphore isNil ifTrue: [^self].	[aSemaphore isEmpty] whileFalse: [aSemaphore signal]! !!SmalllintContext methodsFor: 'accessing' stamp: 'nk 2/26/2005 10:19'!sourceCode	^self selectedClass sourceCodeAt: self selector ifAbsent: [ '' ].! !!SmalllintContext methodsFor: 'private' stamp: 'dvf 9/15/2001 17:39'!specialSelectors	| answer |	answer := IdentityDictionary new.	(Smalltalk specialSelectors select: [:sel | sel isSymbol]) do:		[:sel | answer at: sel put: nil.].	^answer.! !!SmalllintContext methodsFor: 'accessing'!superMessages	superMessages isNil ifTrue: [self computeMessages].	^superMessages! !!SmalllintContext methodsFor: 'testing'!uses: anObject 	^self literals includes: anObject! !!RefactoringWarning methodsFor: 'private - actions'!defaultAction	"Proceed through warnings"	^nil! !!RefactoringWarning methodsFor: 'description' stamp: 'dvf 11/12/2002 00:47'!isResumable	^true.! !!ClassDescription methodsFor: '*RefactoringEngine-UI' stamp: 'bh 5/16/2000 23:37'!chooseClassVarAlphabeticallyThenDo: aBlock	| allVars index |	allVars := self allClassVarNames asSortedArray.	allVars isEmpty ifTrue: [^ self inform: 'There are noclass variables'].	index := (PopUpMenu labelArray: allVars lines: #()) startUpWithCaption: 'Class variables in', self name.	index = 0 ifTrue: [^ self].	aBlock value: (allVars at: index)! !!ClassDescription methodsFor: '*RefactoringEngine-UI' stamp: 'bh 5/16/2000 23:36'!chooseClassVarThenDo: aBlock 	| lines labelStream vars allVars index count offerAlpha |	(count := self allClassVarNames size) = 0 ifTrue: 		[^ self inform: 'There are noclass variables.'].	allVars := OrderedCollection new.	lines := OrderedCollection new.	labelStream := WriteStream on: (String new: 200).	(offerAlpha := count > 5)		ifTrue:			[lines add: 1.			allVars add: 'show alphabetically'.			labelStream nextPutAll: allVars first; cr].	self withAllSuperclasses reverseDo:		[:class |		vars := class classVarNames.		vars do:			[:var |			labelStream nextPutAll: var; cr.			allVars add: var].		vars isEmpty ifFalse: [lines add: allVars size]].	labelStream skip: -1 "cut last CR".	(lines size > 0 and: [lines last = allVars size]) ifTrue:		[lines removeLast].  "dispense with inelegant line beneath last item"	index := (PopUpMenu labels: labelStream contents lines: lines)startUpWithCaption: 'Class variables in', self name.	index = 0 ifTrue: [^ self].	(index = 1 and: [offerAlpha]) ifTrue: [^ selfchooseClassVarAlphabeticallyThenDo: aBlock].	aBlock value: (allVars at: index)! !!ClassDescription methodsFor: '*RefactoringEngine-UI' stamp: 'bh 5/16/2000 23:38'!chooseSubclassesClassVarThenDo: aBlock 	| allVars index labelStream |	allVars := self allSubclasses inject:SortedCollection new into:		[:answer :each|		answer addAll:each classVarNames; yourself.].	allVars isEmpty ifTrue:[^self inform: 'There are no class variables in subclasses.'].	labelStream := WriteStream on: (String new: 200).	allVars do: [:var| labelStream nextPutAll:var;cr].		index := (PopUpMenu labels: labelStream contents lines: #()) startUpWithCaption: 'Select class variable:'.	index = 0 ifTrue: [^ self].	aBlock value:(allVars at: index).! !!ClassDescription methodsFor: '*RefactoringEngine-UI' stamp: 'bh 5/16/2000 22:25'!chooseSubclassesInstVarThenDo: aBlock 	"Put up a menu of all the instance variables in the receiver, and whenthe user chooses one, evaluate aBlock with the chosen variable as itsparameter.  If the list is 6 or larger, then offer an alphabeticalformulation as an alternative. triggered by a 'show alphabetically' itemat the top of the list."	| allVars index labelStream |	allVars := self allSubclasses inject:SortedCollection new into:		[:answer :each|		answer addAll:each instVarNames; yourself.].	allVars isEmpty ifTrue:[^self inform: 'There are no instance variables in subclasses.'].	labelStream := WriteStream on: (String new: 200).	allVars do: [:var| labelStream nextPutAll:var;cr].		index := (PopUpMenu labels: labelStream contents lines: #()) startUpWithCaption: 'Select instance variable:'.	index = 0 ifTrue: [^ self].	aBlock value:(allVars at: index).! !!ClassDescription methodsFor: '*RefactoringEngine-UI' stamp: 'bh 5/16/2000 23:39'!chooseThisClassClassVarThenDo: aBlock 	| allVars index labelStream |	allVars := self classVarNames asSortedCollection.	allVars isEmpty ifTrue:[^self inform: 'There are no class variables.'].	labelStream := WriteStream on: (String new: 200).	allVars do: [:var| labelStream nextPutAll:var;cr].		index := (PopUpMenu labels: labelStream contents lines: #()) startUpWithCaption: 'Select class variable:'.	index = 0 ifTrue: [^ self].	aBlock value:(allVars at: index).! !!ClassDescription methodsFor: '*RefactoringEngine-UI' stamp: 'bh 5/16/2000 22:45'!chooseThisClassInstVarThenDo: aBlock 	"Put up a menu of all the instance variables in the receiver, and whenthe user chooses one, evaluate aBlock with the chosen variable as itsparameter.  If the list is 6 or larger, then offer an alphabeticalformulation as an alternative. triggered by a 'show alphabetically' itemat the top of the list."	| allVars index labelStream |	allVars := self instVarNames asSortedCollection.	allVars isEmpty ifTrue:[^self inform: 'There are no instance variables.'].	labelStream := WriteStream on: (String new: 200).	allVars do: [:var| labelStream nextPutAll:var;cr].		index := (PopUpMenu labels: labelStream contents lines: #()) startUpWithCaption: 'Select instance variable:'.	index = 0 ifTrue: [^ self].	aBlock value:(allVars at: index).! !!RefactoringBrowser class methodsFor: 'class initialization' stamp: 'nk 3/4/2005 12:46'!hierarchyBrowserIsRBPreferenceChanged	(Preferences valueOfPreference: #hierarchyBrowserIsRB)		ifTrue: [ HierarchyBrowser superclass == self			ifFalse: [ HierarchyBrowser superclass: self ]]		ifFalse: [ HierarchyBrowser superclass == self			ifTrue: [  HierarchyBrowser superclass: Browser  ]]! !!RefactoringBrowser class methodsFor: 'class initialization' stamp: 'nk 3/4/2005 07:56'!initialize	"self initialize"	TheWorldMenu registerOpenCommand: {'Refactoring Browser'. {self. #openBrowser}}.	self registerInAppRegistry.	Preferences addPreference: #hierarchyBrowserIsRB		categories: #(browsing)		default: true		balloonHelp: 'if true, the HierarchyBrowser will be a kind of RefactoringBrowser'		projectLocal: false		changeInformee: self		changeSelector: #hierarchyBrowserIsRBPreferenceChanged.	self hierarchyBrowserIsRBPreferenceChanged ! !!RefactoringBrowser class methodsFor: 'instance creation' stamp: 'nk 7/30/2004 16:13'!newOnEnvironment: aBrowserEnvironment	^self new initializeOnEnvironment: aBrowserEnvironment.! !!RefactoringBrowser class methodsFor: 'instance creation' stamp: 'jf 7/24/2005 00:55'!openBrowser	"Create and schedule a BrowserView with label 'RB'. The 	view consists of five subviews, starting with the list view of system 	categories of SystemOrganization. The initial text view part is empty."	self openBrowserView: (self new openEditString: nil)			label: 'RB'! !!RefactoringBrowser class methodsFor: 'instance creation' stamp: 'nk 7/30/2004 16:09'!openOnEnvironment: aBrowserEnvironment		^(self newOnEnvironment: aBrowserEnvironment) open.! !!RefactoringBrowser class methodsFor: 'class initialization' stamp: 'nk 3/4/2005 12:46'!unload	"Called when the class is being removed"	TheWorldMenu unregisterOpenCommandWithReceiver: self.	Preferences removePreference: #hierarchyBrowserIsRB.	HierarchyBrowser superclass == self		ifTrue: [  HierarchyBrowser superclass: Browser  ].! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:40'!abstractClassVar	| name |	name := self selectClassVar.	name isEmpty ifTrue: [^self].	self abstractClassVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/19/2000 23:52'!abstractClassVar: aString 	self performRefactoring: (AbstractClassVariableRefactoring 				variable: aString asSymbol				class: (self nonMetaClass whichClassDefinesClassVar: aString))! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:39'!abstractInstVar	| name |	name := self selectInstVar.	name isEmpty ifTrue: [^self].	self abstractInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:02'!abstractInstVar: aString 	self 		performRefactoring: (AbstractInstanceVariableRefactoring variable: aString				class: (self selectedClassOrMetaClass whichClassDefinesInstVar: aString))! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 01:00'!abstractSelectedInstVar	| name |	name := self selectedVariableName.	name isEmpty ifTrue: [^self].	self abstractInstVar: name! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:24'!addClassSubMenuTo: aMenu 	| findSubMenu rewriteSubMenu lintSubMenu lastBrowse pkg |	World ifNil: [^aMenu].	pkg := self packageForSelectedCategory.	findSubMenu := (MenuMorph new)				defaultTarget: self;				add: 'code in class...' translated action: #finderOnClass;				add: 'code in class hierarchy...' translated					action: #finderOnClassHierarchy;				add: 'code in class category...' translated action: #finderOnClassCategory;				yourself.	pkg ifNotNil: 			[findSubMenu add: 'code in package...' translated				action: #finderOnPackageWithClassCategory].	rewriteSubMenu := (MenuMorph new)				defaultTarget: self;				add: 'code in class...' translated action: #rewriteToolOnClass;				add: 'code in class hierarchy...' translated					action: #rewriteToolOnClassHierarchy;				add: 'code in class category...' translated					action: #rewriteToolOnClassCategory;				yourself.	pkg ifNotNil: 			[rewriteSubMenu add: 'code in package...' translated				action: #rewriteToolOnPackageWithClassCategory].	lintSubMenu := (MenuMorph new)				defaultTarget: self;				addLine;				add: 'on class...' translated action: #lintOnClass;				add: 'on class category...' translated action: #lintOnClassCategory;				add: 'on class hierarchy...' translated action: #lintOnClassHierarchy;				yourself.	pkg ifNotNil: 			[lintSubMenu add: 'on package...' translated				action: #lintOnPackageWithClassCategory].	aMenu defaultTarget: aMenu.	lastBrowse := 4.	pkg ifNotNil: 			[aMenu				add: 'browse package ' , pkg packageName					target: self					action: #browsePackageWithClassCategory;				addMorph: aMenu submorphs last asElementNumber: 4.			lastBrowse := 5].	aMenu		add: 'browse category' translated			target: self			action: #browseSelectedClassCategory;		addMorph: aMenu submorphs last asElementNumber: lastBrowse.	aMenu		add: 'find...' subMenu: findSubMenu;		add: 'rewrite...' subMenu: rewriteSubMenu;		add: 'lint...' subMenu: lintSubMenu;		addLine;		add: 'class'			subMenu: ((MenuMorph new)					defaultTarget: self;					addLine;					add: 'references...' translated action: #classRefs;					add: 'create subclass...' translated action: #createSubclass;					add: 'rename as...' translated action: #rbRenameClass;					add: 'remove...' translated action: #removeClass;					add: 'safe remove' translated action: #removeClassSafe;					add: 'convert to sibling' translated action: #convertToSibling;					add: 'inspect all instances...' translated action: #inspectAllInstances;					add: 'find reference path to an instance...' translated						action: #findReferencePathToInstance;					add: 'find all reference paths to an instance...' translated						action: #findAllReferencesToInstances;					add: 'check protocols...' translated action: #checkProtocols;					yourself)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 10:17'!addClassVar	self changeRequest ifFalse: [^self].	self addClassVarIn: self nonMetaClass.	self changedClass! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 10:19'!addClassVarIn: aClass 	| newName |	newName := self requestClassVarName: ''.	newName isNil ifTrue: [^self].	self handleError: 			[(AddClassVariableRefactoring variable: newName class: aClass) execute]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!addClassVariableSubMenuTo: aMenu 	World ifNotNil: 			[aMenu defaultTarget: aMenu.			aMenu add: 'class variables'				subMenu: ((MenuMorph new)						defaultTarget: self;						add: 'references...' translated action: #classVarRefs;						add: 'add...' translated action: #addClassVar;						add: 'rename as...' translated action: #renameClassVar;						add: 'remove...' translated action: #removeClassVar;						add: 'push down...' translated action: #pushDownClassVar;						add: 'pull up...' translated action: #pullUpClassVar;						add: 'create accessors...' translated action: #createClassVarAccessors;						add: 'abstract...' translated action: #abstractClassVar;						yourself)]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:02'!addInstVar	self changeRequest ifFalse: [^self].	self addInstVarIn: self selectedClassOrMetaClass.	self changedClass! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 10:21'!addInstVarIn: aClass 	| newName |	newName := self requestInstVarName: ''.	newName isNil ifTrue: [^self].	self handleError: 			[(AddInstanceVariableRefactoring variable: newName class: aClass) execute]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!addInstanceVariableSubMenuTo: aMenu 	World ifNotNil: 			[aMenu defaultTarget: aMenu.			aMenu add: 'instance variables'				subMenu: ((MenuMorph new)						defaultTarget: self;						add: 'references...' translated action: #instVarRefs;						add: 'readers...' translated action: #instVarReaders;						add: 'writers...' translated action: #instVarWriters;						add: 'add...' translated action: #addInstVar;						add: 'rename as...' translated action: #renameInstVar;						add: 'remove...' translated action: #removeInstVar;						add: 'push down...' translated action: #pushDownInstVar;						add: 'pull up...' translated action: #pullUpInstVar;						add: 'create accessors...' translated action: #createInstVarAccessors;						add: 'abstract...' translated action: #abstractInstVar;						add: 'protect/concrete...' translated action: #protectInstVar;						yourself)]! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'nk 7/30/2004 17:57'!addParameter	| newSelector aCollection |	messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	newSelector := self addParameterTo: self selector				in: self selectedClassOrMetaClass.	newSelector isNil ifTrue: [^self].	aCollection := Array with: newSelector.	self changed: #messageList.	self changedSelector.	Beeper  beep! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'dvf 9/30/2001 02:16'!addParameterTo: aSelector in: aClass 	| initializer newSelector initialAnswer |	initialAnswer := aSelector numArgs == 0 				ifTrue: [aSelector , ':']				ifFalse: [aSelector].	newSelector := self request: 'Enter new selector:'				initialAnswer: initialAnswer.	newSelector isEmpty ifTrue: [^nil].	initializer := self request: 'Enter default value for parameter:'				initialAnswer: 'nil'.	initializer isEmpty ifTrue: [^nil].	^self handleError: 			[(AddParameterRefactoring 				addParameterToMethod: aSelector				in: aClass				newSelector: newSelector asSymbol				initializer: initializer) execute.			newSelector]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 12:24'!addSelectionSubMenuTo: aMenu	| title subMenu |	World ifNotNil: 		[aMenu defaultTarget: aMenu.		title := 'selection...'.		subMenu := self selectMenu. 		aMenu add: title subMenu: subMenu]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!assignmentMenuFor: aNode 	^(MenuMorph new)		defaultTarget: self;		add: 'inline temporary' translated action: #inlineTemporary;		yourself! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:02'!bindTight	self performRefactoring: (MoveVariableDefinitionRefactoring 				bindTight: (self convertToSourceInterval: self selectedInterval)				in: self selectedClassOrMetaClass				selector: self selector)! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:49'!browseAllCallsOn: aSymbol	((BrowserEnvironment new)			referencesTo: aSymbol) openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:23'!browseAllCallsOn: aSymbol localTo: aClass 	| localClasses |	aClass ifNil: [ ^self inform: 'no class selected' ].	localClasses := OrderedCollection new.	aClass withAllSubAndSuperclassesDo: [ :cls | localClasses add: cls ].	((BrowserEnvironment new forClasses: localClasses)			referencesTo: aSymbol) openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/28/2005 08:05'!browseAllImplementorsOf: aSymbol	((BrowserEnvironment new)			implementorsOf: aSymbol) openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:23'!browseAllImplementorsOf: aSymbol localTo: aClass 	| localClasses |	aClass ifNil: [ ^self inform: 'no class selected' ].	localClasses := OrderedCollection new.	aClass withAllSubAndSuperclassesDo: [ :cls | localClasses add: cls ].	((BrowserEnvironment new forClasses: localClasses)			implementorsOf: aSymbol) openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:40'!browseAllMessages	"Create and schedule a message set browser on all implementors of all the messages sent by the current method."	| aName method filteredList result |	(aName := self selectedMessageName) ifNotNil: 			[method := self selectedClassOrMetaClass compiledMethodAt: aName.			filteredList := method messages 						reject: [:each | #(#new #initialize #=) includes: each].			filteredList := filteredList inject: Set new						into: 							[:s :sel | 							s								addAll: (self systemNavigation allImplementorsOf: sel);								yourself].			result := SelectorEnvironment new.			filteredList 				do: [:mr | result addClass: mr actualClass selector: mr methodSymbol].			result openEditor]! !!RefactoringBrowser methodsFor: 'message list menu' stamp: 'nk 2/27/2005 15:54'!browseClassRefs	| cls association |	(cls := self selectedClass) ifNotNil: [	association := Smalltalk associationAt: cls theNonMetaClass name ifAbsent: [^self].	self navigator browseGlobalReferencesTo: association ].! !!RefactoringBrowser methodsFor: 'message list menu' stamp: 'nk 2/27/2005 15:52'!browseClassVarRefs	| name association |	name := self selectClassVar.	name isEmptyOrNil ifTrue: [^self].	association := self navigator findAssociationForClassVariable: name.	self navigator browseGlobalReferencesTo: association in: self nonMetaClass! !!RefactoringBrowser methodsFor: 'message list menu' stamp: 'nk 2/27/2005 16:00'!browseClassVariables	self browseClassVarRefs! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/20/2000 11:15'!browseGlobalInstVarReadersTo: instVar in: aClass 	self showWaitCursorWhile: 			[(BrowserEnvironment new instVarReadersTo: instVar in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/20/2000 00:01'!browseGlobalInstVarRefsTo: instVar in: aClass 	self showWaitCursorWhile: 			[(BrowserEnvironment new instVarRefsTo: instVar in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/20/2000 11:15'!browseGlobalInstVarWritersTo: instVar in: aClass 	self showWaitCursorWhile: 			[(BrowserEnvironment new instVarWritersTo: instVar in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/19/2000 23:57'!browseGlobalReferencesTo: aLiteral 	self showWaitCursorWhile: 			[(BrowserEnvironment new referencesTo: aLiteral) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/19/2000 23:34'!browseGlobalReferencesTo: aLiteral in: aClass 	self showWaitCursorWhile: 			[(BrowserEnvironment new referencesTo: aLiteral in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/28/2005 08:06'!browseImplementors	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen in or below	the selected class.	Do nothing if no message is chosen."	self getSelectorAndSendQuery: #browseAllImplementorsOf:		to: self navigator! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:48'!browseImplementorsOf: aSymbol	(SelectorEnvironment implementorsOf: aSymbol in: BrowserEnvironment new) openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 15:58'!browseInstVarDefs	self browseInstVarWriters! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 13:28'!browseInstVarReaders	| name |	name := self selectInstVar.	name isEmptyOrNil ifTrue: [^self].	self navigator browseGlobalInstVarReadersTo: name		in: self selectedClassOrMetaClass! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 12:53'!browseInstVarReadersTo: instVar in: aClass 	self showWaitCursorWhile: 			[(self browserEnvironment instVarReadersTo: instVar in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'rga 9/16/2001 22:06'!browseInstVarRefs	"first handle situation where no class selected"	| name |	self selectedClass		ifNil: [^ self inform: 'Nothing selected.'].	name := self selectInstVar.	"then handle the situation where no ivar selected"	name isEmpty		ifFalse: [self navigator browseGlobalInstVarRefsTo: name in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 12:53'!browseInstVarRefsTo: instVar in: aClass 	self showWaitCursorWhile: 			[(self browserEnvironment instVarRefsTo: instVar in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'dvf 8/29/2001 00:58'!browseInstVarWriters	| name |	name := self selectInstVar.	name notNil 		ifTrue: [self navigator browseGlobalInstVarWritersTo: name in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 12:53'!browseInstVarWritersTo: instVar in: aClass 	self showWaitCursorWhile: 			[(self browserEnvironment instVarWritersTo: instVar in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:11'!browseLocalImplementors	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen in or below	the selected class.	Do nothing if no message is chosen."	self getSelectorAndSendQuery: #browseAllImplementorsOf:localTo:		to: self navigator		with: { self selectedClass }! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/27/2005 16:23'!browseLocalSendersOfMessages	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen in or below	the selected class.	Do nothing if no message is chosen."	self getSelectorAndSendQuery: #browseAllCallsOn:localTo: 		to: self navigator		with: { self selectedClass }! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'hk 5/6/2006 15:59'!browseMessages	"Present a menu of all messages sent by the currently selected message. 	Open a message set browser of all implementors of the message chosen in or below	the selected class.	Do nothing if no message is chosen."	self getSelectorAndSendQuery: #browseAllImplementorsOf:		to: self systemNavigation! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 13:33'!browsePackageWithClassCategory	(self environmentForPackageWithClassCategory ifNil: [ ^nil ])	openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 12:53'!browseReferencesTo: aLiteral 	self showWaitCursorWhile: 			[(self browserEnvironment referencesTo: aLiteral) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 12:53'!browseReferencesTo: aLiteral in: aClass 	self showWaitCursorWhile: 			[(self browserEnvironment referencesTo: aLiteral in: aClass) openEditor]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/19/2000 23:57'!browseReferencesToGlobal	| name association |	name := self selectedVariableName.	name isNil ifTrue: [^self].	association := Smalltalk associationAt: name asSymbol ifAbsent: [^self].	self navigator browseGlobalReferencesTo: association! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 16:57'!browseSelectedClassCategory	(self environmentForSelectedClassCategory ifNil: [ ^nil ])	openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'dvf 8/29/2001 00:59'!browseSelectedClassVarRefs	| name association |	name := self selectedVariableName.	association := self navigator findAssociationForClassVariable: name.	self navigator browseGlobalReferencesTo: association in: self nonMetaClass! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'dvf 8/29/2001 00:59'!browseSelectedInstVarReaders	| name |	name := self selectedVariableName.	name notNil 		ifTrue: [self navigator browseGlobalInstVarReadersTo: name in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'dvf 8/29/2001 00:58'!browseSelectedInstVarRefs	| name |	name := self selectedVariableName.	name notNil 		ifTrue: [self navigator browseGlobalInstVarRefsTo: name in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'dvf 8/29/2001 00:58'!browseSelectedInstVarWriters	| name |	name := self selectedVariableName.	name notNil 		ifTrue: [self navigator browseGlobalInstVarWritersTo: name in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 5/17/2000 22:33'!browseSenders	| node |	node := self findNode.	(node isNil or: [node isMessage not]) ifTrue: [^self].	(BrowserEnvironment new referencesTo: node selector) openEditor! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'hk 5/6/2006 15:58'!browseSendersOfMessages	"Present a menu of the currently selected message, as well as all messages sent by it.  Open a message set browser of all senders of the selector chosen."	self getSelectorAndSendQuery: #browseAllCallsOn: to: self systemNavigation! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'nk 3/4/2005 13:00'!browserEnvironment	^BrowserEnvironment new! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'bh 11/8/2000 15:26'!categories	^#().! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 10:28'!changeClassCategory	| state |	self changeRequest ifFalse: [^self].	state := self getState.	self changeClassCategoryFor: self nonMetaClasses.	self setState: state updateClasses: true.	self changed: #category with: self category! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 10:33'!changeClassCategoryFor: classCollection 	self needsWork.	self error:'not yet implemented.'.	"| dialog newCategory oldCategory changeClasses |	classCollection isEmpty ifTrue: [^self].	oldCategory := self environment whichCategoryIncludes: classCollection first name.	dialog := CategoryDialog new.	dialog organizer: Smalltalk organization.	dialog currentCategory: oldCategory.	dialog open ifFalse: [^self].	newCategory := dialog categoryName asSymbol.	changeClasses := classCollection				select: [:each | (self environment whichCategoryIncludes: each name) ~= newCategory].	changeClasses isEmpty ifTrue: [^self].	changeClasses do: 			[:each | 			Smalltalk organization classify: each name under: newCategory.			ChangeSet current changeClass: each]"! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/12/2000 22:29'!changeRequest	^self okToChange.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 6/14/2000 10:30'!changed: aSymbol with:anObject	"Temporary"	aSymbol == #category ifTrue: [ self changed: #categoryList ].	! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'hboon 11/12/2004 15:29'!changedClass	self changed: #categoryList.	self changed: #messageList.	self changed: #classList.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/12/2000 22:14'!changedSelector	self changed: #contents.! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'dvf 10/3/2001 18:18'!checkProtocolFor: aSelector in: aClass 	| exp1 exp2 exp3 exp4 |	self needsWork.	self error:'not yet implemented'. {exp1. [exp2]. exp3. [exp4]} allTrue"	| protocol |	protocol := aClass organization categoryOfElement: aSelector.	^protocol isNil 		ifTrue: 			[(Dialog confirm: aSelector asString 						, ' is not classified under a protocol.\Do you want to classify it?' 								withCRs) 				ifTrue: 					[protocol := Dialog 								request: 'Enter a protocol name for ' asText 										, (aSelector asText emphasizeAllWith: #(#italic)) , ':'.					protocol isEmpty 						ifFalse: 							[self 								moveMethods: (Array with: aSelector)								to: protocol								in: aClass]].			true]		ifFalse: [false]"! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'dvf 9/8/2001 19:58'!checkProtocolMatchFor: aSelector in: aClass 	self needsWork.	self error:'not yet implemented'.[ "comment block"	| protocol superClass superProtocol patchClass |	protocol := aClass organization categoryOfElement: aSelector.	protocol isNil ifTrue: [^false].	superClass := aClass superclass whichClassIncludesSelector: aSelector.	superClass isNil ifTrue: [^false].	superProtocol := superClass organization categoryOfElement: aSelector.	superProtocol == protocol ifTrue: [^false].	superProtocol isNil ifTrue: [^false].	patchClass := self 				choose: (aSelector printString , ' is classified under "' , protocol 						, '" in ' , aClass name 						, '\and under "' , superProtocol 						, '" in ' , superClass name 						, '. Patch?') withCRs				labels: (Array 						with: aClass name asString						with: superClass name asString						with: 'neither')				values: (Array 						with: aClass						with: superClass						with: nil)				default: aClass.	patchClass isNil ifTrue: [^false].	patchClass == aClass 		ifTrue: 			[self 				moveMethods: (Array with: aSelector)				to: superProtocol				in: aClass]		ifFalse: 			[self 				moveMethods: (Array with: aSelector)				to: protocol				in: superClass].	^true].! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'dvf 9/8/2001 19:58'!checkProtocols	self changeRequest ifFalse: [^self].	Cursor wait showWhile: 			[(self nonMetaClasses inject: false				into: 					[:changed :class | 					changed | (self checkProtocolsFor: class)						| (self checkProtocolsFor: class class)])					ifTrue: [self setState: self getState updateClasses: true]					ifFalse: [self warn: 'No changes made.']]! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'nk 3/4/2005 12:53'!checkProtocolsFor: aClass 	^(self browserEnvironment selectorsForClass: aClass) inject: false		into: 			[:bool :each | 			bool | (self checkProtocolFor: each in: aClass) 				| (self checkProtocolMatchFor: each in: aClass)]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 12:36'!classListMenu: aMenu shifted: shifted 	| moreItem |	super classListMenu: aMenu shifted: shifted.	shifted 		ifFalse: 			[moreItem := aMenu submorphs last.			moreItem delete.			self addClassSubMenuTo: aMenu.			self addClassVariableSubMenuTo: aMenu.			self addInstanceVariableSubMenuTo: aMenu.			aMenu addLine.			aMenu addMorphBack: moreItem].	^aMenu! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 11/5/2000 22:06'!className	^self selectedClassName.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/12/2000 23:14'!classNames	^{self selectedClassName}! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 12:53'!classRefs	self 		browseReferencesTo: (self browserEnvironment associationAt: self className)! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 6/14/2000 10:49'!classVarRefs	| classVar association |	classVar := self selectClassVarSupers: true subs: false.	classVar isNil ifTrue: [^self].	association := self findAssociationForClassVariable: classVar.	self browseReferencesTo: association in: self nonMetaClass! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!classVariableMenu	^(MenuMorph new)		defaultTarget: self;		add: 'references...' translated action: #browseClassVarRefs;		add: 'rename class variable...' translated action: #renameClassVar;		add: 'push up' translated action: #pushUpSelectedClassVar;		add: 'create accessors' translated action: #createClassVarAccessors;		add: 'abstract' translated action: #abstractClassVar;		yourself! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/5/2005 16:45'!codePaneMenu: aMenu shifted: shifted 	| moreItem |	super codePaneMenu: aMenu shifted: shifted.	moreItem := aMenu submorphs last.	moreItem delete.	aMenu add: 'extract method' translated action: #extractMethod.	aMenu add: 'extract method to component' translated		action: #extractMethodToComponent.	self addSelectionSubMenuTo: aMenu.	aMenu addLine; addMorphBack: moreItem.	^aMenu! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 11/8/2000 11:21'!convertToSibling	| name subclasses |self needsWork.  "Still not right."	name := self request: 'Enter name for new parent class'.	name isEmpty ifTrue: [^self].	subclasses := self selectSubclassesOf: self nonMetaClass.	subclasses isNil ifTrue: [^self].	self handleError: 			[(ChildrenToSiblingsRefactoring name: name				class: self nonMetaClass				subclasses: subclasses) execute.			self selectClasses: (Array with: name asSymbol)				meta: self isMeta				categories: self categories]! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:13'!convertToSourceInterval: anInterval 	"Convert the selected interval from our text widget, to the interval in the stored source code.	For this widget, we don't need to do anything."	^anInterval! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/19/2000 23:50'!createAccessorsForClassVar: aString 	self performRefactoring: (CreateAccessorsForVariableRefactoring 				variable: aString asSymbol				class: (self nonMetaClass whichClassDefinesClassVar: aString)				classVariable: true)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:03'!createAccessorsForInstVar: aString 	self performRefactoring: (CreateAccessorsForVariableRefactoring 				variable: aString				class: (self selectedClassOrMetaClass whichClassDefinesInstVar: aString)				classVariable: false)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'nk 3/4/2005 13:27'!createClassVarAccessors	| name |	name := self selectClassVar.	name isEmptyOrNil ifTrue: [^self].	self createAccessorsForClassVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:03'!createInstVar	self performRefactoring: (TemporaryToInstanceVariableRefactoring 				class: self selectedClassOrMetaClass				selector: self selector				variable: self selectedText)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:56'!createInstVarAccessors	| name |	name := self selectInstVar.	name isNil ifTrue: [^self].	self createAccessorsForInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:57'!createSelectedClassVarAccessors	| name |	name := self selectedVariableName.	name isNil ifTrue: [^self].	self createAccessorsForClassVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:56'!createSelectedInstVarAccessors	| name |	name := self selectedVariableName.	name isNil ifTrue: [^self].	self createAccessorsForInstVar: name! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'hboon 11/30/2004 14:23'!createSubclass	| class |	self changeRequest		ifFalse: [^ self].	class := self createSubclassOf: self nonMetaClass.	class isNil		ifTrue: [^ self].			self changedClass.	self selectClass: class! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'hboon 11/30/2004 14:20'!createSubclassOf: aClass 	| name subclasses aCategory categoryChoices |	name := self requestClassName.	name isNil		ifTrue: [^ nil].	subclasses := self selectSubclassesOf: aClass.	subclasses isNil		ifTrue: [^ nil].	categoryChoices := (OrderedCollection with: aClass category) addAll: Smalltalk organization categories;				 yourself.	aCategory := (SelectionMenu selections: categoryChoices lines: #(1 ))				startUpWithCaption: 'Choose a class category:'.	aCategory		ifNil: [^ nil].	^ self		handleError: [(AddClassRefactoring				addClass: name				superclass: aClass				subclasses: subclasses				category: aCategory) execute.			Smalltalk				at: name asSymbol				ifAbsent: []]! !!RefactoringBrowser methodsFor: 'initialize-release' stamp: 'jf 7/24/2005 01:02'!defaultBrowserTitle	^ 'RB'! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'nk 3/4/2005 12:15'!environmentForPackageWithClassCategory	self selectedEnvironment ifNil: [^nil].	^BrowserEnvironment new 		forPackageContainingClassCategory: self selectedSystemCategoryName! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'nk 3/4/2005 12:21'!environmentForSelectedClassCategory	self selectedEnvironment ifNil: [^nil].	^BrowserEnvironment new forCategories: {self selectedSystemCategoryName}! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'nk 3/4/2005 12:17'!environmentForSelectedClassHierarchy	| classes |	self selectedClass ifNil: [^nil].	classes := Set new.	self selectedClass withAllSubAndSuperclassesDo: [:cls | classes add: cls].	^BrowserEnvironment new forClasses: classes! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'nk 7/30/2004 17:58'!extractMethod	| currentSelector |	messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	currentSelector := self selectedMessageName.	self performRefactoring: (ExtractMethodRefactoring 				extract: self selectedInterval				from: self selectedMessageName				in: self selectedClassOrMetaClass).	self messageListIndex: (self messageList indexOf: currentSelector).	Beeper  beep! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'nk 7/30/2004 17:58'!extractMethodToComponent	messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	self performRefactoring: (ExtractMethodToComponentRefactoring 				extract: self selectedInterval				from: self selectedMessageName				in: self selectedClassOrMetaClass).	Beeper  beep! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/30/2001 02:18'!extractToTemp	| newName node |	self updateRequest ifFalse: [^self].	node := self findNode.	(node isNil or: [node isValue not]) 		ifTrue: [^self warn: 'Could not find the node'].	newName := self request: 'Enter name for Temporary:'.	newName isEmpty ifTrue: [^self].	self performRefactoring: (ExtractToTemporaryRefactoring 				extract: (self convertToSourceInterval: node sourceInterval)				to: newName				from: self selector				in: self selectedClassOrMetaClass)! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'bh 6/14/2000 10:54'!findAllReferencesToInstances	self needsWork.	self error:'ReferenceFinder does not work yet. Sorry.'.	"self showWaitCursorWhile: 			[| paths |			paths := ReferenceFinder findAllPathsToInstanceOf: self selectedClass.			paths isEmpty 				ifTrue: [self warn: 'No reference paths exist']				ifFalse: [paths inspect]]"! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:33'!findAssociationForClassVariable: classVar 	| association definingClass name |self needsWork. "well, maybe not work, but needs testing."	definingClass := self nonMetaClass.	association := nil.		[definingClass notNil and: 			[name := definingClass classPool keys 						detect: [:each | each asString = classVar asString]						ifNone: [nil].			association := definingClass classPool associationAt: name ifAbsent: [nil].			association isNil]] 			whileTrue: [definingClass := definingClass superclass].	^association! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'fc 12/2/2004 10:42'!findNode	| tree node interval |	interval := self selectedInterval.	interval isEmpty ifTrue: [^nil].	tree := RBParser parseMethod: self text				onError: [:str :err | ^self parseSelection].	node := tree whichNodeIsContainedBy: interval.	node isNil ifTrue: [node := tree bestNodeFor: interval].	^node! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'bh 6/14/2000 11:03'!findReferencePathToInstance	self needsWork.	self error:'ReferenceFinder does not work yet, sorry.'.	"self showWaitCursorWhile: 			[| path |			path := ReferenceFinder findPathToInstanceOf: self selectedClass.			path notNil 				ifTrue: [path inspect]				ifFalse: [self warn: 'No reference paths exist']]"! !!RefactoringBrowser methodsFor: 'tools' stamp: 'dvf 9/29/2001 00:04'!finderOnClass	self selectedClass ifNil: [^self finderOnClassCategory].	(FinderTool onClass: self selectedClass) openAsMorph ! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 9/17/2003 12:32'!finderOnClassCategory	(self selectedEnvironment 		ifNil: [FinderTool new] 		ifNotNil: [(FinderTool onClassCategory: self selectedSystemCategoryName)]) openAsMorph ! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 2/25/2005 07:44'!finderOnClassHierarchy	self selectedClass ifNil: [^self finderOnClassCategory].	(FinderTool onClassHierarchyIncluding: self selectedClass) openAsMorph ! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 9/17/2003 14:26'!finderOnPackageWithClassCategory	| tool |	tool := (self selectedEnvironment 		ifNil: [FinderTool new] 		ifNotNil: [ FinderTool onPackageWithClassCategory: self selectedSystemCategoryName ]).	tool ifNotNil: [ tool openAsMorph ]! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 6/14/2000 10:26'!getState	"do nothing, this is temporary"! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!globalVariableMenuFor: aNode 	^(MenuMorph new)		defaultTarget: self;		add: 'navigate to' translated action: #navigateToClass;		add: 'open browser on...' translated action: #openBrowserForClass;		add: 'browse references...' translated action: #browseReferencesToGlobal;		yourself! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/8/2001 19:57'!handleError: aBlock 	^[Cursor execute showWhile: aBlock] on: Refactoring preconditionSignal		do: 			[:ex | 			ex isResumable 				ifTrue: 					[(self confirm: (ex messageText last == $? 								ifTrue: [ex messageText]								ifFalse: [ex messageText , '\Do you want to proceed?' withCRs])) 						ifTrue: [ex resume]]				ifFalse: 					[ex parameter notNil 						ifTrue: [(self confirm: ex messageText) ifTrue: [ex parameter value]]						ifFalse: [self warn: ex messageText]].			ex return: nil]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:03'!inlineMethod	| node |	node := self findNode.	(node isNil or: [node isMessage not]) 		ifTrue: [^self warn: 'Could not find message send'].	(node receiver isVariable 		and: [#('self' 'super') includes: node receiver name]) 			ifTrue: 				[self performRefactoring: (InlineMethodRefactoring 							inline: (self convertToSourceInterval: node sourceInterval)							inMethod: self selector							forClass: self selectedClassOrMetaClass)]			ifFalse: 				[self performRefactoring: (InlineMethodFromComponentRefactoring 							inline: (self convertToSourceInterval: node sourceInterval)							inMethod: self selector							forClass: self selectedClassOrMetaClass)]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:03'!inlineParameter	self handleError: 			[| ref |			ref := InlineParameterRefactoring 						inlineParameter: self selectedText						in: self selectedClassOrMetaClass						selector: self selector.			ref execute.			"codeModel setSelector: ref newSelector"]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'nk 7/30/2004 17:58'!inlineSelfSends	messageListIndex = 0 ifTrue: [^self].	self handleError: 			[| refactoring aCollection |			refactoring := InlineAllSendersRefactoring sendersOf: self selector						in: self selectedClassOrMetaClass.			refactoring execute.			refactoring messagesNotReplaced > 0 				ifTrue: 					[self warn: ('<1p> message sends were not replaced' 								expandMacrosWith: refactoring messagesNotReplaced)].			self changed: #messageList.			self changedSelector].	Beeper  beep! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:04'!inlineTemporary	| node |	self updateRequest ifFalse: [^self].	node := self findNode.	(node isNil or: [node isAssignment not]) 		ifTrue: [^self warn: 'Could not find the node'].	self performRefactoring: (InlineTemporaryRefactoring 				inline: (self convertToSourceInterval: node sourceInterval)				from: self selector				in: self selectedClassOrMetaClass)! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/15/2000 22:12'!inspectAllInstances	(self nonMetaClass allInstances) inspect! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/4/2005 13:28'!instVarReaders	| instVar |	instVar := self selectInstVarSupers: true subs: false.	instVar isEmptyOrNil ifTrue: [^self].	self browseInstVarReadersTo: instVar in: self selectedClassOrMetaClass! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 3/5/2005 16:18'!instVarRefs	| instVar |	instVar := self selectInstVarSupers: true subs: false.	instVar isEmptyOrNil ifFalse: 		 [self browseInstVarRefsTo: instVar in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'bh 10/15/2000 21:04'!instVarWriters	| instVar |	instVar := self selectInstVarSupers: true subs: false.	instVar notNil		ifTrue: [self browseInstVarWritersTo: instVar in: self selectedClassOrMetaClass]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!instanceVariableMenu	^(MenuMorph new)		defaultTarget: self;		add: 'references...' translated action: #browseSelectedInstVarRefs;		add: 'readers...' translated action: #browseSelectedInstVarReaders;		add: 'writers...' translated action: #browseSelectedInstVarWriters;		add: 'rename instance variable...' translated			action: #renameSelectedInstVar;		add: 'pull up' translated action: #pushUpSelectedInstVar;		add: 'create accessors' translated action: #createSelectedInstVarAccessors;		add: 'abstract' translated action: #abstractSelectedInstVar;		add: 'protect/concrete' translated action: #protectSelectedInstVar;		yourself! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 11/8/2000 10:47'!isMeta	^self metaClassIndicated.! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 3/4/2005 11:11'!lintOnClass	self selectedClass ifNil: [^nil].	LintDialog onEnvironment: (BrowserEnvironment new forClasses: {self selectedClass}).! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 3/4/2005 12:21'!lintOnClassCategory	^LintDialog onEnvironment: (self environmentForSelectedClassCategory ifNil: [ ^nil ]).! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 3/4/2005 12:19'!lintOnClassHierarchy	^LintDialog onEnvironment: (self environmentForSelectedClassHierarchy ifNil: [ ^nil ]).! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 3/4/2005 12:16'!lintOnPackageWithClassCategory	^LintDialog onEnvironment: (self environmentForPackageWithClassCategory ifNil: [ ^nil ])! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 12:25'!messageListMenu: aMenu shifted: shifted 	^shifted ifFalse: [		super messageListMenu: aMenu shifted: shifted.		aMenu addStayUpItem.		aMenu submorphs last delete.		aMenu addTranslatedList: #(			#-			#('safe remove' #removeMethodSafe) 			#('add parameter' #addParameter) 			#('rename method' #renameMethod) 			#('inline all self sends' #inlineSelfSends) 			#('push up' #pushUpMethod) 			#('push down' #pushDownMethod) 			#-			#('more...' #shiftedYellowButtonActivity))]		ifTrue: [self shiftedMessageListMenu: aMenu]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!messageMenuFor: aNode 	"add: stuff action: bar"	^(MenuMorph new)		defaultTarget: self;		add: 'senders...' translated action: #browseSenders;		add: 'implementors...' translated action: #browseImplementors;		add: 'inline message' translated action: #inlineMethod;		add: 'extract to temporary...' translated action: #extractToTemp;		yourself! !!RefactoringBrowser methodsFor: 'browsing' stamp: 'nk 2/28/2005 07:02'!methodHierarchy	self browseAllImplementorsOf: (self selectedMessageName ifNil: [ ^self ]) localTo: (self selectedClassOrMetaClass ifNil: [ ^self ])! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/29/2001 17:53'!navigateToClass	self navigateToClass: self selectedClassInCode! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/28/2001 23:46'!navigateToClass: foundClass 	self selectCategoryForClass: foundClass.	self selectClass: foundClass! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'nk 7/31/2004 09:21'!navigateToClassNamed: className 	| foundClass |	foundClass := Smalltalk classNamed: className.	self navigateToClass: foundClass! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:31'!navigator	^self.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/12/2000 23:13'!newClassList:aCollection	self changed: #classList.! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!noMenu	^(MenuMorph new)		add: 'no selection' translated action: #printString;		yourself! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 10/15/2000 21:04'!nonMetaClass	^self selectedClassOrMetaClass.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 10/15/2000 21:04'!nonMetaClasses	^{self selectedClassOrMetaClass}.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/29/2001 18:13'!openBrowserForClass	self class fullOnClass: self selectedClassInCode! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'md 7/18/2006 14:23'!packageForSelectedCategory		self selectedSystemCategoryName isNil ifTrue:[ ^ nil].	^PackageInfo allPackages 		detect: [:p | p includesSystemCategory: self selectedSystemCategoryName]		ifNone: []! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!parameterMenu	"MenuEditor new openOnClass: self andSelector: #temporaryMenu"	^(MenuMorph new)		defaultTarget: self;		add: 'remove parameter' translated action: #removeParameter;		add: 'inline parameter' translated action: #inlineParameter;		add: 'rename...' translated action: #renameTemporary;		yourself	"Things that used to be here -#(#MenuItem #rawLabel: 'con&vert to instance variable' #value: #createInstVar) #(#MenuItem #rawLabel: 'move to inner &scope' #value: #bindTight)) #(5) nil) 		decodeAsLiteralArray"! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'fc 12/2/2004 10:45'!parseSelection	^RBParser parseExpression: self selectedText onError: [:str :pos | ^nil]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/1/2001 14:41'!performClassRefactoring: refactoring 	self handleError: 			[refactoring execute.			self changedClass]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/30/2001 01:15'!performRefactoring: aRefactoring 	aRefactoring isNil ifTrue: [^self].	self handleError: 			[aRefactoring execute.			self changed: #messageList.			self changed: #contents]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:43'!protectInstVar	| name |	name := self selectInstVar.	name isNil ifTrue: [^self].	self protectInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:04'!protectInstVar: aString 	self 		performRefactoring: (ProtectInstanceVariableRefactoring variable: aString				class: (self selectedClassOrMetaClass whichClassDefinesInstVar: aString))! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 01:01'!protectSelectedInstVar	| name |	name := self selectedVariableName.	name isNil ifTrue: [^self].	self protectInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/1/2001 14:45'!pullUpClassVar	| classVar |	self changeRequest ifFalse: [^self].	classVar := self selectSubclassClassVar.	classVar isNil ifTrue: [^self].	self pullUpClassVar: self nonMetaClass in: classVar.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/1/2001 14:44'!pullUpClassVar: class in: classVar 	| refactoring |	refactoring := PullUpClassVariableRefactoring variable: classVar				class: class.	self performClassRefactoring: refactoring! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'nk 7/30/2004 17:58'!pullUpInstVar	| instVar |	self changeRequest ifFalse: [^self].	instVar := self selectSubclassInstVar.	instVar isNil ifTrue: [^self].	self handleError: 			[(PullUpInstanceVariableRefactoring variable: instVar				class: self selectedClassOrMetaClass) execute.			self changedClass].	Beeper  beep! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/30/2001 18:12'!pushDownClassVar	| classVar |	self changeRequest ifFalse: [^self].	classVar := self selectClassVarSupers: false subs: false.	classVar isNil ifTrue: [^self].	self handleError: 			[(PushDownClassVariableRefactoring variable: classVar				class: self nonMetaClass) execute.			self changedClass].self needsWork.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:05'!pushDownInstVar	| instVar |	self changeRequest ifFalse: [^self].	instVar := self selectInstVarSupers: false subs: false.	instVar isNil ifTrue: [^self].	self handleError: 			[(PushDownInstanceVariableRefactoring variable: instVar				class: self selectedClassOrMetaClass) execute.			self changedClass]! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'nk 7/30/2004 17:58'!pushDownMethod	messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	self handleError: 			[(PushDownMethodRefactoring pushDown: { 						self selectedMessageName}				from: self selectedClassOrMetaClass) execute.			self changed: #messageList.			self changed: #contents].	Beeper  beep! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/19/2000 23:49'!pushUpClassVar: aString 	self performRefactoring: (PullUpClassVariableRefactoring 				variable: aString asSymbol				class: (self nonMetaClass whichClassDefinesClassVar: aString) superclass)! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'nk 7/30/2004 17:58'!pushUpMethod	messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	self handleError: 			[(PushUpMethodRefactoring pushUp: { 						self selectedMessageName}				from: self selectedClassOrMetaClass) execute.			self changed: #messageList.			self changed: #contents].	Beeper  beep! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/1/2001 14:37'!pushUpSelectedClassVar	| name |	name := self selectClassVar.	name isNil ifTrue: [^self].	self pushUpClassVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'md 2/26/2006 16:53'!pushUpSelectedInstVar	| instVar |	self changeRequest ifFalse: [^self].	instVar := self selectedVariableName.	instVar isNil ifTrue: [^self].	self handleError: 			[(PullUpInstanceVariableRefactoring variable: instVar				class: self selectedClassOrMetaClass superclass) execute.			self changedClass].	Beeper  beep! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'bh 6/14/2000 11:07'!rbRenameClass	self changeRequest ifFalse: [^self].	self renameClass: self nonMetaClass! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/12/2000 23:15'!removeClassSafe	classListIndex = 0 ifTrue: [^self].	self changeRequest ifFalse: [^self].	self removeClassesSafe: self nonMetaClasses.	self newClassList: self classNames.	self changedClass! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 11:09'!removeClassVar	| classVar |	self changeRequest ifFalse: [^self].	classVar := self selectClassVarSupers: false subs: false.	classVar isNil ifTrue: [^self].	self handleError: 			[(RemoveClassVariableRefactoring variable: classVar				class: self nonMetaClass) execute.			self changedClass]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/12/2000 23:05'!removeClassesSafe: classCollection 	self handleError: 			[(RemoveClassRefactoring 				classNames: (classCollection collect: [:each | each name])) execute]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:05'!removeInstVar	| instVar |	self changeRequest ifFalse: [^self].	instVar := self selectInstVarSupers: false subs: false.	instVar isNil ifTrue: [^self].	self removeInstVar: instVar fromClass: self selectedClassOrMetaClass.	self changedClass! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 6/14/2000 11:10'!removeInstVar: instVar fromClass: cls 	self handleError: 			[(RemoveInstanceVariableRefactoring variable: instVar class: cls) execute]! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'nk 7/30/2004 17:58'!removeMethodSafe	messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	self removeMethodsSafe: self selectors from: self selectedClassOrMetaClass.	self changed: #messageList.	self changedSelector.	Beeper  beep! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'bh 5/12/2000 21:58'!removeMethodsSafe: sels from: cls 	self		handleError: [(RemoveMethodRefactoring removeMethods: sels from: cls) execute]! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'bh 10/15/2000 21:07'!removeParameter	self handleError: 			[| ref |			ref := RemoveParameterRefactoring 						removeParameter: self selectedText						in: self selectedClassOrMetaClass						selector: self selector.			ref execute.			"codeModel setSelector: ref newSelector"]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 11/2/2002 18:54'!renameClass: aClass 	| aString newName |	aString := self request: 'Enter new ClassName' initialAnswer: aClass name.	aString isEmpty ifTrue: [^self].	newName := aString asSymbol.	self handleError: 			[(RenameClassRefactoring rename: aClass to: newName) execute.			self selectClasses: (Array with: aString asSymbol)				meta: self isMeta				categories: self categories.			self changedClass]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 01:11'!renameClassVar	| name |	name := self selectClassVar.	name isNil ifTrue: [^self].	self renameClassVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/19/2000 23:45'!renameClassVar: aString 	self navigator renameClassVar: aString asSymbol		in: (self nonMetaClass whichClassDefinesClassVar: aString).	self updateContents! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 5/19/2000 23:46'!renameClassVar: oldName in: aClass 	| newName |	newName := self requestClassVarName: oldName.	newName isNil ifTrue: [^self].	self handleError: 			[(RenameClassVariableRefactoring rename: oldName				to: newName				in: aClass) execute]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/26/2001 17:02'!renameInstVar	| name |	name := self selectInstVarSupers: false subs: false.	name isNil ifTrue: [^self].	self renameInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:07'!renameInstVar: aString 	self navigator renameInstVar: aString		in: (self selectedClassOrMetaClass whichClassDefinesInstVar: aString).	self updateContents! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/26/2001 17:02'!renameInstVar: oldName in: aClass 	| newName |	newName := self requestInstVarName: oldName.	newName isNil ifTrue: [^self].	self handleError: 			[(RenameInstanceVariableRefactoring rename: oldName				to: newName				in: aClass) execute]! !!RefactoringBrowser methodsFor: 'message pane' stamp: 'nk 7/30/2004 17:58'!renameMethod	| newSelector |	messageListIndex = 0 ifTrue: [^self].	self okToChange ifFalse: [^self].	newSelector := self renameMethod: self selector				in: self selectedClassOrMetaClass.	newSelector isNil ifTrue: [^self].	self changed: #messageList.	self messageListIndex: (self messageList indexOf: newSelector).	self changedSelector.	Beeper  beep! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'md 3/15/2006 17:28'!renameMethod: aSelector in: aClass 	| oldMethodName newMethodName oldArguments argumentPermutation |	oldArguments := (RBParser parseMethod: self selectedMessage) argumentNames.	oldMethodName := RBMethodName selector: aSelector arguments: oldArguments.	(newMethodName := MethodNameEditor forMethodName: oldMethodName) 		ifNil: [^nil].	argumentPermutation := newMethodName arguments 				collect: [:e | oldArguments indexOf: e].	^self handleError: 			[(RenameMethodRefactoring 				renameMethod: aSelector				in: aClass				to: newMethodName selector				permutation: argumentPermutation) execute.			newMethodName selector]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/29/2001 00:55'!renameSelectedClassVar	| name |	name := self selectedVariableName.	name isNil ifTrue: [^self].	self renameClassVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 8/27/2003 14:25'!renameSelectedInstVar	| name |	name := self selectedVariableName.	name isNil ifTrue: [^self].	self renameInstVar: name! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:07'!renameTemporary	| newName node |	node := self findNode.	(node isNil or: [node isVariable not]) 		ifTrue: [^self warn: 'Could not find the node'].	newName := self request: 'Enter new name:' initialAnswer: node name.	newName isEmpty ifTrue: [^self].	self performRefactoring: (RenameTemporaryRefactoring 				renameTemporaryFrom: (self convertToSourceInterval: node sourceInterval)				to: newName				in: self selectedClassOrMetaClass				selector: self selector)! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'dvf 9/8/2001 20:06'!request: aString	^FillInTheBlank request: aString! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'bh 11/7/2000 23:01'!requestClassName	| name |	name := self request: 'Enter a class name:'.	^name isEmpty ifTrue: [nil] ifFalse: [name]! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:47'!requestClassVarName: oldName 	| name |	name := self request: 'Enter a class variable name:' initialAnswer: oldName.	(name isEmpty or: [oldName = name]) ifTrue: [^nil].	^name! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/16/2000 23:22'!requestInstVarName: oldName 	| name |	name := self request: 'Enter a instance variable name:' initialAnswer: oldName.	(name isEmpty or: [oldName = name]) ifTrue: [^nil].	^name! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 11/3/2004 09:42'!rewriteToolOnClass	self selectedClass ifNil: [^self rewriteToolOnClassCategory].	(RewriteTool onClass: self selectedClass) openAsMorph ! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 11/3/2004 09:42'!rewriteToolOnClassCategory	(self selectedEnvironment 		ifNil: [RewriteTool new] 		ifNotNil: [(RewriteTool onClassCategory: self selectedSystemCategoryName)]) openAsMorph ! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 2/25/2005 07:52'!rewriteToolOnClassHierarchy	self selectedClass ifNil: [^self rewriteToolOnClassCategory].	(RewriteTool onClassHierarchyIncluding: self selectedClass) openAsMorph ! !!RefactoringBrowser methodsFor: 'tools' stamp: 'nk 11/3/2004 09:42'!rewriteToolOnPackageWithClassCategory	| tool |	tool := (self selectedEnvironment 		ifNil: [RewriteTool new] 		ifNotNil: [ RewriteTool onPackageWithClassCategory: self selectedSystemCategoryName ]).	tool ifNotNil: [ tool openAsMorph ]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:07'!selectClassVar	self selectedClassOrMetaClass chooseClassVarThenDo:[:ivar| ^ivar].	^''.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:07'!selectClassVarSupers: supersBoolean subs: subsBoolean	(supersBoolean & subsBoolean) ifTrue:[^self error:'cannot select cvars from subs and supers yet. sorry.'].	(supersBoolean | subsBoolean) ifFalse:[self selectedClassOrMetaClass chooseThisClassClassVarThenDo:[:ivar| ^ivar]. ^''].	supersBoolean ifTrue:[^self selectClassVar].	subsBoolean ifTrue:[^self selectSubclassClassVar].! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/8/2001 21:03'!selectClassVariables	| variables |	variables := self nonMetaClass classVarNames asSortedCollection.	variables isEmpty ifTrue: [^#()].	^ChooserMorph 		choose: 'Choose variables:'		multipleSelect: true		fromList: variables		values: variables		cancel: [#()]! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 11/8/2000 10:53'!selectClasses: classCollection meta: aBoolean categories: categoriesCollection	classCollection ifNotEmpty:		[ :col |		self selectClass: classCollection first ].! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:06'!selectInstVar	self selectedClassOrMetaClass chooseInstVarThenDo:[:ivar| ^ivar].	^''.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:06'!selectInstVarSupers: supersBoolean subs: subsBoolean	(supersBoolean & subsBoolean) ifTrue:[^self error:'cannot select ivars from subs and supers yet. sorry.'].	(supersBoolean | subsBoolean) ifFalse:[self selectedClassOrMetaClass chooseThisClassInstVarThenDo:[:ivar| ^ivar]. ^''].	supersBoolean ifTrue:[^self selectInstVar].	subsBoolean ifTrue:[^self selectSubclassInstVar].! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'dvf 9/8/2001 21:03'!selectInstanceVariables	| variables |	variables := self selectedClass instVarNames asSortedCollection.	variables isEmpty ifTrue: [^#()].	^ChooserMorph 		choose: 'Choose variables:'		multipleSelect: true		fromList: self selectedClass instVarNames		values: self selectedClass instVarNames		cancel: [#()]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'bh 5/17/2000 21:12'!selectMenu	| node |	node := self findNode.	node isNil ifTrue: [^self noMenu].	node isVariable ifTrue: [^self selectVariableMenuFor: node].	node isMessage ifTrue: [^self messageMenuFor: node].	node isAssignment ifTrue: [^self assignmentMenuFor: node].	node isValue ifTrue: [^self valueNodeMenuFor: node].	^self noMenu! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:06'!selectSubclassClassVar	self selectedClassOrMetaClass chooseSubclassesClassVarThenDo:[:ivar| ^ivar].	^''.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'bh 10/15/2000 21:06'!selectSubclassInstVar	self selectedClassOrMetaClass chooseSubclassesInstVarThenDo:[:ivar| ^ivar].	^''.! !!RefactoringBrowser methodsFor: 'refactorings' stamp: 'nk 2/25/2005 08:32'!selectSubclassesOf: aClass 	| subclasses |	subclasses := aClass subclasses 				asSortedCollection: [:a :b | a name < b name].	subclasses isEmpty ifTrue: [^#()].	^ChooserMorph 		choose: ('Choose subclasses of {1}:' translated format: { aClass name })		multipleSelect: true		fromList: subclasses		values: subclasses		cancel: [nil]! !!RefactoringBrowser methodsFor: 'menus' stamp: 'bh 10/15/2000 21:06'!selectVariableMenuFor: aNode 	(aNode whoDefines: aNode name) notNil 		ifTrue: [^self temporaryMenuFor: aNode].	(self selectedClassOrMetaClass allInstVarNames includes: aNode name) 		ifTrue: [^self instanceVariableMenu].	(self nonMetaClass allClassVarNames 		detect: [:each | each asString = aNode name]		ifNone: [nil]) notNil 		ifTrue: [^self classVariableMenu].	^(Smalltalk includesKey: aNode name asSymbol) 		ifTrue: 			[self globalVariableMenuFor: (Smalltalk associationAt: aNode name asSymbol)]		ifFalse: [self noMenu]! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'dvf 9/29/2001 18:13'!selectedClassInCode	^Smalltalk classNamed: self findNode name asSymbol! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'fc 12/2/2004 10:44'!selectedInterval	^self codeTextMorph selectionInterval! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'fc 12/2/2004 10:46'!selectedText	| interval |	interval := self selectedInterval.	interval isEmpty ifTrue: [^''].	^self codeTextMorph text asString copyFrom: interval first		to: interval last! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:18'!selectedVariableName	| node |	node := self findNode.	^(node notNil and: [node isVariable]) ifTrue: [node name] ifFalse: [nil]! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/12/2000 22:10'!selector	^self selectedMessageName.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/12/2000 22:35'!selectors	^{self selectedMessageName}! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 6/14/2000 10:26'!setState: aNavigatorState updateClasses: aBoolean 	self changedClass.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:37'!showWaitCursorWhile: aBlock	^Cursor execute showWhile:aBlock.! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:24'!systemCategoryMenu: aMenu 	| newMenu findSubMenu rewriteSubMenu lintSubMenu |	newMenu := super systemCategoryMenu: aMenu.	newMenu addLine.	findSubMenu := (MenuMorph new)				defaultTarget: self;				add: 'code in class category...' translated action: #finderOnClassCategory;				add: 'code in package...' translated					target: self					action: #finderOnPackageWithClassCategory;				yourself.	rewriteSubMenu := (MenuMorph new)				defaultTarget: self;				add: 'code in class category...' translated					action: #rewriteToolOnClassCategory;				add: 'code in package...' translated					target: self					action: #rewriteToolOnPackageWithClassCategory;				yourself.	lintSubMenu := (MenuMorph new)				defaultTarget: self;				addLine;				add: 'on class category...' translated action: #lintOnClassCategory;				add: 'on package...' translated action: #lintOnPackageWithClassCategory;				yourself.	newMenu		add: 'find...' subMenu: findSubMenu;		add: 'rewrite...' subMenu: rewriteSubMenu;		add: 'lint...' subMenu: lintSubMenu.	newMenu addLine.	self packageForSelectedCategory ifNotNilDo: 			[:pkg | 			newMenu 				add: 'browse package ' , pkg packageName				target: self				action: #browsePackageWithClassCategory].	newMenu 		add: 'browse category' translated		target: self		action: #browseSelectedClassCategory.	^newMenu! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!temporaryMenu	"MenuEditor new openOnClass: self andSelector: #temporaryMenu"	^(MenuMorph new)		defaultTarget: self;		add: 'convert to instance variable' translated action: #createInstVar;		add: 'rename...' translated action: #renameTemporary;		add: 'move to inner scope' translated action: #bindTight;		yourself! !!RefactoringBrowser methodsFor: 'menus' stamp: 'dvf 9/1/2001 19:07'!temporaryMenuFor: aNode 	aNode parent ifNil:[^self noMenu].	^aNode parent isMethod		ifTrue:[self parameterMenu]		ifFalse:[self temporaryMenu].! !!RefactoringBrowser methodsFor: 'accessing' stamp: 'fc 12/2/2004 10:44'!text	^self contents! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'dvf 8/26/2001 16:33'!updateContents	self changedClass.! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'bh 5/19/2000 23:12'!updateRequest	^true.! !!RefactoringBrowser methodsFor: 'menus' stamp: 'nk 3/4/2005 17:22'!valueNodeMenuFor: aNode 	^(MenuMorph new)		defaultTarget: self;		add: 'extract to temporary...' translated action: #extractToTemp;		yourself! !!RefactoringBrowser methodsFor: 'compatibility' stamp: 'dvf 9/8/2001 19:57'!warn: aString	^PopUpMenu notify:aString.! !!ClassEnvironmentBrowser methodsFor: 'initialize-release' stamp: 'nk 3/4/2005 10:27'!initializeOnEnvironment: aBrowserEnvironment 	super initializeOnEnvironment: aBrowserEnvironment asSelectorEnvironment! !!SelectorEnvironmentBrowser class methodsFor: 'instance creation' stamp: 'bh 5/14/2000 20:27'!newOnEnvironment: aBrowserEnvironment	^self new initializeOnEnvironment: aBrowserEnvironment.! !!SelectorEnvironmentBrowser class methodsFor: 'instance creation' stamp: 'bh 5/14/2000 20:27'!openOnEnvironment: aBrowserEnvironment		^(self newOnEnvironment: aBrowserEnvironment) open.! !!SelectorEnvironmentBrowser methodsFor: 'user interface' stamp: 'nk 2/27/2005 13:16'!addModelItemsToWindowMenu: aMenu	super addModelItemsToWindowMenu: aMenu.	^aMenu addLine;	add: 'find code in methods...' target: self action: #finderForSelectors;	add: 'rewrite code in methods...' target: self action: #rewriteToolForSelectors;	add: 'run lint on methods...' target: self action: #lintForSelectors;	yourself.! !!SelectorEnvironmentBrowser methodsFor: 'creation' stamp: 'nk 3/4/2005 10:21'!addMorphicSwitchesTo: aListMorph 	| switches pane divider dividerFrame |	pane := (BorderedMorph new)				color: Color transparent;				borderWidth: 2;				yourself.	pane layoutPolicy: ProportionalLayout new.	switches := self buildMorphicSwitches.	switches borderWidth: 0.	pane addMorph: switches fullFrame: self morphicSwitchesFrame.	divider := (BorderedSubpaneDividerMorph forTopEdge)				height: 2;				yourself.	Preferences alternativeWindowLook 		ifTrue: 			[| aColor |			aColor := (Color colorFrom: self defaultBackgroundColor) darker.			divider				borderRaised;				borderWidth: 4;				borderColor: aColor darker.			pane				borderRaised;				borderColor: aColor.			aListMorph borderInset].	dividerFrame := self morphicSwitchesFrame.	dividerFrame bottomOffset: dividerFrame topOffset.	dividerFrame topOffset: dividerFrame topOffset - divider height.	pane addMorph: divider fullFrame: dividerFrame.	aListMorph borderWidth: 0.	pane addMorph: aListMorph		fullFrame: (LayoutFrame fractions: (0 @ 0 corner: 1 @ 1)				offsets: (0 @ 0 corner: 0 @ dividerFrame topOffset)).	^pane! !!SelectorEnvironmentBrowser methodsFor: 'accessing' stamp: 'nk 3/2/2005 14:06'!browserEnvironment	^browserEnvironment! !!SelectorEnvironmentBrowser methodsFor: 'accessing' stamp: 'nk 3/2/2005 14:06'!browserEnvironment: anObject	browserEnvironment := anObject! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/2/2005 14:06'!classList	^self browserEnvironment classNames asSortedCollection! !!SelectorEnvironmentBrowser methodsFor: 'creation' stamp: 'nk 3/4/2005 09:42'!classListFrame	^LayoutFrame fractions: (0 @ 0 extent: 0.5 @ 0.4) offsets: (0@0 corner: 0@0)! !!SelectorEnvironmentBrowser methodsFor: 'accessing' stamp: 'nk 3/2/2005 14:06'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	^(self browserEnvironment selectionIntervalFor: self contents) 		ifNil: [1 to: 0]! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/2/2005 14:06'!finderForSelectors	(FinderTool onBrowserEnvironment: self browserEnvironment) openAsMorph 		setLabel: 'FinderTool for ' , self browserEnvironment printString! !!SelectorEnvironmentBrowser methodsFor: 'initialize-release' stamp: 'nk 3/4/2005 10:51'!initializeOnEnvironment: aBrowserEnvironment 	self browserEnvironment: aBrowserEnvironment.	self classListIndex: 1! !!SelectorEnvironmentBrowser methodsFor: 'initialize-release' stamp: 'nk 3/2/2005 14:06'!labelString	| theLabel |	theLabel := self browserEnvironment printStringLimitedTo: 60.	theLabel isEmpty ifTrue: [^super labelString].	^theLabel! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/2/2005 14:06'!lintForSelectors	LintDialog runOnEnvironment: self browserEnvironment! !!SelectorEnvironmentBrowser methodsFor: 'creation' stamp: 'nk 2/26/2005 09:17'!lowerPanesFrame	^0 @ 0.4 corner: 1 @ 1! !!SelectorEnvironmentBrowser methodsFor: 'message list' stamp: 'nk 3/2/2005 14:06'!messageList	self selectedClass ifNil: [^Array new].	^(self instanceMessagesIndicated 		ifTrue: [self browserEnvironment privateSelectorsForClass: self selectedClass]		ifFalse: 			[self browserEnvironment privateSelectorsForClass: self selectedClass class]) 			asSortedCollection! !!SelectorEnvironmentBrowser methodsFor: 'creation' stamp: 'nk 2/26/2005 09:16'!messageListFrame	^0.5 @ 0 extent: 0.5 @ 0.4! !!SelectorEnvironmentBrowser methodsFor: 'creation' stamp: 'nk 3/4/2005 08:17'!morphicSwitchesFrame	"Frame for switches *within* the message list"	^LayoutFrame fractions: (0@1 corner: 1@1)		offsets: (0 @ -25 corner: 0 @ 0)! !!SelectorEnvironmentBrowser methodsFor: 'user interface' stamp: 'bh 5/14/2000 20:30'!open	World ifNotNil: [^ self openAsMorph].	self error: self class name asString, ' only works in Morphic so far.'.! !!SelectorEnvironmentBrowser methodsFor: 'creation' stamp: 'nk 3/4/2005 09:06'!openAsMorph	| window aListMorph pane |	window := (SystemWindow labelled: self browserEnvironment label) 				model: self.	aListMorph := PluggableListMorph 				on: self				list: #classList				selected: #classListIndex				changeSelected: #classListIndex:				menu: #classListMenu:shifted:				keystroke: #classListKey:from:.	pane := self addMorphicSwitchesTo: aListMorph.	window addMorph: pane fullFrame: self classListFrame.	aListMorph := PluggableListMorph 				on: self				list: #messageList				selected: #messageListIndex				changeSelected: #messageListIndex:				menu: #messageListMenu:shifted:				keystroke: #messageListKey:from:.	aListMorph menuTitleSelector: #messageListSelectorTitle.	window addMorph: aListMorph frame: self messageListFrame.	self 		addLowerPanesTo: window		at: self lowerPanesFrame		with: nil.	window setUpdatablePanesFrom: #(#classList #messageList).	^window! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/2/2005 14:06'!rewriteToolForSelectors	(RewriteTool onBrowserEnvironment: self browserEnvironment) openAsMorph 		setLabel: 'RewriteTool for ' , self browserEnvironment printString! !!SelectorEnvironmentBrowser methodsFor: 'system category list' stamp: 'nk 2/26/2005 12:39'!selectCategoryForClass: theClass	self systemCategoryListIndex: 1! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/4/2005 10:45'!selectedClass	| cls envt |	cls := self classList at: classListIndex ifAbsent: [^nil].	envt := self selectedEnvironment.	^envt classNamed: cls.! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/4/2005 10:42'!selectedClassName	^(self selectedClass ifNil: [ ^nil ]) name! !!SelectorEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/4/2005 10:46'!selectedClassOrMetaClass	| cls |	cls := self selectedClass ifNil: [ ^nil ].	^self metaClassIndicated ifTrue: [ cls class ] ifFalse: [ cls ]! !!SelectorEnvironmentBrowser methodsFor: 'system category list' stamp: 'nk 3/4/2005 10:52'!selectedEnvironment	^Smalltalk! !!SelectorEnvironmentBrowser methodsFor: 'message category list' stamp: 'bh 5/17/2000 18:47'!selectedMessageCategoryName 	"Answer the name of the selected message category or nil."	messageListIndex = 0 ifTrue: [^ nil].	^ self selectedClassOrMetaClass organization categoryOfElement: self selectedMessageName! !!SelectorEnvironmentBrowser methodsFor: 'accessing' stamp: 'nk 8/31/2004 08:45'!selectedMethod	| nonMetaClass selector class |	(nonMetaClass := self selectedClass) ifNil:[ ^nil ].	(selector := self selectedMessageName) ifNil:[ ^nil ].	class := self classMessagesIndicated ifTrue:[ nonMetaClass class ] ifFalse:[ nonMetaClass ].	^class compiledMethodAt: selector ifAbsent: [].! !!SelectorEnvironmentBrowser methodsFor: 'system category list' stamp: 'nk 3/7/2005 13:24'!selectedSystemCategoryName	"Answer the name of the selected system category or nil."	^self selectedClass ifNotNilDo: [ :cls | cls category ] ! !!VariableEnvironmentBrowser class methodsFor: 'as yet unclassified' stamp: 'bh 5/16/2000 22:52'!newOnEnvironment: aBrowserEnvironment	^self new initializeOnEnvironment: aBrowserEnvironment.! !!VariableEnvironmentBrowser class methodsFor: 'as yet unclassified' stamp: 'bh 5/16/2000 22:52'!openOnEnvironment: aBrowserEnvironment		^(self newOnEnvironment: aBrowserEnvironment) open.! !!VariableEnvironmentBrowser methodsFor: 'metaclass' stamp: 'nk 3/4/2005 11:04'!addMorphicSwitchesTo: window 	^window! !!VariableEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 3/2/2005 14:06'!classList	^self browserEnvironment classNamesWithVariables asSortedCollection! !!VariableEnvironmentBrowser methodsFor: 'class list' stamp: 'nk 2/26/2005 12:04'!classListFrame	^LayoutFrame fractions: (0 @ 0 extent: 0.5 @ 0.4)! !!VariableEnvironmentBrowser methodsFor: 'accessing' stamp: 'nk 3/2/2005 14:06'!contentsSelection	"Return the interval of text in the code pane to select when I set the pane's contents"	| cls variables ranges firstRange firstQuote |	(cls := self selectedClassOrMetaClass) ifNil: [^1 to: 0].	variables := OrderedCollection 				withAll: (self browserEnvironment instanceVariablesFor: cls).	variables addAll: (self browserEnvironment classVariablesFor: cls).	firstQuote := self contents indexOf: $'.	firstQuote isZero ifTrue: [firstQuote := 1].	ranges := SortedCollection sortBlock: [:a :b | a first < b first].	ranges 		addAll: (variables collect: 					[:var | 					{ 						self contents 							indexOfSubCollection: var							startingAt: firstQuote							ifAbsent: self contents size.						var size}]).	firstRange := ranges at: 1 ifAbsent: [^1 to: 0].	^firstRange first to: firstRange first + firstRange second - 1! !!VariableEnvironmentBrowser methodsFor: 'metaclass' stamp: 'nk 2/25/2005 16:39'!indicateClassMessages! !!VariableEnvironmentBrowser methodsFor: 'nil' stamp: 'nk 3/2/2005 14:36'!instanceMessagesIndicated	^true! !!VariableEnvironmentBrowser methodsFor: 'message list' stamp: 'nk 3/2/2005 14:38'!messageList	self selectedClass ifNil: [^Array new].	^(self instanceMessagesIndicated 		ifTrue: 			[self browserEnvironment instanceVariableSelectorsFor: self selectedClassOrMetaClass]		ifFalse: 			[self browserEnvironment classVariableSelectorsFor: self selectedClassOrMetaClass]) 			asSortedCollection! !!RefactoringError class methodsFor: 'signalling' stamp: 'md 8/2/2005 23:35'!raiseSignal: aString with: anObject 	"Raise an an exception."	^(self new)		searchFrom: thisContext sender;		messageText: aString;		parameter: anObject;		signal.! !!RefactoringError methodsFor: 'as yet unclassified' stamp: 'dvf 9/15/2001 16:28'!parameter 	self needsWork."what should we do?"	^parameter.	! !!RefactoringError methodsFor: 'as yet unclassified' stamp: 'dvf 9/15/2001 16:28'!parameter: anObject 	self needsWork."what should we do?"	parameter := anObject.	! !"RefactoringEngine"!!PluggableShoutMorph commentStamp: '<historical>' prior: 0!I am a subclass of PluggableTextMorph.Instances of me are usually created using my #on:text:accept:readSelection:menu: class method.In order to colour the text, I use an instance of SHTextStylerST80, which I store in my 'styler' instance variable.When my setText: method is called, I use my styler to ...	a) optionally set all assignments to ansi or leftArrow. 	b) Colour my text (immediately, if the text is less than 4096 chars in length, or in a backgroundProcess otherwise)	When my text is changed, my hasUnacceptedEdits: method is called with true, and I ask my styler to re-colour my text. This is performed in a background process so that typing remains responsive regardless of the length of the text.	Just before my styler is about to format/style the text, I send #stylerAboutToStyle:  to my model. This gives my model a chance to veto the styling (by answering false), or to initialize the styler with information it needs in order to parse the text correctly (e.g. the class to which a method belongs, or the workspace in which I am contained).	My styler informs me that it has finished styling by triggering the #stylerStyled: and #stylerStyledInBackground: events which I handle. I then update the textAttributes of my text and refresh the display. 	My 'unstyledAcceptText' instance variable is used in conjunction with my #acceptTextInModel and #correctFrom:to:with: methods to ensure that when my text is modified during a method compilation (removing unused vars etc), I do not lose those changes.	!!PluggableShoutMorph class methodsFor: 'class initialization' stamp: 'tween 8/27/2004 10:35'!initialize	"Register the receiver with MorphicTextEditor in the AppRegistry.	If the old default was a plain old PluggableTextMorph, then make the receiver the new default, otherwise make the default nil so that the user is prompted"	| current |		current := MorphicTextEditor defaultOrNil.	(current isNil or: [current = PluggableTextMorph or: [current = self]])		ifTrue:[MorphicTextEditor default: self]		ifFalse:[	MorphicTextEditor register: self; default: nil]! !!PluggableShoutMorph class methodsFor: 'instance creation' stamp: 'tween 8/26/2004 01:30'!on: anObject text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel	|styler answer |	answer := self new.	styler := SHTextStylerST80 new		view: answer;		yourself.	"styler when: #aboutToStyle send: #shoutStylerAboutToStyle: to: anObject with: styler."	^ answer		styler: styler;		on: anObject		text: getTextSel		accept: setTextSel		readSelection: getSelectionSel		menu: getMenuSel! !!PluggableShoutMorph methodsFor: 'accepting' stamp: 'tween 8/30/2004 11:48'!acceptTextInModel 		self okToStyle ifFalse:[^super acceptTextInModel].				"#correctFrom:to:with: is sent when the method source is	manipulated during compilation (removing unused temps,	changing selectors etc). But 	#correctFrom:to:with: operates 	on the textMorph's text, and we may be saving an unstyled 	copy of the text. This means that these corrections will be lost	unless we also apply the corrections to the unstyled copy that we are saving.		So remember the unstyled copy in unstyledAcceptText, so	that when #correctFrom:to:with: is received we can also apply	the correction to it"	unstyledAcceptText := styler unstyledTextFrom: textMorph asText.	[^setTextSelector isNil or:		[setTextSelector numArgs = 2			ifTrue: [model perform: setTextSelector with: unstyledAcceptText with: self]			ifFalse: [model perform: setTextSelector with: unstyledAcceptText]]	] ensure:[unstyledAcceptText := nil]! !!PluggableShoutMorph methodsFor: 'styler' stamp: 'tween 8/26/2004 09:57'!classOrMetaClass: aBehavior	"set the classOrMetaClass in the receiver's styler to aBehavior"			styler classOrMetaClass: aBehavior ! !!PluggableShoutMorph methodsFor: 'styler' stamp: 'tween 6/28/2004 08:11'!correctFrom: start to: stop with: aString	"see the comment in #acceptTextInModel "	unstyledAcceptText ifNotNil:[unstyledAcceptText replaceFrom: start to: stop with: aString ].	^ super correctFrom: start to: stop with: aString! !!PluggableShoutMorph methodsFor: 'styler' stamp: 'tween 8/26/2004 09:57'!environment: anObject	"set the environment in the receiver's styler to anObject"			styler environment: anObject ! !!PluggableShoutMorph methodsFor: 'styler' stamp: 'tween 8/30/2004 11:35'!font: aFont	super font: aFont.	styler ifNotNil: [styler font: aFont]! !!PluggableShoutMorph methodsFor: 'styler' stamp: 'tween 8/30/2004 12:34'!hasUnacceptedEdits: aBoolean	"re-implemented to re-style the text iff aBoolean is true"	 	super hasUnacceptedEdits: aBoolean.	(aBoolean and: [self okToStyle])		ifTrue: [ styler styleInBackgroundProcess: textMorph contents]! !!PluggableShoutMorph methodsFor: 'styler' stamp: 'tween 8/26/2004 10:57'!okToStyle	styler ifNil:[^false].	Preferences syntaxHighlightingAsYouType ifFalse: [^false].	(model respondsTo: #shoutAboutToStyle: ) ifFalse:[^true].	^model shoutAboutToStyle: self! !!PluggableShoutMorph methodsFor: 'styler' stamp: 'tween 8/30/2004 12:34'!setText: aText		self okToStyle ifFalse:[^super setText: aText].	super setText: (styler format: aText asText).	aText size < 4096		ifTrue:[	styler style: textMorph contents]		ifFalse:[styler styleInBackgroundProcess:  textMorph contents]! !!PluggableShoutMorph methodsFor: 'styler' stamp: 'tween 8/9/2005 15:41'!sourceMap: aSortedCollection	"set the sourceMap in the receiver's styler to aSortedCollection"			styler sourceMap: aSortedCollection! !!PluggableShoutMorph methodsFor: 'styler' stamp: 'tween 8/28/2004 00:25'!styler	^styler! !!PluggableShoutMorph methodsFor: 'styler' stamp: 'tween 8/26/2004 09:44'!styler: anObject		styler := anObject! !!PluggableShoutMorph methodsFor: 'styler' stamp: 'tween 8/27/2004 11:13'!stylerStyled: styledCopyOfText	textMorph contents runs: styledCopyOfText runs .	textMorph paragraph recomposeFrom: 1 to: textMorph contents size delta: 0.	textMorph updateFromParagraph.	selectionInterval 		ifNotNil:[			textMorph editor				selectInvisiblyFrom: selectionInterval first to: selectionInterval last;				storeSelectionInParagraph;				setEmphasisHere].	textMorph editor blinkParen.	self scrollSelectionIntoView! !!PluggableShoutMorph methodsFor: 'styler' stamp: 'tween 4/27/2004 22:02'!stylerStyledInBackground: styledCopyOfText 	"It is possible that the text string	has changed since the styling began. Disregard the styles if styledCopyOfText's string differs with the current textMorph contents string"		textMorph contents string = styledCopyOfText string		ifTrue: [self stylerStyled: styledCopyOfText]	! !!PluggableShoutMorph methodsFor: 'private' stamp: 'tween 8/29/2004 20:44'!textMorphClass	"Answer the class used to create the receiver's textMorph"		^TextMorphForShout! !!PluggableShoutMorph methodsFor: 'styler' stamp: 'tween 9/13/2004 11:49'!workspace: anObject	"set the workspace in the receiver's styler to anObject"			styler workspace: anObject ! !!TextMorphForShoutEditor methodsFor: 'backspace handling' stamp: 'tween 3/12/2005 12:44'!backTo: startIndex	"When backspacing, 2 notifications of the userHasEdited are received.	This then causes a background process to not terminate correctly.	The reason for all this is uncertain, but discarding the superfluous userHasEdited	message received while running backTo: seems to cure the problem"	| answer |	[inBackTo := true.	answer := super backTo: startIndex	] ensure:[		inBackTo:=false.		^answer]	! !!TextMorphForShoutEditor methodsFor: 'parenblinking' stamp: 'tween 3/12/2005 12:38'!blinkParen	lastParentLocation ifNotNil:		[self text string size >= lastParentLocation ifTrue: [			self text				addAttribute: TextEmphasis bold				from: lastParentLocation				to: lastParentLocation]]! !!TextMorphForShoutEditor methodsFor: 'new selection' stamp: 'tween 8/28/2004 00:26'!changeEmphasis: characterStream 	morph editView styler 		evaluateWithoutStyling: [^super changeEmphasis: characterStream]! !!TextMorphForShoutEditor methodsFor: 'parenblinking' stamp: 'tween 3/12/2005 12:38'!clearParens	super clearParens.	lastParentLocation := nil! !!TextMorphForShoutEditor methodsFor: 'new selection' stamp: 'tween 8/26/2004 11:16'!correctFrom: start to: stop with: aString		view ifNotNil: [view correctFrom: start to: stop with: aString].	^super correctFrom: start to: stop with: aString! !!TextMorphForShoutEditor methodsFor: 'backspace handling' stamp: 'tween 3/12/2005 12:46'!userHasEdited	"ignore this if generated during backTo:	See comment in backTo: "	(inBackTo isNil or: [inBackTo not])		ifTrue:[^super userHasEdited]! !!PluggableShoutView commentStamp: 'tween 8/16/2004 15:09' prior: 0!I am a subclass of PluggableTextView.Instances of me are usually created using my #on:text:accept:readSelection:menu: class method.In order to colour the text, I use an instance of SHTextStylerST80, which I store in my 'styler' instance variable.When my #editString: method is called, I use the styler to ...	a) optionally set all assignments to ansi or leftArrow in my text. 	b) Colour my text (immediately, if the text is less than 4096 chars in length, or in a backgroundProcess otherwise)	When my text is changed, my #hasUnacceptedEdits: method is called with true, and I ask my styler to re-colour my text. This is performed in a background process so that typing remains responsive regardless of the length of the text.	Just before my styler is about to format/style the text, I send #stylerAboutToStyle:  to my model. This gives my model a chance to veto the styling (by answering false), or to initialize the styler with information it needs in order to parse the text correctly (e.g. the class to which a method belongs, or the workspace in which I am contained).	My styler informs me that it has finished styling by triggering the #stylerStyled: and #stylerStyledInBackground: events which I handle. I then update the textAttributes of my text and refresh the display. 	My 'unstyledAcceptText' instance variable is used in conjunction with my #correctFrom:to:with: method to ensure that when my text is modified during a method compilation (removing unused vars etc), I do not lose those changes.	!!PluggableShoutView class methodsFor: 'as yet unclassified' stamp: 'tween 8/24/2004 15:25'!initialize	"Register the receiver with MvcTextEditor in the AppRegistry.	If the old default was a plain old PluggableTextView, then make the receiver the new default, otherwise make the default nil so that the user is prompted.	This is run after the monticello package is loaded"	| current |		current := MvcTextEditor defaultOrNil.	(current isNil or: [current = PluggableTextView or: [current = self]])		ifTrue:[MvcTextEditor default: self]		ifFalse:[	MvcTextEditor register: self; default: nil]! !!PluggableShoutView class methodsFor: 'instance creation' stamp: 'tween 8/27/2004 10:36'!on: anObject text: getTextSel accept: setTextSel readSelection: getSelectionSel menu: getMenuSel	|styler answer|	answer := self new.	styler := SHTextStylerST80 new		view: answer;		yourself.	^ answer 		styler: styler;		on: anObject		text: getTextSel		accept: setTextSel		readSelection: getSelectionSel		menu: getMenuSel! !!PluggableShoutView methodsFor: 'styler' stamp: 'tween 8/26/2004 09:56'!classOrMetaClass: aBehavior	"set the classOrMetaClass in the receiver's styler to aBehavior"			styler classOrMetaClass: aBehavior ! !!PluggableShoutView methodsFor: 'styler' stamp: 'tween 7/27/2004 11:42'!correctFrom: start to: stop with: aString	unstyledAcceptText ifNotNil:[unstyledAcceptText replaceFrom: start to: stop with: aString ].! !!PluggableShoutView methodsFor: 'initialization' stamp: 'tween 8/24/2004 14:34'!defaultControllerClass 	^ PluggableShoutViewController! !!PluggableShoutView methodsFor: 'styler' stamp: 'tween 8/30/2004 12:35'!editString: aString 	self okToStyle ifFalse:[^super editString: aString].	super editString: (styler format: aString asText).	aString size < 4096		ifTrue:[	styler style: displayContents text]		ifFalse:[styler styleInBackgroundProcess: displayContents text]! !!PluggableShoutView methodsFor: 'styler' stamp: 'tween 8/26/2004 09:58'!environment: anObject	"set the environment in the receiver's styler to anObject"			styler environment: anObject ! !!PluggableShoutView methodsFor: 'styler' stamp: 'tween 8/30/2004 12:37'!hasUnacceptedEdits: aBoolean	super hasUnacceptedEdits: aBoolean.	(aBoolean and:[self okToStyle])		ifTrue: [ styler styleInBackgroundProcess: displayContents text]! !!PluggableShoutView methodsFor: 'styler' stamp: 'tween 8/26/2004 10:57'!okToStyle	styler ifNil:[^false].	Preferences syntaxHighlightingAsYouType ifFalse: [^false].	(model respondsTo: #shoutAboutToStyle: ) ifFalse:[^true].	^model shoutAboutToStyle: self! !!PluggableShoutView methodsFor: 'styler' stamp: 'tween 8/30/2004 11:54'!setText: textToAccept from: ctlr	"Re-implemented to save an unstyled copy of textToAccept"		self okToStyle ifFalse:[^super setText: textToAccept from: ctlr].	unstyledAcceptText := styler unstyledTextFrom: textToAccept.	[^super setText: unstyledAcceptText from: ctlr]	ensure:[unstyledAcceptText := nil]! !!PluggableShoutView methodsFor: 'styler' stamp: 'tween 8/9/2005 15:39'!sourceMap: aSortedCollection	"set the sourceMap in the receiver's styler to aSortedCollection"			styler sourceMap: aSortedCollection! !!PluggableShoutView methodsFor: 'styler' stamp: 'tween 8/29/2004 20:59'!styler: anObject		styler := anObject! !!PluggableShoutView methodsFor: 'styler' stamp: 'tween 7/27/2004 16:31'!stylerStyled: styledCopyOfText	controller deselectDuring: [		displayContents text runs: styledCopyOfText runs.		displayContents composeAll.		controller recomputeInterval.		controller setEmphasisHere.		controller blinkParen.		viewport ifNotNil:[			unstyledAcceptText ifNil:[				"don't displayView if accepting text (i.e. unstyledAcceptText not nil)				because popup menus are painted over if we do" 				self displayView]]]! !!PluggableShoutView methodsFor: 'styler' stamp: 'tween 4/27/2004 21:54'!stylerStyledInBackground: styledCopyOfText	(displayContents text string = styledCopyOfText string)		ifTrue: [self stylerStyled: styledCopyOfText]! !!FileContentsBrowser methodsFor: '*Shout-Styling' stamp: 'dp 6/28/2006 20:52'!shoutAboutToStyle: aPluggableShoutMorphOrView	"This is a notification that aPluggableShoutMorphOrView is about to re-style its text.	Set the classOrMetaClass in aPluggableShoutMorphOrView, so that identifiers	will be resolved correctly.	Answer true to allow styling to proceed, or false to veto the styling"	self shoutIsModeStyleable ifFalse: [^false].	aPluggableShoutMorphOrView classOrMetaClass: self selectedClassOrMetaClass.	^true! !!SHParserST80 commentStamp: 'tween 8/16/2004 15:44' prior: 0!I am a Smalltalk method / expression parser.Rather than creating an Abstract Syntax Tree, I create a sequence of SHRanges (in my 'ranges' instance variable), which represent the tokens within the String I am parsing.I am used by a SHTextStylerST80 to parse method source strings.I am able to parse incomplete / incorrect methods, and so can be used to parse methods that are being edited.My 'source' instance variable should be set to the string to be parsed.My 'classOrMetaClass' instance var must be set to the class or metaClass for the method source so that I can correctly resolve identifiers within the source. If this is nil , I parse the source as an expression (i.e. a doIt expression).My 'workspace' instance variable can be set to a Workspace, so that I can resolve workspace variables.My 'environment' instance variable is the global namespace (this is initialized to Smalltalk, but can be set to a different environment).Example 1.	ranges := SHParserST80 new		classOrMetaClass: Object;		source: 'testMethod ^self';		parse;		ranges		!!SHParserST80 class methodsFor: 'instance creation' stamp: 'tween 5/9/2004 12:44'!new	^super new		initialize;		yourself! !!SHParserST80 methodsFor: 'accessing' stamp: 'tween 4/13/2004 20:20'!classOrMetaClass: aClass    classOrMetaClass := aClass! !!SHParserST80 methodsFor: 'scan' stamp: 'tween 4/28/2004 09:42'!currentChar	^source at: sourcePosition ifAbsent: [nil]! !!SHParserST80 methodsFor: 'parse support' stamp: 'tween 4/28/2004 09:48'!enterBlock	blockDepth := blockDepth + 1.	bracketDepth := bracketDepth + 1! !!SHParserST80 methodsFor: 'accessing' stamp: 'tween 5/9/2004 12:43'!environment: anObject	environment := anObject! !!SHParserST80 methodsFor: 'error handling' stamp: 'tween 4/28/2004 10:16'!error	self 		rangeType: #excessCode		start: (ranges isEmpty ifTrue: [1] ifFalse: [ranges last end + 1])		end: source size.	errorBlock value! !!SHParserST80 methodsFor: 'error handling' stamp: 'tween 8/7/2005 14:31'!failUnless: aBoolean	aBoolean ifFalse:[self error]! !!SHParserST80 methodsFor: 'error handling' stamp: 'tween 8/7/2005 14:31'!failWhen: aBoolean	aBoolean ifTrue:[self error]! !!SHParserST80 methodsFor: 'accessing' stamp: 'tween 5/9/2004 12:44'!initialize	environment := Smalltalk! !!SHParserST80 methodsFor: 'parse support' stamp: 'tween 4/28/2004 10:08'!initializeInstanceVariables	instanceVariables := classOrMetaClass notNil 		ifTrue: [classOrMetaClass allInstVarNames asArray]		ifFalse: [Set new]! !!SHParserST80 methodsFor: 'token testing' stamp: 'tween 4/28/2004 09:43'!isAnsiAssignment	^currentToken = ':='! !!SHParserST80 methodsFor: 'token testing' stamp: 'tween 4/28/2004 09:43'!isAssignment	^currentToken = ':=' or: [currentToken = '_']! !!SHParserST80 methodsFor: 'character testing' stamp: 'kwl 7/4/2006 06:54'!isBigDigit: aCharacter base: anInteger    "Answer true if aCharacter is a digit or a capital    letter appropriate for base anInteger"	| digitValue |		digitValue := aCharacter digitValue.	^digitValue >= 0 and:[digitValue < anInteger]! !!SHParserST80 methodsFor: 'token testing' stamp: 'tween 4/28/2004 14:20'!isBinary	(currentToken isNil or: [self isName or: [self isKeyword]]) 		ifTrue: [^false].	1 to: currentToken size do: [:i | | c |		c := currentToken at: i.		((self isSelectorCharacter: c) or: [i = 1 and: [c = $-]]) 			ifFalse: [^false]].	^true! !!SHParserST80 methodsFor: 'identifier testing' stamp: 'tween 5/7/2004 06:24'!isBlockArgName: aString 	"Answer true if aString is the name of a block argument, false otherwise"	| temp arg |	blockDepth to: 1 by: -1 do: [:level | 		arg := (arguments at: level ifAbsent: [#()]) includes: aString.		arg ifTrue: [^true].		temp := (temporaries at: level ifAbsent: [#()]) includes: aString.		temp ifTrue: [^false]].	^false! !!SHParserST80 methodsFor: 'identifier testing' stamp: 'tween 5/7/2004 06:24'!isBlockTempName: aString 	"Answer true if aString is the name of a block temporary. false otherwise"	| temp arg |	blockDepth to: 1 by: -1 do: [:level | 		arg := (arguments at: level ifAbsent: [#()]) includes: aString.		arg ifTrue: [^false].		temp := (temporaries at: level ifAbsent: [#()]) includes: aString.		temp ifTrue: [^true]].	^false! !!SHParserST80 methodsFor: 'identifier testing' stamp: 'tween 5/7/2004 06:37'!isIncompleteBlockArgName: aString 	"Answer true if aString is the start of the name of a block argument, false otherwise"	|  arg |	blockDepth to: 1 by: -1 do: [:level | 		arg := (arguments at: level ifAbsent: [#()]) anySatisfy: [:each | each beginsWith: aString].		arg ifTrue: [^true]].	^false! !!SHParserST80 methodsFor: 'identifier testing' stamp: 'tween 5/7/2004 06:37'!isIncompleteBlockTempName: aString 	"Answer true if aString is the start of the name of a block temporary. false otherwise"	| temp  |	blockDepth to: 1 by: -1 do: [:level | 		temp := (temporaries at: level ifAbsent: [#()]) anySatisfy: [:each | each beginsWith: aString].		temp ifTrue: [^true]].	^false! !!SHParserST80 methodsFor: 'identifier testing' stamp: 'tween 5/7/2004 06:38'!isIncompleteMethodArgName: aString 	"Answer true if aString is the start of the name of a method argument, false otherwise.    Does not check whether aString is also a blockArgName"	^(arguments at: 0 ifAbsent: [#()]) anySatisfy: [:each | each beginsWith: aString]! !!SHParserST80 methodsFor: 'identifier testing' stamp: 'tween 5/7/2004 06:39'!isIncompleteMethodTempName: aString 	"Answer true if aString is the start of then name of a method temporary, false otherwise."	^(temporaries at: 0 ifAbsent: [#()]) anySatisfy: [:each | each beginsWith: aString]! !!SHParserST80 methodsFor: 'token testing' stamp: 'tween 4/28/2004 09:44'!isKeyword	^currentTokenFirst isLetter and: [currentToken last = $:]! !!SHParserST80 methodsFor: 'identifier testing' stamp: 'tween 5/7/2004 06:26'!isMethodArgName: aString 	"Answer true if aString is the name of a method argument, false otherwise.    Does not check whether aString is also a blockArgName"	^(arguments at: 0 ifAbsent: [#()]) includes: aString! !!SHParserST80 methodsFor: 'identifier testing' stamp: 'tween 5/7/2004 06:25'!isMethodTempName: aString 	"Answer true if aString is the name of a method temporary, false otherwise.    Does not check whether aString is also a block temporary    or argument"	((arguments at: 0 ifAbsent: [#()]) includes: aString) ifTrue: [^false].	^(temporaries at: 0 ifAbsent: [#()]) includes: aString! !!SHParserST80 methodsFor: 'token testing' stamp: 'tween 4/28/2004 09:44'!isName	^currentTokenFirst isLetter and: [currentToken last isAlphaNumeric]! !!SHParserST80 methodsFor: 'character testing' stamp: 'tween 4/19/2004 18:17'!isSelectorCharacter: aCharacter	aCharacter isAlphaNumeric ifTrue: [^false].	aCharacter isSeparator ifTrue:[^false].	"$- is specified here as NOT being a selector char, but it can appear as the 	first char in a binary selector. That case is handled specially elsewhere"	(#( $" $# $$ $' $: $( $) $. $; $[ $] ${ $} $^ $_ $- ) includes: aCharacter) 		ifTrue:[^false].	aCharacter asciiValue = 30 ifTrue: [^false "the doIt char"].	aCharacter asciiValue = 0 ifTrue: [^false].	"Any other char is ok as a binary selector char."	^true! !!SHParserST80 methodsFor: 'token testing' stamp: 'tween 4/28/2004 09:43'!isTokenExternalFunctionCallingConvention	| descriptorClass |	descriptorClass := Smalltalk at: #ExternalFunction ifAbsent: [nil].	descriptorClass == nil ifTrue: [^false].	^(descriptorClass callingConventionFor: currentToken) notNil! !!SHParserST80 methodsFor: 'parse support' stamp: 'tween 4/28/2004 09:48'!leaveBlock	arguments removeKey: blockDepth ifAbsent: [].	temporaries removeKey: blockDepth ifAbsent: [].	blockDepth := blockDepth - 1.	bracketDepth := bracketDepth - 1! !!SHParserST80 methodsFor: 'scan' stamp: 'tween 4/28/2004 09:42'!nextChar	sourcePosition := sourcePosition + 1.	^source at: sourcePosition ifAbsent: [$ ]! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 4/17/2004 11:29'!parse    "Parse the receiver's text as a Smalltalk method"    ^self parse: (classOrMetaClass notNil) ! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 7/8/2006 11:08'!parse: isAMethod 	"Parse the receiver's text. If isAMethod is true    then treat text as a method, if false as an    expression with no message pattern"	self initializeInstanceVariables.	sourcePosition := 1.	arguments := Dictionary new.	temporaries := Dictionary new.	blockDepth := bracketDepth := 0.	ranges isNil 		ifTrue: [ranges := OrderedCollection new: 100]		ifFalse: [ranges reset].	errorBlock := [^false].	[self scanNext.	isAMethod 		ifTrue: [			self parseMessagePattern.			self parsePragmaSequence].	self parseMethodTemporaries.	isAMethod ifTrue: [self parsePragmaSequence].	self parseStatementList.	currentToken ifNotNil: [self error]]		ensure:[errorBlock := nil].	^true! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 4/28/2004 09:44'!parseArray	[currentTokenFirst = $)] whileFalse: [self parseLiteralArrayElement].	self scanPast: #arrayEnd! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 5/7/2004 09:31'!parseBinary 	| binary type |	self parseUnary.	[self isBinary] 		whileTrue: [			binary := currentToken.			type := #binary.			(binary isEmpty or:[Symbol hasInterned: binary ifTrue: [:sym | ]])				ifFalse:[					type := (Symbol thatStartsCaseSensitive: binary skipping: nil) isNil						ifTrue: [#undefinedBinary]						ifFalse:[#incompleteBinary]].				self scanPast: type. 				self parseTerm.            	self parseUnary]! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 8/7/2005 14:26'!parseBinaryMessagePattern      	self scanPast:  #patternBinary. 	self failUnless: self isName.	self scanPast: #patternArg.! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 8/7/2005 14:26'!parseBlock	self enterBlock.	self scanPast: #blockStart level: bracketDepth.	currentTokenFirst = $: ifTrue: [self parseBlockArguments].	currentTokenFirst = $| ifTrue: [self parseBlockTemporaries].	self parseStatementList.	self failUnless: currentTokenFirst = $].	self scanPast: #blockEnd level: bracketDepth.	self leaveBlock! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 8/7/2005 14:26'!parseBlockArguments	[currentTokenFirst = $:] 		whileTrue: [			self scanPast: #blockArgColon.			self failUnless: self isName.			self scanPast: #blockPatternArg].	currentTokenFirst = $| 		ifTrue: [^self scanPast: #blockArgsBar]! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 8/7/2005 14:27'!parseBlockTemporaries	currentTokenFirst = $| 		ifTrue: [			self scanPast: #blockTempBar.			[self isName] 				whileTrue: [self scanPast: #blockPatternTempVar].			self failUnless: currentToken = '|'.			self scanPast: #blockTempBar]! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 8/7/2005 14:27'!parseBraceArray	self parseStatementListForBraceArray.	self failUnless: currentTokenFirst = $}.	self scanPast: #rightBrace! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 4/28/2004 14:27'!parseCascade	self parseKeyword.	[currentTokenFirst = $;] 		whileTrue: [			self scanPast: #cascadeSeparator.			self parseKeyword]! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 4/28/2004 14:28'!parseCharSymbol	| s e |	s := sourcePosition - 1.	e := sourcePosition.	self nextChar.	self scanPast: #symbol start: s end: e! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 4/28/2004 13:51'!parseExpression	| assignType |	self isName 		ifTrue: [			self scanPast: (self resolve: currentToken).			self isAssignment 				ifTrue: [					assignType := self isAnsiAssignment 						ifTrue: [#ansiAssignment]						ifFalse: [#assignment].					self scanPast: assignType.					self parseExpression]				ifFalse: [self parseCascade]]		ifFalse: [			self parseTerm.			self parseCascade]! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 8/7/2005 14:27'!parseExternalCall	self scanNext.	self scanPast: #externalCallType.	currentToken = '*' 		ifTrue: [self scanPast: #externalCallTypePointerIndicator].	currentTokenFirst isDigit 		ifTrue: [self scanPast: #integer]		ifFalse: 	[			self failUnless: currentTokenFirst = $'.			self parseString].	self failUnless: currentTokenFirst = $(.	self scanPast: #leftParenthesis.	[currentTokenFirst ~= $)] 		whileTrue: [			self scanPast: #externalCallType.			currentToken = '*' 				ifTrue: [self scanPast: #externalCallTypePointerIndicator]].	self scanPast: #rightParenthesis.	currentToken = 'module:' 		ifTrue: [			self scanPast: #module.			self failUnless: currentTokenFirst = $'.			self parseString].	self failUnless: currentToken = '>'.	self scanPast: #primitiveOrExternalCallEnd! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 5/7/2004 09:26'!parseKeyword     | keyword rangeIndices type |    self parseBinary.	keyword := ''.	rangeIndices := #().	[    		[self isKeyword]        		whileTrue: [				keyword := keyword, currentToken. 				self rangeType: #keyword.				"remember where this keyword token is in ranges"				rangeIndices := rangeIndices copyWith: ranges size.				self scanNext.				self parseTerm.				self parseBinary ]	] ensure: [		"do this in an ensure so that it happens even if the errorBlock evaluates before getting here"		"patch up the keyword tokens, so that incomplete and undefined ones look different"		(keyword isEmpty or:[Symbol hasInterned: keyword ifTrue: [:sym | ]])			ifFalse:[				type := (Symbol thatStartsCaseSensitive: keyword skipping: nil) isNil					ifTrue: [#undefinedKeyword]					ifFalse:[#incompleteKeyword].				rangeIndices do: [:i | (ranges at: i) type: type]]]! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 8/7/2005 14:27'!parseKeywordMessagePattern   	[self isKeyword]		whileTrue: [ 			self scanPast:  #patternKeyword. 			self failUnless: self isName.			self scanPast: #patternArg]! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 8/7/2005 14:29'!parseLiteral: inArray 	currentTokenFirst = $$ 		ifTrue: [			| pos |			self failWhen: self currentChar isNil.			self rangeType: #'$'.			pos := currentTokenSourcePosition + 1.			self nextChar.			^self scanPast: #character start: pos end: pos].	currentTokenFirst isDigit 		ifTrue: [			"do not parse the number, can be time consuming"			^self scanPast: #number].	currentToken = '-' 		ifTrue: [			| c |			c := self currentChar.			(inArray and: [c isNil or: [c isDigit not]]) 				ifTrue: [					"single - can be a symbol in an Array"					^self scanPast: #symbol].			self scanPast: #-.			self failWhen: currentToken isNil.			"token isNil ifTrue: [self error: 'Unexpected End Of Input']."			"do not parse the number, can be time consuming"			^self scanPast: #number].	currentTokenFirst = $' ifTrue: [^self parseString].	currentTokenFirst = $# ifTrue: [^self parseSymbol].	(inArray and: [currentToken notNil]) ifTrue: [^self scanPast: #symbol].	self failWhen: currentTokenFirst = $. .	self error	": 'argument missing'"! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 4/28/2004 13:57'!parseLiteralArrayElement	currentTokenFirst isLetter 		ifTrue: [			| type |			type := (#('true' 'false' 'nil') includes: currentToken) 				ifTrue: [currentToken asSymbol]				ifFalse: [#symbol].			^self scanPast: type].	currentTokenFirst = $( 		ifTrue: [			self scanPast: #arrayStart.			^self parseArray].	^self parseLiteral: true! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 8/7/2005 14:28'!parseMessagePattern   	self isName 		ifTrue: [self parseUnaryMessagePattern]		ifFalse: [			self isBinary				ifTrue:[self parseBinaryMessagePattern]				ifFalse:[					self failUnless: self isKeyword.					self parseKeywordMessagePattern]]! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 8/7/2005 14:28'!parseMethodTemporaries	currentTokenFirst = $| 		ifTrue: [			self scanPast: #methodTempBar.			[self isName] 				whileTrue: [self scanPast: #patternTempVar].			self failUnless: currentToken = '|'.			self scanPast: #methodTempBar]! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 7/2/2006 12:59'!parsePragmaKeyword	[self isKeyword]		whileTrue:[			self scanPast: #pragmaKeyword.			self isName				ifTrue:[self scanPast: (self resolvePragmaArgument: currentToken)] 				ifFalse:[	self parseLiteral: false]].	self failUnless: currentToken = '>'.	self scanPast: #primitiveOrExternalCallEnd! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 7/2/2006 13:22'!parsePragmaSequence	[currentToken = '<' ]		whileTrue:[			self scanPast: #primitiveOrExternalCallStart.			currentToken = 'primitive:' 				ifTrue: [					self rangeType: #primitive.					self parsePrimitive]				ifFalse:[					self isTokenExternalFunctionCallingConvention 						ifTrue: [							self rangeType: #externalFunctionCallingConvention.							self parseExternalCall]						ifFalse:[							self isName								ifTrue:[									self scanPast: #pragmaUnary.									self failUnless: currentToken = '>'.									self scanPast: #primitiveOrExternalCallEnd]								ifFalse:[									self isKeyword										ifTrue:[											self parsePragmaKeyword]										ifFalse:[											self error	": 'Invalid External Function Calling convention'" ]]]]]! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 8/7/2005 14:28'!parsePrimitive	self scanNext.	currentTokenFirst isDigit 		ifTrue: [self scanPast: #integer]		ifFalse: [			self failUnless: currentTokenFirst = $'.			self parseString.			currentToken = 'module:' 				ifTrue: [					self scanPast: #module.					self failUnless: currentTokenFirst = $'.					self parseString]].	self failUnless: currentToken = '>'.	self scanPast: #primitiveOrExternalCallEnd! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 4/28/2004 09:44'!parseStatement	currentTokenFirst = $^ ifTrue: [self scanPast: #return].	self parseExpression! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 4/28/2004 09:44'!parseStatementList		[[currentTokenFirst = $.] whileTrue: [self scanPast: #statementSeparator].	(currentToken notNil and: [currentTokenFirst ~= $]]) 		ifTrue: [self parseStatement].	currentTokenFirst = $.] 			whileTrue: [self scanPast: #statementSeparator]! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 4/28/2004 14:29'!parseStatementListForBraceArray	"same as parseStatementList, but does not allow empty statements e.g {...$a...}.	A single terminating . IS allowed e.g. {$a.} "		[currentTokenFirst ~= $} ifTrue: [self parseStatement].	currentTokenFirst = $.] 		whileTrue: [self scanPast: #statementSeparator]! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 4/28/2004 14:05'!parseString	| first c answer last |	first := sourcePosition.	answer := ''.		[(c := self currentChar) isNil 		ifTrue: [			self rangeType: #unfinishedString start: first - 1 end: source size.			self error	": 'unfinished string'"].	(c ~= $' 			ifTrue: [answer := answer copyWith: c. true] 		ifFalse: [false]	) or: [		self peekChar = $' 			ifTrue: [				sourcePosition := sourcePosition + 1.				answer := answer copyWith: $'.				true]			ifFalse: [false]]	] whileTrue: [sourcePosition := sourcePosition + 1].	last := sourcePosition.	self nextChar.	self scanPast: #string start: first - 1 end: last.	^answer! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 8/7/2005 14:29'!parseSymbol	| c |	currentToken = '#' 		ifTrue: [			"if token is just the #, then scan whitespace and comments			and then process the next character.			Squeak allows space between the # and the start of the symbol 			e.g. # (),  #  a, #  'sym' "			self rangeType: #symbol.			self scanWhitespace].	c := self currentChar.	self failWhen: (c isNil or: [c isSeparator]).	c = $( 		ifTrue: [			self nextChar.			self scanPast: #arrayStart start: currentTokenSourcePosition end: currentTokenSourcePosition + 1.			^self parseArray].	c = $' ifTrue: [^self parseSymbolString].	((self isSelectorCharacter: c) or: [c = $-]) 		ifTrue: [^self parseSymbolSelector].	(c isLetter or: [c = $:]) ifTrue: [^self parseSymbolIdentifier].	^self parseCharSymbol! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 8/7/2005 14:28'!parseSymbolIdentifier	| c start end |	c := self currentChar.	self failUnless: (c isLetter or: [c = $:]).	start := sourcePosition.		[c := self nextChar.	c isAlphaNumeric or: [c = $:]] 		whileTrue: [].	end := sourcePosition - 1.	c := source copyFrom: start - 1 to: end.	self scanPast: #symbol start: start - 1 end: end.	^c! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 4/28/2004 14:06'!parseSymbolSelector	| start end |	start := sourcePosition - 1.	end := sourcePosition.	[self isSelectorCharacter: self nextChar] 		whileTrue: [end := sourcePosition].	self scanPast: #symbol start: start end: end! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 4/28/2004 14:09'!parseSymbolString	| first c last |	first := sourcePosition.	self nextChar.	[(c := self currentChar) isNil 		ifTrue: [			self rangeType: #unfinishedString start: first end: source size.			self error	": 'unfinished string'"].	c ~= $' or: [		self peekChar = $' 			ifTrue: [sourcePosition := sourcePosition + 1.true] 			ifFalse: [false]]	] whileTrue: [sourcePosition := sourcePosition + 1].	last := sourcePosition.	self nextChar.	self scanPast: #stringSymbol start: first - 1 end: last! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 8/7/2005 14:29'!parseTerm	self failWhen: currentToken isNil.	currentTokenFirst = $( 		ifTrue: [			bracketDepth := bracketDepth + 1.			self scanPast: #leftParenthesis level: bracketDepth.			self parseExpression.			self failUnless: currentTokenFirst = $).			self scanPast: #rightParenthesis level: bracketDepth.			^bracketDepth := bracketDepth - 1].	currentTokenFirst = $[ ifTrue: [^self parseBlock].	currentTokenFirst = ${ 		ifTrue: [			self scanPast: #leftBrace.			^self parseBraceArray].	self isName ifTrue: [^self scanPast: (self resolve: currentToken)].	self parseLiteral: false! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 5/7/2004 09:33'!parseUnary	| unary type |	    [self isName]        whileTrue: [			unary := currentToken.			type := #unary.			(unary isEmpty or:[Symbol hasInterned: unary ifTrue: [:sym | ]])				ifFalse:[					type := (Symbol thatStartsCaseSensitive: unary skipping: nil) isNil						ifTrue: [#undefinedUnary]						ifFalse:[#incompleteUnary]].			self scanPast: type]! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 4/17/2004 22:17'!parseUnaryMessagePattern		 self scanPast: #patternUnary! !!SHParserST80 methodsFor: 'scan' stamp: 'tween 4/28/2004 09:42'!peekChar	^source at: sourcePosition + 1 ifAbsent: [$ ]! !!SHParserST80 methodsFor: 'parse support' stamp: 'tween 4/28/2004 10:03'!pushArgument: aString 	(arguments at: blockDepth ifAbsentPut: [OrderedCollection new: 10]) 		add: aString! !!SHParserST80 methodsFor: 'parse support' stamp: 'tween 4/28/2004 10:05'!pushTemporary: aString 	(temporaries at: blockDepth ifAbsentPut: [OrderedCollection new: 10]) 		add: aString! !!SHParserST80 methodsFor: 'recording ranges' stamp: 'tween 4/28/2004 09:54'!rangeType: aSymbol 	^self 		rangeType: aSymbol		start: currentTokenSourcePosition		end: currentTokenSourcePosition + currentToken size - 1! !!SHParserST80 methodsFor: 'recording ranges' stamp: 'tween 4/28/2004 10:20'!rangeType: aSymbol start: s end: e 	^ranges add: (SHRange start: s end: e type: aSymbol)! !!SHParserST80 methodsFor: 'parse' stamp: 'tween 8/26/2004 03:07'!rangesIn: sourceString classOrMetaClass: aBehaviour workspace: aWorkspace  environment: anEnvironmentOrNil	anEnvironmentOrNil ifNotNil: [environment := anEnvironmentOrNil].	self		workspace: aWorkspace;		classOrMetaClass: aBehaviour;		source: sourceString.	self parse.	^ranges! !!SHParserST80 methodsFor: 'identifier testing' stamp: 'tween 12/21/2005 12:02'!resolve: aString 	(#('self' 'super' 'true' 'false' 'nil' 'thisContext') includes: aString) 		ifTrue: [^aString asSymbol].	(self isBlockTempName: aString) ifTrue: [^#blockTempVar].	(self isBlockArgName: aString) ifTrue: [^#blockArg].	(self isMethodTempName: aString) ifTrue: [^#tempVar].	(self isMethodArgName: aString) ifTrue: [^#methodArg].	(instanceVariables includes: aString) ifTrue: [^#instVar].	workspace 		ifNotNil: [(workspace hasBindingOf: aString) ifTrue: [^#workspaceVar]].	Symbol hasInterned: aString ifTrue: [:sym | 		classOrMetaClass isBehavior 			ifTrue: [				classOrMetaClass theNonMetaClass withAllSuperclasses do: [:c | 					(c classPool bindingOf: sym) ifNotNil: [^#classVar].					c sharedPools do: [:p | (p bindingOf: sym) ifNotNil: [^#poolConstant]].					(c environment bindingOf: sym) ifNotNil: [^#globalVar]]]			ifFalse: [(environment bindingOf: sym) ifNotNil: [^#globalVar]]].	^self resolvePartial: aString! !!SHParserST80 methodsFor: 'identifier testing' stamp: 'tween 12/21/2005 12:24'!resolvePartial: aString 	"check if any identifier begins with aString"		(#('self' 'super' 'true' 'false' 'nil' 'thisContext') anySatisfy: [:each | each beginsWith: aString]) 		ifTrue: [^#incompleteIdentifier].	(self isIncompleteBlockTempName: aString) ifTrue: [^#incompleteIdentifier].	(self isIncompleteBlockArgName: aString) ifTrue: [^#incompleteIdentifier].	(self isIncompleteMethodTempName: aString) ifTrue: [^#incompleteIdentifier].	(self isIncompleteMethodArgName: aString) ifTrue: [^#incompleteIdentifier].	(instanceVariables anySatisfy: [:each | each beginsWith: aString]) ifTrue: [^#incompleteIdentifier].	workspace 		ifNotNil: [(workspace hasBindingThatBeginsWith: aString) ifTrue: [^#incompleteIdentifier]].	classOrMetaClass isBehavior 		ifTrue: [			classOrMetaClass theNonMetaClass withAllSuperclasses do: [:c | 				(c classPool hasBindingThatBeginsWith: aString) ifTrue: [^#incompleteIdentifier].				c sharedPools do: [:p | (p hasBindingThatBeginsWith: aString) ifTrue: [^#incompleteIdentifier]].				(c environment hasBindingThatBeginsWith: aString) ifTrue: [^#incompleteIdentifier]]]		ifFalse: [(environment hasBindingThatBeginsWith: aString) ifTrue: [^#incompleteIdentifier]].	^#undefinedIdentifier! !!SHParserST80 methodsFor: 'identifier testing' stamp: 'tween 7/2/2006 12:58'!resolvePartialPragmaArgument: aString 	"check if any valid pragma argument begins with aString"		(#('true' 'false' 'nil') anySatisfy: [:each | each beginsWith: aString]) 		ifTrue: [^#incompleteIdentifier].	"should really check that a matching binding is for a Class?"	classOrMetaClass isBehavior 		ifTrue: [			classOrMetaClass theNonMetaClass withAllSuperclasses do: [:c | 				(c environment hasBindingThatBeginsWith: aString) ifTrue: [^#incompleteIdentifier]]]		ifFalse: [(environment hasBindingThatBeginsWith: aString) ifTrue: [^#incompleteIdentifier]].	^#undefinedIdentifier! !!SHParserST80 methodsFor: 'identifier testing' stamp: 'tween 7/2/2006 12:54'!resolvePragmaArgument: aString 	(#('true' 'false' 'nil') includes: aString) ifTrue: [^aString asSymbol].	"should really check that global is a class?"	Symbol hasInterned: aString ifTrue: [:sym | 		classOrMetaClass isBehavior 			ifTrue: [				classOrMetaClass theNonMetaClass withAllSuperclasses do: [:c | 					(c environment bindingOf: sym) ifNotNil: [^#globalVar]]]			ifFalse: [(environment bindingOf: sym) ifNotNil: [^#globalVar]]].	^self resolvePartialPragmaArgument: aString! !!SHParserST80 methodsFor: 'scan' stamp: 'tween 7/5/2004 14:37'!scanBinary	| c d |	c := self currentChar.	currentTokenSourcePosition := sourcePosition.	currentToken := c asString.	d := self nextChar.	((self isSelectorCharacter: c) or: [c = $: or: [c = $-]]) ifFalse: [^currentToken].	(c = $: and: [d = $=]) 		ifTrue: [" := assignment"			currentToken := currentToken , d asString.			self nextChar.			^currentToken].	c = $| ifTrue:["| cannot precede a longer token" ^currentToken].	[self isSelectorCharacter: d] 		whileTrue: [			currentToken := currentToken , d asString.			d := self nextChar].	^currentToken! !!SHParserST80 methodsFor: 'scan' stamp: 'tween 4/28/2004 14:13'!scanComment	| c s e |	s := sourcePosition.		[sourcePosition := sourcePosition + 1.	(c := self currentChar) 		ifNil: [			self rangeType: #unfinishedComment start: s end: source size.			^self error	": 'unfinished comment'"].	c = $"] 		whileFalse: [].	e := sourcePosition.	s < e ifTrue: [self rangeType: #comment start: s end: e].	self nextChar.	self scanWhitespace! !!SHParserST80 methodsFor: 'scan' stamp: 'tween 4/28/2004 09:46'!scanIdentifier	| c start |	start := sourcePosition.	[(c := self nextChar) isAlphaNumeric] whileTrue: [].	(c = $: and: [(self isSelectorCharacter: self peekChar) not]) 		ifTrue: [self nextChar].	currentToken := source copyFrom: start to: sourcePosition - 1.	currentTokenSourcePosition := start! !!SHParserST80 methodsFor: 'scan' stamp: 'tween 4/28/2004 14:14'!scanNext	self scanWhitespace.	currentTokenFirst := self currentChar.	currentTokenFirst isNil 		ifTrue: [" end of input "			currentTokenFirst := $ .			currentTokenSourcePosition := nil.			currentToken := nil.			^nil].	currentTokenFirst isDigit ifTrue: [^self scanNumber].	currentTokenFirst isLetter ifTrue: [^self scanIdentifier].	^self scanBinary! !!SHParserST80 methodsFor: 'scan' stamp: 'tween 7/8/2006 17:15'!scanNumber	| start c nc base |	start := sourcePosition.	self skipDigits.	c := self currentChar.	c = $r 		ifTrue: [			base := Integer readFrom: (ReadStream on: (source copyFrom: start to: sourcePosition - 1)).			self peekChar = $- ifTrue:[self nextChar].			self skipBigDigits: base.			c := self currentChar.			c = $. 				ifTrue: [					(self isBigDigit: self nextChar base: base) 						ifFalse: [sourcePosition := sourcePosition - 1]						ifTrue: [self skipBigDigits: base]].			c := self currentChar.			(#($d $e $q) includes: c) 				ifTrue: [					((nc := self nextChar) isDigit or: [nc = $- and:[self peekChar isDigit]]) 						ifFalse: [sourcePosition := sourcePosition - 1]						ifTrue: [self skipDigits]].			c = $s 				ifTrue: [					self nextChar isDigit 						ifFalse: [sourcePosition := sourcePosition - 1]						ifTrue: [self skipDigits]].			currentToken := source copyFrom: start to: sourcePosition - 1.			^currentTokenSourcePosition := start].	c = $s 		ifTrue: [			self nextChar isDigit 				ifFalse: [sourcePosition := sourcePosition - 1]				ifTrue: [self skipDigits.].			currentToken := source copyFrom: start to: sourcePosition - 1.			^currentTokenSourcePosition := start].	c = $. 		ifTrue: [			self nextChar isDigit 				ifFalse: [					sourcePosition := sourcePosition - 1.					currentToken := source copyFrom: start to: sourcePosition - 1.					^currentTokenSourcePosition := start]				ifTrue: [self skipDigits.].			c := self currentChar.			(#($d $e $q) includes: c) 				ifTrue: [					((nc := self nextChar) isDigit or: [nc = $-  and:[self peekChar isDigit]]) 						ifFalse: [sourcePosition := sourcePosition - 1]						ifTrue: [self skipDigits]].			c = $s 				ifTrue: [					self nextChar isDigit 						ifFalse: [sourcePosition := sourcePosition - 1]						ifTrue: [self skipDigits]]].	currentToken := source copyFrom: start to: sourcePosition - 1.	^currentTokenSourcePosition := start! !!SHParserST80 methodsFor: 'scan' stamp: 'tween 4/28/2004 10:06'!scanPast: rangeType 	"record rangeType for current token .	record argument and temp declarations.	scan and answer the next token"	rangeType = #blockPatternArg ifTrue: [self pushArgument: currentToken].	rangeType = #blockPatternTempVar ifTrue: [self pushTemporary: currentToken].	rangeType = #patternArg ifTrue: [self pushArgument: currentToken].	rangeType = #patternTempVar ifTrue: [self pushTemporary: currentToken].	^self		rangeType: rangeType;		scanNext! !!SHParserST80 methodsFor: 'scan' stamp: 'tween 4/28/2004 14:17'!scanPast: rangeType level: level	"first level adds no suffix to the rangeType.	Suffix from 1 to 7 added in cycles , ((level-2) mod(7) + 1)"	| cycle typePlusCycle |		cycle := level <= 1 		ifTrue: [0]		ifFalse:[ ((level - 2) \\ 7) + 1].	typePlusCycle := cycle = 0 		ifTrue:[rangeType]		ifFalse:[(rangeType, cycle asString) asSymbol].	^self scanPast: typePlusCycle! !!SHParserST80 methodsFor: 'scan' stamp: 'tween 4/28/2004 09:56'!scanPast: rangeType start: startInteger end: endInteger	"record rangeType for current token from startInteger to endInteger,	 and scanNext token"	^self 		rangeType: rangeType start: startInteger end: endInteger;		scanNext	! !!SHParserST80 methodsFor: 'scan' stamp: 'tween 4/28/2004 14:18'!scanWhitespace	| c |		[c := self currentChar.	c notNil and: [c isSeparator]] 		whileTrue: [sourcePosition := sourcePosition + 1].	c = $" ifTrue: [self scanComment]! !!SHParserST80 methodsFor: 'scan' stamp: 'tween 8/6/2005 13:20'!skipBigDigits: baseInteger	[self isBigDigit: self nextChar base: baseInteger] 		whileTrue: []! !!SHParserST80 methodsFor: 'scan' stamp: 'tween 4/28/2004 14:57'!skipDigits	[self nextChar isDigit] 		whileTrue: []! !!SHParserST80 methodsFor: 'accessing' stamp: 'tween 4/17/2004 22:21'!source	^source! !!SHParserST80 methodsFor: 'accessing' stamp: 'tween 4/27/2004 18:59'!source: aString    source := aString! !!SHParserST80 methodsFor: 'accessing' stamp: 'tween 4/15/2004 13:18'!workspace: aWorkspace    workspace := aWorkspace! !!SHRange commentStamp: 'tween 8/16/2004 15:16' prior: 0!I associate a type with a range of characters in a StringI have these instance variables...	start - the one based index of the first character of the range within the String.	end - the one based index of the last character  of the range within the String.	type - a Symbol describing the type of the range	A sequence of instances of me are created by an instance of SHParserST80 which can then used by an instance of  SHTextStyler to style Text. !!SHRange class methodsFor: 'instance creation' stamp: 'tween 4/28/2004 10:19'!start: s end: e type: aSymbol		^self new		start: s;		end: e;		type: aSymbol;		yourself! !!SHRange methodsFor: 'accessing' stamp: 'tween 4/13/2004 18:55'!end	^end! !!SHRange methodsFor: 'accessing' stamp: 'tween 4/13/2004 18:55'!end: anInteger	end := anInteger! !!SHRange methodsFor: 'accessing' stamp: 'tween 4/24/2004 15:48'!length	^end - start + 1! !!SHRange methodsFor: 'accessing' stamp: 'tween 4/13/2004 18:54'!start	^start! !!SHRange methodsFor: 'accessing' stamp: 'tween 4/13/2004 18:54'!start: anInteger	start := anInteger! !!SHRange methodsFor: 'accessing' stamp: 'tween 4/13/2004 18:55'!type	^type! !!SHRange methodsFor: 'accessing' stamp: 'tween 4/13/2004 18:55'!type: aSymbol	type := aSymbol! !!SHTextStyler commentStamp: 'tween 8/27/2004 10:54' prior: 0!I am an Abstract class.Subclasses of me can create formatted, coloured, and styled copies of Text that is given to them.They may perform their styling asynchronously, in a background process which I create and manage.My public interface is...	view: aViewOrMorph - set the view that will receive notifications when styling has completed.		format: aText - modifies aText's string	style: aText - modifies the TextAttributes of aText, but does not change the string, then sends #stylerStyled: to the view.	styleInBackgroundProcess: aText - performs style: in a background process, then sends #stylerStylednBackground: to the view.	styledTextFor: aText - answers a formatted and styled copy of aText	unstyledTextFrom: aText - answers a copy of aText with all TextAttributes removedSubclasses of me should re-implement...	privateFormat: aText - answer a formatted version of aText; the String may be changed	privateStyle: aText - modify the TextAttributes of aText; but do not change the String			!!SHTextStyler class methodsFor: 'as yet unclassified' stamp: 'tween 8/28/2004 00:20'!new	^super new		initialize;		yourself! !!SHTextStyler methodsFor: 'styling' stamp: 'tween 8/28/2004 00:23'!evaluateWithoutStyling: aBlock	|t|	t := stylingEnabled.	[stylingEnabled := false.	aBlock value]		ensure: [stylingEnabled := t]! !!SHTextStyler methodsFor: 'formatting' stamp: 'tween 8/26/2004 02:19'!format: aText	"Answer a copy of <aText> which has been reformatted,	or <aText> if no formatting is to be applied"		self terminateBackgroundStylingProcess.	^self privateFormat: aText! !!SHTextStyler methodsFor: 'styling' stamp: 'tween 8/28/2004 00:21'!initialize	stylingEnabled := true! !!SHTextStyler methodsFor: 'private' stamp: 'tween 4/9/2004 12:13'!monitor	monitor isNil		ifTrue: [monitor := Monitor new].	^monitor! !!SHTextStyler methodsFor: 'private' stamp: 'tween 8/26/2004 02:26'!privateFormat: aText	self shouldBeImplemented! !!SHTextStyler methodsFor: 'private' stamp: 'tween 8/26/2004 02:25'!privateStyle: aText	self shouldBeImplemented! !!SHTextStyler methodsFor: 'styling' stamp: 'tween 8/30/2004 12:32'!style: aText	self terminateBackgroundStylingProcess.	stylingEnabled ifTrue:[		text := aText copy.		self privateStyle: text.		view ifNotNil:[view stylerStyled: text] ]! !!SHTextStyler methodsFor: 'styling' stamp: 'tween 8/30/2004 12:32'!styleInBackgroundProcess: aText	self terminateBackgroundStylingProcess.	stylingEnabled ifTrue:[		text := aText copy.		self monitor critical: [			sem := Semaphore new. 			[sem notNil				ifTrue: [					sem wait.					view ifNotNil:[view stylerStyledInBackground: text]]			] forkAt: Processor activePriority.			backgroundProcess := 				[self privateStyle: text.				sem signal]					forkAt: Processor userBackgroundPriority] ]	! !!SHTextStyler methodsFor: 'styling' stamp: 'tween 8/26/2004 02:30'!styledTextFor: aText	"Answer a copy of aText that is both formatted and styled"		| formattedText |		formattedText := self privateFormat: aText.	self privateStyle: formattedText.	^formattedText! !!SHTextStyler methodsFor: 'private' stamp: 'tween 4/9/2004 12:21'!terminateBackgroundStylingProcess	self monitor critical: [		backgroundProcess 			ifNotNil: [				backgroundProcess terminate.				backgroundProcess := nil].		sem 			ifNotNil:[				sem terminateProcess.				sem := nil].		]		! !!SHTextStyler methodsFor: 'styling' stamp: 'tween 8/26/2004 02:47'!unstyledTextFrom: aText		^Text fromString: aText string! !!SHTextStyler methodsFor: 'accessing' stamp: 'tween 8/26/2004 00:30'!view: aViewOrMorph	view := aViewOrMorph! !!SHTextStylerST80 commentStamp: 'tween 8/27/2004 10:55' prior: 0!I style Smalltalk methods and expressions.My 'styleTable' class instance var holds an array ofArrays which control how each token is styled/coloured. See my defaultStyleTable class method for its structure.My styleTable can be changed by either modifying the defaultStyleTable class method and then executing SHTextStylerST80 initialize ; or by giving me a new styleTable through my #styleTable: class method.My 'textAttributesByPixelSize' class instance var contains a dictionary of dictionaries.	The key is a pixelSize and the value a Dictionary from token type Symbol to TextAttribute array.	It is created/maintained automatically.	I also install these 3 preferences when my class initialize method is executed....	#syntaxHighlightingAsYouType  - controls whether methods are styled in browsers	#syntaxHighlightingAsYouTypeAnsiAssignment - controls whether assignments are formatted to be :=	#syntaxHighlightingAsYouTypeLeftArrowAssignment - controls whether assignments are formatted to be _I reimplement #unstyledTextFrom: so that TextActions are preserved in the unstyled text 					 	!!SHTextStylerST80 class methodsFor: 'preferences' stamp: 'tween 6/27/2004 11:30'!ansiAssignmentPreferenceChanged	"the user has changed the syntaxHighlightingAsYouTypeAnsiAssignment setting.	If they have turned it on then force syntaxHighlightingAsYouTypeLeftArrowAssignment	to be turned off"	Preferences syntaxHighlightingAsYouTypeAnsiAssignment 		ifTrue:[Preferences disable: #syntaxHighlightingAsYouTypeLeftArrowAssignment]! !!SHTextStylerST80 class methodsFor: 'style table' stamp: 'tween 8/29/2004 19:12'!attributeArrayForColor: aColorOrNil emphasis: anEmphasisSymbolOrArrayorNil font: aTextStyleOrFontOrNil	"Answer a new Array containing any non nil TextAttributes specified"	| answer emphArray |	answer := Array new.	aColorOrNil ifNotNil: [answer := answer, {TextColor color: aColorOrNil}].	anEmphasisSymbolOrArrayorNil ifNotNil: [		emphArray := anEmphasisSymbolOrArrayorNil isSymbol 			ifTrue: [{anEmphasisSymbolOrArrayorNil}] 			ifFalse: [anEmphasisSymbolOrArrayorNil].		emphArray do: [:each |			each ~= #normal				ifTrue:[					answer := answer, {TextEmphasis perform: each}]]].	aTextStyleOrFontOrNil ifNotNil: [		answer := answer, {TextFontReference toFont: aTextStyleOrFontOrNil}].	^answer! !!SHTextStylerST80 class methodsFor: 'style table' stamp: 'tween 4/18/2004 21:10'!attributesFor: aSymbol pixelHeight: aNumber		(self textAttributesByPixelHeight includesKey: aNumber)		ifFalse:[self initializeTextAttributesForPixelHeight: aNumber].	^(self textAttributesByPixelHeight at: aNumber) at: aSymbol ifAbsent:[nil]! !!SHTextStylerST80 class methodsFor: 'style table' stamp: 'tween 7/2/2006 12:02'!defaultStyleTable	"color can be a valid argument to Color class>>colorFrom: , or nil to	use the editor text color.	Multiple emphases can be specified using an array e.g. #(bold italic).	If emphasis is not specified, #normal will be used.	if pixel height is not specified , then the editor font size will be used.	"								^#(	"(symbol	color		[emphasisSymbolOrArray		[textStyleName [pixelHeight]]])"			(default 								black 		)	(invalid 								red 			)	(excessCode 								red 			)	(comment 								(green muchDarker) 		italic)	(unfinishedComment 					(red muchDarker) 	italic)	(#'$'									(red muchDarker) 	)	(character								(red muchDarker) 	)	(integer									(red muchDarker) 	)	(number								(red muchDarker) 	)		(#-										(red muchDarker) 	)	(symbol									(blue muchDarker)			bold)		(stringSymbol							(blue muchDarker)			bold)		(literalArray							(blue muchDarker)			bold)	(string									(magenta muchDarker)	normal)	(unfinishedString						red			normal		)	(assignment								nil			bold			)	(ansiAssignment 						nil			bold)	(literal									nil			italic)	(keyword								(blue muchDarker)			)	(binary 								(blue muchDarker)			)		(unary									(blue muchDarker)			)	(incompleteKeyword						(gray muchDarker)			underlined)	(incompleteBinary 						(gray muchDarker)			underlined)		(incompleteUnary						(gray muchDarker)			underlined)	(undefinedKeyword						red			)	(undefinedBinary 						red			)		(undefinedUnary						red			)														(patternKeyword 						nil			bold)	(patternBinary 							nil			bold)	(patternUnary							nil			bold)		(#self 									(red muchDarker)	bold)	(#super									(red muchDarker)	bold) 	(#true 									(red muchDarker)	bold)	(#false 									(red muchDarker)	bold)	(#nil 									(red muchDarker)	bold)	(#thisContext 							(red muchDarker)	bold)	(#return								(red muchDarker)	bold)	(patternArg 							(blue muchDarker)			italic)		(methodArg 								(blue muchDarker)			italic)	(blockPatternArg 						(blue muchDarker)			italic)	(blockArg 								(blue muchDarker)			italic)	(argument 								(blue muchDarker)			italic)	(blockArgColon							black		) 	(leftParenthesis							black		) 	(rightParenthesis						black		) 	(leftParenthesis1						(green muchDarker)		) 	(rightParenthesis1						(green muchDarker)		) 	(leftParenthesis2						(magenta muchDarker)		) 	(rightParenthesis2						(magenta muchDarker)		) 	(leftParenthesis3						(red muchDarker)		) 	(rightParenthesis3						(red muchDarker)		) 	(leftParenthesis4						(green darker)		) 	(rightParenthesis4						(green darker)		) 	(leftParenthesis5						(orange darker)		) 	(rightParenthesis5						(orange darker)		) 	(leftParenthesis6						(magenta darker)		) 	(rightParenthesis6						(magenta darker)		) 	(leftParenthesis7						blue		) 	(rightParenthesis7						blue		) 	(blockStart 								black		) 	(blockEnd 								black		) 	(blockStart1								(green muchDarker)			) 	(blockEnd1								(green muchDarker)			) 	(blockStart2								(magenta muchDarker)		) 	(blockEnd2								(magenta muchDarker)		) 	(blockStart3								(red muchDarker)		) 	(blockEnd3								(red muchDarker)		) 	(blockStart4								(green darker)		) 	(blockEnd4								(green darker)		) 	(blockStart5								(orange darker)		) 	(blockEnd5								(orange darker)		) 	(blockStart6								(magenta darker)		) 	(blockEnd6								(magenta darker)		) 	(blockStart7								blue		) 	(blockEnd7								blue		) 																																																			(arrayStart								black		) 	(arrayEnd								black		) 	(arrayStart1							black		) 	(arrayEnd1								black		) 	(leftBrace 								black		) 	(rightBrace 								black		) 	(cascadeSeparator 						black		) 	(statementSeparator 						black		) 	(externalCallType 						black		) 	(externalCallTypePointerIndicator 		black		) 	(primitiveOrExternalCallStart 			black	bold	) 	(primitiveOrExternalCallEnd				black	bold	)	(methodTempBar							gray		) 	(blockTempBar 							gray		)	(blockArgsBar							gray		)	(primitive								(green muchDarker)		bold)	(pragmaKeyword						(green muchDarker)		bold)	(pragmaUnary							(green muchDarker)		bold)	(externalFunctionCallingConvention		(green muchDarker)		bold) 	(module									(green muchDarker)		bold)	(blockTempVar 							gray		italic)	(blockPatternTempVar					gray		italic)	(instVar 								black		bold)	(workspaceVar							black		bold)	(undefinedIdentifier						red			bold)	(incompleteIdentifier					(gray darker) 	(italic underlined))	(tempVar								(gray darker)	italic)	(patternTempVar						(gray darker)	italic)	(poolConstant							(gray darker)	italic)	(classVar								(gray darker)	bold)	(globalVar								black		bold) )							! !!SHTextStylerST80 class methodsFor: 'class initialization' stamp: 'tween 4/27/2004 20:06'!initialize  	"Clear styleTable and textAttributesByPixelSize cache so that they will 	reinitialize.	 		SHTextStylerST80 initialize	" 		styleTable := nil.	textAttributesByPixelHeight := nil.		self initializePreferences! !!SHTextStylerST80 class methodsFor: 'preferences' stamp: 'tween 6/25/2006 10:12'!initializePreferences		(Preferences preferenceAt: #syntaxHighlightingAsYouType) ifNil:[		Preferences 			disable: #colorWhenPrettyPrinting;			disable: #browseWithPrettyPrint.		Preferences 			addPreference: #syntaxHighlightingAsYouType			 categories: #( browsing)			default: true 			balloonHelp: 'Enable, or disable, Shout - Syntax Highlighting As You Type. When enabled, code in Browsers and Workspaces is styled to reveal its syntactic structure. When the code is changed (by typing some characters, for example), the styling is changed so that it remains in sync with the modified code'].	(Preferences preferenceAt: #syntaxHighlightingAsYouTypeAnsiAssignment) ifNil:[		Preferences 			addPreference: #syntaxHighlightingAsYouTypeAnsiAssignment			 categories: #( browsing)			default: false 			balloonHelp: 'If true, and syntaxHighlightingAsYouType is enabled,  all left arrow assignments ( _ ) will be converted to the ANSI format ( := ) when a method is selected in a Browser. Whilst editing a method, this setting has no effect - both the left arrow and the ansi format may be used'.		(Preferences preferenceAt: #syntaxHighlightingAsYouTypeAnsiAssignment)			changeInformee: self			changeSelector: #ansiAssignmentPreferenceChanged].			(Preferences preferenceAt: #syntaxHighlightingAsYouTypeLeftArrowAssignment) ifNil:[		Preferences 			addPreference: #syntaxHighlightingAsYouTypeLeftArrowAssignment		 	categories: #( browsing)			default: false 			balloonHelp: 'If true, and syntaxHighlightingAsYouType is enabled,  all ANSI format assignments ( := ) will be converted to left arrows ( _ ) when a method is selected in a Browser. Whilst editing a method, this setting has no effect - both the left arrow and the ansi format may be used'.		(Preferences preferenceAt: #syntaxHighlightingAsYouTypeLeftArrowAssignment)			changeInformee: self 			changeSelector: #leftArrowAssignmentPreferenceChanged ].							! !!SHTextStylerST80 class methodsFor: 'style table' stamp: 'tween 8/30/2004 11:27'!initializeTextAttributesForPixelHeight: aNumber	| d element color  textStyleName  pixelHeight emphasis font textStyle attrArray |	 	self textAttributesByPixelHeight at: aNumber put: (d := IdentityDictionary new).	self styleTable do: [:each |		element := each first.		color := each at: 2 ifAbsent:[nil].		color:=color ifNotNil: [Color colorFrom: color].		emphasis := each at: 3 ifAbsent:[nil].		textStyleName := each at: 4 ifAbsent: [nil].		pixelHeight := each at: 5 ifAbsent: [aNumber].			textStyleName ifNil:[pixelHeight := nil].			textStyle := TextStyle named: textStyleName.		font := textStyle ifNotNil:[pixelHeight ifNotNil:[textStyle fontOfSize: pixelHeight]].		attrArray := self attributeArrayForColor: color emphasis: emphasis font: font.		attrArray notEmpty 			ifTrue:[				d at: element put: attrArray]]		! !!SHTextStylerST80 class methodsFor: 'preferences' stamp: 'tween 6/27/2004 11:31'!leftArrowAssignmentPreferenceChanged	"the user has changed the syntaxHighlightingAsYouTypeLeftArrowAssignment setting.	If they have turned it on then force syntaxHighlightingAsYouTypeAnsiAssignment	to be turned off"	Preferences syntaxHighlightingAsYouTypeLeftArrowAssignment 		ifTrue:[Preferences disable: #syntaxHighlightingAsYouTypeAnsiAssignment]! !!SHTextStylerST80 class methodsFor: 'style table' stamp: 'tween 4/18/2004 21:07'!styleTable		styleTable ifNotNil:[^styleTable].	^styleTable := self defaultStyleTable.							! !!SHTextStylerST80 class methodsFor: 'style table' stamp: 'tween 8/28/2004 16:28'!styleTable: anArray	"Set the receiver's styleTable to anArray.	Clear textAttributesByPixelSize cache so that it will reinitialize.	 	" 		styleTable := anArray.	textAttributesByPixelHeight := nil! !!SHTextStylerST80 class methodsFor: 'style table' stamp: 'tween 4/18/2004 21:10'!textAttributesByPixelHeight		textAttributesByPixelHeight ifNotNil:[^textAttributesByPixelHeight].	^textAttributesByPixelHeight := Dictionary new						! !!SHTextStylerST80 methodsFor: 'private' stamp: 'tween 4/24/2004 14:04'!attributesFor: aSymbol 	^self class attributesFor: aSymbol pixelHeight: self pixelHeight	! !!SHTextStylerST80 methodsFor: 'accessing' stamp: 'tween 4/9/2004 12:47'!classOrMetaClass: aBehavior	classOrMetaClass := aBehavior! !!SHTextStylerST80 methodsFor: 'private' stamp: 'tween 4/28/2004 10:44'!convertAssignmentsToAnsi: aText	"If the Preference is to show ansiAssignments then answer a copy of  <aText> where each  left arrow assignment is replaced with a ':=' ansi assignment. A parser is used so that each left arrow is only replaced if it occurs within an assigment statement"	^self replaceStringForRangesWithType: #assignment with: ':=' in: aText! !!SHTextStylerST80 methodsFor: 'private' stamp: 'tween 4/28/2004 10:45'!convertAssignmentsToLeftArrow: aText	"If the Preference is to show leftArrowAssignments then answer a copy of  <aText> where each ansi assignment (:=) is replaced with a left arrow. A parser is used so that each ':=' is only replaced if it actually occurs within an assigment statement"	^self replaceStringForRangesWithType: #ansiAssignment with: '_' in: aText! !!SHTextStylerST80 methodsFor: 'accessing' stamp: 'tween 5/9/2004 12:50'!environment: anObject	environment := anObject! !!SHTextStylerST80 methodsFor: 'accessing' stamp: 'tween 4/18/2004 10:32'!font: aFont	font := aFont! !!SHTextStylerST80 methodsFor: 'accessing' stamp: 'tween 5/1/2004 14:33'!formatAssignments: aBoolean	"determines whether assignments are reformatted according to the Preferences,	or left as they are"	formatAssignments := aBoolean! !!SHTextStylerST80 methodsFor: 'initialize-release' stamp: 'tween 8/28/2004 00:20'!initialize	super initialize.	formatAssignments := true! !!SHTextStylerST80 methodsFor: 'private' stamp: 'tween 8/26/2004 02:55'!parseableSourceCodeTemplate	^'messageSelectorAndArgumentNames	"comment stating purpose of message"	| temporary variable names |	statements'! !!SHTextStylerST80 methodsFor: 'private' stamp: 'tween 4/25/2004 11:56'!pixelHeight	"In Morphic the receiver will have been given a code font, in MVC the font will be nil. So when the font is nil, answer the pixelHeight of the MVC Browsers' code font, i.e. TextStyle defaultFont pixelHeight"	^(font ifNil:[TextStyle defaultFont]) pixelSize! !!SHTextStylerST80 methodsFor: 'private' stamp: 'tween 8/26/2004 10:53'!privateFormat: aText	"Perform any formatting of aText necessary and answer either aText, or a formatted copy of aText"	aText asString = Object sourceCodeTemplate		ifTrue:[			"the original source code template does not parse,			replace it with one that does"			^self parseableSourceCodeTemplate asText].	formatAssignments		ifTrue:[			Preferences syntaxHighlightingAsYouTypeAnsiAssignment 				ifTrue:[^self convertAssignmentsToAnsi: aText].			Preferences syntaxHighlightingAsYouTypeLeftArrowAssignment 				ifTrue:[^self convertAssignmentsToLeftArrow: aText]].			^aText! !!SHTextStylerST80 methodsFor: 'private' stamp: 'tween 8/26/2004 03:14'!privateStyle: aText	| ranges |	ranges := self rangesIn: aText setWorkspace: true.	ranges ifNotNil: [self setAttributesIn: aText fromRanges: ranges]! !!SHTextStylerST80 methodsFor: 'private' stamp: 'tween 8/26/2004 03:13'!rangesIn: aText setWorkspace: aBoolean	"Answer a collection of SHRanges by parsing aText.	When formatting it is not necessary to set the workspace, and this can make the parse take less time, so aBoolean specifies whether the parser should be given the workspace"	parser ifNil: [parser := SHParserST80 new].	^parser 		rangesIn: aText asString 		classOrMetaClass: classOrMetaClass 		workspace: (aBoolean ifTrue:[workspace])  		environment: environment! !!SHTextStylerST80 methodsFor: 'private' stamp: 'tween 8/9/2005 17:29'!replaceStringForRangesWithType: aSymbol with: aString in: aText 	"Answer aText if no replacements, or a copy of aText with 	each range with a type of aSymbol replaced by aString"	| answer toReplace increaseInLength start end thisIncrease first last newFirst newLast	adjustSourceMap |		toReplace := (self rangesIn: aText setWorkspace: false) 		select: [:each | each type = aSymbol].	toReplace isEmpty ifTrue: [^aText].	answer := aText copy.	increaseInLength := 0.	adjustSourceMap := sourceMap notNil and:[sourceMap ~~ processedSourceMap].	(toReplace asSortedCollection: [:a :b | a start <= b start]) 		do: [:each | 			start := each start + increaseInLength.			end := each end + increaseInLength.			answer 	replaceFrom: start to: end with: aString.			thisIncrease := aString size - each length.			increaseInLength := increaseInLength + thisIncrease.			adjustSourceMap ifTrue:[				sourceMap do:[:assoc |					first := newFirst := assoc value first.					last := newLast := assoc value last.					first > start ifTrue:[newFirst := first + thisIncrease].					last > start ifTrue:[newLast := last + thisIncrease].					(first ~= newFirst or:[last ~= newLast])						ifTrue:[assoc value: (newFirst to: newLast)]]]].	adjustSourceMap ifTrue:[processedSourceMap := sourceMap]. 	^answer! !!SHTextStylerST80 methodsFor: 'private' stamp: 'tween 3/12/2005 23:06'!setAttributesIn: aText fromRanges: ranges	| charAttr defaultAttr attr newRuns newValues lastAttr oldRuns | 					oldRuns := aText runs.	defaultAttr := self attributesFor: #default.	charAttr := Array new: aText size.	1 to: charAttr size do: [:i | charAttr at: i put: defaultAttr].	ranges do: [:range |		(attr := self attributesFor: range type) ifNotNil:[			range start to: range end do: [:i | charAttr at: i put: attr]]].	newRuns := OrderedCollection new: charAttr size // 10.	newValues := OrderedCollection new: charAttr size // 10.	1 to: charAttr size do: [:i |		i = 1 			ifTrue: [				newRuns add: 1.				lastAttr := newValues add: (charAttr at: i)]			ifFalse:[				(charAttr at: i) = lastAttr					ifTrue: [newRuns at: newRuns size put: (newRuns last + 1)]					ifFalse: [						newRuns add: 1.						lastAttr := newValues add: (charAttr at: i)]]].		aText runs: (RunArray runs: newRuns values: newValues).	oldRuns withStartStopAndValueDo:[:start :stop :attribs|		(attribs detect: [:each | each isKindOf: TextAction] ifNone:[nil])			ifNotNil:[				attribs do: [:eachAttrib | aText addAttribute: eachAttrib from: start to: stop]]].	! !!SHTextStylerST80 methodsFor: 'accessing' stamp: 'tween 8/9/2005 15:37'!sourceMap: aSortedCollection	"set the receiver's sourceMap to aSortedCollection.	The sourceMap is used by a Debugger to select the appropriate	ranges within its text. These ranges need to be adjusted if, and when, the receiver	reformats the text that is displayed"	sourceMap := aSortedCollection! !!SHTextStylerST80 methodsFor: 'converting' stamp: 'tween 8/26/2004 02:52'!unstyledTextFrom: aText	"Re-implemented so that TextActions are not removed from aText"	| answer |		answer := super unstyledTextFrom: aText.	aText runs withStartStopAndValueDo:[:start :stop :attribs|		(attribs detect: [:each | each isKindOf: TextAction] ifNone:[nil])			ifNotNil:[				attribs do: [:eachAttrib | answer addAttribute: eachAttrib from: start to: stop]]].	^answer! !!SHTextStylerST80 methodsFor: 'accessing' stamp: 'tween 4/15/2004 13:23'!workspace: aWorkspace	workspace := aWorkspace! !!PluggableShoutViewController methodsFor: 'override' stamp: 'tween 8/29/2005 09:00'!blinkParen	lastParentLocation ifNotNil:		[self text string size >= lastParentLocation ifTrue: [			self text				addAttribute: TextEmphasis bold				from: lastParentLocation				to: lastParentLocation]]! !!PluggableShoutViewController methodsFor: 'override' stamp: 'tween 8/29/2005 09:00'!clearParens	super clearParens.	lastParentLocation := nil! !!PluggableShoutViewController methodsFor: 'override' stamp: 'tween 8/24/2004 17:27'!correctFrom: start to: stop with: aString		view correctFrom: start to: stop with: aString.	^super correctFrom: start to: stop with: aString! !!PluggableShoutViewController methodsFor: 'override' stamp: 'tween 8/24/2004 14:34'!deselectDuring: aZeroArgumentBlock	"evaluate aZeroArgumentBlock with the receiver deselected.	answer the receiver"	| wasSelected |	wasSelected := selectionShowing.	self deselect.	aZeroArgumentBlock value.	wasSelected ifTrue:[self select]! !!PluggableShoutViewController methodsFor: 'override' stamp: 'tween 8/29/2004 21:03'!zapSelectionWith: aText 		super zapSelectionWith: aText.	"we always want userHasEdited to be performed, so that styling occurs after each change.	super zapSelectionWith: will have done it when beginTypeInBlock is nil.	So we only need to do it here when beginTypeInBlock is NOT nil"	beginTypeInBlock ifNotNil:[self userHasEdited]! !!ChangeSorter methodsFor: '*Shout-Styling' stamp: 'dp 6/28/2006 20:51'!shoutAboutToStyle: aPluggableShoutMorphOrView	"This is a notification that aPluggableShoutMorphOrView is about to re-style its text.	Set the classOrMetaClass in aPluggableShoutMorphOrView, so that identifiers	will be resolved correctly.	Answer true to allow styling to proceed, or false to veto the styling"	self shoutIsModeStyleable ifFalse: [^false].	self currentSelector ifNil: [^false].	aPluggableShoutMorphOrView classOrMetaClass: self selectedClassOrMetaClass.	^true! !!MessageSet methodsFor: '*Shout-Styling' stamp: 'dp 6/28/2006 20:52'!shoutAboutToStyle: aPluggableShoutMorphOrView	"This is a notification that aPluggableShoutMorphOrView is about to re-style its text.	Set the classOrMetaClass in aPluggableShoutMorphOrView, so that identifiers	will be resolved correctly.	Answer true to allow styling to proceed, or false to veto the styling"		self shoutIsModeStyleable ifFalse: [^false].	aPluggableShoutMorphOrView classOrMetaClass: self selectedClassOrMetaClass.	^true! !!TextMorphForShout methodsFor: 'private' stamp: 'tween 8/29/2004 20:35'!editorClass	"Answer the class used to create the receiver's editor"		^TextMorphForShoutEditor! !!Browser methodsFor: '*Shout-Styling' stamp: 'dp 6/28/2006 20:51'!shoutAboutToStyle: aPluggableShoutMorphOrView	"This is a notification that aPluggableShoutMorphOrView is about to re-style its text.	Set the classOrMetaClass in aPluggableShoutMorphOrView, so that identifiers	will be resolved correctly.	Answer true to allow styling to proceed, or false to veto the styling"	| type |		self shoutIsModeStyleable ifFalse: [^false].	type := self editSelection.	(#(newMessage editMessage editClass newClass) includes: type) ifFalse:[^false].	aPluggableShoutMorphOrView classOrMetaClass: (type = #editClass ifFalse:[self selectedClassOrMetaClass]).	^true! !!Debugger methodsFor: '*Shout-Styling' stamp: 'dp 6/28/2006 20:52'!shoutAboutToStyle: aPluggableShoutMorphOrView	"This is a notification that aPluggableShoutMorphOrView is about to re-style its text.	Set the classOrMetaClass in aPluggableShoutMorphOrView, so that identifiers	will be resolved correctly.	Answer true to allow styling to proceed, or false to veto the styling"		self shoutIsModeStyleable ifFalse: [^false].	aPluggableShoutMorphOrView 		classOrMetaClass: self selectedClassOrMetaClass;		sourceMap: (sourceMap ifNil:["build the sourceMap now by calling pcRange"self pcRange. sourceMap]).	^true! !!CodeHolder methodsFor: '*Shout-Styling' stamp: 'tween 8/26/2004 09:47'!shoutAboutToStyle: aPluggableShoutMorphOrView	"This is a notification that aPluggableShoutMorphOrView is about to re-style its text.	The default is to answer false to veto the styling"		^false! !!CodeHolder methodsFor: '*Shout-Styling' stamp: 'dp 6/28/2006 20:50'!shoutIsModeStyleable	"determine if Shout can style in the current mode"	^ self showingSource or: [self showingPrettyPrint]! !"Shout"!!String methodsFor: '*ecompletion' stamp: 'bar 8/4/2005 21:25'!beginsWithEmpty: prefix caseSensitive: aBoolean	"Answer whether the receiver begins with the given prefix string. 	The comparison is case-sensitive."	| matchTable |	prefix isEmpty		ifTrue: [^ true].	self size < prefix size		ifTrue: [^ false].	 matchTable _ aBoolean				ifTrue: [CaseSensitiveOrder]				ifFalse: [CaseInsensitiveOrder].	^ (self		findSubstring: prefix		in: self		startingAt: 1		matchTable: matchTable)		= 1! !!String methodsFor: '*ecompletion' stamp: 'bar 8/4/2005 21:25'!indexOfFirstUppercaseCharacter	| position found input |	position _ 0.	found _ false.	input _ ReadStream on: self.	[input atEnd | found ] 		whileFalse:			[input next isUppercase 				ifTrue:[ found _ true ]. 			position _ position + 1].	found 		ifTrue:[ ^position ]		ifFalse:[ ^0 ]! !!String methodsFor: '*ecompletion' stamp: 'bar 8/4/2005 21:25'!wordBefore: anIndex	| sep tok |	tok _ false.	sep _ anIndex.	[sep > 0		and: [(self at: sep) tokenish]]		whileTrue: [tok _ true.			sep _ sep - 1].	^ tok		ifTrue: [self copyFrom: sep + 1 to: anIndex]		ifFalse: [String new]! !!ECDetailMorph commentStamp: '<historical>' prior: 0!I display some detail information for a selected ECEntry in the ECMenuMorph.The content I show, is provided by an ECDetailContentProvider subclass. !!ECDetailMorph class methodsFor: 'as yet unclassified' stamp: 'bar 3/3/2006 16:14'!height	^ ECMenuMorph itemHeight * 15.5! !!ECDetailMorph class methodsFor: 'as yet unclassified' stamp: 'bar 3/3/2006 22:45'!width	^ ECMenuMorph itemWidth * 2.0! !!ECDetailMorph methodsFor: 'drawing' stamp: 'bar 3/3/2006 22:45'!bounds	^ super bounds topLeft extent: self class width @ self class height! !!ECDetailMorph methodsFor: 'drawing' stamp: 'bar 3/1/2006 14:56'!contentBounds	| factor rectangle |	factor _ ECMenuMorph itemHeight.	rectangle _ self bounds top: self bounds top + 3.	rectangle _ rectangle left: rectangle left + (factor * 2.0).	rectangle _ rectangle bottom: rectangle bottom - factor. 	^ rectangle! !!ECDetailMorph methodsFor: 'drawing' stamp: 'bar 2/26/2006 11:48'!defaultColor	^ ECMenuMorph backgroundColor. ! !!ECDetailMorph methodsFor: 'accessing' stamp: 'bar 3/1/2006 16:30'!descriptionBounds	^ self contentBounds top: self contentBounds top + 30! !!ECDetailMorph methodsFor: 'drawing' stamp: 'bar 3/2/2006 17:47'!drawArrowOn: aCanvas 	| point factor poligon |	factor _ ECMenuMorph itemHeight.	point _ arrowPosition.	poligon _ OrderedCollection new.	poligon add: point.	poligon add: (point _ point translateBy: factor / 2 @ 0).	poligon add: (point _ point translateBy: 0 @ (factor * -0.5)).	poligon add: (point _ point translateBy: factor @ factor).	poligon add: (point _ point translateBy: factor * -1 @ factor).	poligon add: (point _ point translateBy: 0 @ (factor * -0.5)).	poligon add: (point _ point translateBy: factor * -0.5 @ 0).	aCanvas drawPolygon: poligon fillStyle: ECMenuMorph scrollColor! !!ECDetailMorph methodsFor: 'drawing' stamp: 'bar 3/3/2006 16:12'!drawMessageOn: aCanvas 	| factor rectangle width browseMessage |	factor _ ECMenuMorph itemHeight.	rectangle _ self bounds top: self bounds bottom - factor.	rectangle _ rectangle left: self contentBounds left.	aCanvas		line: rectangle topLeft + (0 @ 2)		to: rectangle topRight + (-3 @ 2)		color: Color gray.	rectangle _ rectangle top: rectangle top + 3.	aCanvas		drawString: '<- close detail'		in: rectangle		font: ECMenuMorph messageFont		color: Color gray.	browseMessage _ 'browse ->'.	width _ ECMenuMorph messageFont widthOfString: browseMessage .	aCanvas		drawString: browseMessage		in: (rectangle left: rectangle right - width)		font: ECMenuMorph messageFont		color: Color gray! !!ECDetailMorph methodsFor: 'drawing' stamp: 'bar 3/2/2006 21:16'!drawOn: aCanvas 	super drawOn: aCanvas.	arrowPosition ifNotNil: [	self drawArrowOn: aCanvas.	self drawMessageOn: aCanvas]! !!ECDetailMorph methodsFor: 'accessing' stamp: 'bar 3/20/2006 15:33'!entryDescription: anECEntryDescription 	| categoryContents entryDescription |	entryDescription := anECEntryDescription.	title		contents: (entryDescription title				ifNil: [description bounds: self titleBounds.					String new]				ifNotNil: [description bounds: self descriptionBounds.					entryDescription title]).	description contentsWrapped: entryDescription description.	categoryContents := entryDescription label.	label contents: categoryContents! !!ECDetailMorph methodsFor: 'accessing' stamp: 'bar 3/2/2006 21:42'!initialize	| childBounds |	super initialize.	childBounds _ self contentBounds.	label _ StringMorph contents: '' font: ECMenuMorph messageFont.	label bounds: childBounds.	self addMorph: label.	title _ StringMorph contents: '' font: ECMenuMorph titleFont.	title bounds: self titleBounds.	self addMorph: title.	description _ TextMorph new.	description autoFit: false.	description bounds: self descriptionBounds.	description borderWidth: 0.	self addMorph: description! !!ECDetailMorph methodsFor: 'drawing' stamp: 'bar 3/20/2006 15:37'!position: aPoint menuWidth: anInteger 	| y x |	arrowPosition := aPoint.	y := aPoint y + self class height.	y := y > Display height				ifTrue: [Display height - self class height]				ifFalse: [aPoint y - ECMenuMorph itemHeight].	x := aPoint x.	x := x + self class width > Display width				ifTrue: [arrowPosition := (self positionOnLeft: anInteger) @ aPoint y.					arrowPosition x]				ifFalse: [x].	self position: x @ y! !!ECDetailMorph methodsFor: 'private' stamp: 'bar 3/3/2006 23:01'!positionOnLeft: anInteger 	^ arrowPosition x - self class width - anInteger ! !!ECDetailMorph methodsFor: 'accessing' stamp: 'bar 3/1/2006 16:31'!titleBounds	^ self contentBounds top: self contentBounds top + 10! !!ECMenuMorph commentStamp: '<historical>' prior: 0!I show the possible completions in a menu like appearance. The user may choose an entry from my list and complete the word he was typing in the editor. I'm showed with the Tab key and will be deleted when with ESC key or when a successful completion occurs. The following keystrokes are supported:Ctrl-Space or Tab: Open a new morph. Tab requires at least one character in front of the cursor. When already open complete the selected entry. Esc: Close meCtrl+u: Change to untyped mode, so I show all selectors of all classes in the system and the variables that are accessible to the current context.Arrow Up: Move one entry up.Arrow Down: Move one entry downEnter: (like Ctrl-Space and Tab): Complete with the selected item and close the morphany letter or digit: Narrow the completion furtherCtrl+t: Toggle the expand flag. When expand is disabled, you don't see selectors belonging to Object and ProtoObject. !!ECMenuMorph class methodsFor: 'preferences' stamp: 'bar 2/26/2006 11:47'!backgroundColor	"ECMenuMorph backgroundColor"	^ Color		r: 0.95		g: 0.95		b: 0.8		alpha: 0.9! !!ECMenuMorph class methodsFor: 'instance creation' stamp: 'bar 12/13/2004 11:34'!controller: aECController position: aPoint 	| newObject |	newObject := self new.	newObject setController: aECController position: aPoint.	^ newObject! !!ECMenuMorph class methodsFor: 'preferences' stamp: 'bar 8/13/2005 18:34'!convertToSHSymbol: aSymbol 	| |	^ (SHTextStylerST80 new attributesFor: aSymbol)			~= nil		ifTrue: [aSymbol]		ifFalse: [#default].! !!ECMenuMorph class methodsFor: 'as yet unclassified' stamp: 'bar 3/12/2006 11:55'!helpText	| text |	text _ TextStream new.	text withAttribute: TextEmphasis bold do: [text nextPut: 'hello']	text! !!ECMenuMorph class methodsFor: 'preferences' stamp: 'bar 10/16/2004 15:12'!itemHeight	"CompletionMorph itemHeight "		^ 14.! !!ECMenuMorph class methodsFor: 'preferences' stamp: 'bar 10/17/2004 15:16'!itemWidth	^ 200.! !!ECMenuMorph class methodsFor: 'preferences' stamp: 'bar 10/17/2004 15:16'!maxLength	"CompletionMorph maxLength "		^30.! !!ECMenuMorph class methodsFor: 'preferences' stamp: 'bar 3/20/2006 16:09'!messageFont	messageFont		ifNil: [messageFont := StrikeFont						familyName: 'Accuny'						size: 8						emphasized: 0].	^ messageFont! !!ECMenuMorph class methodsFor: 'preferences' stamp: 'bar 11/19/2004 20:53'!scrollArrowSize	^8! !!ECMenuMorph class methodsFor: 'preferences' stamp: 'pk 6/3/2004 00:09'!scrollColor	"CompletionMorph scrollColor "	^ Color r: 1 g: 0.55 b: 0.4 alpha: 0.9.! !!ECMenuMorph class methodsFor: 'preferences' stamp: 'bar 8/12/2005 22:37'!selectColorFor: aSymbol 	| attribute |	attribute _ self convertToSHSymbol: aSymbol.	^ (SHTextStylerST80 new attributesFor: attribute) first color. ! !!ECMenuMorph class methodsFor: 'preferences' stamp: 'bar 8/12/2005 22:41'!selectFontFor: aSymbol 	| emphasized attributes |	attributes _ SHTextStylerST80 new				attributesFor: (self convertToSHSymbol: aSymbol).	emphasized _ attributes size > 1				ifTrue: [attributes second emphasisCode]				ifFalse: [0]. 	^ StrikeFont		familyName: 'Accuny'		size: 12		emphasized: emphasized! !!ECMenuMorph class methodsFor: 'preferences' stamp: 'bar 3/20/2006 16:09'!titleFont	titleFont		ifNil: [titleFont := StrikeFont						familyName: 'Accuny'						size: 20						emphasized: 1].	^ titleFont! !!ECMenuMorph methodsFor: 'actions' stamp: 'bar 3/3/2006 16:28'!browse	(self selectedEntry browseWith: context)		ifTrue: [controller closeMenu]! !!ECMenuMorph methodsFor: 'initialization' stamp: 'bar 12/13/2004 11:42'!createTitle	| transformationMorph titleString |	titleString := context model title.	titleString		ifNil: [^ self].	transformationMorph := TransformationMorph new.	self addMorph: transformationMorph.	titleStringMorph := StringMorph new.	titleStringMorph font: self class titleFont.	transformationMorph addMorph: titleStringMorph.	transformationMorph rotationDegrees: -90.0.	titleStringMorph contents: titleString.	transformationMorph x: 0 y: 10! !!ECMenuMorph methodsFor: 'paging' stamp: 'bar 2/21/2006 21:32'!currentPage	^(self selected - 1 // self pageHeight ) + 1.! !!ECMenuMorph methodsFor: 'private' stamp: 'bar 12/13/2004 13:41'!delete	super delete.	controller menuClosed! !!ECMenuMorph methodsFor: 'drawing' stamp: 'bar 3/12/2006 14:41'!detailMessage	^ detailMorph		ifNil: ['ctrl-h=help | -> open detail']		ifNotNil: ['ctrl-h=help | <- close detail']! !!ECMenuMorph methodsFor: 'accessing' stamp: 'bar 3/12/2006 10:46'!detailPosition: aPoint 	detailPosition := aPoint.	self triggerEvent: #positionChanged! !!ECMenuMorph methodsFor: 'drawing' stamp: 'bar 12/17/2004 23:14'!drawBottomScrollArrowOn: aCanvas 	| aPoligon point arrowHeight |	point _ self bounds bottomLeft translateBy: 6 @ -12.	arrowHeight _ self class scrollArrowSize.	aPoligon _ Array				with: point				with: (point translateBy: arrowHeight @ 0)				with: (point translateBy: arrowHeight / 2 @ arrowHeight).	aCanvas drawPolygon: aPoligon fillStyle: self class scrollColor! !!ECMenuMorph methodsFor: 'drawing' stamp: 'bar 2/20/2006 18:51'!drawMessageOn: aCanvas in: rectangle 	self hasMessage ifFalse:[^self].	context model isEmpty 		ifFalse:[			aCanvas				line: rectangle topLeft + (0 @ 2)				to: rectangle topRight + (-3 @ 2)				color: Color gray]. 	self drawModelMessageOn: aCanvas in:rectangle.	self drawPageCountMessageOn: aCanvas in: rectangle.! !!ECMenuMorph methodsFor: 'drawing' stamp: 'bar 3/12/2006 14:46'!drawModelMessageOn: aCanvas in: rectangle 	| message |	message _ context model hasMessage				ifTrue: [context model message, ' | ctrl-h=help']				ifFalse: [self detailMessage].	aCanvas		drawString: message		in: (rectangle insetBy: 3)		font: self class messageFont		color: Color gray! !!ECMenuMorph methodsFor: 'drawing' stamp: 'bar 3/3/2006 16:33'!drawOn: aCanvas 	| rectangle model |	super drawOn: aCanvas.	self drawTitleOn: aCanvas.	rectangle _ self bounds copy.	rectangle bottom: rectangle top + self class itemHeight.	rectangle _ rectangle left: rectangle left + 20.	model _ context model.	self extent: self extent.	self firstVisible > 1		ifTrue: [self drawTopScrollArrowOn: aCanvas].	self lastVisible ~= self itemsCount		ifTrue: [self drawBottomScrollArrowOn: aCanvas].	model notEmpty		ifTrue: [self firstVisible				to: self lastVisible				do: [:index | 					| symbol type string | 					symbol _ model entries at: index.					string _ symbol contents.					type _ symbol type.					index = self selected						ifTrue: [| rect | 							rect _ rectangle withBottom: rectangle top + self class itemHeight.							aCanvas fillRectangle: rect color: self class scrollColor.							self detailPosition: rect topRight ].					aCanvas						drawString: string						in: (rectangle insetBy: 1)						font: (self selectFont: type)						color: (self selectColor: type).					rectangle _ self prepareRectForNextRow: rectangle]].	self drawMessageOn: aCanvas in: rectangle! !!ECMenuMorph methodsFor: 'drawing' stamp: 'bar 2/20/2006 18:32'!drawPageCountMessageOn: aCanvas in: rectangle 	| msg font msgWidth |	self pageCount > 1 ifFalse:[^self].	msg _  self currentPage printString, '/', self pageCount printString.	font _ self class messageFont.	msgWidth _ font widthOfString: msg.	aCanvas 		drawString: msg 		in: (rectangle translateBy: (rectangle width - msgWidth - 3) @ 3)		font: font		color: Color gray. 		! !!ECMenuMorph methodsFor: 'drawing' stamp: 'bar 11/25/2004 09:48'!drawTitleOn: aCanvas	"| morphicTransform angle |	angle := 90 degreesToRadians.	morphicTransform := MorphicTransform offset: self position angle: angle scale: 1.0.	aCanvas 		transformBy: morphicTransform		clippingTo: self owner innerBounds		during: [:myCanvas | myCanvas drawString:'Ruben' at: self position font: self class titleFont color: Color blue]		smoothing: 1."		! !!ECMenuMorph methodsFor: 'drawing' stamp: 'bar 11/19/2004 20:54'!drawTopScrollArrowOn: aCanvas 	| aPoligon point arrowHeight |	arrowHeight := self class scrollArrowSize.	point := self bounds topLeft translateBy: 6 @ 11.	aPoligon := Array 				with: point				with: (point translateBy: arrowHeight @ 0)				with: (point translateBy: arrowHeight / 2 @ arrowHeight negated).	aCanvas 		drawPolygon: aPoligon 		fillStyle: self class scrollColor. 	! !!ECMenuMorph methodsFor: 'actions' stamp: 'bar 2/20/2006 17:26'!end	self gotoPage: self pageCount.	self changed.! !!ECMenuMorph methodsFor: 'actions' stamp: 'bar 12/16/2004 11:36'!expand	context model toggleExpand.	self narrowCompletion! !!ECMenuMorph methodsFor: 'private' stamp: 'bar 12/13/2004 11:46'!firstVisible	^firstVisible min: context model entryCount! !!ECMenuMorph methodsFor: 'paging' stamp: 'bar 3/20/2006 16:05'!gotoPage: anInteger	| item |	item := ((anInteger - 1) * self pageHeight) + 1. 	item >= self itemsCount ifTrue:[^self].	item < 1 ifTrue:[item := 1].	firstVisible := item.	self selected: firstVisible. 	! !!ECMenuMorph methodsFor: 'event handling' stamp: 'bar 3/31/2006 16:07'!handleMouseEnter: anEvent	self activeHand newKeyboardFocus: controller editor morph.	anEvent wasHandled: true. ! !!ECMenuMorph methodsFor: 'drawing' stamp: 'bar 3/12/2006 14:47'!hasMessage	^ true ! !!ECMenuMorph methodsFor: 'accessing' stamp: 'bar 3/2/2006 17:37'!height	| height |	height _ self visible				ifTrue: [Display height - self bounds topLeft y / self class itemHeight - 1 min: self class maxLength]				ifFalse: [self class maxLength].	height asInteger isZero		ifTrue: [^ 1]		ifFalse: [^ height].! !!ECMenuMorph methodsFor: 'actions' stamp: 'bar 3/12/2006 14:37'!help	ECHelpMorph new openInWorld! !!ECMenuMorph methodsFor: 'actions' stamp: 'bar 2/25/2006 17:17'!hideDetail	detailMorph		ifNil: [^ self].	self removeMorph: detailMorph.	detailMorph delete.	detailMorph _ nil. 	self changed! !!ECMenuMorph methodsFor: 'actions' stamp: 'bar 2/20/2006 17:26'!home	self gotoPage: 1.	self changed! !!ECMenuMorph methodsFor: 'initialization' stamp: 'bar 3/3/2006 16:44'!initialize	super initialize.	self color: self class backgroundColor.	self		when: #positionChanged		send: #updateDetail		to: self! !!ECMenuMorph methodsFor: 'actions' stamp: 'bar 12/13/2004 15:04'!insertCompletion: aString 	| caret old pos editor |	editor := controller editor.	caret := editor caret.	editor selectInvisiblyFrom: caret - context completionToken size to: caret - 1.	old := editor selection. 	editor zapSelectionWith: aString.	pos := caret + (aString copyUpTo: $ ) size + 1 - old size.	editor selectAt: pos.	editor morph invalidRect: editor morph bounds! !!ECMenuMorph methodsFor: 'actions' stamp: 'bar 3/3/2006 16:30'!insertSelected	context model isEmpty ifTrue: [^ false].	self insertCompletion: (context model completionAt: self selected).	self delete.	^ true! !!ECMenuMorph methodsFor: 'private' stamp: 'bar 12/13/2004 16:14'!isClosed	^ owner isNil! !!ECMenuMorph methodsFor: 'private' stamp: 'bar 12/13/2004 11:47'!itemsCount	^context model entryCount! !!ECMenuMorph methodsFor: 'private' stamp: 'bar 10/17/2004 15:15'!lastVisible	^ (self firstVisible + self height-1)  min: (self itemsCount).! !!ECMenuMorph methodsFor: 'actions' stamp: 'bar 12/5/2004 22:23'!moveDown	self selected: self selected + 1.	(self selected > self lastVisible			and: [self selected <= self itemsCount])		ifTrue: [firstVisible := firstVisible + 1].	self changed! !!ECMenuMorph methodsFor: 'actions' stamp: 'bar 12/13/2004 15:05'!moveUp	(self selected = 0			and: [self firstVisible = 1])		ifTrue: [^ self].	self selected: self selected - 1.	self selected < self firstVisible		ifTrue: [firstVisible := firstVisible - 1].	self changed. ! !!ECMenuMorph methodsFor: 'actions' stamp: 'bar 3/3/2006 16:31'!narrowCompletion	| model |	self selected: 0.	firstVisible _ 1.	model _ context model.	model narrowWith: context completionToken.	(model entries size = 1 and: [context completionToken notEmpty]) 		ifTrue: 			[self insertCompletion: (model completionAt: 1).			self delete.			^ false].	model notEmpty ifTrue: [self selected: 1].	self show.	^ true! !!ECMenuMorph methodsFor: 'paging' stamp: 'bar 3/30/2006 14:21'!pageCount	| count |	self itemsCount == self pageHeight		ifTrue: [^ 1].	count := self itemsCount // self pageHeight.	(self itemsCount \\ self pageHeight) > 0 		ifTrue:[count := count + 1].	^count! !!ECMenuMorph methodsFor: 'actions' stamp: 'bar 2/20/2006 17:24'!pageDown	self gotoPage: self currentPage + 1.	self changed. ! !!ECMenuMorph methodsFor: 'paging' stamp: 'bar 2/20/2006 17:53'!pageHeight	^pageHeight.! !!ECMenuMorph methodsFor: 'actions' stamp: 'bar 2/20/2006 17:26'!pageUp	self gotoPage: self currentPage - 1.	self changed. ! !!ECMenuMorph methodsFor: 'drawing' stamp: 'bar 1/6/2005 08:44'!prepareRectForNextRow: aRectangle 	^aRectangle translateBy: 0 @ self class itemHeight! !!ECMenuMorph methodsFor: 'title' stamp: 'bar 12/13/2004 14:16'!removeTitle	titleStringMorph		ifNil: [^ self].	self removeMorph: titleStringMorph owner. 	titleStringMorph := nil! !!ECMenuMorph methodsFor: 'drawing' stamp: 'bar 8/12/2005 23:12'!selectColor: type	^ self class selectColorFor: type! !!ECMenuMorph methodsFor: 'drawing' stamp: 'bar 8/12/2005 22:43'!selectFont: aSymbol 	^ self class selectFontFor: aSymbol! !!ECMenuMorph methodsFor: 'accessing' stamp: 'bar 3/31/2006 14:26'!selected	"Answer the value of selected"	selected ifNil:[selected _ self firstVisible ].	^ selected! !!ECMenuMorph methodsFor: 'accessing' stamp: 'bar 3/3/2006 16:43'!selected: aNumber 	"Set the value of selected"	context model notEmpty		ifTrue: [((1 to: self itemsCount)					includes: aNumber)				ifTrue: [aNumber ~= selected						ifTrue: [selected _ aNumber]]]. ! !!ECMenuMorph methodsFor: 'accessing' stamp: 'bar 3/3/2006 16:30'!selectedEntry	^ context model entries at: self selected! !!ECMenuMorph methodsFor: 'initialization' stamp: 'bar 3/31/2006 09:34'!setController: aECController position: aPoint 	controller := aECController.	context := controller context.	self createTitle.	self position: aPoint - (20 @ 0).	self narrowCompletion		ifTrue: [self openInWorld]. ! !!ECMenuMorph methodsFor: 'drawing' stamp: 'bar 3/2/2006 17:35'!show	| extent height |	firstVisible _ 1.	height _ self visibleItemsCount * self class itemHeight.	pageHeight _ self height asInteger.	self hasMessage		ifTrue: [height _ height + self class itemHeight].	titleStringMorph		ifNotNil: [height _ height max: titleStringMorph width + 30].	extent _ self class itemWidth @ height.	self extent: extent.	self changed! !!ECMenuMorph methodsFor: 'actions' stamp: 'bar 3/3/2006 16:59'!showDetail	detailMorph		ifNotNil: [^ self browse].	self itemsCount isZero ifTrue:[^self].	detailMorph _ ECDetailMorph new.	self addMorph: detailMorph.	self updateDetail! !!ECMenuMorph methodsFor: 'actions' stamp: 'bar 12/20/2004 23:21'!switchToUntyped	context switchToUntyped.	self removeTitle; narrowCompletion; changed! !!ECMenuMorph methodsFor: 'private' stamp: 'bar 3/3/2006 22:52'!updateDetail	detailMorph		ifNil: [^ self].	detailMorph		entryDescription: (self selectedEntry descriptionWith: context).	detailMorph position: detailPosition menuWidth: self width.	detailMorph show! !!ECMenuMorph methodsFor: 'private' stamp: 'pk 6/3/2004 16:31'!visibleItemsCount.	^ self lastVisible - self firstVisible + 1! !!ECHelpMorph commentStamp: '<historical>' prior: 0!I am a system window that displays the keybindings of eCompletion. The text is static and generated in the class methods.!!ECHelpMorph class methodsFor: 'private' stamp: 'bar 3/30/2006 14:27'!explanationAttributes	^{TextIndent spaceUsed; tabs: 2}! !!ECHelpMorph class methodsFor: 'help-text' stamp: 'bar 3/13/2006 20:50'!helpText	| stream |	stream _ TextStream on: Text new.	self section: 'character completion' on: stream.	self		shortcut: 'works on'		text: ' [] {} () <> '''' ""'		on: stream.	self		shortcut: 'usage 1'		text: 'enter open character - closing character is entered as well'		on: stream.	self		shortcut: 'usage 2'		text: 'select some text, enter a smart character and the selected text get surrounded by the opening and closing character.'		on: stream.	self section: 'open/close menu' on: stream.	self		shortcut: 'ctrl-space or tab'		text: 'open the completion menu'		on: stream.	self		shortcut: 'ESC'		text: 'close menu'		on: stream.	self		shortcut: 'ctrl-h'		text: 'open this help'		on: stream.	self section: 'menu navigation' on: stream.	self		shortcut: 'Arrows up/down'		text: 'move the selection up and down'		on: stream.	self		shortcut: 'Page up/down'		text: 'page up and down'		on: stream.	self		shortcut: 'Home/End'		text: 'move to first or last page of the menu'		on: stream.	self section: 'show details and browse' on: stream.	self		shortcut: 'right arrow (detail closed)'		text: 'show details about the selected item. This may be the type of the variable, the source of a method or the implementors of the selector.'		on: stream.	self		shortcut: 'right arrow (detail open)'		text: 'open a new browser for the selected item.'		on: stream.	self		shortcut: 'left arrow'		text: 'close the details'		on: stream.	self section: 'changing menu contents' on: stream.	self		shortcut: 'ctrl-u'		text: 'switch to untyped mode in a typed menu'		on: stream.	self		shortcut: 'ctrl-t'		text: 'filter out methods of class Object in a typed menu. press again to make the reappear.'		on: stream.	self		shortcut: 'alphanumeric character'		text: 'filter the menu to the given input'		on: stream.	self		shortcut: 'backspace'		text: 'delete an input character, adjust menu to the new input.'		on: stream.	self section: 'inserting completion' on: stream.	self		shortcut: 'ctrl-space or tab'		text: 'close the menu and insert selected completion. if there only one item left in the menu this done automaticly.'		on: stream.	^ stream contents! !!ECHelpMorph class methodsFor: 'private' stamp: 'bar 3/12/2006 12:26'!section: aString on: aTextStream 	aTextStream		withAttributes: self sectionAttributes		do: [aTextStream nextPutAll: aString].	aTextStream cr! !!ECHelpMorph class methodsFor: 'private' stamp: 'bar 3/12/2006 12:14'!sectionAttributes	^ {TextEmphasis bold}! !!ECHelpMorph class methodsFor: 'private' stamp: 'bar 3/12/2006 14:30'!shortcut: aString text: secondString on: aTextStream 	aTextStream		withAttributes: self shortcutAttributes		do: [aTextStream nextPutAll: aString;				 cr].	aTextStream		withAttributes: self explanationAttributes		do: [aTextStream nextPutAll: secondString;				 cr].! !!ECHelpMorph class methodsFor: 'private' stamp: 'bar 3/30/2006 14:27'!shortcutAttributes	^ {TextIndent spaceUsed; tabs: 1. TextEmphasis italic }! !!ECHelpMorph methodsFor: 'initialize' stamp: 'bar 3/12/2006 14:26'!contents	^self class helpText ! !!ECHelpMorph methodsFor: 'initialize' stamp: 'bar 3/12/2006 13:04'!defaultColor	^ ECMenuMorph backgroundColor! !!ECHelpMorph methodsFor: 'initialize' stamp: 'bar 3/20/2006 15:35'!initialize	"textMorph _ TextMorph new contents: self class helpText;	yourself.	self addMorph: textMorph"	| text |	super initialize.	self setLabel: 'eCompletion Keyboard Help'.	"self height: ECMenuMorph itemHeight * 60."	text := PluggableTextMorph				on: self				text: #contents				accept: nil				readSelection: nil				menu: nil.	self		addMorph: text		frame: (0 @ 0 corner: 1.0 @ 1.0).	text lock.! !!TextMorph methodsFor: '*ecompletion-override' stamp: 'bar 12/18/2004 08:41' prior: 32380632!initialize	super initialize.	borderWidth _ 0.	textStyle _ TextStyle default copy.	wrapFlag _ true! !!TextMorph methodsFor: '*ecompletion-override' stamp: 'bar 3/31/2006 09:01' prior: 32374168!keyStroke: evt 	"Handle a keystroke event."	| action completionAllowed stringHolder |	stringHolder := editor ifNotNil:[editor model].	completionAllowed := ECController allowModel: stringHolder.	completionAllowed		ifTrue: [(stringHolder completionController handleKeystrokeBefore: evt editor: editor)				ifTrue: [^ self]].	evt keyValue = 13		ifTrue: [action := self crAction.			action				ifNotNil: ["Note: Code below assumes that this was some 					input field reacting on CR. Break the keyboard 					focus so that the receiver can be safely deleted."					evt hand newKeyboardFocus: nil.					^ action value]].	self		handleInteraction: [editor readKeyboard]		fromEvent: evt.	self updateFromParagraph.	super keyStroke: evt.	"sends to keyStroke event handler, if any"	"Narrow the completion with any of the keys"	completionAllowed		ifTrue: [stringHolder completionController handleKeystrokeAfter: evt editor: editor]! !!ECVarTypeGuesser commentStamp: '<historical>' prior: 0!I'm an InstructionClient that tries to guess the type of a given instance variable name of a class. !!ECClassVarTypeGuesser methodsFor: 'as yet unclassified' stamp: 'bar 8/11/2005 13:55'!methodRefs	| theClass classVarAssoc |	theClass _ receiverClass classThatDefinesClassVariable: variableName.	classVarAssoc _ theClass classPool associationAt: variableName asSymbol.	classVarAssoc value		ifNil: [^ SystemNavigation new allCallsOn: classVarAssoc]		ifNotNil: [^ classVarAssoc value class]! !!ECClassVarTypeGuesser methodsFor: 'as yet unclassified' stamp: 'bar 8/11/2005 13:52'!popIntoLiteralVariable: anAssociation 	anAssociation key == variableName asSymbol		ifTrue: [			found _ true]		ifFalse: [self reset]! !!ECClassVarTypeGuesser methodsFor: 'as yet unclassified' stamp: 'bar 8/11/2005 13:07'!popIntoReceiverVariable: offset 	self reset! !!ECClassVarTypeGuesser methodsFor: 'as yet unclassified' stamp: 'bar 8/11/2005 13:14'!send: selector super: supered numArgs: numberArguments ! !!ECInstVarTypeGuesser commentStamp: '<historical>' prior: 0!I'm a simple InstructionClient that tries to guess the type of a given instance variable name of a class. !!ECInstVarTypeGuesser methodsFor: 'as yet unclassified' stamp: 'bar 2/20/2006 14:55'!methodRefs	| theClass selectors |	theClass := receiverClass classThatDefinesInstanceVariable: variableName.	selectors := theClass whichSelectorsStoreInto: variableName.	^ selectors collect:[ :each | MethodReference new setStandardClass: theClass methodSymbol: each ].! !!ECInstVarTypeGuesser methodsFor: 'bytecode decoding' stamp: 'bar 8/11/2005 13:16'!popIntoReceiverVariable: offset 	varIndex = offset ifTrue: [found _ true] ifFalse: [self reset]! !!ECInstVarTypeGuesser methodsFor: 'as yet unclassified' stamp: 'bar 8/11/2005 13:58'!prepare: aCompiledMethod 	| theClass |	super prepare: aCompiledMethod.	theClass _ aCompiledMethod actualClass.	varIndex _ (theClass allInstVarNames indexOf: variableName)				- 1. ! !!ECVarTypeGuesser class methodsFor: 'as yet unclassified' stamp: 'bar 12/9/2004 18:37'!getClassFromTypeSuggestingName: aString 	| firstUppercaseLetter className aStream aClass |	aStream := WriteStream on: String new.	aStream nextPut: aString first asUppercase.	aStream		nextPutAll: (aString copyFrom: 2 to: aString size).	className := aStream contents.	aClass := Smalltalk				at: className asSymbol				ifAbsent: [].	(aClass isKindOf: Class)		ifTrue: [^ aClass].	firstUppercaseLetter := aString indexOfFirstUppercaseCharacter.	className := firstUppercaseLetter > 1				ifTrue: [aString copyFrom: firstUppercaseLetter to: aString size]				ifFalse: [^ nil].	aClass := Smalltalk				at: className asSymbol				ifAbsent: [].	(aClass isKindOf: Class)		ifTrue: [^ aClass].	^ nil! !!ECVarTypeGuesser class methodsFor: 'as yet unclassified' stamp: 'bar 12/8/2004 13:47'!variableName: aString class: aClass 	^self variableName: aString source: nil class: aClass ! !!ECVarTypeGuesser class methodsFor: 'as yet unclassified' stamp: 'bar 4/11/2005 11:32'!variableName: aString source: sourceString class: aClass 	| newInstance |	newInstance _ self basicNew initialize.	newInstance		setVariableName: aString		source: sourceString		class: aClass.	^ newInstance! !!ECVarTypeGuesser methodsFor: 'bytecode decoding' stamp: 'bar 12/13/2004 17:07'!blockReturnTop	contextCount _ contextCount - 1! !!ECVarTypeGuesser methodsFor: 'bytecode decoding' stamp: 'bar 8/11/2005 13:15'!computeVarType	| info tempNames name |	types ifEmpty: [^ nil].	info _ types first.	(hasSend and: [info isDefinedByMessageSend not]) 		ifTrue: 			[info type: nil.			^ info].	info isDefinedByTemporary not ifTrue: [^ info].	tempNames _ (receiverClass compilerClass new 				parse: currentMethod getSourceFromFile asString				in: receiverClass				notifying: nil) tempNames.	name _ tempNames at: info temporaryOffset + 1.	info type: (self class getClassFromTypeSuggestingName: name).	^ info! !!ECVarTypeGuesser methodsFor: 'instance creation' stamp: 'bar 12/13/2004 17:26'!initialize	super initialize.	types := OrderedCollection new.	hasSend := false.	contextCount := 0! !!ECVarTypeGuesser methodsFor: 'bytecode decoding' stamp: 'bar 12/1/2004 21:47'!interpretNextInstructionUsing: aScanner 	found := false.	aScanner interpretNextInstructionFor: self.	^found! !!ECVarTypeGuesser methodsFor: 'public' stamp: 'bar 3/20/2006 15:59'!methodRefs	^Array new! !!ECVarTypeGuesser methodsFor: 'public' stamp: 'bar 3/20/2006 15:21'!perform	| infos infosOfMethod methodRefs |	variableName isEmpty		ifTrue: [^ nil].	methodRefs := self methodRefs.	methodRefs		ifNil: [^ nil]. 	methodRefs isBehavior		ifTrue: [^ methodRefs].	contextCount := 0.	infos := SortedCollection				sortBlock: [:a :b | a priority <= b priority].	methodRefs		do: [:each | 			self prepare: each.			infosOfMethod := self typeOfVarIn: each compiledMethod.			infos addAll: infosOfMethod].	infos notEmpty		ifTrue: [^ infos first type].	^ nil! !!ECVarTypeGuesser methodsFor: 'bytecode decoding' stamp: 'bar 8/11/2005 13:03'!popIntoLiteralVariable: anAssociation 	"Remove Top Of Stack And Store Into Literal Variable bytecode."	self reset! !!ECVarTypeGuesser methodsFor: 'bytecode decoding' stamp: 'bar 12/13/2004 17:08'!popIntoTemporaryVariable: offset 	"Remove Top Of Stack And Store Into Temporary Variable bytecode."	self reset! !!ECVarTypeGuesser methodsFor: 'bytecode decoding' stamp: 'bar 8/11/2005 13:19'!prepare: aCompiledMethod ! !!ECVarTypeGuesser methodsFor: 'bytecode decoding' stamp: 'bar 12/13/2004 17:06'!pushActiveContext	"Push Active Context On Top Of Its Own Stack bytecode."	contextCount _ contextCount + 1! !!ECVarTypeGuesser methodsFor: 'bytecode decoding' stamp: 'bar 8/11/2005 13:14'!pushConstant: value 	"Push Constant, value, on Top Of Stack bytecode."	| info |	contextCount > 0		ifTrue: [^ self].	value		ifNotNil: [info _ ECTypeInfo definedByLiteral: value class.			types add: info]! !!ECVarTypeGuesser methodsFor: 'bytecode decoding' stamp: 'bar 12/13/2004 17:15'!pushLiteralVariable: anAssociation 	"Push Contents Of anAssociation On Top Of Stack bytecode."	| info |	contextCount > 0 ifTrue:[^self].	info := ECTypeInfo definedByMessageSend: anAssociation value.	types add: info! !!ECVarTypeGuesser methodsFor: 'bytecode decoding' stamp: 'bar 12/13/2004 17:15'!pushTemporaryVariable: offset 	"Push Contents Of Temporary Variable Whose Index Is the  	argument, offset, On Top Of Stack bytecode."	| info |		contextCount > 0 ifTrue:[^self].	info := ECTypeInfo definedByTemporaryVar: offset.	types add: info! !!ECVarTypeGuesser methodsFor: 'private' stamp: 'bar 12/13/2004 17:14'!reset	contextCount > 0 ifTrue:[^self].	types reset.	hasSend := false.! !!ECVarTypeGuesser methodsFor: 'bytecode decoding' stamp: 'bar 12/13/2004 17:15'!send: selector super: supered numArgs: numberArguments 	"Send Message With Selector, selector, bytecode. The argument,  	supered, indicates whether the receiver of the message is specified with 	'super' in the source method. The arguments of the message are found  	in  	the top numArguments locations on the stack and the receiver just  	below them."	contextCount > 0 ifTrue:[^self].	hasSend := true! !!ECVarTypeGuesser methodsFor: 'instance creation' stamp: 'bar 12/13/2004 13:55'!setVariableName: aString source: aSourceString class: aClass 	variableName := aString.	receiverClass := aClass! !!ECVarTypeGuesser methodsFor: 'bytecode decoding' stamp: 'bar 8/11/2005 13:32'!typeOfVarIn: aMethod 	"Answer whether the receiver references an instance variable."	| scanner end type infos |	scanner _ InstructionStream on: aMethod.	end _ scanner method endPC.	currentMethod _ aMethod.	infos _ OrderedCollection new.	[scanner pc <= end]		whileTrue: [(self interpretNextInstructionUsing: scanner)				ifTrue: [type _ self computeVarType.					type						ifNotNil: [infos add: type]]].	^ infos! !!Workspace methodsFor: '*ecompletion' stamp: 'bar 10/28/2004 10:14'!addSymbols: aCollection	super addSymbols: aCollection.	bindings 		ifNotNil:[bindings keysDo:[ :each | aCollection add: #local -> each ]].! !!Workspace methodsFor: '*ecompletion' stamp: 'bar 3/1/2006 13:44'!completionAdditionals	| additionals |	additionals _ SortedCollection new.	bindings		ifNotNil: [bindings				keysDo: [:each | additionals						add: (ECLocalEntry contents: each type: #local)]].	^ additionals! !!Workspace methodsFor: '*ecompletion' stamp: 'bar 12/15/2004 09:30'!createCompletionController	^ECWorkspaceController model: self! !!Workspace methodsFor: '*ecompletion' stamp: 'bar 12/16/2004 11:24'!guessTypeForName: aString 	| binding |	bindings		ifNotNil: [binding _ bindings						at: aString						ifAbsent: [].			binding				ifNotNil: [^ binding class]].	^ super guessTypeForName: aString! !!Workspace methodsFor: '*ecompletion' stamp: 'bar 12/16/2004 11:24'!hasBindingOf: aString 	^(self guessTypeForName: aString) notNil! !!Workspace methodsFor: '*ecompletion' stamp: 'bar 12/16/2004 11:26'!hasBindingThatBeginsWith: aString	^false! !!ECClassVarTypeGuesserTest methodsFor: 'as yet unclassified' stamp: 'bar 8/10/2005 14:05'!guessVariable: aString in: aClass expected: theClassExpected 	| typeGuesser result |	typeGuesser _ ECClassVarTypeGuesser variableName: aString class: aClass.	result _ typeGuesser perform.	self assert: result == theClassExpected! !!ECClassVarTypeGuesserTest methodsFor: 'as yet unclassified' stamp: 'bar 8/11/2005 13:14'!testClassVar	self		guessVariable: 'ClassVar'		in: ECTestClass		expected: ByteString! !!ECClassVarTypeGuesserTest methodsFor: 'as yet unclassified' stamp: 'bar 8/11/2005 13:57'!testDependentsFieldsClassVar	self		guessVariable: 'DependentsFields'		in: ECTestClass		expected: WeakIdentityKeyDictionary! !!ECClassVarTypeGuesserTest methodsFor: 'as yet unclassified' stamp: 'bar 8/11/2005 13:23'!testSuperClassVar	self		guessVariable: 'SuperClassVar'		in: ECTestClass		expected: Dictionary ! !!ECContextTest methodsFor: 'private' stamp: 'bar 10/5/2005 23:05'!checkUntypedVariablesOnly: aString 	| context model |	context _ self createContextFor: aString at: aString size.	self assert: context isVariablesOnly.	model _ context model.	self assert: model hasMessage not.	self assert: (model entriesOfType: #instVar) notEmpty.	context narrowWith: 'a'.	self assert: (model entriesOfType: #selector) isEmpty! !!ECContextTest methodsFor: 'private' stamp: 'bar 12/13/2004 15:46'!createContextFor: aString at: anInteger 	^ ECContext		controller: ECController new		class: ECTestClass		source: aString		position: anInteger! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 10/5/2005 22:52'!testBlockTemporaries	| text temps context |	text _ 'testIt	| a b c |	a _ [ :each | |d | ^d].	^self'.	context _ self createContextFor: text at: 39.	temps _ context temporaries				collect: [:each | each contents].	self assert: temps size = 5.	self assert: temps first = 'a'.	self assert: temps second = 'b'.	self assert: temps third = 'c'.	self assert: temps fourth = 'each'.	self assert: temps fifth = 'd'! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 10/5/2005 22:51'!testBlockTemporariesBoxed	| text temps context |	text _ 'testIt	| a b c |	a _ [ :each | |d | d = a ifTrue:[ |x|  ] ifFalse:[ |y|.	^self'.	context _ self createContextFor: text at: 73.	temps _ context temporaries				collect: [:each | each contents].	self assert: temps size = 6.	self assert: temps first = 'a'.	self assert: temps second = 'b'.	self assert: temps third = 'c'.	self assert: temps fourth = 'each'.	self assert: temps fifth = 'd'.	self assert: temps sixth = 'y'! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 12/11/2004 23:42'!testCompletionToken	| text context |	text := 'testIt: aRectangle	| abc |	test.	abc daf'.	context := self createContextFor: text at: text size.	self assert: context completionToken = 'daf'! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 12/12/2004 10:06'!testCompletionTokenEmpty	| text context |	text := 'testIt: aRectangle	| abc |	test.	abc daf '.	context := self createContextFor: text at: text size.	self assert: context completionToken = ''! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 12/13/2004 10:40'!testCreateModel	| text context |	text := 'testIt: aRectangle	aRectangle printS'.	context := self createContextFor: text at: text size.	self assert: context createModel class == ECTypedModel.	text := 'testIt:'.	context := self createContextFor: text at: text size.	self assert: context createModel class = ECOverrideModel.	text := 'testIt: rect	rect is'.	context := self createContextFor: text at: text size.	self assert: context createModel class = ECUntypedModel! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 1/6/2005 22:00'!testEmpty	self createContextFor: '' at: 0! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 12/18/2004 22:23'!testInTheMiddelOfAWord	| text context |	text _ 'hagada'.	context _ self createContextFor: text at: 4.	self assert: context completionToken = 'haga'.! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 12/21/2004 22:20'!testReceiverArgument	| text context |	text _ 'testIt: aRectangle	aRectangle printS'.	context _ self createContextFor: text at: text size.	self assert: context receiverClass == Rectangle.	text _ 'testIt: rect	rect is'.	context _ self createContextFor: text at: text size.	self assert: context receiverClass isNil! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 12/13/2004 09:45'!testReceiverCascade	| text context |	text := 'testIt	| b |	b _ Stream new.	b 		nextPutAll: ''test''; 		nextPut: $c;		s'.	context := self createContextFor: text at: text size.	self assert: context receiverClass == Stream.	text := 'testIt	| b |	b _ Stream new		nextPutAll: ''test''; 		nextPut: $c with: true;		s'.	context := self createContextFor: text at: text size.	self assert: context receiverClass == Stream.	text := 'testIt: aStream	| test |	aStream		nextPutAll: ''test''; 		nextPut: $c with: true;		s'.	context := self createContextFor: text at: text size.	self assert: context receiverClass == Stream.	text := 'testIt: aStream	aStream		nextPutAll: ''test''; 		nextPut: $c with: true;		s'.	context := self createContextFor: text at: text size.	self assert: context receiverClass == Stream! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 8/11/2005 13:25'!testReceiverClassVar	| text context |	text _ 'testIt	ClassVar '.	context _ self createContextFor: text at: text size.	self assert: context receiverClass == ByteString! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 12/12/2004 23:03'!testReceiverConstant	| text context |	text := 'testIt	15r16 printS'.	context := self createContextFor: text at: text size.	self assert: context receiverClass == Number.	text := 'testIt	''test'' printS'.	context := self createContextFor: text at: text size.	self assert: context receiverClass == String.	text := 'testIt	true ifTrue:'.	context := self createContextFor: text at: text size.	self assert: context receiverClass == True.	text := 'testIt	false  "this is it"		printStr'.	context := self createContextFor: text at: text size.	self assert: context receiverClass == False.	text := 'testIt	a _ [ :test | test * test ] 		v'.	context := self createContextFor: text at: text size.	self assert: context receiverClass == BlockContext.	text := 'testIt	$c as'.	context := self createContextFor: text at: text size.	self assert: context receiverClass == Character.	text := 'testIt	#gaga as'.	context := self createContextFor: text at: text size.	self assert: context receiverClass == Symbol.	text := 'testIt	#( 1 2 3) as'.	context := self createContextFor: text at: text size.	self assert: context receiverClass == Array.! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 12/12/2004 22:38'!testReceiverGlobal	| text context |	text := 'testIt	Dictionary n'.	context := self createContextFor: text at: text size.	self assert: context receiverClass == Dictionary class.! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 12/12/2004 23:05'!testReceiverGlobalVarNew	| text context |	text := 'testIt	Dictionary new a'.	context := self createContextFor: text at: text size.	self assert: context receiverClass == Dictionary.! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 8/4/2005 21:29'!testReceiverTempVar	| text context |	text _ 'testIt	| aha |	aha _ ''test''.	aha p'.	context _ self createContextFor: text at: text size.	self assert: context receiverClass == String.	text _ 'testIt	| aha |	ah _ ''test''.	ah p'.	context _ self createContextFor: text at: text size.	self assert: context receiverClass isNil.	text _ 'testIt	| aha |	aha _ constantString.	aha p'.	context _ self createContextFor: text at: text size.	self assert: context receiverClass == ByteString.	text _ 'testIt	| aha |	aha _ constant asDate.	aha p'.	context _ self createContextFor: text at: text size.	self assert: context receiverClass isNil.	text _ 'testIt	| aha bili |	aha _ constantString.	bili _ aha.	bili p'.	context _ self createContextFor: text at: text size.	self assert: context receiverClass == ByteString.	text _ 'testIt	| aha bili |	aha _ constantString.	bili _ aha _ 15.	bili p'.	context _ self createContextFor: text at: text size.	self assert: context receiverClass = Number.	text _ 'testIt	| aha bili |	aha _ constantString.	bili _ 15.	bili _ aha.	bili p'.	context _ self createContextFor: text at: text size.	self assert: context receiverClass == Number.	text _ 'testIt	[ :each | |a| a _ 16. a print'.	context _ self createContextFor: text at: text size.	self assert: context receiverClass == Number.	text _ 'testIt	[ :each | |a| a _ Dictionary new. a print'.	context _ self createContextFor: text at: text size.	self assert: context receiverClass == Dictionary.	text _ 'testIt	[ :each | |a| a _ Dictionary. a print'.	context _ self createContextFor: text at: text size.	self assert: context receiverClass == Dictionary class! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 12/13/2004 16:28'!testReceiverTempVar2	| text context |	text := 'openMenuFor: aParagraphEditor 	| theMenu |	context := ECContext				controller: self				class: model receiverClass				source: aParagraphEditor text string				position: aParagraphEditor caret - 1.	editor := aParagraphEditor.	theMenu := ECMenuMorph				controller: self				position: (aParagraphEditor selectionPosition: context completionToken).	theMenu isClosed		ifFalse: [menuMorph := theMenu]. theMenu o'.	context := self createContextFor: text at: text size.	self assert: context receiverClass == ECMenuMorph! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 10/5/2005 22:51'!testTemporaries	| text temps context |	text _ 'testIt: aRectangle	| a b c |	a _ [ :each | |d | ^d].	^self'.	context _ self createContextFor: text at: text size.	temps _ context temporaries				collect: [:each | each contents].	self assert: temps size = 4.	self assert: temps first = 'aRectangle'.	self assert: temps second = 'a'.	self assert: temps third = 'b'.	self assert: temps fourth = 'c'! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 12/18/2004 23:52'!testUnfinishedString	| text context |	text _ 'testIt: aRectangle	| a b c |	self test: ''test it and so'.	context _ self createContextFor: text at: text size.	self assert: context completionToken = 'so'.! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 12/20/2004 23:17'!testUntypedSelectorsOnly	| text context model |	text _ 'testIt: aRectangle	| ab bc bd |	ab '.	context _ self createContextFor: text at: text size.	model _ context model.	self assert: model hasMessage.	self assert: model message = 'press key for selectors'.	context narrowWith: 'a'.	self assert: (model entriesOfType: #selector) notEmpty.	self assert: (model entriesOfType: #local) isEmpty.	self assert: (model entriesOfType: #instance) isEmpty! !!ECContextTest methodsFor: 'as yet unclassified' stamp: 'bar 3/9/2006 10:10'!testUntypedVarsOnly	self checkUntypedVariablesOnly: 'testIt	'.	self checkUntypedVariablesOnly: '+ aTest	'.	self checkUntypedVariablesOnly: 'gaga: aTest	'.	self checkUntypedVariablesOnly: 'gaga	^ '.	self checkUntypedVariablesOnly: 'testIt 	a ifTrue:[ '.	self checkUntypedVariablesOnly: 'testIt 	a ifTrue:[ :each'.	self checkUntypedVariablesOnly: 'testIt 	a ifTrue:[ :each |'.	self checkUntypedVariablesOnly: 'testIt 	a ifTrue:[ :each | '.	self checkUntypedVariablesOnly: 'testIt	<primitive: 67> 	'.	self checkUntypedVariablesOnly: 'testIt	ab _'.	self checkUntypedVariablesOnly: 'testIt	ab _ '.	self checkUntypedVariablesOnly: 'self compare: '.	self checkUntypedVariablesOnly: 'self compare: x caseSensitive: '.	self checkUntypedVariablesOnly: 'self gaga: x gugu: ('.	self checkUntypedVariablesOnly: 'testIt	a _ 15 + '.	self checkUntypedVariablesOnly: 'testIt	self hugatada: '! !!ECEntryTest methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 13:57'!testCompletion	| entry |	entry _ ECSelectorEntry contents: 'makeItHappen' type: #unary:.	self assert: entry completion = #makeItHappen! !!ECEntryTest methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 13:26'!testInstance	| entry |	entry _ ECInstVarEntry contents: 'abc' type: #instVar:.	self assert: entry isInstance! !!ECEntryTest methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 13:44'!testLocal	| entry |	entry _ ECLocalEntry contents: 'abc' type: #patternArg:.	self assert: entry contents = 'abc'.	self assert: entry type = #patternArg:.	self assert: entry isLocal! !!ECEntryTest methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 16:14'!testPrintOn	| entry |	entry _ ECSelectorEntry contents: 'compute' type: #unary:.	self assert: 'ECSelectorEntry(compute,unary:)' = entry printString! !!ECInstVarTypeGuesserTest methodsFor: 'private' stamp: 'bar 3/30/2006 17:05'!guessVariable: aString in: aClass expected: theClassExpected 	| typeGuesser result |	typeGuesser _ ECInstVarTypeGuesser variableName: aString class: aClass.	result _ typeGuesser perform.	self assert: result == theClassExpected ! !!ECInstVarTypeGuesserTest methodsFor: 'testing' stamp: 'bar 12/13/2004 10:41'!tesConstantFalse	self 		guessVariable: 'false'		in: ECTestClass		expected: False.	self 		guessVariable: 'false'		in: nil		expected: False! !!ECInstVarTypeGuesserTest methodsFor: 'testing' stamp: 'bar 3/30/2006 17:06'!testComplexInit	self		guessVariable: 'complexInit'		in: ECTestClass		expected: nil! !!ECInstVarTypeGuesserTest methodsFor: 'testing' stamp: 'bar 12/13/2004 10:41'!testComplexInit2	self 		guessVariable: 'complexInit2'		in: ECTestClass		expected: Dictionary! !!ECInstVarTypeGuesserTest methodsFor: 'testing' stamp: 'bar 12/13/2004 13:46'!testConstantArray	self 		guessVariable: 'constantArray'		in: ECTestClass		expected: Array! !!ECInstVarTypeGuesserTest methodsFor: 'testing' stamp: 'bar 12/13/2004 13:46'!testConstantBoolean	self 		guessVariable: 'constantBoolean'		in: ECTestClass		expected: True! !!ECInstVarTypeGuesserTest methodsFor: 'testing' stamp: 'bar 12/13/2004 13:47'!testConstantInteger	self 		guessVariable: 'constantInteger'		in: ECTestClass		expected: SmallInteger! !!ECInstVarTypeGuesserTest methodsFor: 'testing' stamp: 'bar 12/13/2004 13:47'!testConstantIntegerNil	self		guessVariable: 'constantNil'		in: ECTestClass		expected: nil! !!ECInstVarTypeGuesserTest methodsFor: 'testing' stamp: 'bar 8/6/2005 22:33'!testConstantString	self		guessVariable: 'constantString'		in: ECTestClass		expected: ByteString! !!ECInstVarTypeGuesserTest methodsFor: 'testing' stamp: 'bar 8/4/2005 21:30'!testConstantSymbol	self		guessVariable: 'constantSymbol'		in: ECTestClass		expected: ByteSymbol! !!ECInstVarTypeGuesserTest methodsFor: 'testing' stamp: 'bar 12/13/2004 16:42'!testGlobalVarKeyword	self		guessVariable: 'globalVarKeyword'		in: ECTestClass		expected: SortedCollection! !!ECInstVarTypeGuesserTest methodsFor: 'testing' stamp: 'bar 12/13/2004 17:19'!testGlobalVarKeyword2	self		guessVariable: 'globalVarKeyword2'		in: ECTestClass		expected: SortedCollection! !!ECInstVarTypeGuesserTest methodsFor: 'testing' stamp: 'bar 12/13/2004 13:47'!testMessageSend	self 		guessVariable: 'messageSend'		in: ECTestClass		expected: Dictionary! !!ECInstVarTypeGuesserTest methodsFor: 'testing' stamp: 'bar 2/20/2006 15:12'!testMessageSend2	self 		guessVariable: 'messageSend2'		in: ECTestClass		expected: nil! !!ECInstVarTypeGuesserTest methodsFor: 'testing' stamp: 'bar 12/13/2004 13:48'!testSuperWithAnotherInit	self 		guessVariable: 'superInstVar'		in: ECTestClass		expected: Dictionary! !!ECInstVarTypeGuesserTest methodsFor: 'testing' stamp: 'bar 12/13/2004 13:48'!testTypeSuggestingParameter	self 		guessVariable: 'typeSuggestingParameter2'		in: ECTestClass		expected: Rectangle! !!ECOverrideModelTest methodsFor: 'testing' stamp: 'bar 12/13/2004 10:41'!setUp	model := ECOverrideModel class: ECTestClass.	model toggleExpand! !!ECOverrideModelTest methodsFor: 'testing' stamp: 'bar 12/6/2004 17:10'!testCompletionAt	| completion |	completion := model completionAt: 2.	self assert: completion = 'toBeOverriden: anArgument	super toBeOverriden: anArgument'! !!ECOverrideModelTest methodsFor: 'testing' stamp: 'bar 12/6/2004 16:45'!testCompletionAtWithReturn	| completion |	completion := model completionAt: 3.	self assert: completion = 'toBeOverridenWithReturn	^super toBeOverridenWithReturn'! !!ECOverrideModelTest methodsFor: 'testing' stamp: 'bar 12/6/2004 17:10'!testExpand	| size |	size := model entries size.	self assert: size == model entries size! !!ECOverrideModelTest methodsFor: 'testing' stamp: 'bar 12/6/2004 17:11'!testOverride	| selectors |	self assert: model notEmpty.	self assert: model entries size = 3.	selectors := model entriesOfType: #selector.	self		assert: (selectors includes: #toBeOverriden:).	self		assert: (selectors includes: #initialize).	self		assert: (selectors includes: #toBeOverridenWithReturn)! !!ECOverrideModelTest methodsFor: 'testing' stamp: 'bar 12/13/2004 10:46'!testTitle	self assert: '(override) ECTestSuperClass' = model title! !!ECStringSortingTest methodsFor: 'as yet unclassified' stamp: 'bar 8/6/2005 22:22'!testCaseSensitiveMap	| map colon o |	map _ String classPool at: #CaseSensitiveOrder.	colon _ map at: $: asciiValue + 1.	o _ map at: $O asciiValue + 1.	self assert: colon < o! !!ECStringSortingTest methodsFor: 'as yet unclassified' stamp: 'bar 8/6/2005 20:55'!testCompare	self assert: ('at:' compare: 'atOne' caseSensitive: false)			== 1! !!ECStringSortingTest methodsFor: 'as yet unclassified' stamp: 'bar 8/6/2005 22:16'!testCompareWithCase	self assert: ('at:' compare: 'atOne' caseSensitive: true)			== 1! !!ECTypedModelTest methodsFor: 'as yet unclassified' stamp: 'bar 10/5/2005 23:21'!testExpand	| model selectors |	model _ ECTypedModel class: ECTestClass.	self assert: (model entriesOfType: #locals) isEmpty.	self assert: (model entriesOfType: #instance) isEmpty.	model toggleExpand.	selectors _ model entriesOfType: #selector.	self assert: selectors size == 6.	self		assert: (selectors includes: #initialize).	self		assert: (selectors includes: #lowPriorityOverrides:).	self		assert: (selectors includes: #testIt:).	model toggleExpand.	selectors _ model entriesOfType: #selector.	self assert: selectors size > 100.	self		assert: (selectors includes: #instVarAt:).	self		assert: (selectors includes: #initialize).	self		assert: (selectors includes: #lowPriorityOverrides:).	self		assert: (selectors includes: #testIt:).	self		assert: (selectors includes: #instVarAt:).	model toggleExpand.	selectors _ model entriesOfType: #selector.	self assert: selectors size == 6! !!ECTypedModelTest methodsFor: 'as yet unclassified' stamp: 'bar 12/17/2004 22:44'!testMessage	| model |	model := ECTypedModel class: ECTestClass.	self shouldnt: model hasMessage.	model narrowWith: 'hagadagadu'.	self assert: model hasMessage.	self assert: model message = 'no completions found'! !!ECTypedModelTest methodsFor: 'as yet unclassified' stamp: 'bar 12/13/2004 10:45'!testTitle	| model |	model := ECTypedModel class: ECTestClass.	self assert: 'ECTestClass' = model title! !!ECTypedModelTest methodsFor: 'as yet unclassified' stamp: 'bar 12/13/2004 10:41'!testTyped	| model selectors |	model := ECTypedModel class: ECTestClass.	self assert: (model entriesOfType: #locals) size == 0.	self assert: (model entriesOfType: #instance) size == 0.	selectors := model entriesOfType: #selector.	self assert: selectors size > 0.	self assert: (selectors includes: #initialize).	self assert: (selectors includes: #lowPriorityOverrides:).	self assert: (selectors includes: #testIt:).	model narrowWith: 'low'.	selectors := model entriesOfType: #selector.	self deny: (selectors includes: #initialize).	self assert: (selectors includes: #lowPriorityOverrides:).	self deny: (selectors includes: #testIt:)! !!ECUntypedModelTest methodsFor: 'testing' stamp: 'bar 4/11/2005 10:57'!setUp	prefValueCase _ ECPreferences caseSensitive.	ECPreferences setCaseSensitiveness: true! !!ECUntypedModelTest methodsFor: 'testing' stamp: 'bar 4/11/2005 10:59'!tearDown	ECPreferences setCaseSensitiveness: prefValueCase! !!ECUntypedModelTest methodsFor: 'testing' stamp: 'bar 3/1/2006 13:44'!testAdditionalLocals	| model locals |	model _ ECUntypedModel				class: ECTestClass				temporaries: (OrderedCollection						with: (ECLocalEntry contents: 'a' type: #local)						with: (ECLocalEntry contents: 'b' type: #local))				additionals: (Array						with: (ECLocalEntry contents: 'veryImp' type: #local))				variables: true				selectors: true.	locals _ model entriesOfType: #local.	self		assert: (locals includes: 'veryImp')! !!ECUntypedModelTest methodsFor: 'testing' stamp: 'bar 10/5/2005 23:14'!testCaseSensitive	| model locals |	self assert: ECPreferences caseSensitive.	model _ ECUntypedModel class: ECTestClass temporaries: OrderedCollection new.	locals _ model entriesOfType: #instVar.	self assert: locals size == 17.	self		assert: (locals includes: 'third').	self		assert: (locals includes: 'constantInteger').	self		assert: (locals includes: 'complexInit2').	self		assert: (locals includes: 'typeSuggestingParameter').	model narrowWith: 'fo'! !!ECUntypedModelTest methodsFor: 'testing' stamp: 'bar 10/5/2005 23:08'!testCaseSensitivity	| model instances |	self assert: ECPreferences caseSensitive.	model _ ECUntypedModel class: ECTestClass temporaries: OrderedCollection new.	model narrowWith: 'typesugg'.	self assert: model isEmpty.	Preferences setPreference: #ecompletionCaseSensitive toValue: false.	model narrowWith: 'typesugg'.	instances _ model entriesOfType: #instVar.	self assert: instances size == 2.	self		assert: (instances includes: 'typeSuggestingParameter').	model narrowWith: 'dict'.	self assert: model notEmpty.	self		assert: ((model entriesOfType: #selector)				includes: 'Dictionary')! !!ECUntypedModelTest methodsFor: 'testing' stamp: 'bar 12/13/2004 10:40'!testEmpty	| model |	model := ECUntypedModel new.	self assert: model isEmpty.	self assert: model entries isEmpty.	self assert: model entryCount == 0! !!ECUntypedModelTest methodsFor: 'testing' stamp: 'bar 10/5/2005 23:14'!testForClassInstVars	| model locals |	model _ ECUntypedModel class: ECTestClass temporaries: OrderedCollection new.	locals _ model entriesOfType: #instVar.	self assert: locals size == 17.	self		assert: (locals includes: 'third').	self		assert: (locals includes: 'constantInteger').	self		assert: (locals includes: 'complexInit2').	self		assert: (locals includes: 'typeSuggestingParameter').	locals _ model entriesOfType: #self.	self		assert: (locals includes: 'self').	locals _ model entriesOfType: #super.	self		assert: (locals includes: 'super').	model narrowWith: 'fo'.	locals _ model entriesOfType: #instVar.	self assert: locals size == 1.	self		assert: (locals includes: 'fourth')! !!ECUntypedModelTest methodsFor: 'testing' stamp: 'bar 3/1/2006 13:44'!testForClassLocals	| model locals temps |	temps _ #('loc1' 'x2' 'bar' 'var' )				collect: [:each | ECLocalEntry contents: each type: #local].	model _ ECUntypedModel class: ECTestClass temporaries: temps.	locals _ model entriesOfType: #local.	self assert: locals size == 4.	self		assert: (locals includes: 'loc1').	self		assert: (locals includes: 'x2').	self		assert: (locals includes: 'bar').	self		assert: (locals includes: 'var').	model narrowWith: 'l'.	locals _ model entriesOfType: #local.	self assert: locals size == 1.	self		assert: (locals includes: 'loc1')! !!ECUntypedModelTest methodsFor: 'testing' stamp: 'bar 10/5/2005 23:08'!testForClassVars	| model classVars |	model _ ECUntypedModel class: ECTestClass temporaries: OrderedCollection new.	classVars _ model entriesOfType: #classVar.	self assert: classVars size >= 2.	self		assert: (classVars includes: 'SuperClassVar').	self		assert: (classVars includes: 'ClassVar')! !!ECUntypedModelTest methodsFor: 'testing' stamp: 'bar 12/17/2004 22:50'!testMessage	| model |	model _ ECUntypedModel class: ECTestClass temporaries: #('a' 'b' ).	self assert: model notEmpty.	self assert: model hasMessage.	self assert: model message = 'press key for selectors'.	model narrowWith: 'b'.	self shouldnt: model hasMessage.	model narrowWith: ''.	self assert: model hasMessage.	self assert: model message = 'press key for selectors'.	model narrowWith: 'hagadagadu'.	self assert: model hasMessage.	self assert: model message = 'no completions found'.	model _ ECUntypedModel new.	self assert: model hasMessage.	self assert: model message = 'press key for selectors'! !!ECUntypedModelTest methodsFor: 'testing' stamp: 'bar 12/13/2004 10:40'!testNarrowWith	| count model |	model := ECUntypedModel new.	self assert: model isEmpty.	model narrowWith: 'b'.	count := model entryCount.	self assert: count == model entries size.	self assert: count > 100.	model narrowWith: 'bar'.	self assert: count > model entryCount.	model narrowWith: 'barXXXX'.	self assert: model isEmpty.	model narrowWith: 'b'.	self assert: count == model entryCount.	model narrowWith: 'save'.	self assert: model isEmpty not.	model narrowWith: ''.	self assert: model isEmpty! !!ECUntypedModelTest methodsFor: 'testing' stamp: 'bar 12/13/2004 10:40'!testNoEntriesWithSpace	| model separatorEntry |	model := ECUntypedModel new.	self assert: model isEmpty.	model narrowWith: 'b'.	separatorEntry := model entries detect: 					[:each | 					(each value asString detect: [:char | char isSeparator] ifNone: []) notNil]				ifNone: [].	self assert: separatorEntry isNil! !!ECUntypedModelTest methodsFor: 'testing' stamp: 'bar 12/13/2004 14:03'!testTitle	| model |	model := ECUntypedModel				class: ECTestClass				temporaries: #().	self assert: model title isNil! !!ParagraphEditor methodsFor: '*ecompletion' stamp: 'bar 10/18/2004 07:09'!caret	^self startBlock stringIndex! !!ParagraphEditor methodsFor: '*ecompletion' stamp: 'bar 12/18/2004 09:26'!changeCaretDuring: aBlock	| caret |	caret := self startBlock stringIndex.	[aBlock value] ensure:[self selectAt: caret]! !!ParagraphEditor methodsFor: '*ecompletion' stamp: 'bar 12/13/2004 15:28'!isCaretBehindChar	| pos |	pos := self caret - 1.	^ pos < 1		ifTrue: [false]		ifFalse: [(self text at: pos) isAlphaNumeric]! !!ParagraphEditor methodsFor: '*ecompletion' stamp: 'bar 12/13/2004 14:49'!selectionPosition: aString 	| caret position bottomLeft topLeft |	caret := self startBlock stringIndex.	[self selectAt: caret - aString size.	bottomLeft := paragraph selectionRects first bottomLeft.	topLeft := self morph owner submorphBounds topLeft.	position := topLeft + bottomLeft]		ensure: [self selectAt: caret].	^ position! !!ParagraphEditor methodsFor: '*ecompletion' stamp: 'bar 12/18/2004 23:46'!wordAtCaret	^paragraph text asString wordBefore: self caret -1! !!Symbol methodsFor: '*ecompletion' stamp: 'bar 11/29/2004 22:41'!separateKeywords	^ self isKeyword		ifFalse: [self]		ifTrue:			[String streamContents:				[:s |				(self findTokens: ':')					do: [:ea | s nextPutAll: ea, ':']					separatedBy: [s nextPutAll: '  ']]]					! !!StringHolder methodsFor: '*ecompletion' stamp: 'bar 12/16/2004 10:01'!completionController	| controller |	controller _ self triggerEvent: #getCompletionController.	controller ifNil:[ controller _ self initializeCompletionController ].	^controller! !!StringHolder methodsFor: '*ecompletion' stamp: 'bar 12/15/2004 09:30'!createCompletionController	^ ECController model: self! !!StringHolder methodsFor: '*ecompletion' stamp: 'bar 12/13/2004 16:08'!guessTypeForName: aString	^nil! !!StringHolder methodsFor: '*ecompletion' stamp: 'bar 12/16/2004 10:01'!initializeCompletionController	| controller |	controller _ self createCompletionController.	self		when: #getCompletionController		evaluate: (MessageSend receiver: controller selector: #yourself).	^controller! !!StringHolder methodsFor: '*ecompletion' stamp: 'bar 11/30/2004 16:08'!receiverClass	^nil! !!ECContext commentStamp: '<historical>' prior: 0!A completion is started by the ECController. The controller creates me to compute the context of the completion. The most important information about the context are the receiverClass and the completionToken. I create a ECModel or subclass when requested by the 'model' method.I use SHParser and SHRange to parse the text input.!!ECContext class methodsFor: 'instance creation' stamp: 'bar 4/11/2005 11:23'!controller: aECController class: aClass source: aString position: anInteger 	^ self basicNew initialize		setController: aECController		class: aClass		source: aString		position: anInteger! !!ECContext methodsFor: 'private-temporaries' stamp: 'bar 1/6/2005 22:33'!blockTemporaries	| blocks range vars |	blocks _ OrderedCollection new.	1		to: completionIndex - 1		do: [:index | 			range _ ranges at: index.			self handleBlockStack: blocks with: range.				range isBlockTemporary						ifTrue: [vars _ blocks last.							vars add: range]].	^ self convertBlocksToVariables: blocks! !!ECContext methodsFor: 'private-compute-index' stamp: 'bar 1/6/2005 22:06'!checkForZeroPosition	^ (position = 0			or: [ranges isEmpty])		and: [self insertEmptyRangeAt: 1 start: 0 end: 1.			true]! !!ECContext methodsFor: 'private-receiver-guessing' stamp: 'bar 1/9/2005 14:55'!checkImpossibleReceiver	^ self isSelectorsAndVariables		ifTrue: [self configureSelectorsAndVariables]		ifFalse: [self isVariablesOnly				ifTrue: [self configureVariablesOnly]				ifFalse: [self isSelectorsOnly						and: [self configureSelectorsOnly]]]. ! !!ECContext methodsFor: 'accessing' stamp: 'bar 12/18/2004 23:56'!completionToken	completionToken		ifNil: [| range | 			range _ ranges at: completionIndex.			completionToken _ self sourceOf: range stopAt: position.			completionToken _ completionToken wordBefore: completionToken size].	^ completionToken! !!ECContext methodsFor: 'private' stamp: 'bar 1/6/2005 14:37'!compute	completionIndex _ self computeIndexOfPosition.	receiverClass _ self computeReceiverClass! !!ECContext methodsFor: 'private-compute-index' stamp: 'bar 1/6/2005 22:14'!computeIndexOfPosition	| current |	self checkForZeroPosition		ifTrue: [^ 1].	1		to: ranges size		do: [:index | 			current _ ranges at: index.			(current includesPosition: position)				ifTrue: [^ index]				ifFalse: [current end > position						ifTrue: [^self createEmptyRangeForGapAt: index							]]].	^ self createEmptyRangeAtTail! !!ECContext methodsFor: 'private' stamp: 'bar 1/9/2005 11:35'!computeReceiverClass	| previous found |	recurseCount := 0.	completionIndex = 1 ifTrue: [^nil].	found := self checkImpossibleReceiver.	found ifTrue: [^nil].	previous := ranges at: completionIndex - 1.	previous type = #cascadeSeparator 		ifTrue: [^self guessCascadeReceiver: completionIndex - 1].	(previous type = #unary 		and: [(self sourceOf: previous) = 'new' and: [completionIndex > 2]]) 			ifTrue: 				[previous := ranges at: completionIndex - 2.				previous type = #globalVar 					ifTrue: [^self guessTypeOf: completionIndex - 2]					ifFalse: 						[self configureSelectorsOnly.						^nil]].	^self guessTypeOf: completionIndex - 1! !!ECContext methodsFor: 'private-configure' stamp: 'bar 1/9/2005 11:35'!configureSelectorsAndVariables	variables := true.	selectors := true.	^true! !!ECContext methodsFor: 'private-configure' stamp: 'bar 1/9/2005 11:35'!configureSelectorsOnly	variables := false.	selectors := true.	^true! !!ECContext methodsFor: 'private-configure' stamp: 'bar 1/9/2005 11:34'!configureVariablesOnly	variables := true.	selectors := false.	^true! !!ECContext methodsFor: 'private-temporaries' stamp: 'bar 1/6/2005 22:36'!convertBlocksToVariables: anOrderedCollection 	| result blockStack |	blockStack _ anOrderedCollection.	result _ OrderedCollection new.	blockStack		do: [:each | result addAll: each].	^ result! !!ECContext methodsFor: 'private-compute-index' stamp: 'bar 1/6/2005 22:14'!createEmptyRangeAtTail	| previous |	previous _ ranges last.	ranges		add: (SHRange				start: previous end + 1				end: source size				type: #empty).	^ ranges size! !!ECContext methodsFor: 'private-compute-index' stamp: 'bar 1/6/2005 22:15'!createEmptyRangeForGapAt: index 	| current previous |	current _ ranges at: index.	previous _ ranges at: index - 1.	self		insertEmptyRangeAt: index		start: previous end + 1		end: current start - 1.	^index! !!ECContext methodsFor: 'accessing' stamp: 'bar 12/21/2004 08:38'!createModel	self receiverClass		ifNotNil: [^ ECTypedModel class: receiverClass].	(controller workspace isNil		and: [theClass notNil])		ifTrue: [completionIndex = 1				ifTrue: [^ ECOverrideModel class: theClass]].	^ ECUntypedModel		class: theClass		temporaries: self temporaries		additionals: controller additionals		variables: variables		selectors: selectors! !!ECContext methodsFor: 'private' stamp: 'bar 1/6/2005 14:35'!createRanges	| parser |	parser := SHParserST80 new.	ranges := parser 				rangesIn: source				classOrMetaClass: theClass				workspace: controller workspace				environment: nil.	ranges := ranges select: [:each | each type ~= #comment]! !!ECContext methodsFor: 'private' stamp: 'bar 1/9/2005 14:51'!findSourceRangeFor: aNumber 	aNumber		to: ranges size		by: 2		do: [:index | 			index + 3 > ranges size				ifTrue: [^ nil].			(ranges at: index + 1) isAssignment				ifTrue: [(ranges at: index + 3) type = #statementSeparator						ifTrue: [^ index + 2]						ifFalse: [(ranges at: index + 2) type = #globalVar								ifTrue: [^ index + 2]								ifFalse: [(ranges at: index + 1) isAssignment 										ifFalse: [^ nil]]]]]! !!ECContext methodsFor: 'private-type-guessing' stamp: 'bar 1/9/2005 13:32'!guessArgument: aSHRange 	^ ECInstVarTypeGuesser		getClassFromTypeSuggestingName: (self sourceOf: aSHRange)! !!ECContext methodsFor: 'private' stamp: 'bar 1/6/2005 13:06'!guessCascadeReceiver: aNumber 	| type |	aNumber to: 1 by: -1 do:[ :index |	type _ (ranges at: index) type.			((#(#statementSeparator #assignment #ansiAssignment ) includes: type)					or: [(type beginsWith: 'pattern')							or: [type beginsWith: 'methodTemp']])				ifTrue: [^ self guessTypeOf: index + 1]].	^ nil! !!ECContext methodsFor: 'private' stamp: 'bar 8/9/2005 23:32'!guessClassVarClass: aSHRange 	| aClass name |	name _ self sourceOf: aSHRange.	aClass _ controller guessTypeFor: name.	aClass		ifNotNil: [^ aClass].	^ (ECClassVarTypeGuesser variableName: name class: theClass class) perform! !!ECContext methodsFor: 'private-type-guessing' stamp: 'bar 1/9/2005 13:33'!guessGlobal: aNumber 	| aClass |	aClass _ Smalltalk				at: (self						sourceOf: (ranges at: aNumber)) asSymbol				ifAbsent: [^ nil].	aClass isBehavior		ifFalse: [^ nil].	aNumber = (completionIndex - 1)		ifTrue: [^ aClass class].	(ranges size >= (aNumber + 1)			and: [(ranges at: aNumber + 1) type = #statementSeparator])		ifTrue: [^ aClass class].	^ aClass! !!ECContext methodsFor: 'private' stamp: 'bar 3/30/2006 16:42'!guessInstVarClass: aSHRange 	| aClass name |	name _ self sourceOf: aSHRange.	aClass _ controller guessTypeFor: name. 	aClass		ifNotNil: [^ aClass].	aClass _ self guessWithRoelTyper: name class: theClass.	aClass		ifNotNil: [^ aClass].	^ (ECInstVarTypeGuesser variableName: name class: theClass) perform! !!ECContext methodsFor: 'private' stamp: 'bar 3/1/2006 13:52'!guessTempVarClass: aSHRange 	^self guessTempVarClass: (self sourceOf: aSHRange) type: aSHRange type.! !!ECContext methodsFor: 'private' stamp: 'bar 3/1/2006 13:53'!guessTempVarClass: aString type: aSymbol 	| current type varName varType sourceIndex aClass |	aClass _ controller				guessTypeFor: aString.	aClass		ifNotNil: [^ aClass].	varName _ aString.	varType _ aSymbol.	1		to: completionIndex		do: [:index | 			current _ ranges at: index.			(current type = varType					and: [(self sourceOf: current)								= varName							and: [index + 3 <= ranges size]])				ifTrue: [(sourceIndex _ self findSourceRangeFor: index) notNil						ifTrue: [type _ self guessTypeOf: sourceIndex.							type								ifNotNil: [^ type]]]].	^ nil! !!ECContext methodsFor: 'private-type-guessing' stamp: 'bar 8/9/2005 23:03'!guessTypeOf: aNumber 	| range |	self configureSelectorsOnly.	recurseCount > 10		ifTrue: [^ nil].	recurseCount _ recurseCount + 1.	range _ ranges at: aNumber.	^ range isSelf		ifTrue: [theClass]		ifFalse: [range isSuper				ifTrue: [theClass superclass]				ifFalse: [range isConstant						ifTrue: [range asType]						ifFalse: [range isArgument								ifTrue: [self guessArgument: range]								ifFalse: [range isTemporaryVariable										ifTrue: [self guessTempVarClass: range]										ifFalse: [range isInstanceVariable												ifTrue: [self guessInstVarClass: range]												ifFalse: [range isClassVariable														ifTrue: [self guessClassVarClass: range]														ifFalse: [range isGlobal																ifTrue: [self guessGlobal: aNumber]]]]]]]]! !!ECContext methodsFor: 'private-roel-typer' stamp: 'bar 3/30/2006 17:51'!guessWithRoelTyper: aString class: aClass 	| typeInfo foundTypes infos |	infos _ self typeInfosFor: aClass.	infos ifNil:[^nil].	typeInfo _ infos				at: aString asSymbol				ifAbsent: [^ nil].	foundTypes _ typeInfo types.	typeInfo _ foundTypes size <= 2				ifTrue: [foundTypes first]				ifFalse: [foundTypes _ foundTypes intersection: typeInfo assignments.					foundTypes						ifEmpty: []						ifNotEmpty: [foundTypes first]].	typeInfo		ifNil: [^ nil].	^ (typeInfo == UndefinedObject			or: [typeInfo == Object])		ifTrue: [^ nil]		ifFalse: [typeInfo]! !!ECContext methodsFor: 'private-temporaries' stamp: 'bar 1/6/2005 22:36'!handleBlockStack: aCollection with: aSHRange 	| range blockStack |	range _ aSHRange.	blockStack _ aCollection.	range isBlockStart		ifTrue: [blockStack add: OrderedCollection new]		ifFalse: [range isBlockEnd				ifTrue: [blockStack removeLast]]! !!ECContext methodsFor: 'initialize-release' stamp: 'bar 12/20/2004 23:18'!initialize	super initialize.	source _ String new.	position _ 0.	recurseCount _ 0.	variables _ true.	selectors _ true.	ranges _ OrderedCollection new.	completionIndex _ 0.	completionToken _ nil.! !!ECContext methodsFor: 'private-compute-index' stamp: 'bar 1/6/2005 22:04'!insertEmptyRangeAt: index start: start end: end 	ranges		add: (SHRange				start: start				end: end				type: #empty)		beforeIndex: index! !!ECContext methodsFor: 'private-receiver-guessing' stamp: 'bar 1/9/2005 11:33'!isSelectorsAndVariables	| current |	current := ranges at: completionIndex.	^current isUnfinished! !!ECContext methodsFor: 'private-receiver-guessing' stamp: 'bar 1/9/2005 11:33'!isSelectorsOnly	| previous |	previous := ranges at: completionIndex - 1.	^previous isOpening! !!ECContext methodsFor: 'private-receiver-guessing' stamp: 'bar 3/2/2006 21:29'!isVariablesOnly	| current previous |	current _ ranges at: completionIndex.	^ current isVariablesOnly		or: [current isOpening				or: [previous _ ranges at: completionIndex - 1.					previous isOpening						or: [previous isSeparator								or: [previous isKeyword										or: [previous isAssignment or:[previous isBinary ]]]]]]! !!ECContext methodsFor: 'accessing' stamp: 'bar 12/13/2004 12:01'!model	model isNil ifTrue:[ model _ self createModel].	^model! !!ECContext methodsFor: 'action' stamp: 'bar 12/20/2004 23:16'!narrowWith: aString 	completionToken _ aString.	model ifNotNil:[ model narrowWith: aString ].! !!ECContext methodsFor: 'private' stamp: 'bar 12/13/2004 15:32'!receiverClass	^ receiverClass! !!ECContext methodsFor: 'initialize-release' stamp: 'bar 1/6/2005 14:37'!setController: aECController class: aClass source: aString position: anInteger 	controller _ aECController.	theClass _ aClass.	source _ aString.	position _ anInteger.	self createRanges.	self compute! !!ECContext methodsFor: 'private' stamp: 'bar 3/1/2006 13:25'!sourceOf: aSHRange 	^aSHRange isString		ifTrue: [aSHRange]		ifFalse: [self sourceOf: aSHRange stopAt: aSHRange end]! !!ECContext methodsFor: 'private' stamp: 'bar 12/18/2004 23:55'!sourceOf: aSHRange stopAt: aNumber	^ aSHRange type = #empty		ifTrue: [String new]		ifFalse: [source copyFrom: aSHRange start to: aNumber]! !!ECContext methodsFor: 'action' stamp: 'bar 1/9/2005 11:35'!switchToUntyped	receiverClass := nil.	self configureSelectorsAndVariables.	model := self createModel! !!ECContext methodsFor: 'accessing' stamp: 'bar 3/1/2006 13:43'!temporaries	| tempRanges |	tempRanges _ ranges				select: [:each | #(#patternTempVar #patternArg ) includes: each type].	tempRanges addAll: self blockTemporaries.	^ tempRanges		collect: [:each | ECLocalEntry				contents: (self sourceOf: each)				type: each type]! !!ECContext methodsFor: 'accessing' stamp: 'bar 2/26/2006 09:04'!theClass	^theClass! !!ECContext methodsFor: 'private-roel-typer' stamp: 'bar 3/30/2006 16:37'!typeInfosFor: aClass 	| roelTyper |	(roelTyper _ Smalltalk				at: #TypeCollector				ifAbsent: [])		ifNil: [^ nil].	typeInfos		ifNil: [typeInfos _ roelTyper typeInstvarsOfClass: aClass].	^typeInfos! !!ECController commentStamp: '<historical>' prior: 0!I live as an instance variable in a Browser, Debugger, Workspace or other window. I'm the glue between all participants of the completion system. I create the ECContext and pass myself to the ECMenuMorph. I process the keyboard events and pass them to the ECMenuMorph or close the morph if needed.!!ECController class methodsFor: 'testing' stamp: 'bar 3/31/2006 09:02'!allowModel: aModel 	^ self isEnabled		and: [aModel respondsTo: #completionController] ! !!ECController class methodsFor: 'initialize class' stamp: 'bar 3/20/2006 15:25'!initialize	self initializePreferences.	self initializeSmartCharacters.! !!ECController class methodsFor: 'initialize class' stamp: 'bar 4/11/2005 10:55'!initializePreferences	ECPreferences initialize! !!ECController class methodsFor: 'initialize class' stamp: 'bar 3/3/2006 17:22'!initializeSmartCharacters	smartCharacters _ Dictionary new.	smartCharacters at: $( put: $);		 at: $[ put: $];		 at: ${ put: $};		 at: $" put: $";		 at: $' put: $';		at: $< put: $>! !!ECController class methodsFor: 'initialize class' stamp: 'bar 3/20/2006 15:27'!initialized	^smartCharacters isNil not	! !!ECController class methodsFor: 'testing' stamp: 'bar 3/20/2006 15:27'!isEnabled	self initialized 		ifFalse: [self initialize].	^ ECPreferences enabled! !!ECController class methodsFor: 'instance creation' stamp: 'bar 12/13/2004 12:05'!model: aStringHolder 	^self new setModel: aStringHolder! !!ECController class methodsFor: 'instance creation' stamp: 'bar 2/25/2006 15:11'!smartCharacters	smartCharacters		ifNil:[self initializeSmartCharacters].	^smartCharacters ! !!ECController methodsFor: 'accessing' stamp: 'bar 12/16/2004 11:13'!additionals	^ nil! !!ECController methodsFor: 'keyboard' stamp: 'bar 3/3/2006 17:38'!checkBackspace: anInteger 	anInteger ~= 8		ifTrue: [^ false].	oppositeChar		ifNil: [^ false].	editor selectFrom: editor caret - 1 to: editor caret;		 zapSelectionWith: '';		 selectAt: editor caret.	self invalidateEditorMorph.	^ true! !!ECController methodsFor: 'keyboard' stamp: 'bar 3/3/2006 17:35'!checkNeedlesCharacter: aCharacter	| result |	oppositeChar		ifNil: [^ false].	result _ oppositeChar = aCharacter.	result		ifTrue: [editor selectAt: editor caret + 1.			self invalidateEditorMorph].	oppositeChar _ nil.	^ result! !!ECController methodsFor: 'menu morph' stamp: 'bar 12/13/2004 15:09'!closeMenu	menuMorph		ifNotNil: [menuMorph delete]! !!ECController methodsFor: 'accessing' stamp: 'bar 12/13/2004 12:08'!context	^context! !!ECController methodsFor: 'accessing' stamp: 'bar 12/13/2004 17:34'!editor	^ editor. ! !!ECController methodsFor: 'type guessing' stamp: 'bar 12/17/2004 22:42'!guessTypeFor: aString 	model		ifNil: [			^ nil]		ifNotNil: [^ model guessTypeForName: aString]! !!ECController methodsFor: 'keyboard' stamp: 'bar 1/6/2005 08:57'!handleKeystrokeAfter: aKeyboardEvent editor: aParagraphEditor 	(aParagraphEditor isNil or:[self isMenuOpen not]) ifTrue:[^self].	self setModel: aParagraphEditor model.			context narrowWith: aParagraphEditor wordAtCaret.			menuMorph narrowCompletion! !!ECController methodsFor: 'keyboard' stamp: 'bar 3/20/2006 16:05'!handleKeystrokeBefore: aKeyboardEvent editor: aParagraphEditor 	"I return a boolean. true when I have handled the event and no futher 	processing 	is needed by the caller."	| keyValue controlKeyPressed isSpaceKey |	editor := aParagraphEditor.	self setModel: editor model.	keyValue := aKeyboardEvent keyValue.	controlKeyPressed := aKeyboardEvent controlKeyPressed.	isSpaceKey := #(0 32 ) includes: keyValue.	"Ctrl-Space or Tab for open"	self isMenuOpen		ifFalse: [(isSpaceKey & controlKeyPressed					or: [keyValue = 9							and: [editor isCaretBehindChar									and: [controlKeyPressed not]]])				ifTrue: [self openMenuFor: editor.					^ true]				ifFalse: [(self smartCharInput: keyValue)						ifNotNil: [^ true]].			^ false].	"Home"	keyValue = 1		ifTrue: [menuMorph home.			^ true].	"End"	(keyValue = 4			and: [controlKeyPressed not])		ifTrue: [menuMorph end. 			^ true].	(keyValue = 8 and:[controlKeyPressed ]) ifTrue:[menuMorph help. ^true].	"Right-Arrow"	keyValue = 29		ifTrue: [menuMorph showDetail.			^ true].	"Left Arrow"	keyValue = 28		ifTrue: [menuMorph hideDetail.			^ true].	"Arrow up"	keyValue = 30		ifTrue: [menuMorph moveUp.			^ true].	"Arrow down"	keyValue = 31		ifTrue: [menuMorph moveDown.			^ true].	"Page up"	keyValue = 11		ifTrue: [menuMorph pageUp.			^ true].	"Page down"	keyValue = 12		ifTrue: [menuMorph pageDown.			^ true].	"Tab or Ctrl-Space"	(keyValue = 13			or: [isSpaceKey & controlKeyPressed					or: [keyValue = 9]])		ifTrue: [menuMorph insertSelected				ifTrue: [^ true]].	"Ctrl-u"	keyValue = 21 & controlKeyPressed		ifTrue: [menuMorph switchToUntyped.			^ true].	"Crtl-t"	(keyValue = 20			and: [controlKeyPressed])		ifTrue: [menuMorph expand.			^ true].	"All keys but the alphanumeric chars (without command and control ) 	and the backspace key do close the menu"	keyValue = 8		ifTrue: [editor isCaretBehindChar not				ifTrue: [self closeMenu].			^ false].	(controlKeyPressed not & aKeyboardEvent commandKeyPressed not			and: [aKeyboardEvent keyCharacter isAlphaNumeric])		ifFalse: [self closeMenu.			^ keyValue = 27].	^ false! !!ECController methodsFor: 'keyboard' stamp: 'bar 3/3/2006 17:34'!invalidateEditorMorph		editor morph invalidRect: editor morph bounds.! !!ECController methodsFor: 'menu morph' stamp: 'bar 12/13/2004 11:06'!isMenuOpen	^menuMorph notNil! !!ECController methodsFor: 'menu morph' stamp: 'bar 12/13/2004 16:39'!menuClosed	menuMorph := nil.	context := nil.	editor := nil! !!ECController methodsFor: 'menu morph' stamp: 'bar 3/31/2006 09:41'!openMenuFor: aParagraphEditor 	| theMenu |	context := ECContext				controller: self				class: model selectedClassOrMetaClass 				source: aParagraphEditor text string				position: aParagraphEditor caret - 1.	editor := aParagraphEditor.	theMenu := ECMenuMorph				controller: self				position: (aParagraphEditor selectionPosition: context completionToken).	theMenu isClosed		ifFalse: [menuMorph := theMenu]. ! !!ECController methodsFor: 'initialize-release' stamp: 'bar 12/13/2004 11:02'!setModel: aStringHolder	model _ aStringHolder! !!ECController methodsFor: 'keyboard' stamp: 'al 6/29/2006 10:22'!smartCharInput: anInteger 	| caret selection pos content character |	Preferences ecompletionSmartCharacters ifFalse: [ ^nil ].	character := anInteger asCharacter.	(self checkBackspace: anInteger)		ifTrue: [^ self].	(self checkNeedlesCharacter: character)		ifTrue: [^ self].	oppositeChar := self class smartCharacters				at: character				ifAbsent: [^ nil].	caret := editor caret.	selection := editor selection.	content := WriteStream on: String new.	content nextPut: character;		 nextPutAll: selection;		 nextPut: oppositeChar.	editor zapSelectionWith: content contents.	pos := caret + 1.	editor selectFrom: pos to: pos + selection size - 1.	self invalidateEditorMorph.	selection		ifNotEmpty: [oppositeChar := nil]! !!ECController methodsFor: 'accessing' stamp: 'bar 12/15/2004 09:23'!workspace	^nil! !!ECWorkspaceController commentStamp: '<historical>' prior: 0!I'm a specialized controller, that works with Workspaces.!!ECWorkspaceController methodsFor: 'accessing' stamp: 'bar 12/16/2004 11:14'!additionals	^ self workspace completionAdditionals! !!ECWorkspaceController methodsFor: 'accessing' stamp: 'bar 12/15/2004 09:23'!workspace	^model! !!ECEntry commentStamp: 'bar 10/5/2005 23:31' prior: 0!I represent a completion entry that is management by a ECModel and shown in the ECMenuMorph as a menu entry.!!ECClassVarEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 15:27'!guessTypeWith: anECContext 	^ anECContext guessClassVarClass: contents! !!ECClassVarEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 15:40'!label	^ 'class variable'! !!ECEntry class methodsFor: 'as yet unclassified' stamp: 'bar 8/13/2005 18:55'!contents: aString type: aSymbol	^ self new setContents: aString type: aSymbol! !!ECEntry methodsFor: 'as yet unclassified' stamp: 'bar 10/5/2005 22:35'!<= aECEntry 	^ contents <= aECEntry contents! !!ECEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 16:09'!browseWith: anECContext 	type _ self guessTypeWith: anECContext.	type		ifNil: [^ false].	Browser fullOnClass: type.	^ true! !!ECEntry methodsFor: 'as yet unclassified' stamp: 'bar 8/14/2005 21:44'!completion	^ self contents asSymbol! !!ECEntry methodsFor: 'as yet unclassified' stamp: 'bar 8/13/2005 18:56'!contents	^contents! !!ECEntry methodsFor: 'as yet unclassified' stamp: 'bar 10/5/2005 22:36'!contentsAsSymbol	^ contents asSymbol ! !!ECEntry methodsFor: 'detail information' stamp: 'bar 3/2/2006 22:00'!createDescriptionWith: anECContext 	| clazz |	clazz _ self guessTypeWith: anECContext.	^ clazz		ifNil: [ECEntryDescription label: self label]		ifNotNil: [ECEntryDescription				label: self label				title: clazz printString				description: clazz comment]! !!ECEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/2/2006 18:37'!descriptionWith: anECContext 	| |	description		ifNotNil: [^ description].	^description _ self createDescriptionWith: anECContext! !!ECEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 15:27'!guessTypeWith: anECContext 	^ nil! !!ECEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/2/2006 17:50'!isInstance	^ false! !!ECEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/2/2006 17:51'!isLocal	^ false! !!ECEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/2/2006 17:51'!isSelector	^ false! !!ECEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 15:40'!label	^ 'unknown'! !!ECEntry methodsFor: 'as yet unclassified' stamp: 'bar 8/13/2005 19:08'!printOn: aStream 	aStream nextPutAll: self class name;		 nextPut: $(;		 nextPutAll: contents;		 nextPut: $,;		 nextPutAll: type;		 nextPut: $)! !!ECEntry methodsFor: 'as yet unclassified' stamp: 'bar 8/13/2005 18:55'!setContents: aString type: aSymbol	contents _ aString.	type _ aSymbol! !!ECEntry methodsFor: 'as yet unclassified' stamp: 'bar 8/13/2005 18:56'!type	^type! !!ECGlobalEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/20/2006 15:20'!guessTypeWith: anECContext 	| globalEntry |	globalEntry := Smalltalk at: contents ifAbsent: [^ nil].	globalEntry isBehavior ifTrue: [^ globalEntry].	globalEntry ifNotNil: [^ globalEntry class].	^ nil! !!ECGlobalEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 15:41'!label	^ 'global'! !!ECInstVarEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 15:27'!guessTypeWith: anECContext 	^ anECContext guessInstVarClass: contents! !!ECInstVarEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/2/2006 17:51'!isInstance^true! !!ECInstVarEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 15:41'!label	^ 'instance variable'! !!ECLocalEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 15:27'!guessTypeWith: anECContext 	^ (anECContext guessTempVarClass: contents type: type) 		ifNil: [anECContext guessArgument: contents]! !!ECLocalEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/2/2006 17:51'!isLocal	^true! !!ECLocalEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 15:41'!label	^ 'local variable'! !!ECSelectorEntry methodsFor: 'private' stamp: 'bar 3/8/2006 21:37'!browseWith: anECContext 	| navigation |	navigation _ self systemNavigation.	^ self		findMethodWith: anECContext		do: [:clazz :method | 			Browser fullOnClass: clazz selector: method selector.			true]		ifAbsent: [:selector | 			navigation browseAllImplementorsOf: selector.			true]! !!ECSelectorEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/8/2006 21:42'!createDescriptionWith: anECContext 	^ self		findMethodWith: anECContext		do: [:clazz :method | self				methodSourceDescription: clazz				method: method				]		ifAbsent: [:selector | self implementorsDescription: selector]! !!ECSelectorEntry methodsFor: 'private' stamp: 'bar 3/20/2006 16:15'!findMethodWith: anECContext do: foundBlock ifAbsent: notfoundBlock 	| theClass result implementors |	theClass := anECContext model theClass.	result := theClass				ifNil: [implementors := self systemNavigation allImplementorsOf: contents.					implementors size == 1						ifTrue: [| ref | 							ref := implementors first.							self lookupSelector: ref methodSymbol class: ref actualClass]						ifFalse: [^ notfoundBlock value: contents]]				ifNotNil: [self lookupSelector: contents class: theClass]. 	^ foundBlock value: result first value: result second! !!ECSelectorEntry methodsFor: 'private' stamp: 'bar 3/12/2006 14:53'!implementorsDescription: aSymbol 	| implementors output |	output _ WriteStream on: String new.	implementors _ self systemNavigation allImplementorsOf: aSymbol.	implementors isEmpty		ifTrue: [^ ECEntryDescription				label: 'symbol'				title: '(no implementors)'				description: 'This is just symbol.'].	implementors		do: [:each | output nextPutAll: each classSymbol printString;				 cr].	^ ECEntryDescription		label: self label		title: '(Implementors)'		description: output contents! !!ECSelectorEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/2/2006 21:52'!label	^ 'method'! !!ECSelectorEntry methodsFor: 'private' stamp: 'bar 3/20/2006 15:38'!lookupSelector: aSymbol class: aClass 	"Look up the given selector in my methodDictionary.	Return the corresponding method if found.	Otherwise chase the superclass chain and try again.	Return nil if no method is found."	| lookupClass |	lookupClass := aClass.	[lookupClass isNil]		whileFalse: [(lookupClass includesSelector: aSymbol)				ifTrue: [^ Array						with: lookupClass						with: (lookupClass compiledMethodAt: aSymbol)].			lookupClass := lookupClass superclass].	^ nil! !!ECSelectorEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/30/2006 14:17'!methodSourceDescription: aClass method: aCompiledMethod 	| styler |	styler := SHTextStylerST80 new.	styler classOrMetaClass: aClass.	^ ECEntryDescription		label: self label		title: aClass printString		description: (styler styledTextFor: (self methodSourceOn: aCompiledMethod ) asText)! !!ECSelectorEntry methodsFor: 'private' stamp: 'bar 3/30/2006 14:17'!methodSourceOn: aCompiledMethod		^aCompiledMethod getSourceFor: aCompiledMethod selector in: aCompiledMethod who first! !!ECSelfEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 15:27'!guessTypeWith: anECContext 	^ anECContext theClass! !!ECSelfEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 15:42'!label	^ 'self'! !!ECSuperEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 15:27'!guessTypeWith: anECContext 	^ anECContext theClass ifNotNil: [anECContext theClass superclass]! !!ECSuperEntry methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 15:42'!label	^ 'super'! !!ECEntryDescription class methodsFor: 'as yet unclassified' stamp: 'bar 3/2/2006 22:01'!label: firstString 	^ self new		setLabel: firstString		title: '(unknown)'		description: nil! !!ECEntryDescription class methodsFor: 'as yet unclassified' stamp: 'bar 3/1/2006 15:39'!label: firstString title: secondString description: thirdString 	^ self new 		setLabel: firstString		title: secondString		description: thirdString! !!ECEntryDescription methodsFor: 'accessing' stamp: 'bar 3/2/2006 22:02'!description(	description isNil or:[description isEmpty]) ifTrue:[^'-'].	^ description! !!ECEntryDescription methodsFor: 'accessing' stamp: 'bar 3/1/2006 15:39'!label	^ label! !!ECEntryDescription methodsFor: 'initialize-release' stamp: 'bar 3/1/2006 15:39'!setLabel: firstString title: secondString description: thirdString 	label _ firstString.	title _ secondString.	description _ thirdString! !!ECEntryDescription methodsFor: 'accessing' stamp: 'bar 3/1/2006 15:20'!title^ title! !!ECModel commentStamp: '<historical>' prior: 0!I'm an abstract class that stores the entries to be completed.!!ECModel class methodsFor: 'instance creation' stamp: 'bar 4/11/2005 11:32'!class: aClass 	| newInstance |	newInstance _ self basicNew initialize.	newInstance setClass: aClass.	^ newInstance! !!ECModel methodsFor: 'private' stamp: 'bar 8/14/2005 21:43'!addToEntries: aCollection 	| temp caseSensitive |	caseSensitive _ ECPreferences caseSensitive.	temp _ aCollection				select: [:each | each contents beginsWithEmpty: narrowString caseSensitive: caseSensitive].	entries addAll: temp! !!ECModel methodsFor: 'accessing' stamp: 'bar 12/4/2004 17:21'!at: aNumber 	^ entries at: aNumber ! !!ECModel methodsFor: 'action' stamp: 'bar 8/14/2005 21:43'!completionAt: aNumber 	^ (self at: aNumber) completion separateKeywords , ' '! !!ECModel methodsFor: 'accessing' stamp: 'bar 12/4/2004 17:20'!entries	^entries! !!ECModel methodsFor: 'accessing' stamp: 'bar 10/5/2005 22:53'!entriesOfType: aSymbol 	| collection |	collection _ entries				select: [:each | each type == aSymbol].	^ collection		collect: [:each | each contents]! !!ECModel methodsFor: 'accessing' stamp: 'bar 12/4/2004 17:21'!entryCount	^entries size! !!ECModel methodsFor: 'accessing' stamp: 'bar 12/17/2004 22:45'!hasMessage	^ self message notNil! !!ECModel methodsFor: 'initialize-release' stamp: 'bar 4/11/2005 11:22'!initialize	self reset! !!ECModel methodsFor: 'accessing' stamp: 'bar 12/6/2004 14:18'!initializeSelectors 	self subclassResponsibility ! !!ECModel methodsFor: 'testing' stamp: 'bar 3/3/2006 17:00'!isEmpty	^ entries isEmpty! !!ECModel methodsFor: 'accessing' stamp: 'bar 1/6/2005 08:25'!message	^self isEmpty ifTrue: ['no completions found'] ifFalse: [nil]! !!ECModel methodsFor: 'private' stamp: 'bar 12/4/2004 17:40'!narrowString: aString 	narrowString := aString! !!ECModel methodsFor: 'action' stamp: 'bar 12/6/2004 11:53'!narrowWith: aString	self subclassResponsibility ! !!ECModel methodsFor: 'testing' stamp: 'bar 12/4/2004 17:22'!notEmpty 	^self isEmpty not! !!ECModel methodsFor: 'private' stamp: 'bar 4/11/2005 11:50'!reset	self resetSelectors.	self resetEntries.	narrowString _ String new! !!ECModel methodsFor: 'private' stamp: 'bar 4/11/2005 11:35'!resetEntries	entries _ OrderedCollection new.! !!ECModel methodsFor: 'private' stamp: 'bar 4/11/2005 11:51'!resetSelectors	selectors _ SortedCollection new: 500.! !!ECModel methodsFor: 'initialize-release' stamp: 'bar 1/6/2005 08:54'!setClass: aClass 	clazz := aClass.	self initializeSelectors.	self narrowWith: String new! !!ECModel methodsFor: 'action' stamp: 'bar 3/1/2006 15:48'!theClass	^nil! !!ECModel methodsFor: 'action' stamp: 'bar 12/6/2004 14:44'!title	^nil! !!ECModel methodsFor: 'initialize-release' stamp: 'bar 12/5/2004 23:17'!toggleExpand	! !!ECTypedModel commentStamp: '<historical>' prior: 0!I'm the model for a typed completion, that means when a receiver class is known. I only have selectors. I have an expand toggle: When false I filter out Object and ProtoObject selectors. The default value is true.!!ECOverrideModel commentStamp: '<historical>' prior: 0!I'm used when completing a method override. I contain all selectors of the superclass minus the already implemented selectors of the current class. When a completion occurs I complete a method template with a send to super.!!ECOverrideModel methodsFor: 'action' stamp: 'bar 12/6/2004 16:52'!completionAt: aNumber 	| output source declaration |	source := self methodSourceAt: aNumber.	declaration := (source lineCorrespondingToIndex: 1) withoutTrailingBlanks.	output := WriteStream on: String new.	output nextPutAll: declaration;		 cr;		 tab;				 nextPutAll: (self computeReturn: source);		 nextPutAll: 'super ';		 nextPutAll: declaration.	^ output contents! !!ECOverrideModel methodsFor: 'private' stamp: 'bar 12/6/2004 16:51'!computeReturn: aString	| lastLine |	lastLine := aString lineCorrespondingToIndex: aString size.	^(lastLine				detect: [:each | each = $^]				ifNone: [])				ifNil: ['']				ifNotNil: ['^'].! !!ECOverrideModel methodsFor: 'initialize-release' stamp: 'bar 10/5/2005 23:24'!initializeSelectors	self initializeSelectorsFor: clazz superclass.	clazz methodDictionary		keysDo: [:each | 			| entry | 			entry _ selectors						detect: [:ea | ea contentsAsSymbol == each]						ifNone: [].			entry notNil				ifTrue: [selectors						remove: entry						ifAbsent: []]]! !!ECOverrideModel methodsFor: 'private' stamp: 'bar 10/5/2005 22:36'!methodSourceAt: aNumber 	| method classes selector source methods |	selector _ (self at: aNumber) contentsAsSymbol.	classes _ clazz allSuperclasses.	methods _ classes				collect: [:eachClass | eachClass methodDictionary						at: selector						ifAbsent: []].	methods _ methods				select: [:each | each notNil].	method _ methods first.	source _ method getSourceFromFile asString.	^ source! !!ECOverrideModel methodsFor: 'action' stamp: 'bar 12/6/2004 15:02'!title	^ '(override) ' , clazz superclass name! !!ECTypedModel methodsFor: 'initialize-release' stamp: 'bar 12/6/2004 17:07'!initialize	super initialize.	expanded := true.! !!ECTypedModel methodsFor: 'private' stamp: 'bar 12/6/2004 14:19'!initializeSelectors	self initializeSelectorsFor: clazz! !!ECTypedModel methodsFor: 'private' stamp: 'bar 3/1/2006 13:57'!initializeSelectorsFor: aClass 	| classes selectorSet size |	selectors reset.	classes _ aClass allSuperclasses.	size _ 600.	expanded		ifFalse: [classes remove: Object.			classes remove: ProtoObject.			size _ 100].	selectorSet _ Set new: size.	classes add: aClass.	classes		do: [:eachClass | eachClass methodDictionary				keysDo: [:each | each notEmpty						ifTrue: [selectorSet add: each]]].	selectorSet _ selectorSet				collect: [:each | ECSelectorEntry contents: each type: #selector].	selectors addAll: selectorSet! !!ECTypedModel methodsFor: 'action' stamp: 'bar 8/13/2005 18:13'!narrowWith: aString 	self narrowString: aString.	entries reset.	self addToEntries: selectors! !!ECTypedModel methodsFor: 'action' stamp: 'bar 3/1/2006 15:49'!theClass	^clazz! !!ECTypedModel methodsFor: 'action' stamp: 'bar 12/6/2004 14:44'!title	^clazz name! !!ECTypedModel methodsFor: 'action' stamp: 'bar 3/1/2006 15:50'!toggleExpand	expanded _ expanded not.	self initializeSelectors.	self narrowWith: narrowString! !!ECUntypedModel commentStamp: '<historical>' prior: 0!When no receiver class is known, I'm the right model. I store all temporary variables, instance variables of the selected class and all selectors in system. For performance reasons I only collect selectors when at least one character is known.!!ECUntypedModel class methodsFor: 'instance creation' stamp: 'bar 12/20/2004 09:02'!class: aClass temporaries: aCollection 	^self 		class: aClass		temporaries: aCollection		additionals: #()		variables: true		selectors: true! !!ECUntypedModel class methodsFor: 'instance creation' stamp: 'bar 4/11/2005 11:33'!class: aClass temporaries: aCollection additionals: additionalCollection variables: variablesBoolean selectors: selectorsBoolean 	| newInstance |	newInstance _ self basicNew initialize.	newInstance		setClass: aClass		temporaries: aCollection		additionals: additionalCollection		variables: variablesBoolean		selectors: selectorsBoolean.	^ newInstance! !!ECUntypedModel methodsFor: 'private' stamp: 'bar 8/14/2005 21:50'!addAdditionals: aCollection 	aCollection		ifNotNil: [aCollection				do: [:each | | type | each isLocal						ifTrue: [localVars add: each value]						ifFalse: [each isInstance								ifTrue: [instVars add: each value]								ifFalse: [each isSelector										ifTrue: [selectors add: each value]]]]]! !!ECUntypedModel methodsFor: 'private' stamp: 'bar 8/13/2005 18:14'!addSelectors	selectors		ifEmpty: [self initializeSelectors].	self addToEntries: selectors! !!ECUntypedModel methodsFor: 'private' stamp: 'bar 10/5/2005 23:05'!addVariables	includeVariables		ifFalse: [^ self].	self addToEntries: localVars.	self addToEntries: instVars.	self addToEntries: classVars! !!ECUntypedModel methodsFor: 'initialize-release' stamp: 'bar 8/8/2005 10:41'!initialize	super initialize.	localVars _ SortedCollection new.	instVars _ SortedCollection new.	classVars _ SortedCollection new.	includeSelectors _ true.	includeVariables _ true! !!ECUntypedModel methodsFor: 'initialize-release' stamp: 'bar 3/1/2006 13:58'!initializeClassVars	(clazz isNil			or: [includeVariables not])		ifTrue: [^ self].	classVars _ clazz allClassVarNames asSortedCollection.	classVars _ classVars				collect: [:each | ECClassVarEntry contents: each type: #classVar]! !!ECUntypedModel methodsFor: 'initialize-release' stamp: 'bar 3/1/2006 13:26'!initializeInstVars	(clazz isNil			or: [includeVariables not])		ifTrue: [^ self].	instVars _ clazz allInstVarNames asSortedCollection.	instVars _ instVars				collect: [:each | ECInstVarEntry contents: each type: #instVar].	instVars		add: (ECSelfEntry contents: 'self' type: #self).	instVars		add: (ECSuperEntry contents: 'super' type: #super)! !!ECUntypedModel methodsFor: 'private' stamp: 'bar 3/3/2006 23:02'!initializeSelectors	self resetSelectors.	includeSelectors 		ifFalse: [Smalltalk				keysDo: [:each | selectors						add: (ECGlobalEntry contents: each type: #globalVar)].			^ self].	narrowString		ifEmpty: [^ self].	ECSymbols		startsWith: narrowString first		caseSensitive: ECPreferences caseSensitive		do: [:each | (includeVariables					or: [each first isLowercase])				ifTrue: [selectors						add: (ECSelectorEntry contents: each type: #selector)]]! !!ECUntypedModel methodsFor: 'accessing' stamp: 'bar 12/20/2004 22:18'!message	^ (includeSelectors and:[narrowString isEmpty])		ifTrue: ['press key for selectors']		ifFalse: [super message]! !!ECUntypedModel methodsFor: 'initialize-release' stamp: 'bar 4/11/2005 11:42'!narrowString: aString 	(narrowString isEmpty			or: [aString isEmpty			or: [aString first ~= narrowString first]])		ifTrue: [self reset].	super narrowString: aString! !!ECUntypedModel methodsFor: 'action' stamp: 'bar 4/11/2005 11:35'!narrowWith: aString 	self narrowString: aString.	self resetEntries.	self addVariables.	self addSelectors! !!ECUntypedModel methodsFor: 'initialize-release' stamp: 'bar 8/8/2005 10:38'!setClass: aClass temporaries: aCollection additionals: additionalCollection variables: variablesBoolean selectors: selectorsBoolean 	includeVariables _ variablesBoolean.	includeSelectors _ selectorsBoolean.	clazz _ aClass.	self initializeInstVars.	self initializeClassVars.	includeVariables		ifTrue: [localVars _ aCollection.			self addAdditionals: additionalCollection]		ifFalse: [localVars _ OrderedCollection new].	self narrowWith: ''! !!ECPreferences class methodsFor: 'as yet unclassified' stamp: 'bar 4/11/2005 10:54'!caseSensitive	^ Preferences ecompletionCaseSensitive ! !!ECPreferences class methodsFor: 'as yet unclassified' stamp: 'bar 4/11/2005 10:54'!enabled	^Preferences ecompletionEnabled ! !!ECPreferences class methodsFor: 'as yet unclassified' stamp: 'al 6/29/2006 10:01'!initialize	(Preferences preferenceAt: #ecompletionEnabled)		ifNil: [Preferences				addPreference: #ecompletionEnabled				categories: #(#browsing )				default: true				balloonHelp: 'Enable, or disable eCompletion - a completion system that works in a workspace, browser and debugger.'].	(Preferences preferenceAt: #ecompletionCaseSensitive)		ifNil: [Preferences				addPreference: #ecompletionCaseSensitive				categories: #(#browsing )				default: true				balloonHelp: 'decide if you want eCompletion to be case sensitive or not.'].	(Preferences preferenceAt: #ecompletionSmartCharacters)		ifNil: [Preferences				addPreference: #ecompletionSmartCharacters				categories: #(#browsing )				default: true				balloonHelp: 'decide if you want eCompletion to use smart characters, e.g, to automatically close brackets.']! !!ECPreferences class methodsFor: 'as yet unclassified' stamp: 'bar 4/11/2005 10:58'!setCaseSensitiveness: aBoolean 	Preferences setPreference: #ecompletionCaseSensitive toValue: aBoolean! !!ECSymbols class methodsFor: 'as yet unclassified' stamp: 'bar 4/11/2005 16:24'!startsWith: aChar caseSensitive: aBoolean do: aBlock 	| char caseInSensitive firstChar |	caseInSensitive _ aBoolean not.	firstChar _ caseInSensitive				ifTrue: [aChar asLowercase]				ifFalse: [aChar].	Symbol		allSymbolTablesDo: [:each | 			| size | 			size _ each size.			char _ size > 0						ifTrue: [each first].			(char notNil					and: [char == firstChar							or: [caseInSensitive									and: [char asLowercase == firstChar]]]					and: [(each findAnySubStr: '- ' startingAt: 2)							> size])				ifTrue: [aBlock value: each]]! !!ECTestSuperClass commentStamp: '<historical>' prior: 0!I'm only for SUnit TestCases.!!ECTestClass commentStamp: '<historical>' prior: 0!I'm only for SUnit TestCases.!!ECTestClass class methodsFor: 'as yet unclassified' stamp: 'bar 8/8/2005 10:31'!initialize	super initialize.	ClassVar _ 'Any string'.! !!ECTestClass methodsFor: 'as yet unclassified' stamp: 'bar 12/13/2004 17:41'!initialize: aRectangle 	constantInteger := 15.	constantString := 'Ruben'.	constantSymbol := #Symbol.	constantArray := #(15 16 17 28 ).	constantBoolean := true.	typeSuggestingParameter := aRectangle.	messageSend := Dictionary new.	messageSend2 := aRectangle origin.	globalVarKeyword := SortedCollection				sortBlock: [:a :b | a <= b].	globalVarKeyword2 := SortedCollection new: 15.	constantNil := nil.	typeSuggestingParameter2 := nil.	complexInit := 15 > 16				ifTrue: [#Symbol]				ifFalse: ['String'].	complexInit2 := Dictionary new: aRectangle origin x. ! !!ECTestClass methodsFor: 'as yet unclassified' stamp: 'bar 12/13/2004 17:29'!lowPriorityOverrides: aRectangle 	messageSend := aRectangle.	typeSuggestingParameter2 := aRectangle. ! !!ECTestClass methodsFor: 'as yet unclassified' stamp: 'bar 12/9/2004 19:40'!testIt: anArgument 	| loc1 x2 t |	x2 := [:bar :var | var < bar].	loc1 := constantArray.	x2 value: loc1.	t := 15.	^ x2! !!ECTestSuperClass class methodsFor: 'as yet unclassified' stamp: 'bar 8/8/2005 10:30'!initialize	SuperClassVar _ Dictionary new.! !!ECTestSuperClass methodsFor: 'as yet unclassified' stamp: 'bar 11/29/2004 15:55'!initialize	superInstVar _ Dictionary new.! !!ECTestSuperClass methodsFor: 'as yet unclassified' stamp: 'bar 12/6/2004 08:44'!testIt: aString	self subclassResponsibility ! !!ECTestSuperClass methodsFor: 'as yet unclassified' stamp: 'bar 12/6/2004 08:45'!toBeOverriden: anArgument 	15 > 16		ifTrue: [self sample * anArgument ]! !!ECTestSuperClass methodsFor: 'as yet unclassified' stamp: 'bar 12/6/2004 16:19'!toBeOverridenWithReturn	^ 'saga'! !!ECTypeInfo commentStamp: '<historical>' prior: 0!I'm used in ECInstVarTypeGuesser to store found type informations.!!ECTypeInfo class methodsFor: 'as yet unclassified' stamp: 'bar 12/2/2004 11:52'!definedByLiteral: aClass 	| newInstance |	newInstance := self new.	newInstance setType: aClass kind: 1.	^ newInstance! !!ECTypeInfo class methodsFor: 'as yet unclassified' stamp: 'bar 12/2/2004 11:52'!definedByMessageSend: aClass 	| newInstance |	newInstance := self new.	newInstance setType: aClass kind: 2.	^ newInstance! !!ECTypeInfo class methodsFor: 'as yet unclassified' stamp: 'bar 12/2/2004 12:02'!definedByTemporaryVar: anInteger	| newInstance |	newInstance := self new.	newInstance setType: nil kind: 3.	newInstance temporaryOffset: anInteger.	^ newInstance! !!ECTypeInfo methodsFor: 'as yet unclassified' stamp: 'bar 12/2/2004 11:47'!isDefinedByMessageSend	^kind == 2! !!ECTypeInfo methodsFor: 'as yet unclassified' stamp: 'bar 12/2/2004 11:47'!isDefinedByTemporary	^ kind == 3! !!ECTypeInfo methodsFor: 'as yet unclassified' stamp: 'bar 12/2/2004 12:01'!priority	^kind! !!ECTypeInfo methodsFor: 'as yet unclassified' stamp: 'bar 12/2/2004 12:01'!setType: aClass kind: anInteger 	type := aClass.	kind := anInteger! !!ECTypeInfo methodsFor: 'as yet unclassified' stamp: 'bar 12/2/2004 12:02'!temporaryOffset	^temporaryOffset! !!ECTypeInfo methodsFor: 'as yet unclassified' stamp: 'bar 12/2/2004 12:02'!temporaryOffset: anInteger	temporaryOffset _ anInteger ! !!ECTypeInfo methodsFor: 'as yet unclassified' stamp: 'bar 12/2/2004 11:44'!type	^type! !!ECTypeInfo methodsFor: 'as yet unclassified' stamp: 'bar 12/2/2004 12:59'!type: aClass	type _ aClass! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 1/9/2005 13:20'!asType	type = #symbol		ifTrue: [^ Symbol].	type = #character		ifTrue: [^ Character].	type = #string		ifTrue: [^ String].	type = #number		ifTrue: [^ Number].	type = #true		ifTrue: [^ Smalltalk at: #True].	type = #false		ifTrue: [^ Smalltalk at: #False].	type = #arrayEnd		ifTrue: [^ Array].	self isBlockEnd		ifTrue: [^ BlockContext].	^ nil! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 1/6/2005 22:08'!includesPosition: aNumber^(start <= aNumber					and: [end >= aNumber])! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 1/9/2005 13:14'!isArgument	^ type = #methodArg! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 1/9/2005 14:51'!isAssignment	^#(#assignment #ansiAssignment ) includes: type! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 3/2/2006 21:27'!isBinary	^type == #binary! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 1/6/2005 22:22'!isBlockEnd	^ type beginsWith: 'blockEnd'! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 1/6/2005 22:21'!isBlockStart	^type beginsWith: 'blockStart'! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 9/20/2006 08:29'!isBlockTemporary	^#(#blockPatternTempVar #blockPatternArg) includes: type! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 8/9/2005 23:04'!isClassVariable	^ type = #classVar! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 1/6/2005 13:17'!isComment	^ type == #comment! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 1/9/2005 13:20'!isConstant	^ self isBlockEnd		or: [#(#false #true #string #number #symbol #character #arrayEnd ) includes: type]! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 1/9/2005 13:06'!isGlobal	^type = #globalVar! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 1/9/2005 13:13'!isInstanceVariable	^ type = #instVar! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 3/9/2006 10:10'!isKeyword	^ type == #keyword or:[type == #undefinedKeyword]! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 1/6/2005 13:56'!isOpening^ ((type beginsWith: 'blockStart')			or: [type beginsWith: 'leftParenthesis'])		! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 1/9/2005 13:05'!isSelf	^type = #self! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 1/9/2005 14:37'!isSeparator	^ #(#methodTempBar #statementSeparator #patternUnary #patternArg #blockPatternArg #blockArgsBar #return #primitiveOrExternalCallEnd) includes: type! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 1/9/2005 13:05'!isSuper	^type = #super! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 1/9/2005 13:03'!isTemporaryVariable	^ #(#tempVar #blockTempVar workspaceVar ) includes: type! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 1/6/2005 13:18'!isUnfinished	^#(#unfinishedString #unfinishedComment ) includes: type! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 1/9/2005 13:13'!isVariable	^ self isTemporaryVariable		or: [self isInstanceVariable				or: [self isSelf or:[self isSuper]]]! !!SHRange methodsFor: '*ecompletion' stamp: 'bar 3/2/2006 21:26'!isVariablesOnly	^ self isAssignment		or: [self isVariable				or: [self isConstant						or: [self isSeparator or:[self isBinary]]]]! !!Debugger methodsFor: '*ecompletion' stamp: 'bar 3/30/2006 10:35'!guessTypeForName: aString 	| index object |	index _ tempNames				indexOf: aString				ifAbsent: [].	object _ index				ifNil: [index _ self receiver class allInstVarNames								indexOf: aString								ifAbsent: [].					self receiver instVarAt: index]				ifNotNil: [self selectedContext tempAt: index].	^ object class! !!CodeHolder methodsFor: '*ecompletion-override' stamp: 'bar 12/13/2004 14:39' prior: 18751619!contentsChanged	super contentsChanged.	self changed: #annotation.	self completionController closeMenu! !!CodeHolder methodsFor: '*ecompletion' stamp: 'bar 11/30/2004 16:10'!receiverClass	^ self selectedClassOrMetaClass! !"ECompletion"!----SNAPSHOT----an Array(7 July 2009 3:54:29 pm) Squeak3.9u1.image priorSource: 479803!----QUIT----an Array(7 July 2009 3:55:33 pm) Squeak3.9u1.image priorSource: 2219173!----STARTUP----an Array(19 October 2009 3:31:34 pm) as Z:\home\users\michael\source\ateo\bootstrap\ATEO-bootstrap.image!!FileStream class methodsFor: 'concrete classes' stamp: 'HM 10/19/2009 15:33' prior: 20743200!concreteStream	"Who should we really direct class queries to?  "	"^ MultiByteFileStream."	"Changed return type so that CR are replaced with LF (CRLF on win32) for fileouts/fileins."	^ CrLfFileStream! !----QUIT----an Array(19 October 2009 3:33:33 pm) ATEO-bootstrap.image priorSource: 2219262!----STARTUP----an Array(19 October 2009 3:34:15 pm) as Z:\home\users\michael\source\ateo\AAF\ATEO-AAF.image!Object subclass: #AAFControl	instanceVariableNames: 'isDebugRun nodes nodesToVisit'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF'!!AAFControl methodsFor: 'as yet unclassified' stamp: 'MH 7/5/2009 20:08'!addNode: anAAFNode	nodes addLast: anAAFNode.! !!AAFControl methodsFor: 'as yet unclassified' stamp: 'HM 7/23/2009 23:12'!connectParent: parent withChild: child	(nil == parent)		ifFalse: [			parent addChild: child.		].		"A parent takes ownership of its children, hence we only use addNode on the child."	child addParent: parent.	self addNode: child.! !!AAFControl methodsFor: 'as yet unclassified' stamp: 'HM 7/23/2009 22:58'!createGraphWithRoot: root	nodes := OrderedCollection new.	invertVisitedFlag := false.	self connectParent: nil	     withChild: root.! !!AAFControl methodsFor: 'as yet unclassified' stamp: 'HM 7/23/2009 20:40'!graphSize	^(nodes size)! !!AAFControl methodsFor: 'as yet unclassified' stamp: 'HM 9/15/2009 00:14'!initialize	super initialize.		nodes := OrderedCollection new: 32.	nodesToVisit := OrderedCollection new: 32.	isDebugRun := false.! !!AAFControl methodsFor: 'as yet unclassified' stamp: 'MH 6/30/2009 00:34'!isDebugRun: aBoolean	isDebugRun := aBoolean.! !!AAFControl methodsFor: 'as yet unclassified' stamp: 'HM 7/23/2009 04:07'!processGraph: aSamState	(nodes isEmpty)		ifTrue: [			"Nothing to do!! Return unmodified state."			^aSamState		].	^(self processGraph: aSamState startAt: (self root) endAt: (self sink)).! !!AAFControl methodsFor: 'as yet unclassified' stamp: 'HM 7/23/2009 23:12'!processGraph: aSamState startAt: root endAt: sink		"If nodesToVisit wasn't properly emptied during the last run we know something went terribly wrong, so we complain!!"	(nodesToVisit isEmpty)		ifFalse: [self break].			nodesToVisit addLast: root.	root result: aSamState.		(nodes)		do: [			:node |		"Reset visited flag for each node. Increases runtime cost by O(n). I should NOT optimize this ..."		"I tested the difference when using an evil hack to toggle the meaning of the nodes' visited flag with each run (We know that the visited flags switch from true to false (and vice versa) with each run of the BFS). It would save -O(n), in theory. But I don't think this is noticable. In fact, I tested it, and for 640.000 nodes it was the difference of 9.7secs to 10.2 secs. Not worth using an evil hack like this (which easily breaks, if the next dev comes along). The reason is that the AAFAgent>>compute costs are much much higher (read: the constant part of big-O) than the constat part of flipping a bit in a list."		node isVisited: false.	].		"Run BFS. For a Graph G = (V, E), runtime costs are O(|V| + |E|), plus the potentially expensive computations run by the agents."	[nodesToVisit isEmpty]		whileFalse: [			| node |						node := nodesToVisit removeFirst.			node isVisited: true.			node  compute.						(node children)				do: [					:child |								(false = (child isVisited))						ifTrue: [							nodesToVisit addLast: child.						].				].		].	^(sink result)! !!AAFControl methodsFor: 'as yet unclassified' stamp: 'HM 9/15/2009 00:19'!processGraphWithProxy: anAAFProxy	"Process the graph, reading and writing the SAM state from a given proxy instance."	anAAFProxy state: (self processGraph: (anAAFProxy state)).! !!AAFControl methodsFor: 'as yet unclassified' stamp: 'MH 7/6/2009 14:07'!root	^(nodes first)	! !!AAFControl methodsFor: 'as yet unclassified' stamp: 'HM 7/24/2009 01:19'!sink	"This is just a clever guess. But if you think about it - it's the same assumption as with the root node!!"	^(nodes last)	! !!AAFControl methodsFor: 'testing' stamp: 'HM 7/16/2009 02:42'!testBreaksGraph	| root |		root := AAFNode new		             agent: (AAFBreaksAgent new).			self createGraphWithRoot: root.! !!AAFControl methodsFor: 'testing' stamp: 'HM 7/16/2009 13:25'!testBreaksInversionGraph	| breaks inversion |		breaks := AAFNode new agent: (AAFBreaksAgent new).	inversion := AAFNode new agent: (AAFInversionAgent new).	self createGraphWithRoot: breaks.	self connectParent: breaks withChild: inversion.! !!AAFControl methodsFor: 'testing' stamp: 'MH 7/7/2009 18:01'!testInversionGraph	| root |		root := AAFNode new		             agent: (AAFInversionAgent new).			self createGraphWithRoot: root.! !!AAFControl methodsFor: 'testing' stamp: 'HM 7/23/2009 19:50'!testLinearGraphWith: anAAFAgent size: size	| node parent |		node := AAFNode new		             agent: anAAFAgent.			self createGraphWithRoot: node.	parent := node.		(2 to: size)		do: [			:idx |						node := AAFNode new			                agent: (anAAFAgent copy).			self connectParent: parent withChild: node.			parent := node.				].! !!AAFControl methodsFor: 'testing' stamp: 'HM 7/26/2009 10:57'!testLoopedGraphProcessingWith: anAAFAgent times: anInt	| pathLength |		pathLength := 64.	proxy := AAFProxy reset getInstance.		self testLinearGraphWith: anAAFAgent size: pathLength.	(1 to: anInt)		do: [			:iter |			proxy testFetchDataFromSam.			self processGraph: (proxy state).		].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AAFControl class	instanceVariableNames: 'instance'!!AAFControl class methodsFor: 'as yet unclassified' stamp: 'HM 7/25/2009 19:40'!garbageCollect	"Taken from http://onsmalltalk.com/squeak-smalltalk-image-maintenance"    | tasks |    tasks := OrderedCollection new                add: [MCFileBasedRepository flushAllCaches];                "add: [WARegistry clearAllHandlers];"                add: [SMSqueakMap default clearCaches];                add: [Smalltalk removeEmptyMessageCategories];                add: [Workspace                        allSubInstancesDo: [:each | each setBindings: Dictionary new]];                add: [Undeclared removeUnreferencedKeys];                add: [Categorizer sortAllCategories];                "add: [ODBCConnection cleanAll];"                add: [Symbol compactSymbolTable];                add: [ReleaseBuilderDeveloper new fixObsoleteReferences];                add: [Smalltalk garbageCollectMost];                 yourself.    Utilities        informUserDuring: [:bar | tasks                do: [:block |                     bar value: block printString.                    [block value]                        on: Error                        do: [:error | Transcript show: error;                                 cr]]].    SystemNavigation default obsoleteClasses isEmpty        ifTrue: [SmalltalkImage current saveSession]        ifFalse: [SystemNavigation default obsoleteClasses                do: [:each | [PointerFinder on: each]                        on: Error                        do: [:error | Transcript show: error; cr]]]! !!AAFControl class methodsFor: 'as yet unclassified' stamp: 'HM 7/25/2009 16:03'!getInstance	( nil = instance )	ifTrue: [		"I refuse to be judged by our 'poor' performance only because the Squeak VM doesn't do its job properly.'"		AAFControl setSaneVmDefaults.		instance := (AAFControl new).	].	^instance! !!AAFControl class methodsFor: 'as yet unclassified' stamp: 'MH 7/6/2009 13:17'!reset	instance := nil.! !!AAFControl class methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 11:01'!setSaneVmDefaults	"The Squeak developers love to see the IGC doing its work, as often as possible. Well, I don't. Certainly not for every 4k allocations."	SmalltalkImage current vmParameterAt: 5 put: 400000.	SmalltalkImage current vmParameterAt: 6 put: 12000.	! !EventSensor subclass: #AAFEventSensor	instanceVariableNames: 'joystickDiffs joysticksOffsets joysticks'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF'!!AAFEventSensor commentStamp: 'MH 6/22/2009 21:48' prior: 0!The AAFEventSensor class adds a user-specified differential between sensor reads. The differential is reset to 0@0 after each read.!!AAFEventSensor methodsFor: 'as yet unclassified' stamp: 'MH 7/6/2009 12:17'!initialize	super initialize.		self resetJoysticks.! !!AAFEventSensor methodsFor: 'as yet unclassified' stamp: 'MH 7/6/2009 12:17'!joysticks: anArray	joysticks := (anArray copy).! !!AAFEventSensor methodsFor: 'as yet unclassified' stamp: 'MH 7/6/2009 12:19'!resetJoysticks	joysticks := Array		with: (super joystickXY: 1)		with: (super joystickXY: 2).! !!AAFEventSensor methodsFor: 'override' stamp: 'MH 7/6/2009 12:20'!joystickXY: index	^(joysticks at: index)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AAFEventSensor class	instanceVariableNames: 'instance joystickDiffs'!!AAFEventSensor class methodsFor: 'as yet unclassified' stamp: 'MH 6/23/2009 15:35'!fetchDataFrom: anAAFProxy	| sensor |	"This method fetches modified tracking data from ATEO's Automatic Framework."	sensor := AAFEventSensor getInstance.! !!AAFEventSensor class methodsFor: 'as yet unclassified' stamp: 'MH 6/22/2009 21:35'!getInstance	( nil = instance )	ifTrue: [		instance := (AAFEventSensor basicNew) initialize.	].	^instance! !!AAFEventSensor class methodsFor: 'as yet unclassified' stamp: 'MH 6/22/2009 22:34'!reset	instance := nil.! !!AAFEventSensor class methodsFor: 'nil' stamp: 'MH 6/23/2009 15:33'!fetchDataFromProxy	| sensor state |	"This method fetches modified tracking data from ATEO's Automatic Framework."	sensor := AAFEventSensor getInstance.	state := SamState new.! !Object subclass: #AAFNode	instanceVariableNames: 'agent children parents result hasResult id isVisited'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF'!!AAFNode methodsFor: 'as yet unclassified' stamp: 'MH 7/6/2009 13:13'!addChild: aNode	^(self		addToCollection: (self children)		node: aNode)! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'MH 7/6/2009 13:13'!addParent: aNode	^(self		addToCollection: (self parents)		node: aNode)! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'MH 7/6/2009 13:14'!addToCollection: aCollection node: node	(self ~= node and: [nil ~= node])		ifTrue: [			aCollection addLast: node.		].	^node! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'MH 7/7/2009 19:50'!agent	^agent! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'MH 6/29/2009 21:46'!agent: anAAFAgent	agent := anAAFAgent.! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'MH 6/29/2009 20:02'!children	^children! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'HM 9/14/2009 23:05'!compute	"(self hasResult)		ifFalse: [			self mergeParentResults.		]."		self result: (agent compute: result).! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'HM 7/25/2009 13:30'!hasOnlyOneChild	^(1 = (children size))! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'MH 6/30/2009 14:36'!hasResult	^hasResult and: [result ~= nil]! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'MH 7/6/2009 01:45'!haveParentResults	| tmp |		tmp := false.	parents do: [		:node |				tmp := node hasResult.		(tmp)			ifFalse: [				^false			].	].	^tmp! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'MH 6/30/2009 17:43'!id	^id! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'MH 6/30/2009 17:43'!id: anInt	id := anInt.! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'HM 7/22/2009 23:32'!initialize	super initialize.	id := AAFNode autoId.	result := nil.	hasResult := false.	isVisited := false.	parents := OrderedCollection new.	children := OrderedCollection new.! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'MH 6/30/2009 23:06'!isVisited	^isVisited! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'MH 6/30/2009 23:07'!isVisited: aBoolean	isVisited := aBoolean.! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'HM 9/15/2009 00:38'!mergeParentResults	| tmp nodeResult |		"No need to use complex merge if only one parent exists." 	(1 = (parents size))		ifTrue: [			| parent |						"No need to copy the result if we are the only descendant of the parent."			parent := parents first.			(parent hasOnlyOneChild)				ifTrue:  [self result: (parent takeResult)]				ifFalse: [self result: (parent takeResult copy)].							^self.		].		"We have to wait until all parent results were computed.	Consider root->sink, root->child, child->sink. Without this check, we would compute sink's result before visiting child, given BFS"	(self haveParentResults)		ifFalse: [^self].	"This 'new' call might be too expensive ..."	tmp := SamState new.		(self parents)		do: [			:node |					"Do we really need a copy? the parents are not going to use their results anymore, after all. Hm, but we could have several merge nodes for the same parents ..."			nodeResult := node takeResult copy.			"TODO: use simple vector addition to merge different joystick results of sibblings."		].	self result: tmp.! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'MH 6/30/2009 11:20'!parents	^parents! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'MH 6/30/2009 00:27'!result	^result! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'MH 6/30/2009 15:16'!result: aSamState	result := aSamState.	hasResult := true.! !!AAFNode methodsFor: 'as yet unclassified' stamp: 'MH 7/6/2009 01:46'!takeResult	hasResult := false.	^result! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AAFNode class	instanceVariableNames: 'count log'!!AAFNode class methodsFor: 'as yet unclassified' stamp: 'MH 6/30/2009 17:45'!autoId	(nil = count)	ifTrue: [		self resetCounter.	] ifFalse: [		count := count + 1.	].	^count! !!AAFNode class methodsFor: 'as yet unclassified' stamp: 'MH 6/29/2009 22:08'!resetCounter	count := 0.! !Object subclass: #AAFProxy	instanceVariableNames: 'state isDebugRun trackingState'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF'!!AAFProxy methodsFor: 'as yet unclassified' stamp: 'HM 9/14/2009 22:06'!initialize	super initialize.		isDebugRun := false.	state := SamState new.! !!AAFProxy methodsFor: 'as yet unclassified' stamp: 'MH 6/22/2009 20:53'!isDebugRun: aBoolean	isDebugRun := aBoolean.! !!AAFProxy methodsFor: 'as yet unclassified' stamp: 'HM 9/15/2009 00:27'!readUpdatesFromSam: SAMModelData	state := SamState new.	state readUpdatesFromTrackingState: SAMModelData.! !!AAFProxy methodsFor: 'as yet unclassified' stamp: 'MH 6/22/2009 20:20'!state	^state! !!AAFProxy methodsFor: 'as yet unclassified' stamp: 'HM 7/23/2009 04:08'!state: currentSamState	state := currentSamState.! !!AAFProxy methodsFor: 'as yet unclassified' stamp: 'HM 9/15/2009 00:30'!writeUpdatesToSam: SAMModelData	"Update SAM with correction from the AAF."	state writeUpdatesToTrackingState: SAMModelData.	! !!AAFProxy methodsFor: 'deprecated' stamp: 'HM 7/29/2009 05:07'!fetchDataFromSam	"This method fetches tracking data of the current state of SAM."		"trackingState holds read-only data only"	trackingState frand: JoyID frand;	              carPos: CarID aktpos;	              speed: JoyID schritt;	              currentSection: ParID currentSection;	              distanceTotal: JoyID summschritt.			"state is a composite structure allowing rw access to its member variables, and read-only access to members of members (here: trackingState)"	"We read the raw joystick data since if we were to read from SAM we'd end up reading the values we just manipulated."	state joystickXY: 1 put: (Sensor joystickXY: 1);	      joystickXY: 2 put: (Sensor joystickXY: 1).! !!AAFProxy methodsFor: 'deprecated' stamp: 'HM 7/31/2009 22:54'!loadRacingLine	"A track is a collection of track section."	| imageFile racingLine xmlFile offset racingLineAsArray |			(ParID isKindOf: ATEOPar)		ifFalse: [^self].	racingLine := Dictionary new.	offset := 0.	(ParID track)		do: [:segment |						imageFile := ParID images at: segment.			xmlFile := ('racinglines\xml\', imageFile, '.xml') asByteString. 			AAFRacingLine parseFile: xmlFile			              appendTo: racingLine			              offset: offset.						"Computing the offset only works if we read all xml files in order and skipped none."			(0 < (racingLine size))				ifTrue: [offset := racingLine keysSortedSafely last].		].		"Copying racingline from a dictionary to an array."	racingLineAsArray := Array new: (racingLine size).	(1 to: (racingLine size))		do: [:idx |				racingLineAsArray at: idx				                  put: (racingLine at: idx).			].		trackingState racingLine: racingLineAsArray.! !!AAFProxy methodsFor: 'deprecated' stamp: 'HM 7/23/2009 04:09'!testFetchDataFromSam	"This method fetches tracking data of the current state of SAM."		"state trackingState: trackingState."		   "joystickXY: 1 put: (1024@1024);		   joystickXY: 2 put: (-1024@-1024)."! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AAFProxy class	instanceVariableNames: 'instance'!!AAFProxy class methodsFor: 'as yet unclassified' stamp: 'MH 6/22/2009 20:55'!getInstance	( nil = instance )	ifTrue: [		instance := (AAFProxy basicNew) initialize.	].	^instance! !!AAFProxy class methodsFor: 'as yet unclassified' stamp: 'MH 6/22/2009 20:56'!reset	instance := nil.! !Object subclass: #AAFRacingLine	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AAF'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AAFRacingLine class	instanceVariableNames: ''!!AAFRacingLine class methodsFor: 'as yet unclassified' stamp: 'HM 7/29/2009 05:16'!parseFile: fileName appendTo: yxPairs	^(AAFRacingLine parseFile: fileName	                appendTo: yxPairs	                offset: 0)! !!AAFRacingLine class methodsFor: 'as yet unclassified' stamp: 'HM 7/29/2009 05:15'!parseFile: fileName appendTo: yxPairs offset: offset	| file xmlDoc elements yValue xValues xValue |	(FileStream isAFileNamed: fileName asByteString)		ifFalse: [^yxPairs].				file := FileStream fileNamed: fileName asByteString.		xmlDoc := XMLDOMParser parseDocumentFrom: file.	file close.	elements := xmlDoc elements at: 1.		elements tagsNamed: #y		do: [:yNode |						yValue := (yNode attributeAt: #val) asInteger.			xValues := OrderedCollection new.			yNode tagsNamed: #x				do: [:xNode |					xValue := (xNode attributeAt: #val) asInteger.					xValues add: xValue.				].			yxPairs at: (yValue + offset) put: xValues.		].		^yxPairs! !Object subclass: #SamState	instanceVariableNames: 'trackingState joystickXAxis joystickYAxis'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF'!!SamState methodsFor: 'as yet unclassified' stamp: 'HM 9/15/2009 00:41'!initialize	super initialize.	joystickXAxis     := Array with: 0 with: 0.	joystickYAxis     := Array with: 0 with: 0.	trackingState := SAMModelData getInstance.! !!SamState methodsFor: 'as yet unclassified' stamp: 'HM 9/14/2009 18:15'!joystickXAxisAt: mwbIndex	^(joystickXAxis at: mwbIndex)! !!SamState methodsFor: 'as yet unclassified' stamp: 'HM 9/15/2009 00:41'!joystickXAxisAt: mwbIndex put: value	joystickXAxis at: mwbIndex put: value.! !!SamState methodsFor: 'as yet unclassified' stamp: 'HM 9/14/2009 18:16'!joystickYAxisAt: mwbIndex	^(joystickYAxis at: mwbIndex)! !!SamState methodsFor: 'as yet unclassified' stamp: 'HM 9/15/2009 00:40'!joystickYAxisAt: mwbIndex put: value	joystickYAxis at: mwbIndex put: value.! !!SamState methodsFor: 'as yet unclassified' stamp: 'HM 9/15/2009 00:28'!readUpdatesFromTrackingState: SAMModelData	trackingState := SAMModelData.	"Copies writeable parameters into SamState members."	joystickXAxis at: 1	              put: (trackingState joystick1XAxis asInteger).	joystickYAxis at: 1	              put: (trackingState joystick1YAxis asInteger).	joystickXAxis at: 2	              put: (trackingState joystick2XAxis asInteger).	joystickYAxis at: 2	              put: (trackingState joystick2YAxis asInteger).	! !!SamState methodsFor: 'as yet unclassified' stamp: 'MH 7/5/2009 15:48'!trackingState	^trackingState! !!SamState methodsFor: 'as yet unclassified' stamp: 'HM 9/15/2009 00:29'!trackingState: samModelData	trackingState := samModelData.! !!SamState methodsFor: 'as yet unclassified' stamp: 'HM 9/15/2009 00:29'!writeUpdatesToTrackingState: SAMModelData	SAMModelData joystick1XAxis: (self joystickXAxisAt: 1);	             joystick1YAxis: (self joystickYAxisAt: 1);	             joystick2XAxis: (self joystickXAxisAt: 2);	             joystick2YAxis: (self joystickYAxisAt: 2).	! !!SamState methodsFor: 'deprecated' stamp: 'MH 7/5/2009 17:55'!joystickXY: index	^(joysticks at: index)! !!SamState methodsFor: 'deprecated' stamp: 'HM 7/23/2009 02:02'!joystickXY: index put: aPoint	joysticks at: index put: aPoint.! !!SamState methodsFor: 'deprecated' stamp: 'MH 7/5/2009 17:56'!joysticks	^joysticks! !!SamState methodsFor: 'deprecated' stamp: 'MH 7/5/2009 17:56'!joysticks: anArray	joysticks := anArray.! !Object subclass: #SamTrackingState	instanceVariableNames: 'carPos frand speed racingLine currentSection distanceTotal'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF'!!SamTrackingState methodsFor: 'as yet unclassified' stamp: 'MH 7/5/2009 15:51'!carPos	^carPos! !!SamTrackingState methodsFor: 'as yet unclassified' stamp: 'HM 7/16/2009 02:31'!carPos: aPoint	(nil ~= aPoint)		ifTrue: [carPos := aPoint].! !!SamTrackingState methodsFor: 'as yet unclassified' stamp: 'HM 7/29/2009 04:50'!currentSection	^currentSection! !!SamTrackingState methodsFor: 'as yet unclassified' stamp: 'HM 7/29/2009 04:50'!currentSection: aNumber	currentSection := aNumber.! !!SamTrackingState methodsFor: 'as yet unclassified' stamp: 'HM 7/29/2009 05:07'!distanceTotal	^distanceTotal! !!SamTrackingState methodsFor: 'as yet unclassified' stamp: 'HM 7/29/2009 05:06'!distanceTotal: aNumber	distanceTotal := aNumber.! !!SamTrackingState methodsFor: 'as yet unclassified' stamp: 'MH 7/5/2009 15:52'!frand	^frand! !!SamTrackingState methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 17:11'!frand: aColor	frand := aColor.! !!SamTrackingState methodsFor: 'as yet unclassified' stamp: 'HM 7/29/2009 04:52'!initialize	super initialize.	carPos := 0@0.	frand := nil.	speed := 0.	images := nil.	currentSection := -1.	racingLine := Dictionary new.	! !!SamTrackingState methodsFor: 'as yet unclassified' stamp: 'HM 7/29/2009 04:42'!racingLine: racingLineDict	racingLine := racingLineDict.! !!SamTrackingState methodsFor: 'as yet unclassified' stamp: 'HM 7/29/2009 05:28'!racingLineAt: yPos	^(racingLine at: (yPos rounded)	             ifAbsent: [nil])! !!SamTrackingState methodsFor: 'as yet unclassified' stamp: 'HM 7/15/2009 21:28'!speed	^speed! !!SamTrackingState methodsFor: 'as yet unclassified' stamp: 'HM 7/16/2009 02:31'!speed: aNumber	(nil ~= aNumber)		ifTrue: [speed := aNumber].! !----End fileIn of Z:\home\users\michael\source\ateo\AAF\AAF.st----!Object subclass: #SAMConfig	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-SAM'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SAMConfig class	instanceVariableNames: ''!!SAMConfig class methodsFor: 'as yet unclassified' stamp: 'HM 10/4/2009 19:21'!tracksPath	^('gfx\bmp\tracks\')! !Object subclass: #SAMControllerExperiment	instanceVariableNames: 'modelData instructions controllerNetwork'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-SAM'!!SAMControllerExperiment methodsFor: 'as yet unclassified' stamp: 'CL 8/21/2009 17:50'!configureStep: currentStep	| currentMwi |		currentMwi := (currentStep at: 2) asInteger.		(currentMwi = 1)	ifTrue:[		modelData inputMwi1: 1.0.		modelData directSetPowerMWI1: 1.0.		modelData directSetPowerMWI2: 0.0.	].		(currentMwi = 2)	ifTrue:[modelData inputMwi1: 0.0.		modelData directSetPowerMWI1: 0.0.		modelData directSetPowerMWI2: 1.0.	].		(currentMwi = 12)	ifTrue:[modelData inputMwi1: 0.5.		modelData directSetPowerMWI1: 0.5.		modelData directSetPowerMWI2: 0.5.	].		modelData maxSpeed: 20.48;					denyLeft: false;					denyRight: false;					currentStep: (currentStep at: 1);					currentMwi: currentMwi;					currentTrackFile: (currentStep at: 3);					tickLog: OrderedCollection new;					dummy: 'dummy';					totalCalculatedXAxisForBlitter: -387;					trackEditMWIStaticObstacle: '0';					firstStaticObstacleXCoordinate: '0';					firstStaticObstacleYCoordinate: '0';					secondStaticObstacleXCoordinate: '0';					secondStaticObstacleYCoordinate: '0';						trackEditMWIDynamicObstacle: '0';					dynamicObstacleXCoordinate: '0';					dynamicObstacleYCoordinate: '0';					trackEditMWIFork: '0';					visualHint: 0;					auditiveHint: 0;					audHintAccuracy: '0';					audHintAllocation: 0;					audHintDirection: '0';					audHintPower: '0';					audHintSpeed: '0';					visHintDirection: '0';					visHintObstacle: '0';				 	visHintFork: '0';				 	visHintSpeed: '0';				 	visualHint: 0;					trackEditOADynamicObstacle: '0';					trackEditOAFork: '0';					trackEditOAStaticObstacle: '0';					directSetPowerMWI1: (modelData directSetPowerMWI1);					directSetPowerMWI2: (modelData directSetPowerMWI2);					directSetPowerReset: 0;					directSetDirection: 0;					directSetSpeed: 1;					directSetSpeedReset: 0;					speedometer: 0;					trackEnded: false;					blindClick: '0@0';					changed.! !!SAMControllerExperiment methodsFor: 'as yet unclassified' stamp: 'CL 8/20/2009 13:41'!initialize		"World on: #keyStroke send: #keyPressed: to: (SAMControllerKeyboard new)."		modelData := SAMModelData getInstance.		self loadExperimentConfiguration.	self loadTileNamesPerTrack .	"self loadGraphics ."	self loadLogTags.	self loadObstacleConfiguration .	self loadInstructions.		modelData experimentFolderName: (SAMControllerLog new) newExperimentFolder;				dynamicObstacleDistanceTick: 10.24;				changed .		instructions := (SAMViewInstructionInitial new) 							controller: self.	! !!SAMControllerExperiment methodsFor: 'as yet unclassified' stamp: 'nn 9/10/2009 17:56'!loadExperimentConfiguration	| fileStreamSteps line stepFile lineTokens |		fileStreamSteps := FileStream readOnlyFileNamed: 'trackConfig\steps.txt'.	stepFile := OrderedCollection new.		"reading steps.txt and putting it linewise in an OrderedCollection (steps)"	[fileStreamSteps atEnd]	whileFalse:	[		line := fileStreamSteps nextLine.		lineTokens := line findTokens: ';'.			((lineTokens size) > 0)		ifTrue:[			lineTokens do: [:token | lineTokens at: (lineTokens indexOf: token) put: token withBlanksTrimmed.].			stepFile add: lineTokens.		].	].	fileStreamSteps close.		modelData stepFile: stepFile; changed.! !!SAMControllerExperiment methodsFor: 'as yet unclassified' stamp: 'CL 8/4/2009 13:57'!loadGraphics	| tileNamesPerTrack nameSet trackGraphics progressBarValue|		trackGraphics := Dictionary new.	progressBarValue := 0.		tileNamesPerTrack := modelData tileNamesPerTrack .	nameSet := Set new.		"using a set, therefore no entry exists more than once"	tileNamesPerTrack do: 	[		:spiderJens |		spiderJens do: 		[			:miniSpiderJens | 			((miniSpiderJens = '111') | (miniSpiderJens = '1110') | (miniSpiderJens = '1111')) "these are the codes for the obstacles - only graphic names are needed"			ifFalse:[nameSet add: miniSpiderJens].		].			].	'Initial loading of all trackgraphics...' 		displayProgressAt: 0 @ 0		from: 0		to: nameSet size		during: 		[			:bar | 			nameSet do: 			[				:graphicFileName | 				progressBarValue := progressBarValue + 1.				bar value: progressBarValue.				trackGraphics at: graphicFileName put: (Form fromFileNamed: ('gfx\', graphicFileName)).			].		].		modelData trackGraphics: trackGraphics; changed. ! !!SAMControllerExperiment methodsFor: 'as yet unclassified' stamp: 'CL 8/21/2009 15:45'!loadInstructions	| stepInstructionsFile currentLine startInstructionsForSingleStep endInstructionsForSingleStep startInstructions endInstructions everyBodysFile |		startInstructions := Dictionary new.	endInstructions := Dictionary new.	startInstructionsForSingleStep := OrderedCollection new. "holds all startinstructions for a single step - can be more than one file"	endInstructionsForSingleStep := OrderedCollection new.	"holds all endinstructions for a single step - can be more than one file"	modelData stepFile do:	[		:stepFileEntry | 				stepInstructionsFile := FileStream readOnlyFileNamed: ('instructions\instructionsStep_', (stepFileEntry at: 1) asString, '.txt').							[stepInstructionsFile atEnd]		whileFalse:		[			currentLine := (stepInstructionsFile nextLine) withBlanksTrimmed.						(currentLine size > 1) "just in case some comedian inserts an empty line"			ifTrue:			[				everyBodysFile := FileStream readOnlyFileNamed: ('instructions\resources\', currentLine).							((currentLine at: 1) = $S)				ifTrue:				[										startInstructionsForSingleStep add: (everyBodysFile upToEnd ) withBlanksTrimmed.				].								((currentLine at: 1) = $E)				ifTrue:				[					endInstructionsForSingleStep add: (everyBodysFile upToEnd ) withBlanksTrimmed.				].			].				].				startInstructions at: (stepFileEntry at: 1) put: startInstructionsForSingleStep copy.		endInstructions at: (stepFileEntry at: 1) put: endInstructionsForSingleStep copy.		startInstructionsForSingleStep := nil.		startInstructionsForSingleStep := OrderedCollection new.		endInstructionsForSingleStep := nil.		endInstructionsForSingleStep := OrderedCollection new.	].	stepInstructionsFile close.	everyBodysFile close.	modelData startInstructions: startInstructions;			endInstructions: endInstructions;			changed.! !!SAMControllerExperiment methodsFor: 'as yet unclassified' stamp: 'nn 8/11/2009 09:28'!loadLogTags	| monkey |	monkey := OrderedCollection new.		monkey add: #('<TimeTotal>' '</TimeTotal>');			add: #('<TimeDelta>' '</TimeDelta>');			add: #('<XCoordinateOnSection>' '</XCoordinateOnSection>');			add: #('<YCoordinateOnSection>' '</YCoordinateOnSection>');			add: #('<ColorCode>' '</ColorCode>');			add: #('<DistanceTotal>' '</DistanceTotal>');			add: #('<DistanceTick>' '</DistanceTick>');						add: #('<LeftRightMWI1>' '</LeftRightMWI1>');			add: #('<LeftRightMWI2>' '</LeftRightMWI2>');			add: #('<UpDownMWI1>' '</UpDownMWI1>');			add: #('<UpDownMWI2>' '</UpDownMWI2>');						add: #('<NoSensorsOffTrack>' '</NoSensorsOffTrack>');			add: #('<CollisionAtSensor>' '</CollisionAtSensor>');			add: #('<FirstStaticObstacleXCoordinate>' '</FirstStaticObstacleXCoordinate>');			add: #('<FirstStaticObstacleYCoordinate>' '</FirstStaticObstacleYCoordinate>');			add: #('<SecondStaticObstacleXCoordinate>' '</SecondStaticObstacleXCoordinate>');			add: #('<SecondStaticObstacleYCoordinate>' '</SecondStaticObstacleYCoordinate>');			add: #('<DynamicObstacleXCoordinate>' '</DynamicObstacleXCoordinate>');			add: #('<DynamicObstacleYCoordinate>' '</DynamicObstacleYCoordinate>');			add: #('<DynamicObstacleDistanceTick>' '</DynamicObstacleDistanceTick>');			add: #('<TrackEditMWIVisibleStaticObstacle>' '</TrackEditMWIVisibleStaticObstacle>');			add: #('<TrackEditMWIVisibleDynamicObstacle>' '</TrackEditMWIVisibleDynamicObstacle>');			add: #('<TrackEditMWIVisibleFork>' '</TrackEditMWIVisibleFork>');			add: #('<TrackEditOAVisibleStaticObstacle>' '</TrackEditOAVisibleStaticObstacle>');			add: #('<TrackEditOAVisibleDynamicObstacle>' '</TrackEditOAVisibleDynamicObstacle>');			add: #('<TrackEditOAVisibleFork>' '</TrackEditOAVisibleFork>');			add: #('<AudHintAllocation>' '</AudHintAllocation>');			add: #('<AudHintSpeed>' '</AudHintSpeed>');			add: #('<AudHintDirection>' '</AudHintDirection>');			add: #('<AudHintAccuracy>' '</AudHintAccuracy>');			add: #('<AudHintPower>' '</AudHintPower>');			add: #('<DirectSetDirection>' '</DirectSetDirection>');			add: #('<DirectSetPowerMWI1>' '</DirectSetPowerMWI1>');			add: #('<DirectSetPowerMWI2>' '</DirectSetPowerMWI2>');			add: #('<DirectSetPowerReset>' '</DirectSetPowerReset>');			add: #('<DirectSetSpeed>' '</DirectSetSpeed>');			add: #('<DirectSetSpeedReset>' '</DirectSetSpeedReset>');			add: #('<VisHintObstacle>' '</VisHintObstacle>');			add: #('<VisHintFork>' '</VisHintFork>');			add: #('<VisHintSpeed>' '</VisHintSpeed>');			add: #('<VisHintDirection>' '</VisHintDirection>');			add: #('<BlindClick>' '</BlindClick>').				modelData logTags: monkey; changed.! !!SAMControllerExperiment methodsFor: 'as yet unclassified' stamp: 'CL 8/8/2009 13:51'!loadObstacleConfiguration		| fileStreamSteps line lineTokens obstacleConfig dentaSnax dentaSnaxEntry|		obstacleConfig := Dictionary new.	dentaSnax := OrderedCollection new.	dentaSnaxEntry := Array new:2.		modelData stepFile do:	[		:drStruve | 						fileStreamSteps := FileStream readOnlyFileNamed: 'trackConfig\hindernisKonfiguration\', (drStruve at: 4).		1 to: dentaSnax size do: [:index | dentaSnax removeFirst.]. "emptying the current dictionary entry"			[fileStreamSteps atEnd]		whileFalse:		[			line := fileStreamSteps nextLine.			lineTokens := line findTokens: ';'.							dentaSnaxEntry at: 1 put: ((lineTokens at: 1) asInteger) . "what kind of obstacle: 111, 1110, 1111"			dentaSnaxEntry at: 2 put: ((lineTokens at: 2) asInteger) .	"at which position, a single number - the y coordinate"			dentaSnax add: (dentaSnaxEntry copy).				].			obstacleConfig at: (drStruve at: 1) put: (dentaSnax copy). 		fileStreamSteps close.	].			modelData obstacleConfig: obstacleConfig; changed.! !!SAMControllerExperiment methodsFor: 'as yet unclassified' stamp: 'CL 8/18/2009 10:52'!loadTileNamesPerTrack	| tileNamesPerTrack trackFile hamAndTurkey foo |		tileNamesPerTrack := Dictionary new.	"for each trackentry from steps - loading of all tilefilenames"	modelData stepFile do: 	[		:entry | 		"entry := entry findTokens: ';' ."		trackFile := FileStream readOnlyFileNamed: ('trackConfig\', (entry at: 3) asString, '.txt' "withBlanksTrimmed").		hamAndTurkey := OrderedCollection new.					[trackFile atEnd]		whileFalse:		[			foo := (((trackFile nextLine) findTokens: ';') at: 1) withBlanksTrimmed.						(foo size > 1)			ifTrue:			[				"((foo = '111') | (foo = '1110') | (foo = '1111'))				ifFalse:[hamAndTurkey add: foo.]."				hamAndTurkey add: foo.			].				].				tileNamesPerTrack at: ((entry at: 1) withBlanksTrimmed) put: hamAndTurkey.	].	trackFile close.		modelData tileNamesPerTrack: tileNamesPerTrack; changed.! !!SAMControllerExperiment methodsFor: 'as yet unclassified' stamp: 'nn 8/11/2009 20:46'!processExperiment	| controllerStep |		instructions delete.		controllerStep := (SAMControllerStep new) 								controllerNetwork: controllerNetwork.		(controllerStep track) controllerNetwork: controllerNetwork.		modelData stepFile do:	[		:currentStep |		self configureStep: currentStep.				controllerStep processStep .		"Transcript show: 'currentStep:', currentStep asString;cr. "	].! !!SAMControllerExperiment methodsFor: 'as yet unclassified' stamp: 'nn 8/10/2009 17:28'!showInitialInstruction	instructions comeToFront; show.! !!SAMControllerExperiment methodsFor: 'accessing' stamp: 'nn 8/11/2009 19:44'!controllerNetwork	^controllerNetwork! !!SAMControllerExperiment methodsFor: 'accessing' stamp: 'nn 8/11/2009 19:44'!controllerNetwork: anObject	controllerNetwork := anObject! !Object subclass: #SAMControllerInput	instanceVariableNames: 'modelData'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-SAM'!!SAMControllerInput methodsFor: 'as yet unclassified' stamp: 'CL 8/8/2009 22:48'!initialize	super initialize.		modelData := SAMModelData getInstance .! !!SAMControllerInput methodsFor: 'as yet unclassified' stamp: 'nn 9/18/2009 10:30'!processInputData	| maxSpeed joystick1 joystick1XAxis joystick1YAxis joystick2 joystick2XAxis joystick2YAxis threshold calculatedXAxis calculatedYAxis inputMwi1 inputMwi2 currentMwi totalCalculatedXAxisForBlitter |		(modelData directSetSpeed >= 0)	ifTrue:[maxSpeed := (modelData maxSpeed) * (modelData directSetSpeed).]	ifFalse:[maxSpeed := (modelData maxSpeed).].			threshold := 30.	inputMwi1 := modelData directSetPowerMWI1.	inputMwi2 := modelData directSetPowerMWI2.			"joystick 1"	joystick1 := Sensor joystickXY: 1.		joystick1XAxis := joystick1 x.	joystick1YAxis := joystick1 y.		(joystick1XAxis abs < threshold)	ifTrue: [joystick1XAxis := 0.].		(joystick1YAxis abs < threshold)	ifTrue: [joystick1YAxis := 0.].	"joystick 2"	joystick2 := Sensor joystickXY: 2.		joystick2XAxis := joystick2 x.	joystick2YAxis := joystick2 y.		(joystick2XAxis abs < threshold)	ifTrue: [joystick2XAxis := 0.].		(joystick2YAxis abs < threshold)	ifTrue: [joystick2YAxis := 0.].		(modelData denyRight)	ifTrue: 	[		(joystick1XAxis > 0) ifTrue: [joystick1XAxis := 0].		(joystick2XAxis > 0) ifTrue: [joystick2XAxis := 0]	].		(modelData denyLeft)	ifTrue: 	[		(joystick1XAxis < 0) ifTrue: [joystick1XAxis := 0].		(joystick2XAxis < 0) ifTrue: [joystick2XAxis := 0]	].	calculatedXAxis := ((joystick1XAxis * inputMwi1) + (joystick2XAxis * inputMwi2) / 1.5 / 50.0) .		calculatedYAxis := (((1024 - joystick1YAxis * inputMwi1) + (1024 - joystick2YAxis * inputMwi2)) / 100.0).	(calculatedYAxis > maxSpeed) 	ifTrue:[calculatedYAxis := maxSpeed .].	modelData totalStepDistance: modelData totalStepDistance + calculatedYAxis.	modelData calculatedXAxis: calculatedXAxis.	modelData speedometer: (calculatedYAxis abs).	modelData calculatedYAxis: calculatedYAxis.		totalCalculatedXAxisForBlitter := modelData totalCalculatedXAxisForBlitter + (calculatedXAxis negated).	"making sure we are NOT leaving the track"	(totalCalculatedXAxisForBlitter between: -15 and: -753)	ifFalse:	[		(totalCalculatedXAxisForBlitter >= -15) ifTrue:[totalCalculatedXAxisForBlitter := -15.].		(totalCalculatedXAxisForBlitter <= -753) ifTrue:[totalCalculatedXAxisForBlitter := -753.].	].	modelData totalCalculatedXAxisForBlitter: totalCalculatedXAxisForBlitter.		currentMwi := modelData currentMwi.	((currentMwi = 1) | (currentMwi  = 12))	ifTrue:	[		modelData joystick1XAxis: joystick1XAxis.		modelData joystick1YAxis: joystick1YAxis.	]	ifFalse:	[		modelData joystick1XAxis: '0'.		modelData joystick1YAxis: '0'.	].		((currentMwi = 2) | (currentMwi  = 12))	ifTrue:	[		modelData joystick2XAxis: joystick2XAxis.		modelData joystick2YAxis: joystick2YAxis.	]	ifFalse:	[		modelData joystick2XAxis: '0'.		modelData joystick2YAxis: '0'.	].	modelData changed.! !!SAMControllerInput methodsFor: 'as yet unclassified' stamp: 'HM 9/14/2009 22:35'!updateJoystickPositions	| joy1Pos joy2Pos |		joy1Pos := Sensor joystickXY: 1.	joy2Pos := Sensor joystickXY: 2.		modelData joystick1XAxis: (joy1Pos x);	          joystick1YAxis: (joy1Pos y);	          joystick2XAxis: (joy2Pos x);	          joystick2YAxis: (joy2Pos y).! !Object subclass: #SAMControllerKeyboard	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-SAM'!!SAMControllerKeyboard methodsFor: 'as yet unclassified' stamp: 'CL 8/8/2009 11:06'!keyPressed: event	| refinedKeyCode | 	refinedKeyCode := event keyString.		(refinedKeyCode = '<Cmd-q>')	ifTrue:[Transcript show: 'quit'; cr.].		(refinedKeyCode = '<Cmd-e>')	ifTrue:[Transcript show: 'step überspringen'; cr.].		(refinedKeyCode = '<Cmd-r>')	ifTrue:[Transcript show: 'step reset'; cr.].		(refinedKeyCode = '<Cmd-a>')	ifTrue:[Transcript show: 'experiment reset'; cr.].		"Transcript show: refinedKeyCode; cr."! !Object subclass: #SAMControllerLog	instanceVariableNames: 'tickLog modelData'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-SAM'!!SAMControllerLog methodsFor: 'as yet unclassified' stamp: 'CL 8/4/2009 10:53'!initialize	modelData := SAMModelData getInstance.! !!SAMControllerLog methodsFor: 'as yet unclassified' stamp: 'CL 8/6/2009 17:08'!newExperimentFolder	| date month day experimentFolderName timeNow hours minutes seconds |	date := Date today.	month := date monthIndex.	day := date dayOfMonth.		(day < 10)	ifTrue:[day := '0', day asString]	ifFalse:[day := day asString].	(month < 10)	ifTrue:[month := '0', month asString]	ifFalse:[month := month asString].		timeNow := Time now.		hours := timeNow hours.	minutes := timeNow minutes.	seconds := timeNow seconds.		(hours < 10)	ifTrue:[hours := '0', hours asString.]	ifFalse:[hours := hours asString.].		(minutes < 10)	ifTrue:[minutes := '0', minutes asString.]	ifFalse:[minutes := minutes asString.].		(seconds < 10)	ifTrue:[seconds := '0', seconds asString.]	ifFalse:[seconds := seconds asString.].	experimentFolderName := (date year) asString, month, day, '_', hours, minutes, seconds .		^experimentFolderName.		! !!SAMControllerLog methodsFor: 'as yet unclassified' stamp: 'CL 8/4/2009 14:12'!newExperimentStepFilename	| experimentStepFilename |		experimentStepFilename := modelData experimentFolderName, '_', (modelData currentStep) asString, '.xml'.		modelData experimentStepFilename: experimentStepFilename; changed.! !!SAMControllerLog methodsFor: 'as yet unclassified' stamp: 'CL 8/4/2009 13:55'!processStepLogData	| currentTimeStamp |	currentTimeStamp := Time millisecondClockValue.	modelData stepTotalTime: currentTimeStamp - modelData logStartTime;					timeDelta: currentTimeStamp - modelData timeLastStep;					timeLastStep: currentTimeStamp;					changed.! !!SAMControllerLog methodsFor: 'as yet unclassified' stamp: 'nn 8/31/2009 12:56'!writeStepLogFile	| logfile localTickLog progressBarValue refinedLogEntry logTags tags index tileNamesForThisTrack trackFileNames|	((FileDirectory default directoryNamed: 'log\', modelData experimentFolderName) exists)	ifFalse:[(FileDirectory new) createDirectory: 'log\', modelData experimentFolderName.].	logfile := (FileStream newFileNamed: ('log\', modelData experimentFolderName, '\', modelData experimentStepFilename)).		tileNamesForThisTrack := (modelData tileNamesPerTrack) at: modelData currentStep .	trackFileNames := ''.		tileNamesForThisTrack do: 	[		:oreo | 		((oreo = '111') | (oreo = '1110') | (oreo = '1111'))		ifFalse:[trackFileNames := trackFileNames, oreo, ';'.]	].		logfile nextPutAll: ('<experiment ExpNr = "' , (modelData experimentType) asString , 					'" TeamNr = "' , (modelData team) asString , 					'" SubjNr1 = "' , (modelData mwi1) asString , 					'" SubjNr2 = "' , (modelData mwi2) asString , 					'" AssistenceNo = "' , (modelData assistance ) asString , 					'" KindOfAssistance = "' , (modelData kindOfAssistance ) asString , 					'" TeamSex = "' , (modelData gender) asString , 					'" StepNr = "', (modelData currentStep) asString , 					'" ShareMWI1 = "', (modelData inputMwi1 ) asString ,					'" ShareMWI2 = "', (1 - (modelData inputMwi1)) asString ,					'" TrackFileNames = "', trackFileNames ,					'">',					(Character cr) asString).		localTickLog := modelData tickLog.	logTags := modelData logTags.	progressBarValue := 0.		'erstelle logfile...' 		displayProgressAt: 0 @ 0		from: 0		to: localTickLog size		during: 		[			:bar | 			localTickLog do: 			[				:rawLogEntry | 				progressBarValue := progressBarValue + 1.				bar value: progressBarValue.								refinedLogEntry := '<Time>', (Character cr) asString.								"self halt."								rawLogEntry := rawLogEntry findTokens: ';'.				index := 1.								rawLogEntry do:				[					:singleEntry |					tags := (logTags at: index).					refinedLogEntry := refinedLogEntry, (tags at: 1), (singleEntry withBlanksTrimmed) , (tags at: 2), (Character cr) asString.					index := index + 1.				].								refinedLogEntry := refinedLogEntry, '</Time>', (Character cr) asString.				"self halt."				logfile nextPutAll: refinedLogEntry.			].		].		logfile nextPutAll: '</experiment>'.	logfile close.	! !!SAMControllerLog methodsFor: 'as yet unclassified' stamp: 'nn 9/18/2009 10:31'!writeTickLog	tickLog := modelData tickLog.		tickLog add: 		(modelData stepTotalTime) asString, 					';',	"TimeTotal"							(modelData timeDelta) asString, 							';',	"TimeDelta"							(modelData xCoordinateOnSection) asString, 			';',	"XCoordinateOnSection"							(modelData yCoordinateOnSection) asString, 			';',	"YCoordinateOnSection"							(modelData colorCode) asString, 							';',	"ColorCode"							(modelData totalStepDistance) asString, 				';', 	"DistanceTotal"							(modelData calculatedYAxis ) asString, 				';', 	"DistanceTick"							(modelData joystick1XAxis ) asString, 					';',	"LeftRightMWI1"							(modelData joystick2XAxis) asString, 					';',	"UpDownMWI1"							((modelData joystick1YAxis) * -1) asString, 			';',	"LeftRightMWI2"							((modelData joystick2YAxis) * -1) asString, 			';',	"UpDownMWI2"											(modelData noSensorsOffTrack) asString, 				';',	"NoSensorsOffTrack"							(modelData collisionAtSensor) asString, 				';',	"CollisionAtSensor"							(modelData firstStaticObstacleXCoordinate ) , 		';',	"FirstStaticObstacleXCoordinate"							(modelData firstStaticObstacleYCoordinate ) , 		';',	"FirstStaticObstacleYCoordinate"							(modelData secondStaticObstacleXCoordinate ) , 		';',	"SecondStaticObstacleXCoordinate"							(modelData secondStaticObstacleYCoordinate ) , 		';',	"SecondStaticObstacleYCoordinate"							(modelData dynamicObstacleXCoordinate ) , 			';',	"DynamicObstacleXCoordinate"							(modelData dynamicObstacleYCoordinate ) , 			';',	"DynamicObstacleYCoordinate"							(modelData dynamicObstacleDistanceTick ) asString ,';',	"DynamicObstacleDistanceTick"							(modelData trackEditMWIStaticObstacle) , 				';',	"TrackEditMWIVisibleStaticObstacle"							(modelData trackEditMWIDynamicObstacle) ,';',		"TrackEditMWIVisibleDynamicObstacle"							(modelData trackEditMWIFork) , ';',					"TrackEditMWIVisibleFork"							(modelData trackEditOAStaticObstacle), ';',		"TrackEditOAVisibleStaticObstacle"							(modelData trackEditOADynamicObstacle ) , ';',		"TrackEditOAVisibleDynamicObstacle"							(modelData trackEditOAFork ) , ';',						"TrackEditOAVisibleFork"							(modelData audHintAllocation ) asString, ';',	"AudHintAllocation"							(modelData audHintSpeed ), ';',						"AudHintSpeed"							(modelData audHintDirection ) , ';',				"AudHintDirection"							(modelData audHintAccuracy ) , ';',					"AudHintAccuracy"							(modelData audHintPower ) , ';',						"AudHintPower"								(modelData directSetDirection ) asString, ';',	"DirectSetDirection"							(modelData directSetPowerMWI1 ) asString, ';',	"DirectSetPowerMWI1"							(modelData directSetPowerMWI2 ) asString, ';',	"DirectSetPowerMWI2"							(modelData directSetPowerReset  ) asString, ';',"DirectSetPowerReset"							(modelData directSetSpeed ) asString, ';',		"DirectSetSpeed"							(modelData directSetSpeedReset  ) asString, ';',"DirectSetSpeedReset"							(modelData visHintObstacle), ';',					"VisHintObstacle"							(modelData visHintFork), ';',							"VisHintFork"							(modelData visHintSpeed), ';',						"VisHintSpeed"							(modelData visHintDirection) asString, ';',		"VisHintDirection"							(modelData blindClick) asString. 					"BlindClick"								modelData tickLog: tickLog; changed.		! !Object subclass: #SAMControllerNetwork	instanceVariableNames: 'speedData coordData dynamicObstacleData joystickData trackData buttonActionData blindClicksData trackEditData modelData stepConfigData inspectWindow statusData obstacleConfig collisionData'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-SAM'!!SAMControllerNetwork methodsFor: 'as yet unclassified' stamp: 'nn 9/16/2009 10:43'!closeSockets	joystickData closeAndDestroy.	speedData closeAndDestroy.	coordData closeAndDestroy.	trackData closeAndDestroy.	buttonActionData closeAndDestroy.	dynamicObstacleData closeAndDestroy.	blindClicksData closeAndDestroy .	trackEditData closeAndDestroy .	stepConfigData closeAndDestroy .	obstacleConfig closeAndDestroy .	statusData closeAndDestroy .	collisionData closeAndDestroy .	"	inspectWindow delete."! !!SAMControllerNetwork methodsFor: 'as yet unclassified' stamp: 'nn 9/16/2009 10:43'!createSockets	| hostName |	hostName := 'ATEO2'.		"UDP"	speedData 				:= Socket newUDP setPeer: (NetNameResolver addressForName: hostName) port: 40100.	coordData 				:= Socket newUDP setPeer: (NetNameResolver addressForName: hostName) port: 40200.	dynamicObstacleData 	:= Socket newUDP setPeer: (NetNameResolver addressForName: hostName) port: 40300.	joystickData 			:= Socket newUDP setPeer: (NetNameResolver addressForName: hostName) port: 40400.	collisionData 			:= Socket newUDP setPeer: (NetNameResolver addressForName: hostName) port: 40500.		"TCP"	stepConfigData 	:= Socket newTCP connectTo: (NetNameResolver addressForName: hostName) port: 60100.	trackData 			:= Socket newTCP connectTo: (NetNameResolver addressForName: hostName) port: 60200.	buttonActionData 	:= Socket newTCP connectTo: (NetNameResolver addressForName: hostName) port: 60300.	blindClicksData 	:= Socket newTCP connectTo: (NetNameResolver addressForName: hostName) port: 60400.	trackEditData 		:= Socket newTCP connectTo: (NetNameResolver addressForName: hostName) port: 60500.	statusData			:= Socket newTCP connectTo: (NetNameResolver addressForName: hostName) port: 60600.	obstacleConfig		:= Socket newTCP connectTo: (NetNameResolver addressForName: hostName) port: 60700.				self flushData .	"	inspectWindow := self inspect."! !!SAMControllerNetwork methodsFor: 'as yet unclassified' stamp: 'CL 8/21/2009 18:37'!flushData		buttonActionData receiveAvailableData .	blindClicksData receiveAvailableData .	trackEditData receiveAvailableData .! !!SAMControllerNetwork methodsFor: 'as yet unclassified' stamp: 'CL 8/8/2009 21:46'!initialize	super initialize .		modelData := SAMModelData getInstance .! !!SAMControllerNetwork methodsFor: 'as yet unclassified' stamp: 'nn 9/10/2009 10:45'!refineAndSendObstacleData	| obstacles networkData |		obstacles := (modelData obstacleConfig) at: (modelData currentStep).	networkData := ''.		obstacles do: [:arrayWithLengthTwo |		networkData := networkData, (arrayWithLengthTwo at: 1) asString, '-', (arrayWithLengthTwo at: 2) asString, ';'.	].	self sendObstacleConfig: networkData.! !!SAMControllerNetwork methodsFor: 'sendingData' stamp: 'nn 9/16/2009 10:43'!sendCollisionData: data	collisionData sendData: data! !!SAMControllerNetwork methodsFor: 'sendingData' stamp: 'CL 8/8/2009 21:41'!sendCoordData: data	coordData sendData: data! !!SAMControllerNetwork methodsFor: 'sendingData' stamp: 'CL 8/8/2009 21:41'!sendDynamicObstacleData: data	dynamicObstacleData sendData: data! !!SAMControllerNetwork methodsFor: 'sendingData' stamp: 'CL 8/9/2009 19:12'!sendJoystickData: data	joystickData sendData: data			! !!SAMControllerNetwork methodsFor: 'sendingData' stamp: 'CL 9/18/2009 17:32'!sendOPData	self sendSpeedData: (modelData totalStepDistance) asString, ';'.	self sendCoordData: ((modelData totalCalculatedXAxisForBlitter) negated) asString, ';'.			((modelData directSetPowerMWI1) = 0)	ifTrue:[		self sendJoystickData: ('0;0',';',((modelData joystick2XAxis) asString),';',((modelData joystick2YAxis) asString), ';').		].		((modelData directSetPowerMWI1) = 1)	ifTrue:[		self sendJoystickData: (((modelData joystick1XAxis) asString),';',((modelData joystick1YAxis) asString),';','0;0;').		].		(((modelData directSetPowerMWI1) > 0) & ((modelData directSetPowerMWI1) < 1))	ifTrue:[		self sendJoystickData: (((modelData joystick1XAxis) asString),';',((modelData joystick1YAxis) asString),';',((modelData joystick2XAxis) asString),';',((modelData joystick2YAxis) asString), ';').		].		! !!SAMControllerNetwork methodsFor: 'sendingData' stamp: 'nn 9/10/2009 10:35'!sendObstacleConfig: data	obstacleConfig sendData: data! !!SAMControllerNetwork methodsFor: 'sendingData' stamp: 'CL 8/9/2009 19:11'!sendSpeedData: data	speedData sendData: data! !!SAMControllerNetwork methodsFor: 'sendingData' stamp: 'nn 9/10/2009 10:34'!sendStatusData: data	statusData sendData: data! !!SAMControllerNetwork methodsFor: 'sendingData' stamp: 'nn 8/11/2009 20:22'!sendStepConfigData: data	stepConfigData sendData: data! !!SAMControllerNetwork methodsFor: 'sendingData' stamp: 'CL 8/8/2009 21:41'!sendTrackData: data	trackData sendData: data! !!SAMControllerNetwork methodsFor: 'receivingData' stamp: 'CL 8/8/2009 23:04'!processNetwork	self receiveBlindClickData .	self receiveButtonDataFromOP .	self receiveTrackEditDataFromOP .! !!SAMControllerNetwork methodsFor: 'receivingData' stamp: 'nn 9/11/2009 16:44'!receiveBlindClickData	| networkData |	networkData := (blindClicksData receiveAvailableData) .				(networkData isNil)	ifFalse:	[		"Transcript show: '-- ', networkData, ' --' ; cr."		(networkData size > 0)		ifTrue:[ modelData blindClick: ((networkData findTokens: ';') last) asString; changed. ]		ifFalse:[ modelData blindClick: '0@0'; changed. ]			].! !!SAMControllerNetwork methodsFor: 'receivingData' stamp: 'CL 9/21/2009 16:05'!receiveButtonDataFromOP	| networkData directSetPowerMWI1 directSetPowerMWI2 directSetPowerReset directSetSpeedReset directSetSpeed|	networkData := (buttonActionData receiveAvailableData).		"resetting logdata"	modelData "audHintAllocation: 0;"				auditiveHint: 0;				visualHint:0;				directSetPowerReset: 0;				directSetSpeedReset: 0";				directSetDirection: 0".					(modelData directSetDirection = 3)	ifTrue:[ modelData directSetDirection: 0. ].				(networkData isNil)	ifFalse:	[		"(networkData size > 0)		ifTrue:[Transcript show: networkData ; cr.]."		networkData := networkData findTokens: ';'.			networkData do: 		[			:token | 			token := token asInteger.			"((token = 11) | (token = 12) | (token = 13))			ifTrue:[modelData audHintAllocation: (token \\ 10).]."						"((token >= 21) & (token <= 52))""AudHintSpeed - up(22) down(21) | AudHintDirection - left(31) right(32) | AudHintAccuracy - up(42) down(41) | AudHintPower - up(42) down(41)"			"ifTrue:[modelData auditiveHint: token.]."			(token >= 4000) & (token < 5000)			ifTrue:[modelData auditiveHint: token.].						(token > 5000)			ifTrue:[ modelData audHintAllocation: (token - 5000). ].					(token > 60) & (token < 100) "VisHintObstacle - 69; VisHintFork - 79; VisHintSpeed - Up - 82; Down - 81: VisHintDirection - Left - 91; Right - 92"			ifTrue:[modelData visualHint: token].					((token >= 101) & (token <= 103)) "DirectSetDirection - Left"			ifTrue:[				(token = 101)				ifTrue:[					modelData denyLeft: true.					modelData denyRight: false.				].								(token = 102)				ifTrue:[					modelData denyRight: true.					modelData denyLeft: false.				].												(token = 103)				ifTrue:[					modelData denyLeft: false. 					modelData denyRight: false.				].								modelData directSetDirection: (token \\ 10).			].					(token >= 999) & (token < 2000) "DirectSetPowerMWI1 + DirectSetPowerMWI2 (this one is calculated)"			ifTrue:			[				(token = 999)				ifTrue:[					directSetPowerMWI1 := 0.5. 					directSetPowerMWI2 := 0.5.					directSetPowerReset := 1.					]				ifFalse:[					directSetPowerMWI1 := (token - 1000.0)/100.0.					directSetPowerMWI2 := 1.0 - directSetPowerMWI1.					directSetPowerReset := 0.					].								modelData directSetPowerMWI1: directSetPowerMWI1; 								directSetPowerMWI2: directSetPowerMWI2;								directSetPowerReset: directSetPowerReset. 			].					((token >= 2999) & (token < 4000)) "DirectSetSpeed"			ifTrue:[				(token = 2999)				ifTrue:[					directSetSpeed := 1.0.					directSetSpeedReset := 1.					]				ifFalse:[					directSetSpeed := (token - 3000) / 100.0.					directSetSpeedReset := 0.				].				modelData directSetSpeed: directSetSpeed;								directSetSpeedReset: directSetSpeedReset.			].		].	].	modelData changed .! !!SAMControllerNetwork methodsFor: 'receivingData' stamp: 'nn 9/11/2009 16:44'!receiveTrackEditDataFromOP	| networkData |		modelData trackEditOAFork: '0';					trackEditOAStaticObstacle: '0';					trackEditOADynamicObstacle: '0'.						networkData := trackEditData receiveAvailableData .				(networkData isNil)	ifFalse:	[		"Transcript show: '-- ', networkData, ' --' ; cr."		(networkData size > 0)		ifTrue:[			(networkData findTokens: ';') do: [				:token |				token := token asInteger.				((token = 1002) | (token = 1001))				ifTrue:[ modelData trackEditOAFork: (token \\ 1000) asString. ].								((token = 101) | (token = 102))				ifTrue:[ modelData trackEditOAStaticObstacle: (token \\ 100) asString. ].				(token = 103)				ifTrue:[ modelData trackEditOADynamicObstacle: '1'. ]. 			].		].	].	modelData changed.! !Object subclass: #SAMControllerOperator	instanceVariableNames: 'modelData timeStartShowing operator soundPlayed'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-SAM'!!SAMControllerOperator methodsFor: 'as yet unclassified' stamp: 'nn 9/16/2009 13:50'!initialize	super initialize.		modelData := SAMModelData getInstance .	operator := SAMViewOperator new.	timeStartShowing := 0.	soundPlayed := false.! !!SAMControllerOperator methodsFor: 'as yet unclassified' stamp: 'nn 9/16/2009 13:52'!processAuditiveHints	| audHintAllocation auditiveHint indexInSoundArray|		auditiveHint := (modelData auditiveHint - 4000) \\ 100.	audHintAllocation := modelData audHintAllocation.		(soundPlayed)	ifTrue:[		modelData audHintAllocation: 0.		soundPlayed := false.		].			modelData auditiveHint: 0;					audHintAccuracy: '0';					audHintDirection: '0';					audHintPower: '0';					audHintSpeed: '0'.						(auditiveHint ~= 0)	ifTrue:[				(auditiveHint = 21)		ifTrue:[			modelData audHintSpeed: (auditiveHint \\ 10) asString.			indexInSoundArray := 1.			].			(auditiveHint = 22)		ifTrue:[			modelData audHintSpeed: (auditiveHint \\ 10) asString.			indexInSoundArray := 2.			].			(auditiveHint = 31)		ifTrue:[			modelData audHintDirection: (auditiveHint \\ 10) asString.			indexInSoundArray := 3.			].			(auditiveHint = 32)		ifTrue:[			modelData audHintDirection: (auditiveHint \\ 10) asString.			indexInSoundArray := 4.			].			(auditiveHint = 41)		ifTrue:[			modelData audHintAccuracy: (auditiveHint \\ 10) asString.			indexInSoundArray := 5.			].			(auditiveHint = 42)		ifTrue:[			modelData audHintAccuracy: (auditiveHint \\ 10) asString.			indexInSoundArray := 6.			].			(auditiveHint = 51)		ifTrue:[			modelData audHintPower: (auditiveHint \\ 10) asString.			indexInSoundArray := 7.			].				(auditiveHint = 52)		ifTrue:[			modelData audHintPower: (auditiveHint \\ 10) asString.			indexInSoundArray := 8.			].		]. 		"Transcript show: 'auditiveHint: ', auditiveHint asString, ' audHintAllocation: ', audHintAllocation asString; cr."		((auditiveHint ~= 0) & (audHintAllocation ~= 0))	ifTrue:[		operator playAuditiveHints: indexInSoundArray withBalance: audHintAllocation .		soundPlayed := true.		].		modelData changed.! !!SAMControllerOperator methodsFor: 'as yet unclassified' stamp: 'CL 8/19/2009 15:08'!processVisualHints	| visualHint pathToForm |		visualHint := modelData visualHint .	"resetting the logging data"		modelData visHintDirection: '0';				 visHintObstacle: '0';				 visHintFork: '0';				 visHintSpeed: '0';				 visualHint: 0.		"prepare for logging and maybe later setting the correct sourceForms for blitting"	(visualHint ~= 0) 	ifTrue:[			(visualHint = 69) "VisHintObstacle"		ifTrue:[			modelData visHintObstacle: (visualHint \\ 10) asString.			pathToForm := 'gfx\Bild_Warnung Hindernis_90x90.png'.		].			(visualHint = 79) "VisHintFork"		ifTrue:[			modelData visHintFork: (visualHint \\ 10) asString.			pathToForm := 'gfx\Bild_Warnung Gabelung_90x90.png'.		].			(visualHint = 82) "VisHintSpeed - faster"		ifTrue:[			modelData visHintSpeed: (visualHint \\ 10) asString.			pathToForm := 'gfx\Bildo.bmp'.		].			(visualHint = 81) "VisHintSpeed - slower"		ifTrue:[			modelData visHintSpeed: (visualHint \\ 10) asString.			pathToForm := 'gfx\Bildu.bmp'.		].			(visualHint = 91) "VisHintDirection - left"		ifTrue:[			modelData visHintDirection: (visualHint \\ 10) asString.			pathToForm := 'gfx\Bildl.bmp'.		].			(visualHint = 92) "VisHintDirection - right"		ifTrue:[			modelData visHintDirection: (visualHint \\ 10) asString.			pathToForm := 'gfx\Bildr.bmp'.		].	].				"currently no hint is displayed and there is information to do so"	((timeStartShowing = 0) & (visualHint ~= 0)) 	ifTrue:[		operator visualHintForm: pathToForm.		timeStartShowing := Time millisecondClockValue .	]. "no connecting ifFalse!! because the following test on timeStartShowing can obviously changed in the ifTrue above"		(timeStartShowing = 0)	ifFalse:[		((Time millisecondClockValue - timeStartShowing) >= 1500) 		ifTrue:[timeStartShowing := 0.] "since showing the last hint, 1.5 seconds are gone by. its enough"		ifFalse:[operator showVisualHint.]. "timeStartShowing is ~= 0 - meaning that something should be shown"	].	modelData changed .! !Object subclass: #SAMControllerStep	instanceVariableNames: 'controllerObstacle controllerOperator controllerLog controllerInput modelData track trackingObject dynamicObstacleDistanceTickMeasurement dynamicObstacleDistanceTickCount speedMeasurement instructions controllerNetwork'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-SAM'!!SAMControllerStep methodsFor: 'as yet unclassified' stamp: 'CL 8/9/2009 18:41'!controllerNetwork: someController		controllerNetwork := someController .! !!SAMControllerStep methodsFor: 'as yet unclassified' stamp: 'nn 8/11/2009 20:27'!initialize	modelData := SAMModelData getInstance .	controllerOperator := SAMControllerOperator new.	controllerLog := SAMControllerLog new.	controllerInput := SAMControllerInput new.	controllerOperator := SAMControllerOperator new.		track := (SAMViewTrack new).	trackingObject := SAMViewTrackingObject new.		dynamicObstacleDistanceTickMeasurement := 0.0.	dynamicObstacleDistanceTickCount := 0.0.	speedMeasurement := false.		instructions := SAMViewInstructionStep new.! !!SAMControllerStep methodsFor: 'as yet unclassified' stamp: 'CL 9/22/2009 11:26'!processStep		| currentTimeStamp startTimeTick endTimeTick deltaTime |		(modelData network)	ifTrue:[		controllerNetwork sendStepConfigData: (modelData inputMwi1 ) asString;									sendTrackData: (modelData currentTrackFile) asString;									refineAndSendObstacleData.											(Delay forMilliseconds: 100) wait.		controllerNetwork sendStatusData: 'buildTrack'.				"Transcript cr; show: 'sending: --', (modelData currentTrackFile) asString, '--'."		].		instructions instructionShown: true.	instructions startAndEndInstructions .		self showInstructions: 'start'.		(modelData network)	ifTrue:[ controllerNetwork sendStatusData: 'waiting'. ].		controllerLog newExperimentStepFilename .	track buildTrack; showTrack .	track buildObstacles .	trackingObject buildTrackingObject; moveTrackingObject .				(modelData network)	ifTrue:[ controllerNetwork sendStatusData: 'countdown'. ].		(Monitor new) critical: [track showCountdown .].		currentTimeStamp := Time millisecondClockValue.	modelData totalStepDistance: 0.0;					logStartTime: currentTimeStamp;					timeLastStep: currentTimeStamp;					changed.		[modelData trackEnded]	whileFalse:	[		startTimeTick := Time millisecondClockValue .		(modelData network)		ifTrue:[controllerNetwork processNetwork.].				controllerInput processInputData .				track moveTrack. 		track moveObstacles .		trackingObject moveTrackingObject .		controllerOperator processVisualHints;									processAuditiveHints.		Display restore.				track processTrackEditMWI.			trackingObject processSensors.				(modelData collisionInTick) 		ifTrue:		[			controllerNetwork sendCollisionData: '1;'.			(Delay forMilliseconds: 1000) wait.			trackingObject penaltyForCollision.			track deleteObstacle. 		].			"done?"		modelData xCoordinateOnSection: ((modelData totalCalculatedXAxisForBlitter) negated);					yCoordinateOnSection: (modelData totalStepDistance + 100.0) ;					changed. 		track colorCode .				(modelData colorCode = 80.8)		ifTrue:[modelData trackEnded: true; changed. track deleteTrack.].				(modelData colorCode = 43.9)		ifTrue:["Transcript show: 'start measuring'; cr."speedMeasurement := true.].				((modelData colorCode = 1.0) | (modelData colorCode = 101.0) | (modelData colorCode2 = 1.0) | (modelData colorCode2 = 101.0))		ifTrue:[			((modelData colorCode = 1.0) | (modelData colorCode2 = 1.0))			ifTrue:[ modelData trackEditMWIFork: '2'. ]. "RL"			((modelData colorCode = 101.0) | (modelData colorCode2 = 101.0))			ifTrue:[ modelData trackEditMWIFork: '1'. ]. "ER"		]		ifFalse:[modelData trackEditMWIFork: '0'.].				(speedMeasurement)		ifTrue:		[			dynamicObstacleDistanceTickMeasurement := dynamicObstacleDistanceTickMeasurement + modelData calculatedYAxis .			dynamicObstacleDistanceTickCount := dynamicObstacleDistanceTickCount + 1.0.		].				((modelData colorCode = 66.8) & (dynamicObstacleDistanceTickCount > 0.0))		ifTrue:		[			speedMeasurement := false.			modelData dynamicObstacleDistanceTick: dynamicObstacleDistanceTickMeasurement / dynamicObstacleDistanceTickCount.			dynamicObstacleDistanceTickMeasurement := 0.0.			dynamicObstacleDistanceTickCount := 0.0.		].				(modelData network)		ifTrue:[controllerNetwork sendOPData.].				(modelData collisionInTick)		ifFalse:		[			endTimeTick := Time millisecondClockValue .			deltaTime := endTimeTick - startTimeTick .			(deltaTime < 39.0)			ifTrue:[(Delay forMilliseconds: (39.0 - deltaTime )) wait.].			"Transcript show: 'deltaTime (actual computing time!!): ', deltaTime asString; cr."		].				controllerLog processStepLogData.		controllerLog writeTickLog .				].	(modelData network)	ifTrue:[ controllerNetwork flushData; sendStatusData: 'waiting+'. ].	instructions instructionShown: true.	self showInstructions: 'end'.		instructions instructionShown: true.		controllerLog writeStepLogFile.		! !!SAMControllerStep methodsFor: 'as yet unclassified' stamp: 'nn 9/16/2009 16:00'!showInstructions: wassup	(wassup = 'start')	ifTrue:[instructions showStartInstruction .]	ifFalse:[instructions showEndInstruction .].		Sensor flushEvents .		[(Sensor redButtonPressed) & (Sensor mousePoint x between: 570 and: 625) & (Sensor mousePoint y between: 620 and: 645)]	whileFalse: 	[		"lalelu"	].		(Delay forMilliseconds: 500) wait.		(instructions instructionsEmpty: wassup)	ifFalse:[self showInstructions: wassup].	instructions hide.! !!SAMControllerStep methodsFor: 'accessing' stamp: 'nn 8/11/2009 20:29'!track	^track! !!SAMControllerStep methodsFor: 'accessing' stamp: 'nn 8/11/2009 20:29'!track: anObject	track := anObject! !Object subclass: #SAMModelData	instanceVariableNames: 'dummy stepFile tileNamesPerTrack trackGraphics logTags inputMwi1 maxSpeed denyLeft denyRight currentStep currentMwi currentTrackFile tickLog experimentFolderName experimentStepFilename stepTotalTime logStartTime timeDelta timeLastStep experimentType team mwi1 mwi2 assistance gender colorCode colorCode2 totalStepDistance calculatedYAxis joystick1XAxis joystick2XAxis joystick1YAxis joystick2YAxis noSensorsOffTrack yCoordinateTrackingObject trackEnded kindOfAssistance network calculatedXAxis collisionAtSensor collisionInTick speedometer totalCalculatedXAxisForBlitter trackHeight obstacleConfig dynamicObstacleDistanceTick startInstructions endInstructions trackEditMWIStaticObstacle trackEditMWIDynamicObstacle trackEditMWIFork dynamicObstacleXCoordinate dynamicObstacleYCoordinate secondStaticObstacleXCoordinate secondStaticObstacleYCoordinate firstStaticObstacleXCoordinate firstStaticObstacleYCoordinate xCoordinateOnSection yCoordinateOnSection visualHint visHintObstacle visHintFork visHintSpeed visHintDirection auditiveHint audHintSpeed audHintDirection audHintAccuracy audHintPower audHintAllocation directSetDirection directSetPowerMWI1 directSetPowerMWI2 directSetPowerReset directSetSpeed directSetSpeedReset blindClick trackEditOAStaticObstacle trackEditOADynamicObstacle trackEditOAFork'	classVariableNames: 'Current'	poolDictionaries: ''	category: 'ATEO-SAM'!!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 15:39'!assistance	^assistance! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 15:39'!assistance: anObject	assistance := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 20:23'!audHintAccuracy	^audHintAccuracy! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 20:23'!audHintAccuracy: anObject	audHintAccuracy := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 20:25'!audHintAllocation	^audHintAllocation! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 20:25'!audHintAllocation: anObject	audHintAllocation := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 20:23'!audHintDirection	^audHintDirection! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 20:23'!audHintDirection: anObject	audHintDirection := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 20:23'!audHintPower	^audHintPower! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 20:23'!audHintPower: anObject	audHintPower := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 20:23'!audHintSpeed	^audHintSpeed! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 20:23'!audHintSpeed: anObject	audHintSpeed := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 20:15'!auditiveHint	^auditiveHint! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 20:15'!auditiveHint: anObject	auditiveHint := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:21'!blindClick	^blindClick! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:21'!blindClick: anObject	blindClick := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:27'!calculatedXAxis	^calculatedXAxis! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:27'!calculatedXAxis: anObject	calculatedXAxis := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:07'!calculatedYAxis	^calculatedYAxis! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:07'!calculatedYAxis: anObject	calculatedYAxis := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:27'!collisionAtSensor	^collisionAtSensor! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:27'!collisionAtSensor: anObject	collisionAtSensor := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:27'!collisionInTick	^collisionInTick! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:27'!collisionInTick: anObject	collisionInTick := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:06'!colorCode	^colorCode! !!SAMModelData methodsFor: 'accessing' stamp: 'nn 9/16/2009 15:45'!colorCode2	^colorCode2! !!SAMModelData methodsFor: 'accessing' stamp: 'nn 9/16/2009 15:45'!colorCode2: anObject	colorCode2 := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:06'!colorCode: anObject	colorCode := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:49'!currentMwi	^currentMwi! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:49'!currentMwi: anObject	currentMwi := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:48'!currentStep	^currentStep! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:48'!currentStep: anObject	currentStep := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:50'!currentTrackFile	^currentTrackFile! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:50'!currentTrackFile: anObject	currentTrackFile := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:47'!denyLeft	^denyLeft! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:47'!denyLeft: anObject	denyLeft := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:47'!denyRight	^denyRight! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:47'!denyRight: anObject	denyRight := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:18'!directSetDirection	^directSetDirection! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:18'!directSetDirection: anObject	directSetDirection := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:18'!directSetPowerMWI1	^directSetPowerMWI1! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:18'!directSetPowerMWI1: anObject	directSetPowerMWI1 := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:18'!directSetPowerMWI2	^directSetPowerMWI2! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:18'!directSetPowerMWI2: anObject	directSetPowerMWI2 := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:18'!directSetPowerReset	^directSetPowerReset! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:18'!directSetPowerReset: anObject	directSetPowerReset := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:19'!directSetSpeed	^directSetSpeed! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:19'!directSetSpeed: anObject	directSetSpeed := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:19'!directSetSpeedReset	^directSetSpeedReset! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:19'!directSetSpeedReset: anObject	directSetSpeedReset := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:48'!dummy	^dummy! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:48'!dummy: anObject	dummy := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:51'!dynamicObstacleDistanceTick	^dynamicObstacleDistanceTick! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:51'!dynamicObstacleDistanceTick: anObject	dynamicObstacleDistanceTick := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 13:04'!dynamicObstacleXCoordinate	^dynamicObstacleXCoordinate! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 13:04'!dynamicObstacleXCoordinate: anObject	dynamicObstacleXCoordinate := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 13:04'!dynamicObstacleYCoordinate	^dynamicObstacleYCoordinate! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 13:04'!dynamicObstacleYCoordinate: anObject	dynamicObstacleYCoordinate := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/6/2009 16:56'!endInstructions	^endInstructions! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/6/2009 16:56'!endInstructions: anObject	endInstructions := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:54'!experimentFolderName	^experimentFolderName! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:54'!experimentFolderName: anObject	experimentFolderName := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:55'!experimentStepFilename	^experimentStepFilename! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:55'!experimentStepFilename: anObject	experimentStepFilename := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:01'!experimentType	^experimentType! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:01'!experimentType: anObject	experimentType := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 13:05'!firstStaticObstacleXCoordinate	^firstStaticObstacleXCoordinate! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 13:05'!firstStaticObstacleXCoordinate: anObject	firstStaticObstacleXCoordinate := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 13:05'!firstStaticObstacleYCoordinate	^firstStaticObstacleYCoordinate! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 13:05'!firstStaticObstacleYCoordinate: anObject	firstStaticObstacleYCoordinate := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:04'!gender	^gender! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:04'!gender: anObject	gender := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:54'!inputMwi1	^inputMwi1! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:31'!inputMwi1: anObject	inputMwi1 := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:08'!joystick1XAxis	^joystick1XAxis! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:08'!joystick1XAxis: anObject	joystick1XAxis := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:08'!joystick1YAxis	^joystick1YAxis! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:08'!joystick1YAxis: anObject	joystick1YAxis := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:08'!joystick2XAxis	^joystick2XAxis! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:08'!joystick2XAxis: anObject	joystick2XAxis := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:08'!joystick2YAxis	^joystick2YAxis! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:08'!joystick2YAxis: anObject	joystick2YAxis := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 15:47'!kindOfAssistance	^kindOfAssistance! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 15:47'!kindOfAssistance: anObject	kindOfAssistance := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:56'!logStartTime	^logStartTime! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:56'!logStartTime: anObject	logStartTime := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:26'!logTags	^logTags! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:26'!logTags: anObject	logTags := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:44'!maxSpeed	^maxSpeed! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:44'!maxSpeed: anObject	maxSpeed := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:02'!mwi1	^mwi1! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:02'!mwi1: anObject	mwi1 := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:02'!mwi2	^mwi2! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:02'!mwi2: anObject	mwi2 := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:27'!network	^network! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:27'!network: anObject	network := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:10'!noSensorsOffTrack	^noSensorsOffTrack! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:10'!noSensorsOffTrack: anObject	noSensorsOffTrack := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/6/2009 13:27'!obstacleConfig	^obstacleConfig! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/6/2009 13:27'!obstacleConfig: anObject	obstacleConfig := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 13:05'!secondStaticObstacleXCoordinate	^secondStaticObstacleXCoordinate! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 13:05'!secondStaticObstacleXCoordinate: anObject	secondStaticObstacleXCoordinate := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 13:05'!secondStaticObstacleYCoordinate	^secondStaticObstacleYCoordinate! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 13:05'!secondStaticObstacleYCoordinate: anObject	secondStaticObstacleYCoordinate := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 14:39'!speedometer	^speedometer! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 14:39'!speedometer: anObject	speedometer := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/6/2009 16:56'!startInstructions	^startInstructions! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/6/2009 16:56'!startInstructions: anObject	startInstructions := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:08'!stepFile	^stepFile! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:08'!stepFile: anObject	stepFile := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:56'!stepTotalTime	^stepTotalTime! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:56'!stepTotalTime: anObject	stepTotalTime := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:02'!team	^team! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:02'!team: anObject	team := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:51'!tickLog	^tickLog! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:51'!tickLog: anObject	tickLog := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:12'!tileNamesPerTrack	^tileNamesPerTrack! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:12'!tileNamesPerTrack: anObject	tileNamesPerTrack := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:57'!timeDelta	^timeDelta! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:57'!timeDelta: anObject	timeDelta := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:58'!timeLastStep	^timeLastStep! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:58'!timeLastStep: anObject	timeLastStep := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/5/2009 14:07'!totalCalculatedXAxisForBlitter	^totalCalculatedXAxisForBlitter! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/5/2009 14:07'!totalCalculatedXAxisForBlitter: anObject	totalCalculatedXAxisForBlitter := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:07'!totalStepDistance	^totalStepDistance! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:07'!totalStepDistance: anObject	totalStepDistance := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 12:23'!trackEditMWIDynamicObstacle	^trackEditMWIDynamicObstacle! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 12:23'!trackEditMWIDynamicObstacle: anObject	trackEditMWIDynamicObstacle := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 12:23'!trackEditMWIFork	^trackEditMWIFork! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 12:23'!trackEditMWIFork: anObject	trackEditMWIFork := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 12:23'!trackEditMWIStaticObstacle	^trackEditMWIStaticObstacle! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 12:23'!trackEditMWIStaticObstacle: anObject	trackEditMWIStaticObstacle := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:39'!trackEditOADynamicObstacle	^trackEditOADynamicObstacle! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:39'!trackEditOADynamicObstacle: anObject	trackEditOADynamicObstacle := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:39'!trackEditOAFork	^trackEditOAFork! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:40'!trackEditOAFork: anObject	trackEditOAFork := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:39'!trackEditOAStaticObstacle	^trackEditOAStaticObstacle! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 22:39'!trackEditOAStaticObstacle: anObject	trackEditOAStaticObstacle := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:23'!trackEnded	^trackEnded! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:23'!trackEnded: anObject	trackEnded := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:25'!trackGraphics	^trackGraphics! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 10:25'!trackGraphics: anObject	trackGraphics := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/6/2009 10:15'!trackHeight	^trackHeight! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/6/2009 10:15'!trackHeight: anObject	trackHeight := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 19:14'!visHintDirection	^visHintDirection! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 19:14'!visHintDirection: anObject	visHintDirection := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 19:14'!visHintFork	^visHintFork! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 19:14'!visHintFork: anObject	visHintFork := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 19:14'!visHintObstacle	^visHintObstacle! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 19:14'!visHintObstacle: anObject	visHintObstacle := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 19:14'!visHintSpeed	^visHintSpeed! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 19:14'!visHintSpeed: anObject	visHintSpeed := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 16:45'!visualHint	^visualHint! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 16:45'!visualHint: anObject	visualHint := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 15:58'!xCoordinateOnSection	^xCoordinateOnSection! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 15:58'!xCoordinateOnSection: anObject	xCoordinateOnSection := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 16:01'!yCoordinateOnSection	^yCoordinateOnSection! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/8/2009 16:01'!yCoordinateOnSection: anObject	yCoordinateOnSection := anObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:15'!yCoordinateTrackingObject	^yCoordinateTrackingObject! !!SAMModelData methodsFor: 'accessing' stamp: 'CL 8/4/2009 11:15'!yCoordinateTrackingObject: anObject	yCoordinateTrackingObject := anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SAMModelData class	instanceVariableNames: ''!!SAMModelData class methodsFor: 'singleton' stamp: 'CL 8/4/2009 09:55'!getInstance	(Current isNil) 	ifTrue: [Current := self basicNew initialize]. 		^Current! !!SAMModelData class methodsFor: 'singleton' stamp: 'CL 8/4/2009 10:23'!new ^self error: 'Class ', self name, ' cannot create new instances. Try ', self name, ' current'.! !!SAMModelData class methodsFor: 'singleton' stamp: 'CL 8/4/2009 10:00'!reset	Current := nil.! !AlignmentMorph subclass: #SAMViewGuiConfig	instanceVariableNames: 'buttonSize label switchButtonSize seperationBar labelContainer team vpMWB1 vpMWB2 male female experimentType gender network networkButton modelData assistance humanAssistance machineAssistance kindOfAssistance controllerNetwork controllerExperiment'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-SAM'!!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 7/18/2009 14:33'!actionSelectorGenderF	female borderColor: #inset; color: Color veryVeryLightGray.	male borderColor: #raised; color: (self groupColor).		gender := 'female'.! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 7/18/2009 14:33'!actionSelectorGenderM	male borderColor: #inset; color: Color veryVeryLightGray.	female borderColor: #raised; color: (self groupColor).		gender := 'male'.! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 8/8/2009 15:47'!actionSelectorHumanAssistance	humanAssistance borderColor: #inset; color: Color veryVeryLightGray.	machineAssistance borderColor: #raised; color: (self groupColor).		kindOfAssistance := 'Operateur'.! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 8/8/2009 15:47'!actionSelectorMachineAssistance	humanAssistance borderColor: #raised; color: (self groupColor).	machineAssistance borderColor: #inset; color: Color veryVeryLightGray.		kindOfAssistance := 'Automatik'.! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 7/27/2009 14:01'!actionSelectorMinusExperimentType	((experimentType contents asInteger) > 1)	ifTrue:[experimentType contents: (((experimentType contents asInteger) - 1) asString).].! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 8/8/2009 15:29'!actionSelectorMinusOperator	((assistance contents asInteger) > 1)	ifTrue:[assistance contents: (((assistance contents asInteger) - 1) asString).].! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 7/18/2009 12:54'!actionSelectorMinusTeam	((team contents asInteger) > 1)	ifTrue:[team contents: (((team contents asInteger) - 1) asString).].! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 7/18/2009 12:57'!actionSelectorMinusVpMWB1	((vpMWB1 contents asInteger) > 1)	ifTrue:[vpMWB1 contents: (((vpMWB1 contents asInteger) - 1) asString).].! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 7/18/2009 12:57'!actionSelectorMinusVpMWB2	((vpMWB2 contents asInteger) > 1)	ifTrue:[vpMWB2 contents: (((vpMWB2 contents asInteger) - 1) asString).].! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'nn 8/10/2009 17:20'!actionSelectorNetwork: bool	network := bool.		(bool)	ifTrue:[controllerNetwork createSockets.]	ifFalse:[controllerNetwork closeSockets.].! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 7/27/2009 14:00'!actionSelectorPlusExperimentType	experimentType contents: (((experimentType contents asInteger) + 1) asString).! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 8/8/2009 15:29'!actionSelectorPlusOperator	assistance contents: (((assistance contents asInteger) + 1) asString).! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 7/18/2009 12:54'!actionSelectorPlusTeam	team contents: (((team contents asInteger) + 1) asString).! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 7/18/2009 12:58'!actionSelectorPlusVpMWB1	vpMWB1 contents: (((vpMWB1 contents asInteger) + 1) asString).! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 7/18/2009 12:58'!actionSelectorPlusVpMWB2	vpMWB2 contents: (((vpMWB2 contents asInteger) + 1) asString).! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'nn 8/26/2009 09:34'!actionSelectorStartExperiment	controllerExperiment := (SAMControllerExperiment new).	modelData assistance: (assistance contents asInteger); 			team: (team contents asInteger);			mwi1: (vpMWB1 contents asInteger);			mwi2: (vpMWB2 contents asInteger);			gender:  gender;			kindOfAssistance: kindOfAssistance;			network: network;			experimentType: (experimentType contents asInteger);			changed .				self hide.		 controllerExperiment controllerNetwork: controllerNetwork;										showInitialInstruction.		! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 4/22/2009 11:39'!buttonSize	^buttonSize! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 7/18/2009 12:59'!createAlignmentMorph: thisExtent	^AlignmentMorph new		color: Color transparent ;			listDirection: #leftToRight;		borderColor: Color blue;		borderWidth: 0;		wrapCentering: #center;		extent: thisExtent ;		vResizing: #rigid;		hResizing: #rigid;		layoutInset: 0;		useRoundedCorners .! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'nn 9/16/2009 11:09'!createGuiElements	| assistanceContainer groupContainer teamContainer vpMWB1Container vpMWB2Container genderContainer inputContainer networkContainer startContainer |	"Operator"	assistance := self createStringMorph: '1'.		assistanceContainer := (self createAlignmentMorph: 300@50) 									addMorphBack: (self createSimpleButton: '-' withActionSelector: #actionSelectorMinusOperator);									addMorphBack: (self createAlignmentMorph: 10@5);									addMorphBack: ((self createAlignmentMorph: 20@30) listCentering: #center; addMorphBack: assistance);									addMorphBack: (self createAlignmentMorph: 10@5);									addMorphBack: (self createSimpleButton: '+' withActionSelector: #actionSelectorPlusOperator);									addMorphBack: (self createAlignmentMorph: 10@5);									addMorphBack: (self createStringMorph: 'Nummer Assistenz').										"Versuchsbedingung"	experimentType := self createStringMorph: '1'.		groupContainer := (self createAlignmentMorph: 300@50) 									addMorphBack: (self createSimpleButton: '-' withActionSelector: #actionSelectorMinusExperimentType);									addMorphBack: (self createAlignmentMorph: 10@5);									addMorphBack: ((self createAlignmentMorph: 20@30) listCentering: #center; addMorphBack: experimentType);									addMorphBack: (self createAlignmentMorph: 10@5);									addMorphBack: (self createSimpleButton: '+' withActionSelector: #actionSelectorPlusExperimentType);									addMorphBack: (self createAlignmentMorph: 10@5);									addMorphBack: (self createStringMorph: 'Versuchsbedingung').																				"Teamnummer"	team := self createStringMorph: '1'.		teamContainer := (self createAlignmentMorph: 300@50) 									addMorphBack: (self createSimpleButton: '-' withActionSelector: #actionSelectorMinusTeam);									addMorphBack: (self createAlignmentMorph: 10@5);									addMorphBack: ((self createAlignmentMorph: 20@30) listCentering: #center; addMorphBack: team);									addMorphBack: (self createAlignmentMorph: 10@5);									addMorphBack: (self createSimpleButton: '+' withActionSelector: #actionSelectorPlusTeam);									addMorphBack: (self createAlignmentMorph: 10@5);									addMorphBack: (self createStringMorph: 'Nummer Team').										"vpMWB1"	vpMWB1 := self createStringMorph: '1'.		vpMWB1Container := (self createAlignmentMorph: 300@50) 									addMorphBack: (self createSimpleButton: '-' withActionSelector: #actionSelectorMinusVpMWB1);									addMorphBack: (self createAlignmentMorph: 10@5);									addMorphBack: ((self createAlignmentMorph: 20@30) listCentering: #center; addMorphBack: vpMWB1);									addMorphBack: (self createAlignmentMorph: 10@5);									addMorphBack: (self createSimpleButton: '+' withActionSelector: #actionSelectorPlusVpMWB1);									addMorphBack: (self createAlignmentMorph: 10@5);									addMorphBack: (self createStringMorph: 'Nummer MWB1').												"vpMWB2"	vpMWB2 := self createStringMorph: '1'.		vpMWB2Container := (self createAlignmentMorph: 300@50) 									addMorphBack: (self createSimpleButton: '-' withActionSelector: #actionSelectorMinusVpMWB2);									addMorphBack: (self createAlignmentMorph: 10@5);									addMorphBack: ((self createAlignmentMorph: 20@30) listCentering: #center; addMorphBack: vpMWB2);									addMorphBack: (self createAlignmentMorph: 10@5);									addMorphBack: (self createSimpleButton: '+' withActionSelector: #actionSelectorPlusVpMWB2);									addMorphBack: (self createAlignmentMorph: 10@5);									addMorphBack: (self createStringMorph: 'Nummer MWB2').																					"Geschlecht"		male := (self createSimpleButton: 'Männlich' withActionSelector: #actionSelectorGenderM) borderColor: #inset; color: Color veryVeryLightGray; extent: 100@35.	female := (self createSimpleButton: 'Weiblich' withActionSelector: #actionSelectorGenderF) extent: 100@35.		genderContainer := (self createAlignmentMorph: 300@50)									addMorphBack: male;									addMorphBack: female;									addMorphBack: (self createAlignmentMorph: 10@5);									addMorphBack: (self createStringMorph: 'Geschlecht').																"Eingabe"																															humanAssistance := (self createSimpleButton: 'Operateur' withActionSelector: #actionSelectorHumanAssistance) borderColor: #inset; color: Color veryVeryLightGray; extent: 100@35.	machineAssistance := (self createSimpleButton: 'Automatik' withActionSelector: #actionSelectorMachineAssistance) extent: 100@35.		inputContainer := (self createAlignmentMorph: 300@50)									addMorphBack: humanAssistance;									addMorphBack: machineAssistance;									addMorphBack: (self createAlignmentMorph: 10@5);									addMorphBack: (self createStringMorph: 'Assistenz').														"Netzwerk"	networkButton := (self createSwitchButton: 'Netzwerk' withActionSelector: #actionSelectorNetwork:).												networkContainer := (self createAlignmentMorph: 300@50)									addMorphBack: networkButton.										"Versuch starten"	startContainer := (self createAlignmentMorph: 300@70) addMorphBack: ((self createSimpleButton: 'Versuch starten' withActionSelector: #actionSelectorStartExperiment) extent: 300@35).													self 	addMorphBack: groupContainer;			addMorphBack: teamContainer;			addMorphBack: vpMWB1Container;			addMorphBack: vpMWB2Container;			addMorphBack: assistanceContainer;			addMorphBack: inputContainer;			addMorphBack: genderContainer;			addMorphBack: networkContainer;			addMorphBack: startContainer;			setWindwoSize: 400@550.! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 7/18/2009 12:24'!createIconicButton: aFile withActionSelector: aSelector 	^IconicButton new		target: self;		labelGraphic: ((Form fromFileNamed: aFile) replaceColor: Color white withColor: Color transparent );		actionSelector: aSelector;		borderColor: #raised;		borderWidth: 4;		extent: 100@100;		"recolor: Color veryVeryLightGray;"		color: (self groupColor );		useRoundedCorners .! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 7/18/2009 12:40'!createSimpleButton: buttonLabel withActionSelector: foo 	"in buttonBag all the created buttons are stored for later manipulation"	^SimpleButtonMorph new				color: (self groupColor);				borderColor: #raised;				borderWidth: 2;				label: buttonLabel;				extent: 25@25;				target: self;				actionSelector: foo.! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 5/29/2009 16:38'!createStringMorph: buttonLabel ^(StringMorph new) contents: buttonLabel; fontName: #BitstreamVeraSans size: 16.! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 7/18/2009 13:30'!createSwitchButton: buttonLabel withActionSelector: foo 	^SimpleSwitchMorph new				onColor: (Color green mixed: 0.5 with: Color white);				offColor: (Color red mixed: 0.5 with: Color white);				color: (Color green mixed: 0.5 with: Color white);				borderColor: #inset;				borderWidth: 2;				label: buttonLabel;				extent: 100@35;				target: self;				setSwitchState: false;				actionSelector: foo.! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 5/27/2009 16:27'!groupColor	^(Color gray mixed: 0.14 with: Color white)! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 8/20/2009 13:41'!initialize	| sepaerationBarContainer |	super initialize.		SmalltalkImage current vmParameterAt: 5 put: 400000.	SmalltalkImage current vmParameterAt: 6 put: 12000.		SAMModelData reset.	modelData:= SAMModelData getInstance .	controllerNetwork := SAMControllerNetwork new.			gender := 'male'.	kindOfAssistance := 'Operateur'.	network := false.	self		color: Color veryVeryLightGray;		height:190;		width: 350;		borderWidth: 2;		layoutInset: 0;		listDirection: #topToBottom;		wrapCentering: #center;		cellPositioning: #topCenter;		cornerStyle: #rounded;		position: 80 @ 50.	labelContainer := (AlignmentMorph new)				listDirection: #topToBottom;				height: 40;				width: self width - (self borderWidth * 2);				borderWidth: 0;				cellPositioning: #center;				listCentering: #center;				wrapCentering: #center;				vResizing: #rigid;				hResizing: #rigid;				borderColor: Color yellow;				color: Color transparent;				layoutInset: 0.	label := (StringMorph new)				contents: 'SAM Konfiguration';				fontName: #BitstreamVeraSans size: 32.	sepaerationBarContainer := (AlignmentMorph new)				listDirection: #topToBottom;				height: 20;				width: self width - (self borderWidth * 2);				borderWidth: 0;				cellPositioning: #top;				listCentering: #center;				wrapCentering: #center;				vResizing: #rigid;				hResizing: #rigid;				borderColor: Color yellow;				color: Color transparent;				layoutInset: 0.		seperationBar := RectangleMorph new color: Color black; extent: self width - (self borderWidth * 2)@2; borderWidth: 0; borderColor: Color blue .	sepaerationBarContainer addMorphBack: seperationBar.		self addMorphBack: (labelContainer addMorphBack: label); 			addMorphBack: sepaerationBarContainer;			createGuiElements;			openInWorld.						! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 4/22/2009 11:40'!label: foo 	label contents: foo! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 5/28/2009 16:24'!setWindwoSize: newSize	self extent: newSize.	seperationBar extent: self width - (self borderWidth * 2)@2.	labelContainer width: self width - (self borderWidth * 2).! !!SAMViewGuiConfig methodsFor: 'as yet unclassified' stamp: 'CL 4/22/2009 13:00'!switchButtonSize	^switchButtonSize! !!SAMViewGuiConfig methodsFor: 'accessing' stamp: 'nn 8/10/2009 17:21'!controllerNetwork	^controllerNetwork! !!SAMViewGuiConfig methodsFor: 'accessing' stamp: 'nn 8/10/2009 17:21'!controllerNetwork: anObject	controllerNetwork := anObject! !RectangleMorph subclass: #SAMViewInstructionInitial	instanceVariableNames: 'controller'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-SAM'!!SAMViewInstructionInitial methodsFor: 'as yet unclassified' stamp: 'CL 8/7/2009 15:24'!actionSelectorInitialInstruction	controller processExperiment.	! !!SAMViewInstructionInitial methodsFor: 'as yet unclassified' stamp: 'CL 8/7/2009 15:22'!initialize	super initialize.			self color: Color white;			borderColor: Color white;			borderWidth: 40;			position: 75 @ 50;			extent: 600 @ 600;			addMorph: ((IconicButton new)									target: self;									labelGraphic: (Form fromFileNamed: 'gfx\Teaminstruktion1.png');									actionSelector: #actionSelectorInitialInstruction;									borderColor: #raised;									borderWidth: 5;									extent: 130 @ 100;									recolor: Color lightGray;									position: 145 @ 125);					addMorph: ((IconicButton new)									target: self;									labelGraphic: (Form fromFileNamed: 'gfx\Teaminstruktion2.png');									actionSelector: #actionSelectorInitialInstruction;									borderColor: #raised;									borderWidth: 5;									extent: 130 @ 100;									recolor: Color lightGray;									position: 450 @ 125);					addMorph: ((IconicButton new)									target: self;									labelGraphic: (Form fromFileNamed: 'gfx\Teaminstruktion3.png');									actionSelector: #actionSelectorInitialInstruction;									borderColor: #raised;									borderWidth: 5;									extent: 130 @ 100;									recolor: Color lightGray;									position: 300 @ 300);					addMorph: ((IconicButton new)									target: self;									labelGraphic: (Form fromFileNamed: 'gfx\Teaminstruktion4.png');									actionSelector: #actionSelectorInitialInstruction;									borderColor: #raised;									borderWidth: 5;									extent: 130 @ 100;									recolor: Color lightGray;									position: 145 @ 475);					addMorph: ((IconicButton new)									target: self;									labelGraphic: (Form fromFileNamed: 'gfx\Teaminstruktion5.png');									actionSelector: #actionSelectorInitialInstruction;									borderColor: #raised;									borderWidth: 5;									extent: 130 @ 100;									recolor: Color lightGray;									position: 450 @ 475);				openInWorld;				hide.! !!SAMViewInstructionInitial methodsFor: 'accessing' stamp: 'CL 8/7/2009 15:17'!controller	^controller! !!SAMViewInstructionInitial methodsFor: 'accessing' stamp: 'CL 8/7/2009 15:17'!controller: anObject	controller := anObject! !RectangleMorph subclass: #SAMViewInstructionStep	instanceVariableNames: 'modelData startInstructions endInstructions instructionShown'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-SAM'!!SAMViewInstructionStep methodsFor: 'as yet unclassified' stamp: 'CL 8/9/2009 20:26'!initialize	super initialize.			self color: Color white;			borderColor: Color white;			borderWidth: 40;			position: 75 @ 50;			extent: 600 @ 600;			openInWorld;			hide.				modelData := SAMModelData getInstance .	instructionShown := true.! !!SAMViewInstructionStep methodsFor: 'as yet unclassified' stamp: 'CL 8/7/2009 16:16'!instructionsEmpty: mode	(mode = 'start')	ifTrue:[^(startInstructions isEmpty).]	ifFalse:[^(endInstructions isEmpty).].! !!SAMViewInstructionStep methodsFor: 'as yet unclassified' stamp: 'CL 8/7/2009 16:15'!showEndInstruction	self stepInstruction: endInstructions .! !!SAMViewInstructionStep methodsFor: 'as yet unclassified' stamp: 'CL 8/7/2009 16:39'!showStartInstruction	self stepInstruction: startInstructions .! !!SAMViewInstructionStep methodsFor: 'as yet unclassified' stamp: 'CL 8/9/2009 20:26'!startAndEndInstructions	startInstructions := (modelData startInstructions) at: (modelData currentStep).	endInstructions := (modelData endInstructions) at: (modelData currentStep).! !!SAMViewInstructionStep methodsFor: 'as yet unclassified' stamp: 'CL 8/21/2009 15:45'!stepInstruction: instructions	| drKnalltuete drKnalltuetenContainer |		"(instructionShown) 	ifTrue:	["		self submorphs do: [:sub | sub delete.].			self addMorph: ((PluggableTextMorph new)							setText: (instructions first) withCRs ;							font: (StrikeFont familyName: 'Accujen' size: 18 emphasized: 1);							position: (self position + (30 @ 30));							extent: ((self width - 30) @ self height - 60);							borderColor: Color transparent						);			addMorph: ((SimpleButtonMorph new)						label: 'Weiter';						color: Color green;						target: self;						actionSelector: #actionSelectorStepInstruction;						extent: 55@25;						position: 570 @ 620).				(((modelData currentStep) asInteger = 2) & ((instructions first) asString = 'Ihr Team waehlte folgende Instruktion:'))		ifTrue: 		[			"Transcript show: 'if 1';cr."			drKnalltuete := (ImageMorph new 						image: (Form fromFileNamed: 'gfx\Schnelligkeitsinstruktion.png')).			drKnalltuetenContainer := (AlignmentMorph inAColumn: {drKnalltuete})				extent: 220 @ 160;				position: 270 @ 260;				color: Color lightGray;				borderWidth: 0.			self addMorph: drKnalltuetenContainer.		].			(((modelData currentStep) asInteger = 4)  & ((instructions first) asString = 'Ihr Team waehlte folgende Instruktion:'))		ifTrue: 			[				drKnalltuete := (ImageMorph new 						image: (Form fromFileNamed: 'gfx\Genauigkeitsinstruktion.png')).			drKnalltuetenContainer := (AlignmentMorph inAColumn: {drKnalltuete})				extent: 220 @ 160;				position: 270 @ 260;				color: Color lightGray;				borderWidth: 0.			self addMorph: drKnalltuetenContainer.			].		instructions removeFirst.			self show; refreshWorld.		"instructionShown := false.	]	ifFalse:	[instructionShown := true.]."! !!SAMViewInstructionStep methodsFor: 'accessing' stamp: 'CL 8/7/2009 17:29'!instructionShown	^instructionShown! !!SAMViewInstructionStep methodsFor: 'accessing' stamp: 'CL 8/7/2009 17:29'!instructionShown: anObject	instructionShown := anObject! !BitBlt subclass: #SAMViewObstacle	instanceVariableNames: 'kindOfObstacle orderOfObstacle x y'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-SAM'!!SAMViewObstacle methodsFor: 'accessing' stamp: 'CL 8/6/2009 14:02'!initializeObstacle	^ self class destForm: Display			            sourceForm: ((Form fromFileNamed: 'gfx\obstacle.gif') replaceColor: Color white with: Color transparent)		               halftoneForm: nil	 	       	      combinationRule: Form blend	  	    		      destOrigin: 0@0	   	            sourceOrigin: 0@0	    		         extent: 800@768 	      	   		clipRect: Display computeBoundingBox! !!SAMViewObstacle methodsFor: 'accessing' stamp: 'CL 7/27/2009 15:05'!kindOfObstacle	^kindOfObstacle.! !!SAMViewObstacle methodsFor: 'accessing' stamp: 'CL 7/27/2009 15:06'!kindOfObstacle: wassup	kindOfObstacle := wassup.! !!SAMViewObstacle methodsFor: 'accessing' stamp: 'CL 7/27/2009 15:07'!orderOfObstacle	^orderOfObstacle.! !!SAMViewObstacle methodsFor: 'accessing' stamp: 'CL 8/4/2009 15:59'!orderOfObstacle: order	orderOfObstacle := order! !!SAMViewObstacle methodsFor: 'accessing' stamp: 'CL 8/4/2009 15:49'!x	^x! !!SAMViewObstacle methodsFor: 'accessing' stamp: 'CL 8/4/2009 15:49'!x: anObject	x := anObject! !!SAMViewObstacle methodsFor: 'accessing' stamp: 'CL 8/4/2009 15:49'!y	^y! !!SAMViewObstacle methodsFor: 'accessing' stamp: 'CL 8/4/2009 15:49'!y: anObject	y := anObject! !Object subclass: #SAMViewOperator	instanceVariableNames: 'leftVisualHint rightVisualHint modelData currentSound soundArray'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-SAM'!!SAMViewOperator methodsFor: 'as yet unclassified' stamp: 'CL 8/8/2009 20:34'!balanceLeft: shareLeft right: shareRight	<primitive: 'primitiveSoundSetLeftVolume' module: 'SoundPlugin'>! !!SAMViewOperator methodsFor: 'as yet unclassified' stamp: 'nn 8/31/2009 10:43'!initialize	super initialize .		modelData := SAMModelData getInstance .		currentSound := StreamingMP3Sound new.		soundArray := Array new: 8.		soundArray at: 1 put: (StreamingMP3Sound onFileNamed: 'audio\langsamer fahren.mp3');					at: 2 put: (StreamingMP3Sound onFileNamed: 'audio\schneller fahren.mp3');					at: 3 put: (StreamingMP3Sound onFileNamed: 'audio\links fahren.mp3');					at: 4 put: (StreamingMP3Sound onFileNamed: 'audio\rechts fahren.mp3');					at: 5 put: (StreamingMP3Sound onFileNamed: 'audio\kurven abkuerzen.mp3');					at: 6 put: (StreamingMP3Sound onFileNamed: 'audio\kurven genauer fahren.mp3');					at: 7 put: (StreamingMP3Sound onFileNamed: 'audio\fuehrung ueberlassen.mp3');					at: 8 put: (StreamingMP3Sound onFileNamed: 'audio\fuehrung uebernehmen.mp3').		leftVisualHint := (BitBlt destForm: Display		            sourceForm: nil	               halftoneForm: nil	               combinationRule: Form blend	               destOrigin: 0@0	               sourceOrigin: 0@0	               extent: 800@768 	               clipRect: Display computeBoundingBox).		rightVisualHint := (BitBlt destForm: Display		            sourceForm: nil	               halftoneForm: nil	               combinationRule: Form blend	               destOrigin: 0@0	               sourceOrigin: 0@0	               extent: 800@768 	               clipRect: Display computeBoundingBox).! !!SAMViewOperator methodsFor: 'as yet unclassified' stamp: 'nn 9/16/2009 13:29'!playAuditiveHints: index withBalance: audHintAllocation.	((currentSound samplesRemaining) > 0)	ifFalse:[		(audHintAllocation = 1)		ifTrue:[self balanceLeft: 1.0 right: 0.0.].				(audHintAllocation = 2)		ifTrue:[self balanceLeft: 0.0 right: 1.0.].				(audHintAllocation = 3)		ifTrue:[self balanceLeft: 1.0 right: 1.0.].				currentSound := soundArray at: index.		currentSound play .	].! !!SAMViewOperator methodsFor: 'as yet unclassified' stamp: 'CL 8/8/2009 19:47'!showVisualHint	leftVisualHint sourceOrigin: -50 @ -314.	leftVisualHint copyBits.		rightVisualHint sourceOrigin: -660 @ -314.	rightVisualHint copyBits.! !!SAMViewOperator methodsFor: 'as yet unclassified' stamp: 'CL 8/8/2009 20:01'!visualHintForm: pathToForm	leftVisualHint sourceForm: (Form fromFileNamed: pathToForm).	rightVisualHint sourceForm: (Form fromFileNamed: pathToForm).! !Object subclass: #SAMViewTrack	instanceVariableNames: 'track modelData obstacles controllerNetwork'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-SAM'!!SAMViewTrack methodsFor: 'as yet unclassified' stamp: 'nn 9/11/2009 18:49'!buildObstacles	| obstacleAsOrderedCollection trackHeight |	"this returns an orderedCollection, which holds a number of arrays (fixed size 2: 1:kind of obstacle; 2: y coordinate) - each representing an obstacle"	obstacleAsOrderedCollection := (modelData obstacleConfig) at: (modelData currentStep) .	trackHeight := modelData trackHeight .		obstacleAsOrderedCollection do: 	[		:arrayWithLengthTwo |				((arrayWithLengthTwo at: 1) = 1110)		ifTrue:		[			obstacles add: (((SAMViewObstacle new) initializeObstacle)									kindOfObstacle: '1';									x: -418;									y: trackHeight - (arrayWithLengthTwo at: 2) - 131; 									orderOfObstacle: 2);							add: (((SAMViewObstacle new) initializeObstacle)									kindOfObstacle: '1';									x: -328;									y: trackHeight - (arrayWithLengthTwo at: 2) - 406;									orderOfObstacle: 1).		].			((arrayWithLengthTwo at: 1) = 1111)		ifTrue:		[			obstacles add: (((SAMViewObstacle new) initializeObstacle)									kindOfObstacle: '2';									x: -405;									y: trackHeight - (arrayWithLengthTwo at: 2) - 131; 									orderOfObstacle: 2);							add: (((SAMViewObstacle new) initializeObstacle)									kindOfObstacle: '2';									x: -342;									y: trackHeight - (arrayWithLengthTwo at: 2) - 406;									orderOfObstacle: 1).		].			((arrayWithLengthTwo at: 1) = 111)		ifTrue:		[			obstacles add: (((SAMViewObstacle new) initializeObstacle)									kindOfObstacle: 'dynamic';									x: 0;									y: trackHeight - (arrayWithLengthTwo at: 2) - 930; 									orderOfObstacle: 1)		].	].		! !!SAMViewTrack methodsFor: 'as yet unclassified' stamp: 'HM 10/4/2009 19:21'!buildTrack		| trackBMP |		"trackBMP := Form fromBMPFileNamed: 'gfx\bmp\tracks\testTrack_Qx.bmp'."	trackBMP := Form fromBMPFileNamed: (SAMConfig  tracksPath), (modelData currentTrackFile) asString, '.bmp'.		modelData trackHeight: ((trackBMP height) - 768). "- 800 accounts for the offset caused by the shift into the visible area (coord (0,0) is the upp left point of the screen)"		track := (BitBlt destForm: Display 	                 sourceForm: trackBMP	                 halftoneForm: nil	                 combinationRule: Form over	                 destOrigin: 0@0	                 sourceOrigin: 0@0	                 extent: 800@768 	                 clipRect: Display computeBoundingBox).! !!SAMViewTrack methodsFor: 'as yet unclassified' stamp: 'nn 9/16/2009 15:46'!colorCode	modelData colorCode: (((Display colorAt: 3 @ modelData yCoordinateTrackingObject) red * 2550.0) rounded / 10.0);				colorCode2: (((Display colorAt: 3 @ 1) red * 2550.0) rounded / 10.0);				changed.! !!SAMViewTrack methodsFor: 'as yet unclassified' stamp: 'CL 8/4/2009 11:22'!delete	track := nil.! !!SAMViewTrack methodsFor: 'as yet unclassified' stamp: 'CL 8/5/2009 16:02'!deleteObstacle	obstacles do:	[		:obstacle |		(((obstacle y + modelData yCoordinateTrackingObject) < ((modelData totalStepDistance) + 30)) & ((obstacle y + modelData yCoordinateTrackingObject) > ((modelData totalStepDistance) - 30)))		ifTrue:[obstacles remove: obstacle.].	].! !!SAMViewTrack methodsFor: 'as yet unclassified' stamp: 'CL 8/21/2009 11:07'!deleteTrack	track := nil.! !!SAMViewTrack methodsFor: 'as yet unclassified' stamp: 'CL 8/5/2009 15:11'!initialize	modelData := SAMModelData getInstance .	modelData trackEnded: false.	obstacles := OrderedCollection new.						! !!SAMViewTrack methodsFor: 'as yet unclassified' stamp: 'CL 8/19/2009 11:18'!moveObstacles	obstacles do:	[		:obstacle |		((modelData totalStepDistance - obstacle y) > 800.0)		ifTrue: [			obstacles remove: obstacle.			]		ifFalse:[			(obstacle kindOfObstacle = 'dynamic') & ((modelData totalStepDistance - obstacle y) > 0)			ifTrue:[				obstacle x: obstacle x - modelData dynamicObstacleDistanceTick.								(modelData network)				ifTrue:[controllerNetwork sendDynamicObstacleData: ((obstacle x) abs) asString.].				].			obstacle sourceOrigin: (obstacle x @ (obstacle y - modelData totalStepDistance)).			obstacle copyBits.		].	].! !!SAMViewTrack methodsFor: 'as yet unclassified' stamp: 'CL 8/6/2009 10:14'!moveTrack		track sourceOrigin: (0 @ (modelData trackHeight - modelData totalStepDistance )).	track copyBits.! !!SAMViewTrack methodsFor: 'as yet unclassified' stamp: 'nn 9/11/2009 18:53'!processTrackEditMWI	modelData trackEditMWIStaticObstacle: '0'.	modelData firstStaticObstacleXCoordinate: '0'.	modelData firstStaticObstacleYCoordinate: '0'.	modelData secondStaticObstacleXCoordinate: '0'.	modelData secondStaticObstacleYCoordinate: '0'.		modelData trackEditMWIDynamicObstacle: '0'.	modelData dynamicObstacleXCoordinate: '0'.	modelData dynamicObstacleYCoordinate: '0'. 	obstacles do:	[		:obst |		((modelData totalStepDistance - obst y) > 0.0)		ifTrue:[			((obst kindOfObstacle = '1') | (obst kindOfObstacle = '2'))			ifTrue: [				modelData trackEditMWIStaticObstacle: (obst kindOfObstacle).								(obst orderOfObstacle = 1)				ifTrue:[					modelData firstStaticObstacleXCoordinate: ((obst x) negated) asString.					modelData firstStaticObstacleYCoordinate: (modelData totalStepDistance - obst y) asString.					].								(obst orderOfObstacle = 2)				ifTrue:[					modelData secondStaticObstacleXCoordinate: ((obst x) negated) asString.					modelData secondStaticObstacleYCoordinate: (modelData totalStepDistance - obst y) asString.					].			].						(obst kindOfObstacle = 'dynamic')			ifTrue: [				modelData trackEditMWIDynamicObstacle: '1'.				modelData dynamicObstacleXCoordinate: ((obst x) negated) asString.				modelData dynamicObstacleYCoordinate: (modelData totalStepDistance - obst y) asString. 				].		].	].	modelData changed.! !!SAMViewTrack methodsFor: 'as yet unclassified' stamp: 'CL 8/6/2009 10:18'!showCountdown	| countdownGraphic |	0 to: 3 do: 	[			:i |		countdownGraphic := (BitBlt destForm: Display 	                 sourceForm: (Form fromFileNamed: 'gfx\Countdown' , (3 - i) asString , '.gif')	                 halftoneForm: nil	                 combinationRule: Form blend	                 destOrigin: 0@0	                 sourceOrigin: 0@0	                 extent: 800@768 	                 clipRect: Display computeBoundingBox).						countdownGraphic sourceOrigin: (-300 @ -200).		countdownGraphic copyBits.			(Delay forSeconds: 1) wait.	].		! !!SAMViewTrack methodsFor: 'as yet unclassified' stamp: 'CL 8/6/2009 10:13'!showTrack		track sourceOrigin: (0 @ modelData trackHeight).	track copyBits.! !!SAMViewTrack methodsFor: 'accessing' stamp: 'nn 8/11/2009 20:27'!controllerNetwork	^controllerNetwork! !!SAMViewTrack methodsFor: 'accessing' stamp: 'nn 8/11/2009 20:27'!controllerNetwork: anObject	controllerNetwork := anObject! !Object subclass: #SAMViewTrackingObject	instanceVariableNames: 'speedometer offTrackColor obstacleColor modelData trackingObject speedoFrames localtrackingObjectGreen localtrackingObjectBlack speedoFramesGray speedoLeftHalfGray trackingObjectLowerHalfGreen speedoLowerHalfBlack speedoUpperHalfBlack'	classVariableNames: ''	poolDictionaries: ''	category: 'ATEO-SAM'!!SAMViewTrackingObject methodsFor: 'as yet unclassified' stamp: 'nn 9/11/2009 18:39'!buildTrackingObject	| lowerHalfGreen lowerHalfBlack upperHalfBlack |		localtrackingObjectGreen	:= Form fromFileNamed: 'gfx\trackingObject_green.png'.	localtrackingObjectBlack	:= Form fromFileNamed: 'gfx\trackingObject_black.png'.	lowerHalfGreen 	:= Form fromFileNamed: 'gfx\trackingObject_lowerHalf_green.png'.	lowerHalfBlack 	:= Form fromFileNamed: 'gfx\trackingObject_lowerHalf_black.png'.	upperHalfBlack	:= Form fromFileNamed: 'gfx\trackingObject_upperHalf_black.png'.	"leftHalfGray	:= Form fromFileNamed: 'gfx\trackingObject_leftHalf_gray.png'."	speedoFrames := Array new: 360.	"speedoFramesGray := Array new: 360."		"Something odd happens with the rotation here, I have to correct the position of all rotated forms by 7@7."	1 to: (speedoFrames size)  do: [:idx | 		"index := ((idx + 90) \\ 360).		(index = 0)		ifTrue:[ index := 360. ]."		speedoFrames at: idx put: (lowerHalfBlack copy rotateBy: (idx - 1.0)). 		"speedoFramesGray at: idx put: (leftHalfGray copy rotateBy: (idx - 1.0))."].				trackingObject := (BitBlt destForm: Display		            sourceForm: localtrackingObjectGreen	               halftoneForm: nil	               combinationRule: Form blend	               destOrigin: 0@0	               sourceOrigin: 0@0	               extent: 800@768 	               clipRect: Display computeBoundingBox).	trackingObjectLowerHalfGreen := (BitBlt destForm: Display		                sourceForm: lowerHalfGreen	                   halftoneForm: nil	                   combinationRule: Form blend	                   destOrigin: 0@0	                   sourceOrigin: 0@0	                   extent: 800@768 	                   clipRect: Display computeBoundingBox).		speedoLowerHalfBlack := (BitBlt destForm: Display 		               sourceForm: lowerHalfBlack	                  halftoneForm: nil	                  combinationRule: Form blend	                  destOrigin: 0@0	                  sourceOrigin: 0@0	                  extent: 800@768 	                  clipRect: Display computeBoundingBox).		"speedoLeftHalfGray := (BitBlt destForm: Display 		               sourceForm: leftHalfGray	                  halftoneForm: nil	                  combinationRule: Form blend	                  destOrigin: 0@0	                  sourceOrigin: 0@0	                  extent: 800@768 	                  clipRect: Display computeBoundingBox)."	speedoUpperHalfBlack := (BitBlt destForm: Display		                   sourceForm: upperHalfBlack	                      halftoneForm: nil	                      combinationRule: Form blend	                      destOrigin: 0@0	                      sourceOrigin: 0@0	                      extent: 800@768 	                      clipRect: Display computeBoundingBox).! !!SAMViewTrackingObject methodsFor: 'as yet unclassified' stamp: 'CL 8/5/2009 14:25'!centerOfTrackingObject	^(((modelData totalCalculatedXAxisForBlitter) abs) @ (modelData yCoordinateTrackingObject)) + (15 @ 15).! !!SAMViewTrackingObject methodsFor: 'as yet unclassified' stamp: 'nn 8/11/2009 21:38'!initialize		super initialize.		modelData := SAMModelData getInstance .		offTrackColor := (Color r: 0.199 g: 0.599 b: 0.199).	obstacleColor := (Color r: 0.897 g: 0.372 b: 0.258) .		modelData yCoordinateTrackingObject: 715; changed.! !!SAMViewTrackingObject methodsFor: 'as yet unclassified' stamp: 'nn 9/11/2009 18:42'!moveTrackingObject	| formRotateErrorX formRotateErrorY angleDegrees totalCalculatedXAxisForBlitter|	formRotateErrorX := 7.	formRotateErrorY := 7.		totalCalculatedXAxisForBlitter := modelData totalCalculatedXAxisForBlitter.		angleDegrees := 360 - ((360.0 / (modelData maxSpeed)) * modelData speedometer ) asInteger.	"Transcript cr; show: 'angleDegrees: ', angleDegrees asString, ' (360 - angleDegrees) abs: ', (360 - angleDegrees) abs asString."			(angleDegrees = 360)	ifTrue:[		trackingObject sourceForm: localtrackingObjectGreen.		trackingObject sourceOrigin: (totalCalculatedXAxisForBlitter @ (modelData yCoordinateTrackingObject) negated).		trackingObject copyBits.		].		(angleDegrees = 0)	ifTrue:[		trackingObject sourceForm: localtrackingObjectBlack.		trackingObject sourceOrigin: (totalCalculatedXAxisForBlitter @ (modelData yCoordinateTrackingObject) negated).		trackingObject copyBits.		].		((angleDegrees > 0) & (angleDegrees < 360))	ifTrue:[		trackingObject sourceForm: localtrackingObjectGreen.		trackingObject sourceOrigin: (totalCalculatedXAxisForBlitter @ (modelData yCoordinateTrackingObject) negated).		trackingObject copyBits.				speedoLowerHalfBlack sourceForm: (speedoFrames at: angleDegrees).		speedoLowerHalfBlack sourceOrigin: (totalCalculatedXAxisForBlitter + formRotateErrorX) @ (formRotateErrorY - (modelData yCoordinateTrackingObject)).		speedoLowerHalfBlack copyBits.					"speedometer"		(angleDegrees <= 180)		ifFalse: [			trackingObjectLowerHalfGreen  sourceOrigin: (totalCalculatedXAxisForBlitter @ (modelData yCoordinateTrackingObject) negated).			trackingObjectLowerHalfGreen copyBits.		] ifTrue: [			speedoUpperHalfBlack sourceOrigin: (totalCalculatedXAxisForBlitter @ (modelData yCoordinateTrackingObject) negated).			speedoUpperHalfBlack copyBits.		].	].	"(angleDegrees > 360)	ifTrue:[		trackingObject sourceForm: localtrackingObjectBlack.		trackingObject sourceOrigin: (totalCalculatedXAxisForBlitter @ (modelData yCoordinateTrackingObject) negated).		trackingObject copyBits.				speedoLeftHalfGray sourceForm: (speedoFramesGray at: (angleDegrees - 360)).		speedoLeftHalfGray sourceOrigin: (totalCalculatedXAxisForBlitter + formRotateErrorX) @ (formRotateErrorY - (modelData yCoordinateTrackingObject)).		speedoLeftHalfGray copyBits.				speedoLeftHalfBlack sourceForm: (speedoFrames at: 360).		speedoLeftHalfBlack sourceOrigin: (totalCalculatedXAxisForBlitter + formRotateErrorX) @ (formRotateErrorY - (modelData yCoordinateTrackingObject)).		speedoLeftHalfBlack copyBits.	]."! !!SAMViewTrackingObject methodsFor: 'as yet unclassified' stamp: 'CL 8/5/2009 17:47'!penaltyForCollision	| sensor1 sensor7 sensor3 |	sensor1 := Display colorAt: (self centerOfTrackingObject + (0 @ -17)) .	sensor3 := Display colorAt: (self centerOfTrackingObject + (17 @ 0)) .	sensor7 := Display colorAt: (self centerOfTrackingObject + (-17 @ 0)) .		[(sensor1 = offTrackColor) & (sensor7 = offTrackColor) & (sensor3 = offTrackColor)]	whileFalse:	[		modelData totalCalculatedXAxisForBlitter: modelData totalCalculatedXAxisForBlitter + 0.1; changed.						sensor1 := Display colorAt: (self centerOfTrackingObject + (0 @ -17)) .		sensor3 := Display colorAt: (self centerOfTrackingObject + (17 @ 0)) .		sensor7 := Display colorAt: (self centerOfTrackingObject + (-17 @ 0)) .	].! !!SAMViewTrackingObject methodsFor: 'as yet unclassified' stamp: 'CL 8/5/2009 14:28'!processSensors	|noSensorsOffTrack collisionAtSensor sensor1 sensor2 sensor3 sensor4 sensor5 sensor6 sensor7 sensor8 centerOfTrackingObject |	noSensorsOffTrack := 0.	collisionAtSensor := ''.		centerOfTrackingObject := self centerOfTrackingObject.		"Transcript show: 'centerPositionTrackingObject: ', centerPositionTrackingObject asString, ' totalCalculatedXAxis:', totalCalculatedXAxis asString; cr."	"sensor1 is 12 o'clock, the rest clockwise"	sensor1 := Display colorAt: (centerOfTrackingObject  + (0 @ -17)) .	sensor2 := Display colorAt: (centerOfTrackingObject + (12 @ -12)) .	sensor3 := Display colorAt: (centerOfTrackingObject + (17 @ 0)) .	sensor4 := Display colorAt: (centerOfTrackingObject + (12 @ 12)) .	sensor5 := Display colorAt: (centerOfTrackingObject + (0 @ 17)) .	sensor6 := Display colorAt: (centerOfTrackingObject + (-12 @ 12)) .	sensor7 := Display colorAt: (centerOfTrackingObject + (-17 @ 0)) .	sensor8 := Display colorAt: (centerOfTrackingObject + (-12 @ -12)) .		(sensor1 = offTrackColor) ifTrue:[noSensorsOffTrack := noSensorsOffTrack + 1.].	(sensor2 = offTrackColor) ifTrue:[noSensorsOffTrack := noSensorsOffTrack + 1.].	(sensor3 = offTrackColor) ifTrue:[noSensorsOffTrack := noSensorsOffTrack + 1.].	(sensor4 = offTrackColor) ifTrue:[noSensorsOffTrack := noSensorsOffTrack + 1.].	(sensor5 = offTrackColor) ifTrue:[noSensorsOffTrack := noSensorsOffTrack + 1.].	(sensor6 = offTrackColor) ifTrue:[noSensorsOffTrack := noSensorsOffTrack + 1.].	(sensor7 = offTrackColor) ifTrue:[noSensorsOffTrack := noSensorsOffTrack + 1.].	(sensor8 = offTrackColor) ifTrue:[noSensorsOffTrack := noSensorsOffTrack + 1.].		(sensor1 = obstacleColor) ifTrue:[collisionAtSensor := '1,'.].	(sensor2 = obstacleColor) ifTrue:[collisionAtSensor := collisionAtSensor, '2,'.].	(sensor3 = obstacleColor) ifTrue:[collisionAtSensor := collisionAtSensor, '3,'.].	(sensor4 = obstacleColor) ifTrue:[collisionAtSensor := collisionAtSensor, '4,'.].	(sensor5 = obstacleColor) ifTrue:[collisionAtSensor := collisionAtSensor, '5,'.].	(sensor6 = obstacleColor) ifTrue:[collisionAtSensor := collisionAtSensor, '6,'.].	(sensor7 = obstacleColor) ifTrue:[collisionAtSensor := collisionAtSensor, '7,'.].	(sensor8 = obstacleColor) ifTrue:[collisionAtSensor := collisionAtSensor, '8,'.].		(collisionAtSensor size > 0)	ifTrue:[modelData collisionInTick: true. ]	ifFalse:[modelData collisionInTick: false. ].		(collisionAtSensor = '')	ifTrue:[collisionAtSensor := '0'.].		modelData noSensorsOffTrack: noSensorsOffTrack;					collisionAtSensor: collisionAtSensor;					changed.		"(sensor1 ~= offTrackColor)	ifTrue:[	Transcript show: 'sensor1: ', sensor1 asString; cr.	Transcript show: 'sensor2: ', sensor2 asString; cr.	Transcript show: 'sensor3: ', sensor3 asString; cr.	Transcript show: 'sensor4: ', sensor4 asString; cr.	Transcript show: 'sensor5: ', sensor5 asString; cr.	Transcript show: 'sensor6: ', sensor6 asString; cr.	Transcript show: 'sensor7: ', sensor7 asString; cr.	Transcript show: 'sensor8: ', sensor8 asString; cr.	Transcript show: '---------------------'; cr.	]."	"Transcript show: 'Display colorAt: (', centerPositionTrackingObject asString, ' + (-12 @ 12)): ', (Display colorAt: (centerPositionTrackingObject + (-12 @ 12))) asString; cr."	"Transcript show: 'collisionAtSensor: ', collisionAtSensor asString, ' noSensorsOffTrack: ', noSensorsOffTrack asString; cr."				! !----End fileIn of Z:\home\users\michael\source\ateo\AAF\ATEO-SAM.st----!Dictionary subclass: #AAFDictionary	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-Track'!!AAFDictionary methodsFor: 'as yet unclassified' stamp: 'HM 10/6/2009 03:13'!at: index	"Make the dictionary behave sane by default. In a dynamic language I surely dont want an out-of-boundaries access to throw up a fatal error."	^(super at: index ifAbsent: nil).! !Object subclass: #AAFTrackAnalyzer	instanceVariableNames: 'trackFunctions'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-Track'!!AAFTrackAnalyzer methodsFor: 'as yet unclassified' stamp: 'HM 10/6/2009 02:08'!findCounterparts	"trackPoints is a collection of y_i: (x_i to x_i+1)* elements, that is, pairs of horizontal trackPoints for each vertical point."	| fnLoop |	fnLoop := (1 to: (trackFunctions size)).		(fnLoop)		do: [:fnIndex || fn |						fn := trackFunctions at: fnIndex.						(0 to: ((fn size) - 1))				do: [:fnArg || fnVal |										fnVal := fn at: fnArg.					(nil ~= fnVal)						ifTrue: [							Transcript show: ((fn at: fnArg) @ fnArg);							           cr.						].				].		].! !!AAFTrackAnalyzer methodsFor: 'as yet unclassified' stamp: 'HM 10/19/2009 12:35'!findRacingLine! !!AAFTrackAnalyzer methodsFor: 'as yet unclassified' stamp: 'HM 10/7/2009 08:54'!findTrackPoints: trackFileName	^(self findTrackPoints: trackFileName writeToForm: nil)! !!AAFTrackAnalyzer methodsFor: 'as yet unclassified' stamp: 'HM 10/19/2009 12:35'!findTrackPoints: trackFileName writeToForm: resultBitmap	| track xLoop yLoop onTrack xOffset trackExtent resultBlt color lineBitmap haveToCreateBitmap |		track := Form fromBMPFileNamed: trackFileName.	trackExtent := ((track width) @ (track height)).		"Basically fill up the dictionaries with nils for every height value."	self setupTrackFunctions: (track height).		haveToCreateBitmap := false.	(resultBitmap isKindOf: Form)		ifTrue: [haveToCreateBitmap := true].		(haveToCreateBitmap)		ifTrue: [			resultBitmap setExtent: trackExtent depth: (track depth).						resultBlt := (BitBlt destForm: resultBitmap  			                     sourceForm: nil			                     halftoneForm: nil			                     combinationRule: Form over			                     destOrigin: 0@0			                     sourceOrigin: 0@0			                     extent: trackExtent			                     clipRect: (0@0 extent: trackExtent)).		].	"The first 15 pixels (0-14) are used to encode track information, so we skip them."	xOffset := 15. 		"Storing the loop conditions explicitly speeds up loop iteration in Squeak. Yup, sad."	yLoop :=	(0 to: ((track height) - 1)).	xLoop := (xOffset to: ((track width) - 1)).		(yLoop)		do: [:yIndex || lBorder rBorderMaybe rBorder functionIndex |								lBorder := -1.			rBorderMaybe := -1.			rBorder := -1.			"Remember to which function we have to add the next interesting value."			functionIndex := 1.						onTrack := false.			(haveToCreateBitmap)				ifTrue: [					"Using a new lineBitmap for every yIndex is quite inefficient. We could just draw directly on one form, if that wouldn't create runtime errors. Forms and BitBlits are notoriously bad tested in Squeak. Also, it makes some stuff easier (proper cleanup for each yIndex, at least)."					lineBitmap := Form new.					lineBitmap setExtent: ((track width) @ 1) depth: (track depth).					resultBlt sourceForm: lineBitmap.				].			(xLoop)				do: [:xIndex|					 					color := (track colorAt: (xIndex @ yIndex)).										((onTrack not) and: [self isWhiteish: color])						ifTrue: [							lBorder := xIndex.							(trackFunctions at: functionIndex) at: yIndex put: lBorder.							functionIndex := functionIndex + 1.							onTrack := true.						].										(onTrack and: [self isWhiteish: color])						ifTrue: [							rBorderMaybe := xIndex.						].										(onTrack and: [self isGreenish: color])						ifTrue: [							rBorder := rBorderMaybe.							(trackFunctions at: functionIndex) at: yIndex put: rBorder.							functionIndex := functionIndex + 1.							onTrack := false.														(haveToCreateBitmap)								ifTrue: [									"lineBitmap fillGray."									lineBitmap colorAt: (lBorder @ 0) put: (Color red);									           colorAt: (rBorder @ 0) put: (Color red).									           "colorAt: ((lBorder + ((rBorder - lBorder) * 0.50)) @ 0) put: (Color yellow)."																		resultBlt destOrigin: (0 @ yIndex).									resultBlt copyBits.								].														lBorder := -1.							rBorder := -1. 						].           				].		].! !!AAFTrackAnalyzer methodsFor: 'as yet unclassified' stamp: 'HM 10/7/2009 08:52'!initialize	super initialize.	trackFunctions := OrderedCollection new.! !!AAFTrackAnalyzer methodsFor: 'as yet unclassified' stamp: 'HM 10/5/2009 01:26'!isGreenish: aColor	^((aColor red > 0.15) and: [(aColor red < 0.25) and:	  [(aColor green > 0.55) and: [(aColor green < 0.65) and:	  [(aColor blue > 0.15) and: [(aColor blue < 0.35)]]]]])! !!AAFTrackAnalyzer methodsFor: 'as yet unclassified' stamp: 'HM 10/5/2009 01:13'!isWhiteish: aColor	| threshold |		threshold := 0.9.		^((aColor red > threshold) and:	  [aColor green > threshold] and:	  [aColor blue > threshold])! !!AAFTrackAnalyzer methodsFor: 'as yet unclassified' stamp: 'HM 10/6/2009 02:49'!setupTrackFunctions: argsAmount	(1 to: (AAFTrackAnalyzer maxBranches * 2))		do: [:unused | trackFunctions add: (AAFDictionary new)].! !!AAFTrackAnalyzer methodsFor: 'as yet unclassified' stamp: 'HM 10/6/2009 01:30'!trackFunctions	^trackFunctions! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AAFTrackAnalyzer class	instanceVariableNames: ''!!AAFTrackAnalyzer class methodsFor: 'as yet unclassified' stamp: 'HM 10/6/2009 01:03'!maxBranches	^5! !----End fileIn of Z:\home\users\michael\source\ateo\AAF\AAF-Track.st----!Object subclass: #AAFAgent	instanceVariableNames: 'inactiveSelection'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-Agents'!!AAFAgent methodsFor: 'as yet unclassified' stamp: 'HM 7/22/2009 02:08'!compute: aSamState	self subclassResponsibility.! !!AAFAgent methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 22:07'!initialize	super initialize.	active := true.	activeSelection := nil.	inputMwb1 := 0.5.	inputMwb2 := 0.5.! !!AAFAgent methodsFor: 'properties' stamp: 'HM 7/31/2009 17:41'!inactiveSelection: selection	"For the agent this is a read-only property, that is, the agent is not allowed to change this list (or rather the agent could do it, but no one will listen ...)."	inactiveSelection := selection.! !!AAFAgent methodsFor: 'properties' stamp: 'HM 7/31/2009 17:19'!isInactive: aSamState	(nil = inactiveSelection)		ifTrue: [^false]. "Agents are active for all sections, by default"		^(inactiveSelection at: (aSamState trackingState currentSection))! !!AAFAgent methodsFor: 'signals' stamp: 'HM 7/26/2009 21:46'!agentPropertyChanged	self changed: #agentPropertyChanged.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AAFAgent class	instanceVariableNames: ''!!AAFAgent class methodsFor: 'as yet unclassified' stamp: 'HM 7/29/2009 23:55'!virtualPos: trackingState	"Return where the car would be, given the current speed. Does not regard x movement."	^(trackingState carPos x) @ ((trackingState distanceTotal + (trackingState speed)) asInteger)! !AAFAgent subclass: #AAFBreaksAgent	instanceVariableNames: 'lastKnownVirtualPos distance lerpedColor lookAheadScaling dotSize pointerVisible'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-Agents'!!AAFBreaksAgent methodsFor: 'as yet unclassified' stamp: 'HM 7/31/2009 17:39'!compute: aSamState	| virtualPos lerpedPos xDiff yDiff dot color |	(self isInactive: aSamState)		ifTrue: [^aSamState].		"speed := aSamState trackingState speed.	distance := distance + (speed asInteger).	virtualPos := (aSamState trackingState carPos x) @ (distance)."	virtualPos := AAFAgent virtualPos: (aSamState trackingState).	yDiff := (virtualPos y) - (lastKnownVirtualPos y).	xDiff := (virtualPos x) - (lastKnownVirtualPos x).	yDiff := yDiff * lookAheadScaling.	xDiff := xDiff * lookAheadScaling.		"TODO: replace magic ysize of 700 with something sane."	lerpedPos := ((virtualPos x) + xDiff) @ (700 - yDiff).	lastKnownVirtualPos := virtualPos copy.	color := Display colorAt: lerpedPos.	(0.5 <= color green and: [0.5 > color red])		ifTrue: [			dotSize := dotSize + (1@1).		] ifFalse: [			dotSize := (3@3).		].	(self isPointerVisible)		ifTrue: [			dot := Form extent: dotSize depth: 8.			dot fillColor: Color red;			    displayAt: lerpedPos.		].		((3@3) < dotSize)		ifTrue: [			| joystick slowDown |						slowDown := (dotSize y).						joystick := (aSamState joystickXY: 1).						joystick := (joystick x) @  (joystick y / slowDown).			aSamState joystickXY: 1 put: joystick.			joystick := (aSamState joystickXY: 2).						joystick := (joystick x) @  (joystick y / slowDown).			aSamState joystickXY: 2 put: joystick.		].		^aSamState		! !!AAFBreaksAgent methodsFor: 'as yet unclassified' stamp: 'HM 7/15/2009 21:57'!computeAngle: aPoint	| v1 v2 aSamState direction toDeg angle |	v1 := (aSamState joystickXY: 1).		v2 := (0@-1).		direction := 1.	(0 > (v1 x))		ifTrue: [direction := -1.].		toDeg := (180 / (Float pi)).		angle := 0.	(0@0 ~= v1 and: [-1 ~= v1 x])		ifTrue: [			angle := ((((v1 x) * (v2 x)) + ((v1 y) * (v2 y))) / ((((v1 x raisedTo: 2) + (v1 y raisedTo: 2)) sqrt) * (((v2 x raisedTo: 2) + (v2 y raisedTo: 2)) sqrt))) arcCos.		].	^angle! !!AAFBreaksAgent methodsFor: 'as yet unclassified' stamp: 'HM 7/22/2009 02:56'!initialize	super initialize.	lastKnownVirtualPos := 0@0.	distance := 0.	lookAheadScaling := 3.	dotSize := 3@3.	pointerVisible := false.! !!AAFBreaksAgent methodsFor: 'properties' stamp: 'HM 7/22/2009 02:55'!isPointerVisible	^pointerVisible! !!AAFBreaksAgent methodsFor: 'properties' stamp: 'HM 7/26/2009 21:44'!pointerVisible: aBoolean	(aBoolean == (pointerVisible not))		ifTrue: [			pointerVisible := aBoolean.			self agentPropertyChanged.		].! !AAFAgent subclass: #AAFDummyAgent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-Agents'!!AAFDummyAgent methodsFor: 'as yet unclassified' stamp: 'HM 7/31/2009 17:39'!compute: aSamState	(self isInactive: aSamState)		ifTrue: [^aSamState].	aSamState joystickXY: 1 put: ((aSamState joystickXY: 1) + (1@1)).	^aSamState! !AAFAgent subclass: #AAFIdleAgent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-Agents'!!AAFIdleAgent methodsFor: 'as yet unclassified' stamp: 'MH 7/6/2009 13:51'!compute: aSamState	^aSamState! !AAFAgent subclass: #AAFInputDistributionAgent	instanceVariableNames: 'inputMwb1 inputMwb2'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-Agents'!!AAFInputDistributionAgent methodsFor: 'as yet unclassified' stamp: 'HM 7/31/2009 18:03'!compute: aSamState	(self isInactive: aSamState)		ifTrue: [^aSamState].		"This will only work if at the same time we can tell SAM to not scale the inputMwbs itself. If not, we need a inputDistribution value in the SamState anyway, and we just update that instead, without doing the input scaling here."	aSamState joystickXY: 1 put: (inputMwb1 * (aSamState joystickXY: 1)).	aSamState joystickXY: 2 put: (inputMwb1 * (aSamState joystickXY: 2)).		^aSamState! !!AAFInputDistributionAgent methodsFor: 'as yet unclassified' stamp: 'HM 7/31/2009 17:16'!initialize	super initialize.	inputMwb1 := 0.5.	inputMwb2 := 0.5.! !!AAFInputDistributionAgent methodsFor: 'properties' stamp: 'HM 7/31/2009 18:04'!inputDistribution	^(Array with: inputMwb1	        with: inputMwb2)! !!AAFInputDistributionAgent methodsFor: 'properties' stamp: 'HM 7/31/2009 17:16'!inputDistribution: mwb1 with: mwb2	(mwb1 ~= inputMwb1 and: [mwb2 ~= inputMwb2]	                   and: [(mwb1 + mwb2) asInteger == 1]		                and: [0 <= mwb1]	                   and: [0 <= mwb2])		ifTrue: [			inputMwb1 := mwb1.			inputMwb2 := mwb2.			self agentPropertyChanged.		].! !AAFAgent subclass: #AAFInversionAgent	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-Agents'!!AAFInversionAgent methodsFor: 'as yet unclassified' stamp: 'HM 9/14/2009 20:54'!compute: aSamState	(self isInactive: aSamState)		ifTrue: [^aSamState].		"Manually unrolling the 1 to: 2 loop because the loop variable counts as mem allocation for the GC. Sad, I know ..."	aSamState joystickXAxisAt: 1	          put: ((aSamState joystickXAxisAt: 1) negated).	aSamState joystickYAxisAt: 1	          put: ((aSamState joystickYAxisAt: 1) negated).		aSamState joystickXAxisAt: 2	          put: ((aSamState joystickXAxisAt: 2) negated).	aSamState joystickYAxisAt: 2	          put: ((aSamState joystickYAxisAt: 2) negated).		^aSamState		! !AAFAgent subclass: #AAFSteeringAgent	instanceVariableNames: 'lookAhead threshold adjustmentRate adjustment adjustmentLimit'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-Agents'!!AAFSteeringAgent methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 22:05'!adjustSteeringFor: joystickXY to: xValue given: carPosX	((xValue - carPosX) > threshold) "too far left"		ifTrue: [			(adjustmentLimit > adjustment)				ifTrue: [					adjustment := adjustment + adjustmentRate.					^((joystickXY x + adjustment) @ joystickXY y)				].		].						((carPosX - xValue) > threshold) "too far right"		ifTrue: [			(adjustmentLimit > adjustment)				ifTrue: [					adjustment := adjustment + adjustmentRate.					^((joystickXY x - adjustment) @ joystickXY y)				].		].	adjustment := adjustmentRate.	^joystickXY! !!AAFSteeringAgent methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 00:20'!compute: aSamState	| dist xValues |		(self isInactive: aSamState)		ifTrue: [^aSamState].		"Something doesn't match heare, lookAhead should be 0 and therefore, match the car position."		dist := (aSamState trackingState distanceTotal) + lookAhead.	xValues := aSamState trackingState racingLineAt: dist.		"We currently only check against the first value in the xValues collection. If done correctly, we should attempt to steer to whatever x value is nearest. But let's see the performance of this first."	(nil ~= xValues and: [xValues isEmpty not])		ifTrue: [| carPosX |						"Again, no loop since that saves a variable, lol ..."			carPosX := (aSamState trackingState carPos x).			aSamState joystickXY: 1			          put: (self adjustSteeringFor: (aSamState joystickXY: 1)			                     to: (xValues at: 1)			                     given: carPosX).			aSamState joystickXY: 2			          put: (self adjustSteeringFor: (aSamState joystickXY: 2)			                     to: (xValues at: 1)			                     given: carPosX).		].		^aSamState! !!AAFSteeringAgent methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 22:03'!initialize	super initialize.	"Just a guessed value that seems to fit with the on-screen display though."	lookAhead := -255.		"The threshold smoothens out the manipulation. That is, we start once we are outside and stop once we are inside again."	threshold := 5.		"Now this one needs more planning. A too high value and the SteeringAgent will just drive along the racinglines, with no mistakes. BUT, if we increase the adjustmentRate only during a manipulation run it would simulate some kind of physics and considerably nerf the effect of this agent (which sadly is preferable ...)"	adjustmentRate := 128.	adjustment := adjustmentRate copy.	adjustmentLimit := 1024.	! !!AAFSteeringAgent methodsFor: 'properties' stamp: 'HM 7/31/2009 21:41'!adjustmentRate	^adjustmentRate! !!AAFSteeringAgent methodsFor: 'properties' stamp: 'HM 7/31/2009 21:43'!adjustmentRate: aNumber	"Hum, I have no idea what the boundaries are ... [1,1024]? [-1024,1024]?"	(aNumber ~= adjustmentRate)		ifTrue: [			adjustmentRate := aNumber.			self agentPropertyChanged.		].! !!AAFSteeringAgent methodsFor: 'properties' stamp: 'HM 8/2/2009 00:30'!lookAhead	^lookAhead! !!AAFSteeringAgent methodsFor: 'properties' stamp: 'HM 8/2/2009 00:30'!lookAhead: aNumber	(aNumber ~= lookAhead)		ifTrue: [			lookAhead := aNumber.			self agentPropertyChanged.		].! !!AAFSteeringAgent methodsFor: 'properties' stamp: 'HM 7/31/2009 21:42'!threshold	^threshold! !!AAFSteeringAgent methodsFor: 'properties' stamp: 'HM 7/31/2009 21:43'!threshold: aNumber	(aNumber ~= threshold)		ifTrue: [			threshold := aNumber.			self agentPropertyChanged.		].! !----End fileIn of Z:\home\users\michael\source\ateo\AAF\AAF-Agents.st----!Object subclass: #AAFAgentUi	instanceVariableNames: 'agent title dialog viewportX viewportY inactiveSelectionModel inactiveSelection'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-AgentUis'!!AAFAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 7/22/2009 00:58'!agent	^agent! !!AAFAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 7/24/2009 13:29'!agent: anAAFAgent	agent := anAAFAgent.	"Hum, what happens with the old dialogs that were already connected? Should I use breakDeps?"	agent addDependent: self.! !!AAFAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 7/22/2009 12:51'!dialog	^dialog! !!AAFAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 7/31/2009 20:40'!dialogNew: anAAFAgent	"Create a new dialog instance and populate it with properties that are valid for all agents. Returns nil if no agent was specified yet."	(anAAFAgent isKindOf: AAFAgent)		ifFalse: [^nil].		self agent: anAAFAgent.	viewportX := 0.	viewportY := 0.	dialog := AAFWidgetUtils dialogNewWithCloseButtonAndTitle: title.		(dialog viewport) addWidget: (self inactiveSelectionNew)	                  frame: (viewportX @ viewportY extent: 1@0.29).	viewportY := 0.3.	^dialog! !!AAFAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 7/31/2009 20:40'!inactiveSelectionNew	| list selection size label |	size := 32.	list := Array new: size.	selection := Array new: size.	(1 to: size)		do: [:idx |			list at: idx put: ('Track section ', idx asString).			selection at: idx put: false.		].		inactiveSelectionModel := AAFListModel new.	inactiveSelectionModel addDependent: self.	inactiveSelectionModel list: list;	                       selection: selection.	label := 'Track sections with inactive agent' asStringMorph.	label fontName: AAFWidgetUtils defaultFont	      size: 16. "Really, I don't understand how Squeak handles font sizes. All I know is that this does not show as a 16pt font."	inactiveSelection := AAFWidget new.	inactiveSelection addWidget: label	                  frame: (0@0 extent: 1@0.18).		inactiveSelection  addWidget:	(inactiveSelectionModel listMorph)	                   frame: (0@0.2 extent: 1@0.8).	^inactiveSelection! !!AAFAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 7/31/2009 18:08'!initialize	super initialize.	"The subclasses have to choose a proper agent as its model."	agent := nil.		"This is the title used in self>>showProperties"	title := 'An Agent'.	"This member stores the properties dialog, as long as it stays open (since we 'close' it by deleting the dialog atm)."	dialog := nil.		"Use these coordinates pointing to the dialog viewport's proportional layout to find the next suitable space for your widget to add."	viewportX := 0.	viewportY := 0.! !!AAFAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 7/29/2009 18:06'!show	"Opens a dialog with the pre-initialized model agent."	self dialogNew: agent.			"Forces the dialog to show current data."	self updateFromAgent.	self updateFromListSelection.		(nil ~= dialog)		ifTrue: [dialog openCenteredInWorld].! !!AAFAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 22:03'!update: event	"Filter by event which also tells us which model sent a changed message: #modelAspectChanged."	(#agentPropertyChanged = event)		ifTrue: [self updateFromAgent].	(#listSelectionChanged = event)		ifTrue: [self updateFromListSelection].	! !!AAFAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 7/31/2009 18:45'!updateFromAgent	"Empty for now"! !!AAFAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 7/31/2009 17:45'!updateFromListSelection	agent inactiveSelection: (inactiveSelectionModel selection).! !AAFAgentUi subclass: #AAFBreaksAgentUi	instanceVariableNames: 'pointerVisibleButton'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-AgentUis'!!AAFBreaksAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 21:35'!dialogNew: anAAFAgent	super dialogNew: anAAFAgent.	(nil = dialog)		ifTrue: [self return].	pointerVisibleButton := AAFWidgetUtils toggleButtonNew: agent	                                       action: #pointerVisible:	                                       label: 'Visible pointer' 	                                       disabledLabel: 'Invisible pointer'.	(dialog viewport) addWidget: pointerVisibleButton	                  frame: (viewportX @ viewportY extent: 0.3@0.1).	viewportX := 0.33.			^dialog! !!AAFBreaksAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 7/31/2009 18:08'!initialize	super initialize.	"Set the model for this view, and we have to use the setter here."	self agent: (AAFBreaksAgent new).	title := 'Breaks agent'.! !!AAFBreaksAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 22:04'!updateFromAgent	super updateFromAgent.	(agent isKindOf: AAFBreaksAgent)		ifFalse: [self return].	"Update pointer status."	(agent isPointerVisible)		ifTrue: [pointerVisibleButton  turnOn.]		ifFalse: [pointerVisibleButton turnOff.].	pointerVisibleButton updateLabel.! !AAFAgentUi subclass: #AAFInputDistributionAgentUi	instanceVariableNames: 'inputDistribution'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-AgentUis'!!AAFInputDistributionAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 7/31/2009 18:11'!dialogNew: anAAFAgent	super dialogNew: anAAFAgent.	(nil = dialog)		ifTrue: [self return].	inputDistribution := AAFInputDistribution new.	inputDistribution target: agent	                  action: #inputDistribution:with:.		viewportX := 0.0.	(dialog viewport) addWidget: inputDistribution	                  frame: (viewportX @ viewportY extent: 0.49@0.1).		viewportX := 0.5.			^dialog! !!AAFInputDistributionAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 7/31/2009 18:08'!initialize	super initialize.	"Set the model for this view, and we have to use the setter here."	self agent: (AAFInputDistributionAgent new).	title := 'Input distribution agent'.! !!AAFInputDistributionAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 7/31/2009 18:05'!updateFromAgent	| inputDistInc |	super updateFromAgent.	(agent isKindOf: AAFInputDistributionAgent)		ifFalse: [self return].	"Update input distribution."	inputDistInc := ((agent inputDistribution at: 1) * 100) asInteger.	inputDistribution mwb1: inputDistInc	                  mwb2: (100 - inputDistInc).! !AAFAgentUi subclass: #AAFSteeringAgentUi	instanceVariableNames: 'thresholdInput adjustmentRateInput lookAheadInput'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-AgentUis'!!AAFSteeringAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 12:47'!dialogNew: anAAFAgent	| thresholdTitle adjustmentRateTitle lookAheadTitle |		super dialogNew: anAAFAgent.	(nil = dialog)		ifTrue: [self return].	"Threshold"	thresholdTitle := 'Threshold' asStringMorph.	(dialog viewport) addWidget: thresholdTitle	                  frame: (viewportX @ viewportY extent: 0.30@0.05).	viewportY := viewportY + 0.06.		thresholdInput := AAFSpinButton new.	thresholdInput target: agent action: #threshold:.	(dialog viewport) addWidget: thresholdInput	                  frame: (viewportX @ viewportY extent: 0.30@0.1).	viewportX := 0.33.	viewportY := viewportY - 0.06.	"AdjustmentRate"	adjustmentRateTitle := 'Adjustment rate' asStringMorph.	(dialog viewport) addWidget: adjustmentRateTitle	                  frame: (viewportX @ viewportY extent: 0.30@0.05).	viewportY := viewportY + 0.06.		adjustmentRateInput := AAFSpinButton new.	adjustmentRateInput target: agent action: #adjustmentRate:.	adjustmentRateInput range: (Array with: 32 with: 2048).	adjustmentRateInput climbRate: 64.	(dialog viewport) addWidget: adjustmentRateInput	                  frame: (viewportX @ viewportY extent: 0.30@0.1).	viewportX := 0.66.	viewportY := viewportY - 0.06.	"LookAhead"	lookAheadTitle := 'Look-ahead' asStringMorph.	(dialog viewport) addWidget: lookAheadTitle	                  frame: (viewportX @ viewportY extent: 0.30@0.05).	viewportY := viewportY + 0.06.		lookAheadInput := AAFSpinButton new.	lookAheadInput target: agent action: #lookAhead:.	lookAheadInput range: (Array with: -400 with: 0).	(dialog viewport) addWidget: lookAheadInput	                  frame: (viewportX @ viewportY extent: 0.30@0.1).	viewportX := 0.	viewportY := viewportY + 0.17.			^dialog! !!AAFSteeringAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 00:58'!initialize	super initialize.	"Set the model for this view, and we have to use the setter here."	self agent: (AAFSteeringAgent new).	title := 'Steering agent'.! !!AAFSteeringAgentUi methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 13:20'!updateFromAgent	super updateFromAgent.	(agent isKindOf: AAFSteeringAgent)		ifFalse: [self return].	thresholdInput value: (agent threshold).	adjustmentRateInput value: (agent adjustmentRate).	lookAheadInput value: (agent lookAhead).! !----End fileIn of Z:\home\users\michael\source\ateo\AAF\AAF-AgentUis.st----!SimpleButtonMorph subclass: #AAFButton	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-GUI'!!AAFButton methodsFor: 'override' stamp: 'HM 7/24/2009 01:59'!doButtonAction	"Restore label's font size. Ugly, but meh ..."	AAFWidgetUtils applyDefaultFontSize:self.			super doButtonAction! !Object subclass: #AAFListModel	instanceVariableNames: 'list primary selection'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-GUI'!!AAFListModel methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 20:48'!initialize	super initialize.	list := nil.	selection := nil.	primary := 0.! !!AAFListModel methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 20:20'!list	^ (list collect: [:t1 | t1 asString])! !!AAFListModel methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 20:47'!list: aCollection	list := aCollection.! !!AAFListModel methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 20:46'!listMorph	| view |		(nil = list or: [nil = selection])		ifTrue: [^nil].	view := PluggableListMorphOfMany new.	view on: self	     list: #list	     primarySelection: #primarySelection	     changePrimarySelection: #primarySelection:	     listSelection: #listSelectionAt:	     changeListSelection: #listSelectionAt:put:	     menu: nil	     keystroke: #arrowKey:from:.		AAFWidgetUtils applyDefaultMorphProperties: view.		^view! !!AAFListModel methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 20:22'!listSelectionAt: index	^(selection at: index ifAbsent: [^ false])! !!AAFListModel methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 21:47'!listSelectionAt: index put: object	selection at: index put: object.	self listSelectionChanged.! !!AAFListModel methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 22:10'!listSelectionChanged	self changed: #listSelectionChanged.		"#allSelections is just a stupid event name which is much too generic for my taste. That is why I trigger 2 events here ..."	self changed: #allSelections.! !!AAFListModel methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 20:20'!primarySelection	^primary! !!AAFListModel methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 20:21'!primarySelection: selection	primary := selection! !!AAFListModel methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 20:49'!selection	^selection! !!AAFListModel methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 20:47'!selection: aCollection	selection := aCollection.! !SimpleSwitchMorph subclass: #AAFToggleButton	instanceVariableNames: 'enabledLabel disabledLabel'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-GUI'!!AAFToggleButton methodsFor: 'as yet unclassified' stamp: 'HM 7/21/2009 23:26'!disabledLabel: aString	disabledLabel := aString.! !!AAFToggleButton methodsFor: 'as yet unclassified' stamp: 'HM 7/24/2009 14:27'!enabledLabel: aString	enabledLabel := aString.	self label: aString.! !!AAFToggleButton methodsFor: 'as yet unclassified' stamp: 'HM 7/24/2009 13:35'!updateLabel	(self isOn)		ifTrue: [self label: enabledLabel]		ifFalse: [self label: disabledLabel].			"Restore label's font size. Ugly, but meh ..."	AAFWidgetUtils applyDefaultFontSize:self.! !!AAFToggleButton methodsFor: 'override' stamp: 'HM 7/24/2009 13:35'!doButtonAction	self updateLabel.	super doButtonAction.! !AlignmentMorph subclass: #AAFWidget	instanceVariableNames: 'target action arguments'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-GUI'!!AAFWidget methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 00:46'!action	^action! !!AAFWidget methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 00:57'!actionSelector	"Its neither action nor selector. It's a slot, or a callback, but actionSelector?!! How about actionSelectorOfTargetThatMapsToAMethod? Anyway, we need a common introspection interface for AAFWidgets and Morphs."	^action! !!AAFWidget methodsFor: 'as yet unclassified' stamp: 'HM 7/21/2009 22:48'!addWidget: aWidget frame: aRectangle	"Feels ugly to wrap the addMorph functionality. But with proportional layouts this is just too much typing, and it makes GUI-building code nearly unreadable."	self addMorph: aWidget	     fullFrame: (LayoutFrame fractions: (aRectangle)).! !!AAFWidget methodsFor: 'as yet unclassified' stamp: 'HM 7/24/2009 03:05'!arguments: aCollection	arguments := aCollection asArray copy.! !!AAFWidget methodsFor: 'as yet unclassified' stamp: 'HM 7/24/2009 03:04'!doWidgetAction	(nil ~= target and: [nil ~= action])		ifTrue: [			target perform: action withArguments: arguments.		].! !!AAFWidget methodsFor: 'as yet unclassified' stamp: 'HM 7/21/2009 22:15'!initialize	super initialize.	self layoutPolicy: (ProportionalLayout new);	     borderWidth:0;	     color: Color transparent.! !!AAFWidget methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 00:39'!submorphs	^submorphs! !!AAFWidget methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 00:44'!target	^target! !!AAFWidget methodsFor: 'as yet unclassified' stamp: 'HM 7/24/2009 03:00'!target: anObject action: aMethodSymbol	target := anObject.	action := (aMethodSymbol asSymbol).! !AAFWidget subclass: #AAFDialog	instanceVariableNames: 'viewport title buttonBox'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-GUI'!!AAFDialog methodsFor: 'as yet unclassified' stamp: 'HM 7/21/2009 22:32'!buttonBox	^buttonBox! !!AAFDialog methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 20:39'!initialize	super initialize.		AAFWidgetUtils applyDefaultMorphProperties: self.	self extent: (AAFDialog defaultWidth)@(AAFDialog defaultHeight).	"I have no idea why size doesn't translate directly to a fontsize. It seems you have to use higher values than 36 in case you want a font at that size. Well, I couldn't care less - we already knew before how borken Squeak is."	title := StringMorph new.	title contents: nil;	      fontName: (AAFWidgetUtils defaultFont) size: 50.		self addMorph: title	     fullFrame: (LayoutFrame fractions: (0@0 extent: 1@0.1));	     addMorph: (AAFWidgetUtils separatorNew: (AAFDialog defaultWidth))	     fullFrame: (LayoutFrame fractions: (0@0.1 extent: 1@0.11)).	viewport := AAFWidget new.	self addMorph: viewport	     fullFrame: (LayoutFrame fractions: (0@0.12 extent: 1@0.7)).	buttonBox := AAFWidget new.	self addMorph: buttonBox	     fullFrame: (LayoutFrame fractions: (0@0.9 extent:1@0.1)).! !!AAFDialog methodsFor: 'as yet unclassified' stamp: 'HM 7/21/2009 22:31'!title	^(title contents)! !!AAFDialog methodsFor: 'as yet unclassified' stamp: 'HM 7/21/2009 22:30'!title: aString	title contents: aString.! !!AAFDialog methodsFor: 'as yet unclassified' stamp: 'HM 7/21/2009 22:32'!viewport	^viewport! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AAFDialog class	instanceVariableNames: ''!!AAFDialog class methodsFor: 'as yet unclassified' stamp: 'HM 7/21/2009 22:18'!defaultHeight	^600! !!AAFDialog class methodsFor: 'as yet unclassified' stamp: 'HM 7/22/2009 02:51'!defaultWidth	^600! !AAFWidget subclass: #AAFInputDistribution	instanceVariableNames: 'mwb1Value mwb1Button mwb2Value mwb2Button label climbRate'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-GUI'!!AAFInputDistribution methodsFor: 'as yet unclassified' stamp: 'HM 7/24/2009 03:06'!incDecValues: anInteger	| newVal |		newVal := mwb1Value + anInteger.	(0 <= newVal and: [100 >= newVal])		ifTrue: [			mwb1Value := newVal.			mwb2Value := 100 - newVal.		].	self updateLabels.	self arguments: (self values).	self doWidgetAction.! !!AAFInputDistribution methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 01:58'!initialize	super initialize.	self extent: (AAFDialog defaultWidth * 0.67)@50.		climbRate := 5.	mwb1Value := 50.	mwb1Button := AAFWidgetUtils buttonNew: self action: #onMwb1Clicked label: nil.	self addWidget: mwb1Button frame: (0.0@0 extent: 0.49@1).			mwb2Value := (100 - mwb1Value). 	mwb2Button := AAFWidgetUtils buttonNew: self action: #onMwb2Clicked label: nil.	self addWidget: mwb2Button frame: (0.51@0 extent: 0.49@1).	self updateLabels.	! !!AAFInputDistribution methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 02:53'!mwb1: mwb1 mwb2: mwb2	(100 == (mwb1 + mwb2) and: [0 <= mwb1]	                      and: [0 <= mwb2])		ifTrue: [			mwb1Value := mwb1.			mwb2Value := mwb2.		].		self updateLabels.! !!AAFInputDistribution methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 01:58'!onMwb1Clicked	self incDecValues: climbRate.! !!AAFInputDistribution methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 01:58'!onMwb2Clicked	self incDecValues: (climbRate negated).! !!AAFInputDistribution methodsFor: 'as yet unclassified' stamp: 'HM 7/24/2009 02:45'!updateLabels	mwb1Button label: ('MWB 1: ', mwb1Value asString, '%').	mwb2Button label: ('MWB 2: ', mwb2Value asString, '%').	AAFWidgetUtils applyDefaultFontSize: mwb1Button.	AAFWidgetUtils applyDefaultFontSize: mwb2Button.! !!AAFInputDistribution methodsFor: 'as yet unclassified' stamp: 'HM 7/24/2009 02:38'!values	^(Array with: (mwb1Value asFloat / 100.0)	        with: (mwb2Value asFloat / 100.0))! !AAFWidget subclass: #AAFSpinButton	instanceVariableNames: 'value range climbRate incButton decButton textInput valueStr editButton'	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-GUI'!!AAFSpinButton methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 01:17'!climbRate	^climbRate! !!AAFSpinButton methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 12:47'!climbRate: aNumber	((range at: 1) <= aNumber and: [(range at: 2) >= aNumber])		ifTrue: [climbRate := aNumber].! !!AAFSpinButton methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 11:25'!inRange: aNumber	^((range at: 1) <= aNumber and: [(range at: 2) >= aNumber])! !!AAFSpinButton methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 12:15'!incDecValues: aNumber	| newVal |		newVal := value + aNumber.	(self inRange: newVal)		ifTrue: [			value := newVal.			self updateTextInput.		].	self arguments: (self value).	self doWidgetAction.! !!AAFSpinButton methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 11:01'!initialize	super initialize.	self extent: (100@40).		AAFWidgetUtils applyDefaultMorphProperties: self.	range := Array with: 0 with: 100.	value := 0.	climbRate := 5.		"Just a simple label because Morphics have no simple line input. Instead, I will use good old ST80 MVC to get the user input."	textInput := StringMorph new.	self updateTextInput.	self addWidget: textInput frame: (0.05@0.15 extent: 0.55@0.7).		editButton := AAFWidgetUtils buttonNew: self	                             action: #onEditButtonClicked	                             label: 'E'.	editButton cornerStyle: #squared.	self addWidget: editButton frame: (0.61@0 extent: 0.18@1).		incButton := AAFWidgetUtils buttonNew: self	                            action: #onIncButtonClicked	                            label: '+'.	incButton cornerStyle: #squared.	self addWidget: incButton frame: (0.81@0 extent: 0.19@0.48).	decButton := AAFWidgetUtils buttonNew: self	                            action: #onDecButtonClicked	                            label: '-'.	decButton cornerStyle: #squared.	self addWidget: decButton frame: (0.81@0.52 extent: 0.19@0.48).! !!AAFSpinButton methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 01:49'!onDecButtonClicked	self incDecValues: (climbRate negated).! !!AAFSpinButton methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 13:18'!onEditButtonClicked	| fitbTitle newValue |		fitbTitle := ('Please enter a number between [', (range at: 1) asString, ', ', (range at: 2) asString, ']:').	newValue := (FillInTheBlank request: fitbTitle	                            initialAnswer: (value asString)) asNumber.		(newValue isKindOf: Number)		ifTrue: [self value: newValue].	self arguments: (self value).	self doWidgetAction.! !!AAFSpinButton methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 01:18'!onIncButtonClicked	self incDecValues: climbRate.! !!AAFSpinButton methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 01:15'!range	^range! !!AAFSpinButton methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 12:45'!range: aRange	"a range is an interval, here: an array of size 2 where the second element has to be bigger than the first."	range := aRange.	climbRate := (((range at: 2) - (range at: 1)) / 20.0) rounded.! !!AAFSpinButton methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 10:57'!updateTextInput	textInput contents: (value asString).	textInput fontName: (AAFWidgetUtils defaultFont) size: 24.! !!AAFSpinButton methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 01:36'!value	^(Array with: value)! !!AAFSpinButton methodsFor: 'as yet unclassified' stamp: 'HM 8/2/2009 13:17'!value: aNumber	(self inRange: aNumber)		ifTrue: [value := aNumber].	self updateTextInput.! !Object subclass: #AAFWidgetUtils	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-GUI'!!AAFWidgetUtils commentStamp: 'HM 7/26/2009 20:14' prior: 0!I cannot believe there is no ListModel for PluggableListMorphs. And there is no API doc to telling how to impl. it either. Squeak devs, you really making it hard for no goog reason.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!AAFWidgetUtils class	instanceVariableNames: ''!!AAFWidgetUtils class methodsFor: 'as yet unclassified' stamp: 'HM 7/22/2009 00:41'!applyDefaultButtonProperties: aButton	aButton borderWidth: (AAFWidgetUtils defaultBorderWidth);           cornerStyle: #rounded;           color: Color veryLightGray.	"This feels so stupid. Descend the object hierarchy, grab the first StringMorhp, hope it is the button label, and set the font size. For the lack of a Morph>>fontSize property."	AAFWidgetUtils applyDefaultFontSize: aButton.! !!AAFWidgetUtils class methodsFor: 'as yet unclassified' stamp: 'HM 7/22/2009 00:41'!applyDefaultFontSize: aWidget	(aWidget findA: StringMorph) fontName: (AAFWidgetUtils defaultFont)                                size: 30.! !!AAFWidgetUtils class methodsFor: 'as yet unclassified' stamp: 'HM 7/26/2009 20:39'!applyDefaultMorphProperties: morph	morph borderWidth:2;	      cornerStyle: #rounded;	      color: Color white.	^morph.! !!AAFWidgetUtils class methodsFor: 'as yet unclassified' stamp: 'HM 7/24/2009 02:01'!buttonNew: target action: action label: label	| button |		button := AAFButton new.		button target: target;          actionSelector: action;          label: label.	"Properties like font size can only be set after labels have been set. Don't ask ..."	AAFWidgetUtils applyDefaultButtonProperties: button.		^button! !!AAFWidgetUtils class methodsFor: 'as yet unclassified' stamp: 'HM 7/22/2009 00:28'!defaultBorderWidth	^2! !!AAFWidgetUtils class methodsFor: 'as yet unclassified' stamp: 'HM 7/21/2009 21:53'!defaultFont	^#BitstreamVeraSans! !!AAFWidgetUtils class methodsFor: 'as yet unclassified' stamp: 'HM 7/21/2009 22:55'!dialogNewWithCloseButtonAndTitle: title	| dialog |	dialog := AAFDialog new.	dialog openCenteredInWorld.	dialog title: title.	(dialog buttonBox) addWidget: (AAFWidgetUtils buttonNew: dialog action: #delete label: 'Close')	                   frame: (0@0 extent: 1@1).	^dialog! !!AAFWidgetUtils class methodsFor: 'as yet unclassified' stamp: 'HM 7/22/2009 00:23'!separatorNew: aNumber	^(LineMorph from: (0@0) to: (aNumber@0) color: (Color black) width: (AAFWidgetUtils defaultBorderWidth)).! !!AAFWidgetUtils class methodsFor: 'as yet unclassified' stamp: 'HM 7/24/2009 14:33'!toggleButtonNew: target action: action label: label disabledLabel: disabledLabel	| button |		button := AAFToggleButton new.	button target: target;	       actionSelector: action;          enabledLabel: label;          disabledLabel: disabledLabel.	"Properties like font size can only be set after labels have been set. Don't ask ..."	AAFWidgetUtils applyDefaultButtonProperties: button.	button turnOn.		^button! !----End fileIn of Z:\home\users\michael\source\ateo\AAF\AAF-GUI.st----!TestCase subclass: #AAFAgentUiTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-Test'!!AAFAgentUiTestCase methodsFor: 'testing' stamp: 'HM 7/26/2009 11:13'!agentNew	^(AAFAgent new)! !!AAFAgentUiTestCase methodsFor: 'testing' stamp: 'HM 7/26/2009 11:13'!agentUiNew	^(AAFAgentUi new)! !!AAFAgentUiTestCase methodsFor: 'testing' stamp: 'HM 7/31/2009 17:42'!testAgentDefaults: agent	"Currently empty"! !!AAFAgentUiTestCase methodsFor: 'testing' stamp: 'HM 7/31/2009 21:52'!testModelView	"We want to set a value in the AAFAgent (model) and check whether the view gets updated, and vice versa. To do so, we iterate over the submorphs of AAFAgentUi's (controller) dialog (view)."	| model ctrl view |		"Make sure to override self>>agentNew, self>>agentUiNew correctly in subclasses, else we test the wrong stuff there!!"	model := self agentNew.	ctrl  := self agentUiNew.	ctrl agent: model.	view  := ctrl show dialog.		"Check the default values of the model, to avoid silly mistakes."	self testAgentDefaults: model.	(view viewport submorphs)		do: [ :morph |						"Override self>>testMorph:withAgent:withMethod: to test for other model/ctrl combos. Ignore the PLM. God this is ugly ..."			(nil = (morph findA: PluggableListMorph))				ifTrue: [ 					self testMorph: morph					     withAgent: (morph target)					     withMethod: (morph actionSelector).				]. 		].	"We have to delete the view explicitly because it is opened in the world."	view hide delete.! !!AAFAgentUiTestCase methodsFor: 'testing' stamp: 'HM 7/31/2009 21:49'!testMorph: morph withAgent: agent withMethod: method	(agent isKindOf: AAFAgent)		"If wrong agent then force test runner into a failed assertion."		ifFalse: [self shouldnt: [true]]		ifTrue: [			"Switch through the methods we know, since they (= event handlers) are mapped 1:1 to UI elements. W.o.w., if we know the method, we know the UI element."			"No general UI elements to test, other than the PLMoM ..."		].! !AAFAgentUiTestCase subclass: #AAFBreaksAgentUiTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-Test'!!AAFBreaksAgentUiTestCase methodsFor: 'testing' stamp: 'HM 7/26/2009 11:14'!agentNew	^(AAFBreaksAgent new)! !!AAFBreaksAgentUiTestCase methodsFor: 'testing' stamp: 'HM 7/26/2009 11:14'!agentUiNew	^(AAFBreaksAgentUi new)! !!AAFBreaksAgentUiTestCase methodsFor: 'testing' stamp: 'HM 7/26/2009 11:59'!testAgentDefaults: agent	super testAgentDefaults: agent.		self shouldnt: [agent isPointerVisible].! !!AAFBreaksAgentUiTestCase methodsFor: 'testing' stamp: 'HM 7/26/2009 12:04'!testMorph: morph withAgent: agent withMethod: method	(agent isKindOf: AAFBreaksAgent)		"If wrong agent then force test runner into a failed assertion."		ifFalse: [self shouldnt: [true]]		ifTrue: [						"Test the pointerVisibleButton."			(#pointerVisible: = method asSymbol)				ifTrue: [					"Let's turn the agent's property on."					agent pointerVisible: true.					self  should: [morph isOn].										"Now let's press the button."					morph turnOff doButtonAction.					self shouldnt: [agent isPointerVisible].				].		].! !TestCase subclass: #AAFControlTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-Test'!!AAFControlTestCase methodsFor: 'testing' stamp: 'MH 7/7/2009 16:39'!testGraphProcessing	| control root lchild rchild sink state |	control := AAFControl new.	control isDebugRun: true.		AAFNode resetCounter.		root := AAFNode new		agent: (AAFIdleAgent new).	control createGraphWithRoot: root.		self should: [root parents isEmpty];		  should: [root children isEmpty].		lchild := AAFNode new		agent: (AAFDummyAgent new).	rchild := AAFNode new		agent: (AAFDummyAgent new).	sink   := AAFNode new		agent: (AAFDummyAgent new).	control connectParent: root withChild: lchild.	self should: [root parents isEmpty];		  should: [lchild == root children first];		  should: [root == lchild parents first];			  should: [lchild children isEmpty]. 		self shouldnt: [lchild haveParentResults].	root result: (SamState new).	self should: [lchild haveParentResults].		state := control processGraph: (SamState new).	self should: [(1@1) = (state joystickXY: 1)].		control connectParent: root withChild: rchild.	control connectParent: lchild withChild: sink.	control connectParent: rchild withChild: sink.	state := control processGraph: (SamState new).	"**	  *  root: adds 1@1 to 0@0	  *  lchild: adds 1@1 to 1@1	  *  rchild: adds 1@1 to 1@1	  *  sink: merges lchild and rchild by adding 2@2 and 2@2. Adds 1@1	  **"	self should: [(5@5) = (state joystickXY: 1)].! !!AAFControlTestCase methodsFor: 'testing' stamp: 'HM 7/23/2009 21:06'!testSamIntegration	"TODO: extend integration tests as soon as SamState (and therefore, the integration) grows more complex."	"TODO: run inside a short sample 'simulation', to check whether states are correctly reset and so on."	| proxy control sensor joystick1 joystick2 |		"Get fresh singleton instances."	proxy := AAFProxy reset getInstance.	control := AAFControl reset getInstance.	sensor := AAFEventSensor reset getInstance.		"Create a test graph containing one node using the inversion agent."	control testInversionGraph.	self should:   [control root isKindOf: AAFNode];	     shouldnt: [control root hasResult];		  should:   [control root agent isKindOf: AAFInversionAgent].		"Using AAFProxy>>testFetchDataFromSam instead of the real AAFProxy>>fetchDataFromSam."	proxy testFetchDataFromSam.		"Store the the proxy's joystick values, for later comparision."	joystick1 := proxy state joystickXY: 1.	joystick2 := proxy state joystickXY: 2.		"Run the automation graph for the current simulation state." 	proxy state: (control processGraph: (proxy state)).		"Feed the proxy data to the sensor that would be used by SAM."	sensor joysticks: (Array with: (proxy state joystickXY: 1)	                         with: (proxy state joystickXY: 2)).	self should: [joystick1 = (sensor joystickXY: 1) negated];	     should: [joystick2 = (sensor joystickXY: 2) negated].! !AAFAgentUiTestCase subclass: #AAFInputDistributionAgentUiTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-Test'!!AAFInputDistributionAgentUiTestCase methodsFor: 'as yet unclassified' stamp: 'HM 7/31/2009 21:31'!agentNew	^(AAFInputDistributionAgent new)! !!AAFInputDistributionAgentUiTestCase methodsFor: 'as yet unclassified' stamp: 'HM 7/31/2009 21:31'!agentUiNew	^(AAFInputDistributionAgentUi new)! !!AAFInputDistributionAgentUiTestCase methodsFor: 'as yet unclassified' stamp: 'HM 7/31/2009 21:33'!testAgentDefaults: agent	| fiftyfifty |		super testAgentDefaults: agent.		fiftyfifty := (Array with: 0.5 with: 0.5).	self should: [fiftyfifty = (agent inputDistribution)].! !!AAFInputDistributionAgentUiTestCase methodsFor: 'as yet unclassified' stamp: 'HM 7/31/2009 21:50'!testMorph: morph withAgent: agent withMethod: method	(agent isKindOf: AAFInputDistributionAgent)		"If wrong agent then force test runner into a failed assertion."		ifFalse: [self shouldnt: [true]]		ifTrue: [						"Test the input distribution."			(#inputDistribution:with: = method asSymbol)				ifTrue: [					agent inputDistribution: 0.1 with: 0.9.					self should: [(Array with: 0.1 with: 0.9) = (morph values)].																	morph onMwb2Clicked.					self should: [(Array with: 0.0 with: 1.0) = (agent inputDistribution)].											"This event should be ignored since MWB2 already has 100%."					morph onMwb2Clicked.					self should: [(Array with: 0.0 with: 1.0) = (agent inputDistribution)].											morph onMwb1Clicked onMwb1Clicked onMwb1Clicked.					self should: [(Array with: 0.3 with: 0.7) = (agent inputDistribution)].				].			].! !TestCase subclass: #AAFPerformanceTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'AAF-Test'!!AAFPerformanceTestCase methodsFor: 'testing' stamp: 'HM 7/28/2009 20:49'!testLoopedGraphProcessing	| ctrl times timeEllapsed |		ctrl := AAFControl reset getInstance.	times := 10000.	"This test runs a linear graph of 64 AAFInversionAgents 10.000 times. So basically we measure how long it takes to call 'AAFAgent>>compute:' 640.000 times, with all its needed infrastructure to fetch the data and such."	timeEllapsed := MessageTally time: [		ctrl testLoopedGraphProcessingWith: (AAFInversionAgent new)		     times: times.	].	"Takes less than 3 secs on my 2.2 DualCore."	self should: [4000 > timeEllapsed].	self should: [64 = (ctrl graphSize)].		"Ditto, now with the more expensive AAFBreaksAgent"	timeEllapsed := MessageTally time: [		ctrl testLoopedGraphProcessingWith: (AAFBreaksAgent new)		     times: times.	].	"Takes less than 10 secs on my 2.2 DualCore."	self should: [12000 > timeEllapsed].	self should: [64 = (ctrl graphSize)].		"Now only a single run, since we need to know the additional costs of running the agents during the simulation (per frame)"	timeEllapsed := MessageTally time: [		ctrl testLoopedGraphProcessingWith: (AAFBreaksAgent new)		     times: 1.	].	"Takes less than 4 msecs on my 2.2 DualCore."	self should: [6 > timeEllapsed].	self should: [64 = (ctrl graphSize)].		AAFControl reset.	! !----End fileIn of Z:\home\users\michael\source\ateo\AAF\AAF-Test.st----!----QUIT----an Array(19 October 2009 3:37:54 pm) ATEO-AAF.image priorSource: 2219773!----STARTUP----an Array(19 October 2009 3:38:01 pm) as Z:\home\users\michael\source\ateo\AAF\ATEO-AAF.image!----QUIT----an Array(19 October 2009 3:38:46 pm) ATEO-AAF.image priorSource: 2401697!